<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Changan&#39;s Blog</title>
  
  
  <link href="http://github.com/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2025-12-26T01:44:00.000Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>Changan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 1019 | 链表中的下一个更大节点</title>
    <link href="http://github.com/posts/leetcode-1019/"/>
    <id>http://github.com/posts/leetcode-1019/</id>
    <published>2025-12-26T01:44:00.000Z</published>
    <updated>2025-12-26T01:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1019 题：<a href="https://leetcode.cn/problems/next-greater-node-in-linked-list/">链表中的下一个更大节点</a>。<br>问题的核心与“每日温度”类似，是寻找每个元素右侧第一个比它大的元素，但数据结构从数组变成了链表。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个长度为 <code>n</code> 的链表 <code>head</code>。</p><p>对于列表中的每个节点，查找下一个 <strong>更大节点</strong> 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 <strong>严格大于</strong> 它的值。</p><p>返回一个整数数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 个节点( 从1开始 )的下一个更大的节点的值。如果第 <code>i</code> 个节点没有下一个更大的节点，设置 <code>answer[i] = 0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [2,1,5]</span><br><span class="line">输出：[5,5,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [2,7,4,3,5]</span><br><span class="line">输出：[7,0,5,5,0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数为 <code>n</code></li><li>1 &lt;&#x3D; n &lt;&#x3D; 10^4</li><li>1 &lt;&#x3D; Node.val &lt;&#x3D; 10^9</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-问题的转化"><a href="#1-问题的转化" class="headerlink" title="1. 问题的转化"></a>1. 问题的转化</h4><p>这道题本质上是经典的 <strong>单调栈</strong> 问题，寻找右侧第一个比当前大的值。<br>如果输入是数组，我们可以直接 <strong>从后往前</strong> 遍历数组，维护一个单调栈来解决。<br>但在链表中，我们无法直接反向遍历。</p><h4 id="2-解决方案：如何反向遍历链表？"><a href="#2-解决方案：如何反向遍历链表？" class="headerlink" title="2. 解决方案：如何反向遍历链表？"></a>2. 解决方案：如何反向遍历链表？</h4><p>针对链表无法直接倒序访问的特性，我们通常有两种策略：</p><ol><li><strong>转化为数组</strong>：先将链表遍历一遍，存入数组或列表，然后对数组使用单调栈解法（Python 代码采用此法，避免递归深度过大）。</li><li><strong>利用递归</strong>：利用系统调用栈来实现倒序处理。先递归到链表末尾，在“归”的过程中处理当前节点，这天然就是从后往前的顺序（Go 代码采用此法）。</li></ol><h4 id="3-单调栈逻辑"><a href="#3-单调栈逻辑" class="headerlink" title="3. 单调栈逻辑"></a>3. 单调栈逻辑</h4><p>无论采用哪种遍历方式，核心逻辑是一致的：<br>我们维护一个栈，栈中存储链表节点的值（或者带上下标）。我们在 <strong>从后往前</strong> 处理节点时：</p><ol><li>如果栈不为空，且 <strong>栈顶元素 &lt;&#x3D; 当前节点值</strong>：<br>说明栈顶元素比当前节点小，且在当前节点的右边。对于当前节点更左边的节点来说，当前节点是“距离更近且更大”的优选，所以栈顶元素已经没用了，<strong>弹出栈顶</strong>。</li><li>重复步骤 1，直到栈为空或栈顶元素 &gt; 当前节点值。</li><li>此时，如果栈不为空，<strong>栈顶元素</strong> 就是当前节点右侧第一个更大的值。</li><li>将 <strong>当前节点值</strong> 入栈。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextLargerNodes</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 1. 将链表转换为数组，以便通过索引访问和倒序遍历</span></span><br><span class="line">        nums = []</span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            nums.append(curr.val)</span><br><span class="line">            curr = curr.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = [<span class="number">0</span>] * n</span><br><span class="line">        st = [] <span class="comment"># 单调栈，存储数值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 从后往前遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            val = nums[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 维护单调栈：弹出所有小于等于当前值的元素</span></span><br><span class="line">            <span class="comment"># 因为对于更左边的元素，当前值 val 是一个更好的“下一个更大值”候选</span></span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> st[-<span class="number">1</span>] &lt;= val:</span><br><span class="line">                st.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果栈不为空，栈顶即为右侧第一个更大的值</span></span><br><span class="line">            <span class="keyword">if</span> st:</span><br><span class="line">                ans[i] = st[-<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将当前值入栈</span></span><br><span class="line">            st.append(val)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextLargerNodes</span><span class="params">(head *ListNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    st := []<span class="type">int</span>&#123;&#125; <span class="comment">// 单调栈，用于存储节点的值</span></span><br><span class="line">    <span class="keyword">var</span> ans []<span class="type">int</span> <span class="comment">// 结果数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义递归函数 f</span></span><br><span class="line">    <span class="comment">// node: 当前遍历到的节点</span></span><br><span class="line">    <span class="comment">// i: 当前节点的索引（从0开始）</span></span><br><span class="line">    <span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(*ListNode, <span class="type">int</span>)</span></span></span><br><span class="line">    f = <span class="function"><span class="keyword">func</span><span class="params">(node *ListNode, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 基本情况：遍历到链表末尾</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 此时知道了链表的总长度 i，初始化结果数组</span></span><br><span class="line">            ans = <span class="built_in">make</span>([]<span class="type">int</span>, i)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归调用：先深入到下一个节点</span></span><br><span class="line">        <span class="comment">// 这会一直执行直到链表末尾</span></span><br><span class="line">        f(node.Next, i+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// --- 下面的代码在递归返回（回溯）阶段执行 ---</span></span><br><span class="line">        <span class="comment">// 此时相当于“从后往前”遍历链表</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 单调栈逻辑：</span></span><br><span class="line">        <span class="comment">// 如果栈顶元素 &lt;= 当前节点值，说明栈顶元素不可能是左边节点的“下一个更大值”</span></span><br><span class="line">        <span class="comment">// （因为当前节点更近且更大），所以将其弹出</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(st) &gt; <span class="number">0</span> &amp;&amp; st[<span class="built_in">len</span>(st)<span class="number">-1</span>] &lt;= node.Val &#123;</span><br><span class="line">            st = st[:<span class="built_in">len</span>(st)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果栈不为空，栈顶元素就是当前节点右侧第一个更大的值</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(st) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            ans[i] = st[<span class="built_in">len</span>(st)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若栈为空，ans[i] 默认为 0 (make 初始化时已置 0)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前节点的值压入栈中，供前面的节点（上一层递归）判断使用</span></span><br><span class="line">        st = <span class="built_in">append</span>(st, node.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从头节点开始递归，索引从 0 开始</span></span><br><span class="line">    f(head, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>无论是通过数组转换还是递归，每个节点都只会被访问一次。在单调栈的操作中，每个节点的值最多被压入栈一次，也最多被弹出栈一次，均摊复杂度为 <code>O(1)</code>。因此总时间复杂度为线性。</p></li><li><p><strong>空间复杂度</strong>: <code>O(n)</code></p><ul><li><strong>Python</strong>: 需要额外的数组 <code>nums</code> 存储链表值，以及栈 <code>st</code> 和结果数组 <code>ans</code>，均为 <code>O(n)</code>。</li><li><strong>Go</strong>: 递归调用栈的深度为 <code>n</code>，且手动维护的单调栈 <code>st</code> 和结果数组 <code>ans</code> 最坏情况下也为 <code>O(n)</code>。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1019 题：&lt;a href=&quot;https://leetcode.cn/problems/next-greater-node-in-linked-list/&quot;&gt;链表中的下一个更大节点&lt;/a&gt;。&lt;br&gt;问题的核心与“每日温度”类似，是寻找每个元素右侧第一个比它大的元素，但数据结构从数组变成了链表。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="单调栈" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    <category term="进阶" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%8D%95%E8%B0%83%E6%A0%88/%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="栈" scheme="http://github.com/tags/%E6%A0%88/"/>
    
    <category term="单调栈" scheme="http://github.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    <category term="链表" scheme="http://github.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="第130场周赛" scheme="http://github.com/tags/%E7%AC%AC130%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 853 | 车队</title>
    <link href="http://github.com/posts/leetcode-853/"/>
    <id>http://github.com/posts/leetcode-853/</id>
    <published>2025-12-25T04:23:00.000Z</published>
    <updated>2025-12-25T04:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 853 题：<a href="https://leetcode.cn/problems/car-fleet/">车队</a>。<br>这道题看似是物理追及问题，实际上通过转换“到达时间”并利用单调栈的特性，可以巧妙地模拟车队合并的过程。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在一条单行道上，有 <code>n</code> 辆车开往同一目的地。目的地是几英里以外的 <code>target</code>。</p><p>给定两个整数数组 <code>position</code> 和 <code>speed</code>，长度都是 <code>n</code>，其中 <code>position[i]</code> 是第 <code>i</code> 辆车的位置，<code>speed[i]</code> 是第 <code>i</code> 辆车的速度（单位是英里&#x2F;小时）。</p><p>一辆车永远不会超过前面的另一辆车，但它可以追上去，并以较慢车的速度在另一辆车旁边行驶。即便一辆车在 <code>target</code> 才赶上了一个车队，它们仍然会被视作是同一个车队。</p><p>返回到达目的地的车队数量。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从 10 和 8 开始的车会组成一个车队，在 12 相遇。</span><br><span class="line">从 0 开始的车自己是一个车队。</span><br><span class="line">从 5 和 3 开始的车组成一个车队，在 6 相遇。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-转换视角：关注到达时间"><a href="#1-转换视角：关注到达时间" class="headerlink" title="1. 转换视角：关注到达时间"></a>1. 转换视角：关注到达时间</h4><p>每辆车到达终点所需的时间 <code>time = (target - position) / speed</code>。<br>这是解题的关键指标。</p><h4 id="2-追及与合并的逻辑"><a href="#2-追及与合并的逻辑" class="headerlink" title="2. 追及与合并的逻辑"></a>2. 追及与合并的逻辑</h4><p>由于这是一条单行道，且后车不能超车：</p><ul><li>如果 <strong>后车</strong>（离终点远）的到达时间 <strong>少于等于</strong> <strong>前车</strong>（离终点近）的到达时间，说明后车速度快，它会在到达终点前（或刚好在终点）追上前车。</li><li>追上后，后车会被迫减速，与前车成为同一个车队，到达时间实际上变成了前车的到达时间（较慢的那个）。</li><li>如果 <strong>后车</strong> 的到达时间 <strong>大于</strong> <strong>前车</strong> 的到达时间，说明后车太慢了，追不上前车，它将自己形成一个新的车队（或者成为后面更慢车队的头）。</li></ul><h4 id="3-排序与单调栈"><a href="#3-排序与单调栈" class="headerlink" title="3. 排序与单调栈"></a>3. 排序与单调栈</h4><p>我们可以按照 <strong>位置从小到大</strong>（即从离终点最远的地方开始向终点方向）遍历车辆：</p><ol><li><strong>排序</strong>：将车辆按照 <code>position</code> 升序排列。这样遍历时，我们总是先处理“后面”的车，再处理“前面”的车。</li><li><strong>计算时间</strong>：计算排序后每辆车的理论到达时间。</li><li><strong>栈模拟合并</strong>：<ul><li>我们要维护一个栈，栈中存储的是当前已经形成的各个车队的“领头车”到达时间。</li><li>当我们遍历到一辆车（设其时间为 <code>t</code>，这辆车在位置上比栈里的车更靠前&#x2F;更接近终点）时，我们看栈顶元素（即它后面那辆车的车队时间）。</li><li><strong>核心逻辑</strong>：如果 <code>当前车的时间 t</code> &gt;&#x3D; <code>后方车队的时间 st[-1]</code>，这意味着什么？<ul><li>意味着 <strong>前面的车（当前车）比后面的车（栈顶）更慢</strong>。</li><li>后面的车虽然出发得早（或者相对位置靠后），但因为前面的车太慢，导致后面的车会追上来并撞上前面的车（合并）。</li><li>合并后，整个车队的速度取决于最慢的那辆（也就是当前的 <code>t</code>）。</li><li>因此，原本栈顶那个“较快”的时间就没有意义了（它不再是独立的领头羊，而是被当前这辆慢车阻挡了），我们需要将其弹出。</li><li>这个过程会持续进行，直到栈为空或者后方车队的时间比当前车慢（无法追上）为止。</li></ul></li><li>最后将当前车的时间 <code>t</code> 入栈。</li></ul></li></ol><p>最终，栈的长度就是无法被合并的车队数量。这个栈实际上是一个 <strong>严格单调递减栈</strong>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">carFleet</span>(<span class="params">self, target: <span class="built_in">int</span>, position: <span class="type">List</span>[<span class="built_in">int</span>], speed: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(position)</span><br><span class="line">        time = [<span class="number">0</span>]*n</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将车辆按照位置 position 从小到大排序 (离 target 最远的排在前面)</span></span><br><span class="line">        <span class="comment"># 并计算每一辆车到达 target 所需的时间</span></span><br><span class="line">        <span class="keyword">for</span> i,(pos,sp) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">sorted</span>(<span class="built_in">zip</span>(position,speed))):</span><br><span class="line">            time[i] = (target-pos)/sp</span><br><span class="line">            </span><br><span class="line">        st = []</span><br><span class="line">        <span class="comment"># 遍历排序后的时间数组</span></span><br><span class="line">        <span class="comment"># time[i] 对应的车在 time[i+1] 的后面</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> time:</span><br><span class="line">            <span class="comment"># 单调栈维护逻辑：</span></span><br><span class="line">            <span class="comment"># 如果当前车（位置靠前）的时间 t &gt;= 栈顶车（位置靠后）的时间 st[-1]</span></span><br><span class="line">            <span class="comment"># 说明靠前的车更慢，靠后的车会追上它并与它合并。</span></span><br><span class="line">            <span class="comment"># 靠后的车不再能作为独立车队的代表，因此弹出。</span></span><br><span class="line">            <span class="comment"># 新的车队到达时间由当前这辆慢车 t 决定。</span></span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> t&gt;=st[-<span class="number">1</span>]:</span><br><span class="line">                st.pop()</span><br><span class="line">            st.append(t)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(st)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">    pos  <span class="type">int</span></span><br><span class="line">    time <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">carFleet</span><span class="params">(target <span class="type">int</span>, position []<span class="type">int</span>, speed []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(position)</span><br><span class="line">    cars := <span class="built_in">make</span>([]Car, n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建包含位置和到达时间的结构体数组</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        cars[i] = Car&#123;</span><br><span class="line">            pos:  position[i],</span><br><span class="line">            time: <span class="type">float64</span>(target-position[i]) / <span class="type">float64</span>(speed[i]),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按照位置 position 从小到大排序</span></span><br><span class="line">    sort.Slice(cars, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cars[i].pos &lt; cars[j].pos</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    st := []<span class="type">float64</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历排序后的车辆</span></span><br><span class="line">    <span class="keyword">for</span> _, car := <span class="keyword">range</span> cars &#123;</span><br><span class="line">        t := car.time</span><br><span class="line">        <span class="comment">// 维护单调递减栈</span></span><br><span class="line">        <span class="comment">// 如果当前车（靠前）的时间 &gt;= 栈顶车（靠后）的时间</span></span><br><span class="line">        <span class="comment">// 说明后车能追上前车，合并为同一个车队（由前车速度决定）</span></span><br><span class="line">        <span class="comment">// 弹出栈顶的后车时间</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(st) &gt; <span class="number">0</span> &amp;&amp; t &gt;= st[<span class="built_in">len</span>(st)<span class="number">-1</span>] &#123;</span><br><span class="line">            st = st[:<span class="built_in">len</span>(st)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        st = <span class="built_in">append</span>(st, t)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(st)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(N log N)</code><br>主要的时间消耗在于对车辆按照位置进行排序。遍历和栈操作的过程是 <code>O(N)</code>，因为每个元素最多进栈一次、出栈一次。</p></li><li><p><strong>空间复杂度</strong>: <code>O(N)</code><br>需要存储 <code>time</code> 数组（或结构体数组）以及栈 <code>st</code>，最坏情况下栈的大小为 <code>N</code>。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 853 题：&lt;a href=&quot;https://leetcode.cn/problems/car-fleet/&quot;&gt;车队&lt;/a&gt;。&lt;br&gt;这道题看似是物理追及问题，实际上通过转换“到达时间”并利用单调栈的特性，可以巧妙地模拟车队合并的过程。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="单调栈" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%8D%95%E8%B0%83%E6%A0%88/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="排序" scheme="http://github.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="栈" scheme="http://github.com/tags/%E6%A0%88/"/>
    
    <category term="单调栈" scheme="http://github.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    <category term="第89场周赛" scheme="http://github.com/tags/%E7%AC%AC89%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 503 | 下一个更大元素 II</title>
    <link href="http://github.com/posts/leetcode-503/"/>
    <id>http://github.com/posts/leetcode-503/</id>
    <published>2025-12-24T05:00:00.000Z</published>
    <updated>2025-12-24T05:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 503 题：<a href="https://leetcode.cn/problems/next-greater-element-ii/">下一个更大元素 II</a>。<br>在循环数组中寻找每个元素的下一个更大元素，是单调栈的进阶应用。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个循环数组 <code>nums</code>（<code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code>），返回 <code>nums</code> 中每个元素的 <strong>下一个更大元素</strong>。</p><p>数字 <code>x</code> 的 <strong>下一个更大的元素</strong> 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p><strong>示例 1:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,3]</span><br><span class="line">输出: [2,3,4,-1,4]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4</li><li>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-循环数组的处理"><a href="#1-循环数组的处理" class="headerlink" title="1. 循环数组的处理"></a>1. 循环数组的处理</h4><p>这道题与普通的“下一个更大元素”问题的区别在于数组是<strong>循环</strong>的。这意味着当我们查找最后一个元素的下一个更大值时，可能需要回到数组开头继续查找。</p><p>解决循环数组通常有两种方法：</p><ol><li><strong>物理扩容</strong>：将数组复制一份拼接到末尾，变成长度为 <code>2n</code> 的数组，然后按普通线性数组处理。</li><li><strong>逻辑模拟</strong>：利用取模运算 <code>%</code> 来模拟双倍长度的遍历，而不实际占用额外的 <code>O(n)</code> 空间来存储新数组。</li></ol><h4 id="2-单调栈的应用"><a href="#2-单调栈的应用" class="headerlink" title="2. 单调栈的应用"></a>2. 单调栈的应用</h4><p>我们依然可以使用<strong>单调栈</strong>来解决这个问题。解法采用了<strong>倒序遍历</strong>的策略：</p><ol><li><strong>遍历范围</strong>：为了处理循环特性，我们假设数组长度变成了 <code>2 * n</code>。遍历索引 <code>i</code> 从 <code>2 * n - 1</code> 到 <code>0</code>。</li><li><strong>索引映射</strong>：在遍历过程中，实际访问的元素是 <code>nums[i % n]</code>。</li><li><strong>维护栈</strong>：栈中存储元素的<strong>数值</strong>（注意：这里可以直接存数值，也可以存下标，本题解代码采用存数值的方式）。栈内的元素保持单调递减（从栈底到栈顶），这样栈顶始终是当前看来“最近且更大”的候选元素。</li><li><strong>核心逻辑</strong>：<ul><li>如果当前元素 <code>x</code> 大于等于栈顶元素，说明栈顶元素被 <code>x</code> 挡住了，对于更前面的元素来说，<code>x</code> 是更好的选择（或者更近的更大值），因此弹出栈顶。</li><li>重复弹出直到栈为空或栈顶元素大于 <code>x</code>。</li><li>此时，如果栈不为空，栈顶元素就是 <code>x</code> 的下一个更大元素。</li><li><strong>关键点</strong>：我们只需要记录 <code>0</code> 到 <code>n-1</code> 范围内的答案。对于 <code>n</code> 到 <code>2n-1</code> 的部分，它们的作用主要是为了填充栈，以便让 <code>0</code> 到 <code>n-1</code> 的尾部元素能“看”到数组开头的元素。</li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 初始化结果数组，默认为 -1</span></span><br><span class="line">        ans = [-<span class="number">1</span>] * n</span><br><span class="line">        st = []  <span class="comment"># 单调栈，存储数值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 模拟遍历两遍数组</span></span><br><span class="line">        <span class="comment"># 范围从 2*n - 1 到 0，通过取模来实现循环效果</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n * <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 使用取模操作获取当前实际的元素值</span></span><br><span class="line">            x = nums[i % n]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 维护单调栈：如果栈顶元素 &lt;= 当前元素</span></span><br><span class="line">            <span class="comment"># 说明栈顶元素不可能是“下一个更大元素”，将其弹出</span></span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> x &gt;= st[-<span class="number">1</span>]:</span><br><span class="line">                st.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 只有当索引 i 在原始数组范围内（0 到 n-1）时，才记录结果</span></span><br><span class="line">            <span class="comment"># 因为 n 到 2n-1 的部分只是为了辅助寻找循环后的更大值</span></span><br><span class="line">            <span class="keyword">if</span> st <span class="keyword">and</span> i &lt; n:</span><br><span class="line">                ans[i] = st[-<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将当前元素推入栈中，作为后续遍历元素的候选“更大值”</span></span><br><span class="line">            st.append(x)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextGreaterElements</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">// 初始化结果数组，长度为 n，并填充默认值 -1</span></span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ans &#123;</span><br><span class="line">        ans[i] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单调栈，这里存储的是数值</span></span><br><span class="line">    st := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模拟遍历两遍数组，从 2*n-1 倒序遍历到 0</span></span><br><span class="line">    <span class="keyword">for</span> i := n*<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 通过取模获取真实索引对应的数值</span></span><br><span class="line">        x := nums[i%n]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保持栈的单调性：栈顶必须大于当前元素</span></span><br><span class="line">        <span class="comment">// 如果栈顶元素 &lt;= 当前元素 x，则栈顶无效，弹出</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(st) &gt; <span class="number">0</span> &amp;&amp; x &gt;= st[<span class="built_in">len</span>(st)<span class="number">-1</span>] &#123;</span><br><span class="line">            st = st[:<span class="built_in">len</span>(st)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 i &lt; n，说明我们在处理原始数组的对应位置</span></span><br><span class="line">        <span class="comment">// 此时栈顶（如果存在）即为下一个更大元素</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; n &amp;&amp; <span class="built_in">len</span>(st) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            ans[i] = st[<span class="built_in">len</span>(st)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前元素压入栈中</span></span><br><span class="line">        st = <span class="built_in">append</span>(st, x)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(N)</code><br>我们需要遍历数组前 <code>2N</code> 个位置（模拟两遍）。虽然内部有一个 <code>while</code> 循环，但每个元素在整个过程中最多被入栈一次、出栈一次。因此整体操作次数与数组长度成线性关系。</p></li><li><p><strong>空间复杂度</strong>: <code>O(N)</code><br>我们需要一个栈来存储元素。在最坏情况下（例如数组是单调递增的），栈中可能需要存储 <code>N</code> 个元素。结果数组 <code>ans</code> 也占用 <code>O(N)</code> 空间。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 503 题：&lt;a href=&quot;https://leetcode.cn/problems/next-greater-element-ii/&quot;&gt;下一个更大元素 II&lt;/a&gt;。&lt;br&gt;在循环数组中寻找每个元素的下一个更大元素，是单调栈的进阶应用。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="单调栈" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%8D%95%E8%B0%83%E6%A0%88/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="栈" scheme="http://github.com/tags/%E6%A0%88/"/>
    
    <category term="单调栈" scheme="http://github.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 496 | 下一个更大元素 I</title>
    <link href="http://github.com/posts/leetcode-496/"/>
    <id>http://github.com/posts/leetcode-496/</id>
    <published>2025-12-23T09:05:00.000Z</published>
    <updated>2025-12-23T09:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 496 题：<a href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素 I</a>。<br>这是单调栈的入门题目，需要在寻找下一个更大元素的基础上，结合哈希表处理子集查询。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。</p><p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 0 开始计数，其中 <code>nums1</code> 是 <code>nums2</code> 的子集。</p><p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p><p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出：[-1,3,-1]</span><br><span class="line">解释：nums1 中每个值的下一个更大元素如下所述：</span><br><span class="line">- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</span><br><span class="line">- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。</span><br><span class="line">- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">输出：[3,-1]</span><br><span class="line">解释：nums1 中每个值的下一个更大元素如下所述：</span><br><span class="line">- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。</span><br><span class="line">- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; nums1.length &lt;&#x3D; nums2.length &lt;&#x3D; 1000</li><li>0 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 10^4</li><li>nums1和nums2中所有整数 <strong>互不相同</strong></li><li>nums1 中的所有整数同样出现在 nums2 中</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1. 问题分析"></a>1. 问题分析</h4><p>题目要求我们针对 <code>nums1</code> 中的每个元素，去 <code>nums2</code> 中找到它右侧第一个比它大的值。由于 <code>nums1</code> 是 <code>nums2</code> 的子集，本质上我们要解决的是：如何在 <code>nums2</code> 中高效地找到每个元素的“下一个更大元素”，然后把结果映射回 <code>nums1</code> 的对应位置。</p><h4 id="2-单调栈-哈希表"><a href="#2-单调栈-哈希表" class="headerlink" title="2. 单调栈 + 哈希表"></a>2. 单调栈 + 哈希表</h4><p>我们可以利用 <strong>单调栈</strong> 来解决“寻找右侧第一个更大元素”的问题。为了快速知道 <code>nums2</code> 中的元素对应 <code>nums1</code> 中的哪个位置（或者是否在 <code>nums1</code> 中），我们需要使用一个 <strong>哈希表</strong>。</p><p>具体步骤如下：</p><ol><li><strong>预处理映射</strong>：遍历 <code>nums1</code>，建立一个哈希表 <code>idx</code>，记录 <code>值 -&gt; nums1中的下标</code> 的映射关系。</li><li><strong>倒序遍历 <code>nums2</code></strong>：从右向左遍历 <code>nums2</code>。<ul><li>为什么倒序？因为当我们来到 <code>nums2[i]</code> 时，如果栈里存放的是它右边的元素，我们可以很方便地知道谁比它大。</li></ul></li><li><strong>维护单调栈</strong>：<ul><li>栈中存储的是 <code>nums2</code> 中的元素值。</li><li>当遍历到元素 <code>x</code> 时，如果栈顶元素 <strong>小于等于</strong> <code>x</code>，说明栈顶元素被 <code>x</code> “挡住”了（对于 <code>x</code> 左边的元素来说，<code>x</code> 是更近且更大的选择，或者 <code>x</code> 本身就比栈顶大），因此栈顶元素对于寻找“下一个更大”已经没有价值，将其 <strong>弹出</strong>。</li><li>重复弹出直到栈为空或栈顶元素大于 <code>x</code>。</li></ul></li><li><strong>记录结果</strong>：<ul><li>此时，如果栈不为空，栈顶元素就是 <code>x</code> 右侧第一个比它大的元素。</li><li>检查 <code>x</code> 是否存在于哈希表 <code>idx</code> 中。如果存在，说明 <code>x</code> 是 <code>nums1</code> 需要查询的元素，将栈顶元素更新到 <code>ans</code> 数组的对应位置。</li></ul></li><li><strong>入栈</strong>：将 <code>x</code> 入栈，因为它可能是其左边元素的“下一个更大元素”。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 建立 nums1 中 元素值 -&gt; 索引 的映射，方便快速定位</span></span><br><span class="line">        idx = &#123;x: i <span class="keyword">for</span> i,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums1)&#125;</span><br><span class="line">        <span class="comment"># 初始化答案数组，默认值为 -1</span></span><br><span class="line">        ans = [-<span class="number">1</span>] * <span class="built_in">len</span>(nums1)</span><br><span class="line">        st = [] <span class="comment"># 单调栈</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 倒序遍历 nums2</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">reversed</span>(nums2):</span><br><span class="line">            <span class="comment"># 维护单调栈：如果栈顶元素 &lt;= 当前元素 x</span></span><br><span class="line">            <span class="comment"># 说明栈顶元素不可能成为 x 或 x 左边元素的“下一个更大元素”，弹出</span></span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> x &gt;= st[-<span class="number">1</span>]:</span><br><span class="line">                st.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果栈不为空，且当前元素 x 在 nums1 中需要查询</span></span><br><span class="line">            <span class="comment"># 则栈顶元素即为 x 的下一个更大元素</span></span><br><span class="line">            <span class="keyword">if</span> st <span class="keyword">and</span> x <span class="keyword">in</span> idx:</span><br><span class="line">                ans[idx[x]] = st[-<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将当前元素入栈</span></span><br><span class="line">            st.append(x)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;slices&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextGreaterElement</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 建立 nums1 中 元素值 -&gt; 索引 的映射</span></span><br><span class="line">    idx := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line">        idx[x] = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化答案数组，默认为 -1</span></span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums1))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ans &#123;</span><br><span class="line">        ans[i] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st := []<span class="type">int</span>&#123;&#125; <span class="comment">// 单调栈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 slices.Backward 进行倒序遍历 nums2 (Go 1.23+)</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> slices.Backward(nums2) &#123;</span><br><span class="line">        <span class="comment">// 维护单调栈：弹出比当前元素小或相等的栈顶元素</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(st) &gt; <span class="number">0</span> &amp;&amp; x &gt;= st[<span class="built_in">len</span>(st)<span class="number">-1</span>] &#123;</span><br><span class="line">            st = st[:<span class="built_in">len</span>(st)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果栈不为空，且当前元素 x 需要在 nums1 中查询</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(st) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> i, ok := idx[x]; ok &#123;</span><br><span class="line">                ans[i] = st[<span class="built_in">len</span>(st)<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前元素推入栈中</span></span><br><span class="line">        st = <span class="built_in">append</span>(st, x)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(M + N)</code><br>其中 <code>N</code> 是 <code>nums1</code> 的长度，<code>M</code> 是 <code>nums2</code> 的长度。我们需要遍历 <code>nums1</code> 一次建立哈希表，遍历 <code>nums2</code> 一次进行单调栈操作。在单调栈操作中，<code>nums2</code> 的每个元素最多入栈一次、出栈一次。</p></li><li><p><strong>空间复杂度</strong>: <code>O(N + M)</code><br>哈希表存储 <code>nums1</code> 的映射需要 <code>O(N)</code> 的空间。单调栈最坏情况下需要存储 <code>nums2</code> 的所有元素，需要 <code>O(M)</code> 的空间。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 496 题：&lt;a href=&quot;https://leetcode.cn/problems/next-greater-element-i/&quot;&gt;下一个更大元素 I&lt;/a&gt;。&lt;br&gt;这是单调栈的入门题目，需要在寻找下一个更大元素的基础上，结合哈希表处理子集查询。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="单调栈" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%8D%95%E8%B0%83%E6%A0%88/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="栈" scheme="http://github.com/tags/%E6%A0%88/"/>
    
    <category term="单调栈" scheme="http://github.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2905 | 找出满足差值条件的下标 II</title>
    <link href="http://github.com/posts/leetcode-2905/"/>
    <id>http://github.com/posts/leetcode-2905/</id>
    <published>2025-12-22T02:00:00.000Z</published>
    <updated>2025-12-22T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 2905 题：<a href="https://leetcode.cn/problems/find-indices-with-index-and-value-difference-ii/">找出满足差值条件的下标 II</a>。<br>该题相对I数据范围扩大到了 10^5，需要优化时间复杂度到 O(n)。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个下标从 0 开始、长度为 n 的整数数组 <code>nums</code> ，以及整数 <code>indexDifference</code> 和整数 <code>valueDifference</code> 。</p><p>你的任务是从范围 <code>[0, n - 1]</code> 内找出 2 个满足下述所有条件的下标 <code>i</code> 和 <code>j</code> ：</p><ol><li><code>abs(i - j) &gt;= indexDifference</code></li><li><code>abs(nums[i] - nums[j]) &gt;= valueDifference</code></li></ol><p>返回整数数组 <code>answer</code>。如果存在满足题目要求的两个下标，则 <code>answer = [i, j]</code> ；否则，<code>answer = [-1, -1]</code> 。如果存在多组可供选择的下标对，只需要返回其中任意一组即可。</p><p><strong>注意</strong>：i 和 j 可能相等。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,1,4,1], indexDifference = 2, valueDifference = 4</span><br><span class="line">输出：[0,3]</span><br><span class="line">解释：在示例中，可以选择 i = 0 和 j = 3 。</span><br><span class="line">abs(0 - 3) &gt;= 2 且 abs(nums[0] - nums[3]) &gt;= 4 。</span><br><span class="line">因此，[0,3] 是一个符合题目要求的答案。</span><br><span class="line">[3,0] 也是符合题目要求的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,1], indexDifference = 0, valueDifference = 0</span><br><span class="line">输出：[0,0]</span><br><span class="line">解释：</span><br><span class="line">在示例中，可以选择 i = 0 和 j = 0 。 </span><br><span class="line">abs(0 - 0) &gt;= 0 且 abs(nums[0] - nums[0]) &gt;= 0 。 </span><br><span class="line">因此，[0,0] 是一个符合题目要求的答案。 </span><br><span class="line">[0,1]、[1,0] 和 [1,1] 也是符合题目要求的答案。 </span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3], indexDifference = 2, valueDifference = 4</span><br><span class="line">输出：[-1,-1]</span><br><span class="line">解释：在示例中，可以证明无法找出 2 个满足所有条件的下标。</span><br><span class="line">因此，返回 [-1,-1] 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; n &#x3D;&#x3D; nums.length &lt;&#x3D; 10^5</li><li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</li><li>0 &lt;&#x3D; indexDifference &lt;&#x3D; 10^5</li><li>0 &lt;&#x3D; valueDifference &lt;&#x3D; 10^9</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-为什么暴力法不可行"><a href="#1-为什么暴力法不可行" class="headerlink" title="1. 为什么暴力法不可行"></a>1. 为什么暴力法不可行</h4><p>如果是简单版（第 2903 题），数据范围较小，我们可以使用双重循环枚举所有可能的 <code>(i, j)</code> 对，时间复杂度为 O(n^2)。<br>但在本题中，<code>n</code> 高达 10^5，O(n^2) 的算法会超时。我们需要寻找 O(n) 的解法。</p><h4 id="2-枚举右，维护左"><a href="#2-枚举右，维护左" class="headerlink" title="2. 枚举右，维护左"></a>2. 枚举右，维护左</h4><p>这道题的核心限制条件有两个：下标差和数值差。<br>我们可以通过<strong>枚举右端点</strong> <code>j</code>，来寻找合法的左端点 <code>i</code>。</p><ol><li><strong>下标条件</strong>：对于固定的 <code>j</code>，合法的 <code>i</code> 必须满足 <code>i &lt;= j - indexDifference</code>。</li><li><strong>数值条件</strong>：我们需要找到一个合法的 <code>i</code>，使得 <code>abs(nums[i] - nums[j]) &gt;= valueDifference</code>。这个绝对值不等式可以拆分为两种情况：<ul><li><code>nums[i] - nums[j] &gt;= valueDifference</code>，即 <code>nums[i] &gt;= nums[j] + valueDifference</code>。这意味着我们需要在合法的 <code>i</code> 范围内找到一个<strong>尽可能大</strong>的 <code>nums[i]</code>。</li><li><code>nums[j] - nums[i] &gt;= valueDifference</code>，即 <code>nums[i] &lt;= nums[j] - valueDifference</code>。这意味着我们需要在合法的 <code>i</code> 范围内找到一个<strong>尽可能小</strong>的 <code>nums[i]</code>。</li></ul></li></ol><p><strong>算法流程</strong>：<br>我们遍历 <code>j</code> 从 <code>indexDifference</code> 到 <code>n - 1</code>。<br>在遍历过程中，合法的 <code>i</code> 的范围是 <code>[0, j - indexDifference]</code>。<br>随着 <code>j</code> 向右移动，合法范围的右边界 <code>j - indexDifference</code> 也在向右移动，每次只增加一个新的元素。<br>因此，我们只需要维护当前合法范围内的<strong>最大值下标</strong> <code>mx</code> 和<strong>最小值下标</strong> <code>mn</code> 即可。</p><ul><li>当遍历到 <code>j</code> 时，新的合法位置是 <code>i = j - indexDifference</code>。</li><li>更新 <code>mx</code>：如果 <code>nums[i]</code> 比当前的最大值还大，更新 <code>mx = i</code>。</li><li>更新 <code>mn</code>：如果 <code>nums[i]</code> 比当前的最小值还小，更新 <code>mn = i</code>。</li><li>检查条件：<ul><li>如果 <code>nums[mx] - nums[j] &gt;= valueDifference</code>，返回 <code>[mx, j]</code>。</li><li>如果 <code>nums[j] - nums[mn] &gt;= valueDifference</code>，返回 <code>[mn, j]</code>。</li></ul></li></ul><p>这样，我们只需要遍历数组一次，时间复杂度为 O(n)。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findIndices</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], indexDifference: <span class="built_in">int</span>, valueDifference: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># mx 和 mn 分别记录满足下标条件的范围 [0, j - indexDifference] 内</span></span><br><span class="line">        <span class="comment"># 最大值和最小值的下标</span></span><br><span class="line">        mx = mn = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举右端点 j，从 indexDifference 开始，保证 j - indexDifference &gt;= 0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(indexDifference, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 计算当前新加入合法范围的左端点 i</span></span><br><span class="line">            i = j - indexDifference</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 维护合法范围内的最大值下标</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[mx]:</span><br><span class="line">                mx = i</span><br><span class="line">            <span class="comment"># 维护合法范围内的最小值下标</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[mn]:</span><br><span class="line">                mn = i</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 检查最大值与当前 nums[j] 的差值是否满足条件</span></span><br><span class="line">            <span class="comment"># 对应情况：nums[i] - nums[j] &gt;= valueDifference</span></span><br><span class="line">            <span class="keyword">if</span> nums[mx] - nums[j] &gt;= valueDifference:</span><br><span class="line">                <span class="keyword">return</span> [mx, j]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 检查当前 nums[j] 与最小值的差值是否满足条件</span></span><br><span class="line">            <span class="comment"># 对应情况：nums[j] - nums[i] &gt;= valueDifference</span></span><br><span class="line">            <span class="keyword">if</span> nums[j] - nums[mn] &gt;= valueDifference:</span><br><span class="line">                <span class="keyword">return</span> [mn, j]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果遍历完都没找到，返回 [-1, -1]</span></span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findIndices</span><span class="params">(nums []<span class="type">int</span>, indexDifference <span class="type">int</span>, valueDifference <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// mx 和 mn 分别记录满足下标条件的范围 [0, j - indexDifference] 内</span></span><br><span class="line">    <span class="comment">// 最大值和最小值的下标</span></span><br><span class="line">    mx, mn := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 枚举右端点 j，从 indexDifference 开始</span></span><br><span class="line">    <span class="keyword">for</span> j := indexDifference; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">        <span class="comment">// 计算当前新加入合法范围的左端点 i</span></span><br><span class="line">        i := j - indexDifference</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 维护合法范围内的最大值下标</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[mx] &#123;</span><br><span class="line">            mx = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 维护合法范围内的最小值下标</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[mn] &#123;</span><br><span class="line">            mn = i</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查最大值与当前 nums[j] 的差值是否满足条件</span></span><br><span class="line">        <span class="comment">// 对应情况：nums[i] - nums[j] &gt;= valueDifference</span></span><br><span class="line">        <span class="keyword">if</span> nums[mx] - nums[j] &gt;= valueDifference &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;mx, j&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查当前 nums[j] 与最小值的差值是否满足条件</span></span><br><span class="line">        <span class="comment">// 对应情况：nums[j] - nums[i] &gt;= valueDifference</span></span><br><span class="line">        <span class="keyword">if</span> nums[j] - nums[mn] &gt;= valueDifference &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;mn, j&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果遍历完都没找到，返回 [-1, -1]</span></span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: O(n)<br>其中 n 是数组 <code>nums</code> 的长度。我们只需要遍历数组一次，每次迭代中的操作都是 O(1) 的。</p></li><li><p><strong>空间复杂度</strong>: O(1)<br>我们只需要常数级别的额外空间来存储 <code>mx</code>, <code>mn</code> 等变量。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 2905 题：&lt;a href=&quot;https://leetcode.cn/problems/find-indices-with-index-and-value-difference-ii/&quot;&gt;找出满足差值条件的下标 II&lt;/a&gt;。&lt;br&gt;该题相对I数据范围扩大到了 10^5，需要优化时间复杂度到 O(n)。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="http://github.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="第367场周赛" scheme="http://github.com/tags/%E7%AC%AC367%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 3584 | 子序列首尾元素的最大乘积</title>
    <link href="http://github.com/posts/leetcode-3584/"/>
    <id>http://github.com/posts/leetcode-3584/</id>
    <published>2025-12-22T01:29:00.000Z</published>
    <updated>2025-12-22T01:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 3584 题：<a href="https://leetcode.cn/problems/maximum-product-of-first-and-last-elements-of-a-subsequence/description/">子序列首尾元素的最大乘积</a>。<br>该题核心在于如何在满足长度限制的情况下，通过一次遍历找到最优解。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>m</code>。</p><p>返回任意大小为 <code>m</code> 的 <strong>子序列</strong> 中首尾元素乘积的最大值。</p><p><strong>子序列</strong> 是可以通过删除原数组中的一些元素（或不删除任何元素），且不改变剩余元素顺序而得到的数组。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入： nums = [-1,-9,2,3,-2,-3,1], m = 1</span><br><span class="line">输出： 81</span><br><span class="line">解释：</span><br><span class="line">子序列 [-9] 的首尾元素乘积最大：-9 * -9 = 81。因此，答案是 81。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入： nums = [1,3,-5,5,6,-4], m = 3</span><br><span class="line">输出： 20</span><br><span class="line">解释：</span><br><span class="line">子序列 [-5, 6, -4] 的首尾元素乘积最大。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入： nums = [2,-1,2,-6,5,2,-5,7], m = 2</span><br><span class="line">输出： 35</span><br><span class="line">解释：</span><br><span class="line">子序列 [5, 7] 的首尾元素乘积最大。</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li><li><code>1 &lt;= m &lt;= nums.length</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1. 问题分析"></a>1. 问题分析</h4><p>题目要求选择一个长度为 <code>m</code> 的子序列，使得该子序列的 <strong>第一个元素</strong> 和 <strong>最后一个元素</strong> 的乘积最大。<br>假设我们在原数组 <code>nums</code> 中选择的子序列的第一个元素下标为 <code>j</code>，最后一个元素下标为 <code>i</code>。<br>由于是子序列，原数组中下标的相对顺序必须保持不变，即 <code>j &lt;= i</code>（如果是长度为 1，则 <code>j=i</code>）。</p><p>为了构成一个长度至少为 <code>m</code> 的子序列，<code>j</code> 和 <code>i</code> 之间（包含 <code>j</code> 和 <code>i</code> 本身）必须至少有 <code>m</code> 个元素可供选择。也就是说，在原数组中，下标 <code>j</code> 和 <code>i</code> 必须满足：<br><code>i - j + 1 &gt;= m</code><br>即：<br><code>j &lt;= i - m + 1</code></p><h4 id="2-枚举右，维护左"><a href="#2-枚举右，维护左" class="headerlink" title="2. 枚举右，维护左"></a>2. 枚举右，维护左</h4><p>我们可以遍历数组，枚举每一个元素作为子序列的 <strong>最后一个元素</strong>（记为 <code>x</code>，下标为 <code>i</code>）。<br>对于固定的 <code>i</code>，我们需要在合法的范围 <code>[0, i - m + 1]</code> 中找到一个 <strong>第一个元素</strong>（记为 <code>y</code>，下标为 <code>j</code>），使得 <code>x * y</code> 最大。</p><ul><li><p><strong>遍历过程</strong>：<br>我们让 <code>i</code> 从 <code>m - 1</code> 开始遍历到数组结束。<br>当 <code>i</code> 移动时，合法的 <code>j</code> 的范围上限 <code>i - m + 1</code> 也会随之向右移动一步。这意味着每一轮循环，都会有一个新的元素进入“合法的第一个元素”的候选池。</p></li><li><p><strong>维护极值</strong>：<br>为了使乘积 <code>x * y</code> 最大，我们需要考虑 <code>x</code> 的正负性：</p><ul><li>如果 <code>x</code> 是正数，我们需要 <code>y</code> 尽可能大（正得越多越好）。</li><li>如果 <code>x</code> 是负数，我们需要 <code>y</code> 尽可能小（负得越多越好，负负得正）。</li></ul><p>因此，我们只需要在遍历过程中，动态维护合法范围内（<code>nums[0...i-m+1]</code>）的 <strong>最小值</strong> (<code>mn</code>) 和 <strong>最大值</strong> (<code>mx</code>)。</p></li></ul><h4 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h4><ol><li>初始化全局最大乘积 <code>ans</code> 为极小值。</li><li>初始化当前合法左侧区间的最小值 <code>mn</code> 和最大值 <code>mx</code>。</li><li>从 <code>i = m - 1</code> 开始遍历数组 <code>nums</code>：<ul><li>获取新进入合法左侧区间的元素 <code>y = nums[i - m + 1]</code>。</li><li>更新 <code>mn</code> 和 <code>mx</code>。</li><li>获取当前作为子序列结尾的元素 <code>x = nums[i]</code>。</li><li>计算 <code>x * mn</code> 和 <code>x * mx</code>，并更新 <code>ans</code>。</li></ul></li><li>返回 <code>ans</code>。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumProduct</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化答案为负无穷，确保能被任何实数结果更新</span></span><br><span class="line">        ans = -math.inf</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># mn 和 mx 用于维护 &quot;合法起始元素&quot; 的最小值和最大值</span></span><br><span class="line">        <span class="comment"># 初始时，mn 设为正无穷，mx 设为负无穷</span></span><br><span class="line">        mn, mx = math.inf, -math.inf</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 我们枚举子序列的 &quot;最后一个元素&quot; 的下标 i</span></span><br><span class="line">        <span class="comment"># i 至少需要是 m-1，这样前面才有足够的元素（包括它自己）构成长度为 m 的子序列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># y 是当前刚刚进入 &quot;合法起始元素范围&quot; 的那个数</span></span><br><span class="line">            <span class="comment"># 它的下标是 i - m + 1</span></span><br><span class="line">            <span class="comment"># 比如 m=2，当 i=1 时，y 是 nums[0]</span></span><br><span class="line">            y = nums[i - m + <span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新合法范围内的最小值和最大值</span></span><br><span class="line">            <span class="keyword">if</span> y &lt; mn: mn = y</span><br><span class="line">            <span class="keyword">if</span> y &gt; mx: mx = y</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># x 是当前选定的子序列 &quot;最后一个元素&quot;</span></span><br><span class="line">            x = nums[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算乘积</span></span><br><span class="line">            <span class="comment"># 如果 x 是正数，它乘以 mx (最大值) 可能得到最大积</span></span><br><span class="line">            <span class="comment"># 如果 x 是负数，它乘以 mn (最小值) 可能得到最大积（负负得正）</span></span><br><span class="line">            res1 = x * mn</span><br><span class="line">            res2 = x * mx</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新全局最大值</span></span><br><span class="line">            <span class="keyword">if</span> res1 &gt; ans: ans = res1</span><br><span class="line">            <span class="keyword">if</span> res2 &gt; ans: ans = res2</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(ans)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumProduct</span><span class="params">(nums []<span class="type">int</span>, m <span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化答案为 int64 范围内的最小值</span></span><br><span class="line">    ans := math.MinInt</span><br><span class="line">    <span class="comment">// mn 和 mx 分别记录合法左侧区间内的最小值和最大值</span></span><br><span class="line">    <span class="comment">// 初始时赋予相反的极值以便第一次比较时能被覆盖</span></span><br><span class="line">    mn,mx := math.MaxInt,math.MinInt</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历数组，i 代表子序列 &quot;最后一个元素&quot; 的下标</span></span><br><span class="line">    <span class="comment">// 从 m-1 开始，是因为至少需要 m 个元素才能构成子序列</span></span><br><span class="line">    <span class="keyword">for</span> i := m<span class="number">-1</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        <span class="comment">// y 代表子序列可能的 &quot;第一个元素&quot;</span></span><br><span class="line">        <span class="comment">// 随着 i 的增加，nums[i-m+1] 正好是可以作为第一个元素的最新成员</span></span><br><span class="line">        y:=nums[i-m+<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 维护合法左侧区间 [0, i-m+1] 的最小值和最大值</span></span><br><span class="line">        mn = min(mn,y)</span><br><span class="line">        mx = max(mx,y)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// x 是当前的 &quot;最后一个元素&quot;</span></span><br><span class="line">        x := nums[i]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算最大乘积：</span></span><br><span class="line">        <span class="comment">// 1. 当前元素 x * 历史最小值 mn (应对 x 为负数的情况)</span></span><br><span class="line">        <span class="comment">// 2. 当前元素 x * 历史最大值 mx (应对 x 为正数的情况)</span></span><br><span class="line">        <span class="comment">// 更新全局最大值 ans</span></span><br><span class="line">        ans = max(ans,x*mn,x*mx)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 题目要求返回 int64</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">int64</span>(ans)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(N)</code><br>其中 <code>N</code> 是数组 <code>nums</code> 的长度。我们需要遍历数组一次，每次迭代中的操作（比较、乘法）都是 <code>O(1)</code> 的。</p></li><li><p><strong>空间复杂度</strong>: <code>O(1)</code><br>只需要常数级别的额外空间来存储 <code>mn</code>, <code>mx</code>, <code>ans</code>, <code>x</code>, <code>y</code> 等变量。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 3584 题：&lt;a href=&quot;https://leetcode.cn/problems/maximum-product-of-first-and-last-elements-of-a-subsequence/description/&quot;&gt;子序列首尾元素的最大乘积&lt;/a&gt;。&lt;br&gt;该题核心在于如何在满足长度限制的情况下，通过一次遍历找到最优解。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="http://github.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="第454场周赛" scheme="http://github.com/tags/%E7%AC%AC454%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 3761 | 镜像对之间最小绝对距离</title>
    <link href="http://github.com/posts/leetcode-3761/"/>
    <id>http://github.com/posts/leetcode-3761/</id>
    <published>2025-12-21T07:39:00.000Z</published>
    <updated>2025-12-21T07:39:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 3761 题：<a href="https://leetcode.cn/problems/minimum-absolute-distance-between-mirror-pairs/">镜像对之间最小绝对距离</a>。<br>通过“枚举右，维护左”的思想，可以在一次遍历中解决问题。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组 <code>nums</code>。</p><p><strong>镜像对</strong> 是指一对满足下述条件的下标 <code>(i, j)</code>：</p><ul><li><code>0 &lt;= i &lt; j &lt; nums.length</code></li><li><code>reverse(nums[i]) == nums[j]</code></li></ul><p>其中 <code>reverse(x)</code> 表示将整数 <code>x</code> 的数字反转后形成的整数。反转后会忽略前导零，例如 <code>reverse(120) = 21</code>。</p><p>返回任意镜像对的下标之间的 <strong>最小绝对距离</strong>。下标 <code>i</code> 和 <code>j</code> 之间的绝对距离为 <code>abs(i - j)</code>。如果不存在镜像对，返回 -1。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： nums = [12,21,45,33,54]</span><br><span class="line">输出： 1</span><br><span class="line">解释：</span><br><span class="line">镜像对 (0, 1): reverse(12) = 21, 距离 1</span><br><span class="line">镜像对 (2, 4): reverse(45) = 54, 距离 2</span><br><span class="line">最小距离为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： nums = [120,21]</span><br><span class="line">输出： 1</span><br><span class="line">解释：reverse(120) = 21，即 nums[1]，距离 1。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</li><li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="哈希表-枚举右，维护左"><a href="#哈希表-枚举右，维护左" class="headerlink" title="哈希表 (枚举右，维护左)"></a>哈希表 (枚举右，维护左)</h4><p>这道题的核心在于找到满足 <code>reverse(nums[i]) == nums[j]</code> 且 <code>i &lt; j</code> 的下标对，并使 <code>j - i</code> 最小。</p><p>我们可以使用一次遍历的策略：</p><ol><li>当我们遍历到当前元素 <code>nums[j]</code> 时，我们需要知道在它之前（即下标小于 <code>j</code> 的位置），是否存在一个下标 <code>i</code>，使得 <code>reverse(nums[i])</code> 的结果恰好等于当前的 <code>nums[j]</code>。</li><li>变换一下等式：<code>reverse(nums[i]) == nums[j]</code>。这意味着，如果我们之前的遍历中，将每个数反转后的值作为 <strong>Key</strong>，将其下标作为 <strong>Value</strong> 存入哈希表。那么当遍历到 <code>nums[j]</code> 时，我们只需要去查哈希表中是否存在 Key 为 <code>nums[j]</code> 的记录。</li><li>如果哈希表中存在 <code>nums[j]</code>，说明之前有一个 <code>nums[i]</code> 翻转后等于当前数，此时 <code>j - map[nums[j]]</code> 就是一个合法的距离。</li><li>为了保证距离最小，我们需要尽可能让 <code>i</code> 大（即离 <code>j</code> 最近）。因此，在更新哈希表时，对于同一个翻转值，我们总是存储最新的下标。</li></ol><p><strong>算法流程：</strong></p><ol><li>初始化一个哈希表 <code>lastIndex</code>，用于存储 <code>&#123;翻转后的数值: 下标&#125;</code>。</li><li>遍历数组，当前下标为 <code>j</code>，数值为 <code>x</code>。</li><li><strong>查询</strong>：检查 <code>x</code> 是否在 <code>lastIndex</code> 中。<ul><li>如果存在，说明找到了一个镜像对，计算距离 <code>j - lastIndex[x]</code> 并更新全局最小值。</li></ul></li><li><strong>更新</strong>：计算当前数 <code>x</code> 的翻转值 <code>rev</code>。将 <code>lastIndex[rev]</code> 更新为 <code>j</code>。这里更新为最新下标是为了让后续匹配时 <code>j&#39; - j</code> 尽可能小（虽然本题是求最小距离，逻辑上我们只需要最近的匹配，但实际上更新 <code>lastIndex</code> 是为了服务于<code>nums[j]</code>作为“左边”那个数的情况）。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMirrorPairDistance</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = n</span><br><span class="line">        <span class="comment"># 哈希表，用于存储 &#123; reverse(nums[i]) : i &#125;</span></span><br><span class="line">        <span class="comment"># key 是数值 x 翻转后的结果，value 是该数值对应的下标</span></span><br><span class="line">        last_index = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 存储输入的中间变量 (题目要求)</span></span><br><span class="line">        ferilonsar = nums</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 1. 检查是否存在 i &lt; j 使得 reverse(nums[i]) == nums[j]</span></span><br><span class="line">            <span class="comment"># 根据我们的存储逻辑，如果 x 存在于 last_index 中，</span></span><br><span class="line">            <span class="comment"># 说明之前有一个数 nums[i] 翻转后等于 x</span></span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> last_index:</span><br><span class="line">                i = last_index[x]</span><br><span class="line">                <span class="comment"># 更新最小距离</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans, j - i)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 2. 计算当前数 x 的翻转值 rev</span></span><br><span class="line">            <span class="comment"># 例如 x=120 -&gt; s=&#x27;120&#x27; -&gt; rev_s=&#x27;021&#x27; -&gt; int=21</span></span><br><span class="line">            s = <span class="built_in">str</span>(x)</span><br><span class="line">            rev = <span class="built_in">int</span>(s[::-<span class="number">1</span>])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 3. 将 &#123; rev : j &#125; 存入哈希表</span></span><br><span class="line">            <span class="comment"># 我们记录的是：如果未来有一个数等于 rev，它应该匹配当前的下标 j</span></span><br><span class="line">            <span class="comment"># 更新为最新的 j 可以保证后续匹配时距离最近（贪心思想）</span></span><br><span class="line">            last_index[rev] = j</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> ans == n:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMirrorPairDistance</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    ans := n</span><br><span class="line">    lastIndex := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, n)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储输入的中间变量</span></span><br><span class="line">    ferilonsar := nums</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 检查哈希表中是否存在当前数值 x</span></span><br><span class="line">        <span class="comment">// 如果存在，说明之前有一个 nums[i] (i &lt; j)，其翻转值 reverse(nums[i]) 等于当前的 x</span></span><br><span class="line">        <span class="keyword">if</span> i, ok := lastIndex[x]; ok &#123;</span><br><span class="line">            ans = min(ans, j-i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算当前数值 x 的翻转值 rev</span></span><br><span class="line">        rev := <span class="number">0</span></span><br><span class="line">        <span class="comment">// 注意：Go 语言中 range 出来的 x 是值的拷贝，</span></span><br><span class="line">        <span class="comment">// 在这里修改 x 不会影响原数组 nums 或 ferilonsar</span></span><br><span class="line">        <span class="keyword">for</span> ; x &gt; <span class="number">0</span>; x /= <span class="number">10</span> &#123;</span><br><span class="line">            rev = rev*<span class="number">10</span> + x%<span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 &#123;翻转值: 当前下标&#125; 存入哈希表</span></span><br><span class="line">        <span class="comment">// 这样当未来遇到一个数等于 rev 时，就能找到当前的 j 作为镜像对的左侧</span></span><br><span class="line">        <span class="comment">// 如果 rev 已经存在，更新为当前的 j（更大的下标），这有助于在后续匹配中获得更小的距离</span></span><br><span class="line">        lastIndex[rev] = j</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 ans 没有被更新过（仍为初始值 n），说明没有找到镜像对</span></span><br><span class="line">    <span class="keyword">if</span> ans == n &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(N * M)</code><br>其中 <code>N</code> 是数组的长度，<code>M</code> 是数字的最大位数（<code>log10(max(nums))</code>）。在本题范围内，数字最大为 10^9，位数不超过 10，可以视为常数。因此整体接近 <code>O(N)</code>。</p></li><li><p><strong>空间复杂度</strong>: <code>O(N)</code><br>我们需要一个哈希表来存储每个数字翻转后的值及其下标。最坏情况下需要存储 <code>N</code> 个元素。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 3761 题：&lt;a href=&quot;https://leetcode.cn/problems/minimum-absolute-distance-between-mirror-pairs/&quot;&gt;镜像对之间最小绝对距离&lt;/a&gt;。&lt;br&gt;通过“枚举右，维护左”的思想，可以在一次遍历中解决问题。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="数学" scheme="http://github.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="第478场周赛" scheme="http://github.com/tags/%E7%AC%AC478%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 3371 | 识别数组中的最大异常值</title>
    <link href="http://github.com/posts/leetcode-3371/"/>
    <id>http://github.com/posts/leetcode-3371/</id>
    <published>2025-12-20T07:18:00.000Z</published>
    <updated>2025-12-20T07:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 3371 题：<a href="https://leetcode.cn/problems/identify-the-largest-outlier-in-an-array/">识别数组中的最大异常值</a>。<br>这是一道结合了数学推导和哈希表计数的题目，关键在于理解总和、特殊数字之和以及异常值之间的数量关系。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组 <code>nums</code>。该数组包含 <code>n</code> 个元素，其中 恰好 有 <code>n - 2</code> 个元素是 <strong>特殊数字</strong> 。剩下的 <strong>两个</strong> 元素中，一个是所有 <strong>特殊数字</strong> 的 <strong>和</strong> ，另一个是 <strong>异常值</strong> 。</p><p><strong>异常值</strong> 的定义是：既不是原始特殊数字之一，也不是表示元素和的那个数。</p><p>注意，特殊数字、和 以及 异常值 的下标必须 <strong>不同</strong> ，但可以共享 <strong>相同</strong> 的值。</p><p>返回 <code>nums</code> 中可能的 <strong>最大异常值</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入： nums = [2,3,5,10]</span><br><span class="line">输出： 10</span><br><span class="line">解释：</span><br><span class="line">特殊数字可以是 2 和 3，因此和为 5，异常值为 10。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入： nums = [-2,-1,-3,-6,4]</span><br><span class="line">输出： 4</span><br><span class="line">解释：</span><br><span class="line">特殊数字可以是 -2、-1 和 -3，因此和为 -6，异常值为 4。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入： nums = [1,1,1,1,1,5,5]</span><br><span class="line">输出： 5</span><br><span class="line">解释：</span><br><span class="line">特殊数字可以是 1、1、1、1 和 1，因此和为 5，另一个 5 为异常值。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>3 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</li><li>-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li><li>输入保证 nums 中至少存在 一个 可能的异常值。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-数学推导"><a href="#1-数学推导" class="headerlink" title="1. 数学推导"></a>1. 数学推导</h4><p>设数组所有元素的总和为 <code>total</code>。<br>根据题意，数组被分成了三部分：</p><ol><li><code>n - 2</code> 个特殊数字，设它们的和为 <code>sum_special</code>。</li><li>1 个元素是特殊数字的和，即该元素的值等于 <code>sum_special</code>。</li><li>1 个元素是异常值，设为 <code>outlier</code>。</li></ol><p>我们可以列出以下等式：<br><code>total = sum_special + (特殊数字的和这一元素) + outlier</code><br>因为“特殊数字的和这一元素”的值就是 <code>sum_special</code>，所以：<br><code>total = sum_special + sum_special + outlier</code><br><code>total = 2 * sum_special + outlier</code></p><p>由此可以推导出：<br><code>total - outlier = 2 * sum_special</code></p><p>这意味着，如果我们从总和中减去潜在的异常值 <code>outlier</code>，剩下的值 <code>total - outlier</code> 必须满足两个条件：</p><ol><li>是一个偶数（因为它等于 <code>2 * sum_special</code>）。</li><li>除以 2 后的值（即 <code>sum_special</code>）必须存在于数组中，充当“特殊数字的和”这个角色。</li></ol><h4 id="2-哈希表计数与枚举"><a href="#2-哈希表计数与枚举" class="headerlink" title="2. 哈希表计数与枚举"></a>2. 哈希表计数与枚举</h4><p>基于上述推导，我们可以采用枚举的方法：</p><ol><li><strong>预处理</strong>：首先计算数组的总和 <code>total</code>，并使用哈希表（或计数器）记录每个数字出现的次数。</li><li><strong>枚举异常值</strong>：遍历数组中的每一个数字 <code>x</code>，将其假设为 <strong>异常值</strong>。</li><li><strong>验证合法性</strong>：<ul><li>首先从计数器中暂时减去 <code>x</code>（因为它被假设为异常值，不能同时作为“特殊数字的和”或“特殊数字”）。</li><li>计算剩余部分的和：<code>remain = total - x</code>。</li><li>检查 <code>remain</code> 是否为偶数。</li><li>如果为偶数，计算目标值 <code>target = remain / 2</code>。</li><li>检查 <code>target</code> 是否存在于计数器中（即 <code>cnt[target] &gt; 0</code>）。</li><li>如果所有条件满足，说明 <code>x</code> 是一个合法的异常值，更新最大值结果。</li><li>恢复计数器（将 <code>x</code> 加回去），继续枚举下一个数字。</li></ul></li></ol><p>该方法只需要遍历两次数组（一次统计，一次枚举），时间复杂度为 O(n)，非常高效。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLargestOutlier</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 统计每个数字出现的频率</span></span><br><span class="line">        cnt = Counter(nums)</span><br><span class="line">        <span class="comment"># 计算数组总和</span></span><br><span class="line">        total = <span class="built_in">sum</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化答案为负无穷大</span></span><br><span class="line">        ans = -inf</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历数组中的每个数字，将其作为潜在的“异常值” x</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 假设 x 是异常值，先将其从计数中减去</span></span><br><span class="line">            <span class="comment"># 这样做是为了处理 x 和“特殊数字之和”数值相同的情况</span></span><br><span class="line">            <span class="comment"># 例如 nums = [2, 2, 4]，total=8。若 x=4，remain=4，target=2，cnt[2]&gt;0，合法。</span></span><br><span class="line">            <span class="comment"># 若 nums = [2, 2]，total=4。若 x=2，remain=2，target=1，cnt[1]=0，不合法。</span></span><br><span class="line">            cnt[x] -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 根据公式 total = 2 * sum_special + outlier</span></span><br><span class="line">            <span class="comment"># 推导得：total - outlier = 2 * sum_special</span></span><br><span class="line">            <span class="comment"># 所以 (total - x) 必须是偶数</span></span><br><span class="line">            <span class="keyword">if</span> (total - x) % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> cnt[(total - x) // <span class="number">2</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 如果满足条件，且计算出的 sum_special 存在于剩余数组中</span></span><br><span class="line">                <span class="comment"># 更新最大异常值</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, x)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 恢复计数，以便下一次迭代</span></span><br><span class="line">            cnt[x] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLargestOutlier</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 创建哈希表统计每个数字出现的次数</span></span><br><span class="line">    cnt := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一次遍历计算总和并统计频率</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        cnt[x]++</span><br><span class="line">        total += x</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化答案为极小值</span></span><br><span class="line">    <span class="comment">// 题目范围 -1000 &lt;= nums[i]，所以 -2000 足够小，或者使用 math.MinInt</span></span><br><span class="line">    ans := <span class="number">-10000</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组，尝试将每个元素作为异常值</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 暂时移除当前元素 x，因为它被假设为异常值</span></span><br><span class="line">        cnt[x]--</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算移除异常值后的剩余和</span></span><br><span class="line">        remain := total - x</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 剩余和必须是偶数，因为 remain = 2 * sum_special</span></span><br><span class="line">        <span class="keyword">if</span> remain % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 计算出需要的“特殊数字之和”</span></span><br><span class="line">            target := remain / <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查这个和是否存在于剩余的数组元素中</span></span><br><span class="line">            <span class="keyword">if</span> cnt[target] &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> x &gt; ans &#123;</span><br><span class="line">                    ans = x</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 恢复当前元素的计数</span></span><br><span class="line">        cnt[x]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>我们需要遍历数组两次：第一次用于计算总和并建立频率哈希表，第二次用于枚举每个元素作为潜在的异常值。每次哈希表查找的操作是 <code>O(1)</code>。</p></li><li><p><strong>空间复杂度</strong>: <code>O(n)</code><br>需要一个哈希表来存储数组元素的频率。在最坏情况下（所有元素都不同），哈希表的大小与数组长度成正比。考虑到题目提示中 <code>nums[i]</code> 的范围在 -1000 到 1000 之间，实际空间复杂度受限于数值范围，可以视为常数级别 <code>O(C)</code>，其中 <code>C</code> 是数值范围的大小。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 3371 题：&lt;a href=&quot;https://leetcode.cn/problems/identify-the-largest-outlier-in-an-array/&quot;&gt;识别数组中的最大异常值&lt;/a&gt;。&lt;br&gt;这是一道结合了数学推导和哈希表计数的题目，关键在于理解总和、特殊数字之和以及异常值之间的数量关系。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="枚举" scheme="http://github.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
    <category term="计数" scheme="http://github.com/tags/%E8%AE%A1%E6%95%B0/"/>
    
    <category term="第426场周赛" scheme="http://github.com/tags/%E7%AC%AC426%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 3623 | 统计梯形的数目 I</title>
    <link href="http://github.com/posts/leetcode-3623/"/>
    <id>http://github.com/posts/leetcode-3623/</id>
    <published>2025-12-19T01:40:00.000Z</published>
    <updated>2025-12-19T01:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 3623 题：<a href="https://leetcode.cn/problems/count-trapezoids-i/">统计梯形的数目 I</a>。<br>这道题核心在于如何利用“水平边”这一特性快速统计符合条件的四边形。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个二维整数数组 <code>points</code>，其中 <code>points[i] = [xi, yi]</code> 表示第 <code>i</code> 个点在笛卡尔平面上的坐标。</p><p><strong>水平梯形</strong> 是一种凸四边形，具有 <strong>至少一对</strong> 水平边（即平行于 x 轴的边）。两条直线平行当且仅当它们的斜率相同。</p><p>返回可以从 <code>points</code> 中任意选择四个不同点组成的 <strong>水平梯形</strong> 数量。</p><p>由于答案可能非常大，请返回结果对 10^9 + 7 取余数后的值。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入： points = [[1,0],[2,0],[3,0],[2,2],[3,2]]</span><br><span class="line">输出： 3</span><br><span class="line">解释：</span><br><span class="line">有三种不同方式选择四个点组成一个水平梯形：</span><br><span class="line">1. 使用点 [1,0]、[2,0]、[3,2] 和 [2,2]。</span><br><span class="line">2. 使用点 [2,0]、[3,0]、[3,2] 和 [2,2]。</span><br><span class="line">3. 使用点 [1,0]、[3,0]、[3,2] 和 [2,2]。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： points = [[0,0],[1,0],[0,1],[2,1]]</span><br><span class="line">输出： 1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>4 &lt;&#x3D; points.length &lt;&#x3D; 10^5</li><li>-10^8 &lt;&#x3D; xi, yi &lt;&#x3D; 10^8</li><li>所有点两两不同。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-几何特性分析"><a href="#1-几何特性分析" class="headerlink" title="1. 几何特性分析"></a>1. 几何特性分析</h4><p>题目要求统计“水平梯形”的数量，关键定义在于“具有至少一对水平边”。<br>在笛卡尔坐标系中，两个点构成的线段如果是水平的，意味着它们的 <strong>纵坐标（y 值）相同</strong>。</p><p>因此，我们要组成一个水平梯形，可以简化为以下步骤：</p><ol><li>在某个纵坐标 <code>y1</code> 上，选取两个点，构成一条水平底边。</li><li>在另一个纵坐标 <code>y2</code> (<code>y1 != y2</code>) 上，选取两个点，构成另一条水平底边。</li><li>这两条水平线段自然平行，从而构成了梯形的上下底（或者矩形，矩形也是特殊的梯形）。</li></ol><h4 id="2-组合数学转化"><a href="#2-组合数学转化" class="headerlink" title="2. 组合数学转化"></a>2. 组合数学转化</h4><p>根据上述分析，问题转化为：</p><ol><li><strong>统计每个 Y 轴层级上的点数</strong>：使用哈希表统计具有相同 <code>y</code> 坐标的点的数量 <code>c</code>。</li><li><strong>计算单层的线段数</strong>：对于任意一行，如果有 <code>c</code> 个点，那么从中任选 2 个点可以组成的水平线段数量为 <code>C(c, 2)</code>，即 <code>c * (c - 1) / 2</code>。</li><li><strong>计算层级间的组合</strong>：如果我们计算出了所有不同 <code>y</code> 层级各自能构成的线段数量，记为 <code>k1, k2, k3, ...</code>。那么总的梯形数量就是从这些层级中任选两层，将其线段数量相乘并累加。<br>即：<code>Total = k1*k2 + k1*k3 + ... + k2*k3 + ...</code></li></ol><h4 id="3-优化计算-枚举右，维护左"><a href="#3-优化计算-枚举右，维护左" class="headerlink" title="3. 优化计算 (枚举右，维护左)"></a>3. 优化计算 (枚举右，维护左)</h4><p>为了避免双重循环去两两配对不同层级的线段数（复杂度 O(N^2)），我们可以使用前缀和的思想：</p><ul><li>遍历每一个 <code>y</code> 层级。</li><li>计算当前层级能构成的线段数 <code>k</code>。</li><li>用一个变量 <code>s</code> 记录之前所有层级已经构成的线段总数。</li><li>当前层级能与之前所有层级组成的梯形数量为 <code>s * k</code>。</li><li>更新 <code>s</code>，将当前层的 <code>k</code> 加进去，供后续层级使用。</li></ul><p>这样，时间复杂度仅为 O(N)。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countTrapezoids</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        MOD = <span class="number">1_000_000_007</span></span><br><span class="line">        <span class="comment"># 使用哈希表统计每个 y 坐标出现的次数</span></span><br><span class="line">        <span class="comment"># key 是 y 坐标，value 是该纵坐标上点的个数</span></span><br><span class="line">        cnt = Counter(p[<span class="number">1</span>] <span class="keyword">for</span> p <span class="keyword">in</span> points) </span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span> <span class="comment"># 用于累计最终结果</span></span><br><span class="line">        s = <span class="number">0</span>   <span class="comment"># 用于记录之前遍历过的所有层级能够组成的水平线段总数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历哈希表中的计数值 c</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> cnt.values():</span><br><span class="line">            <span class="comment"># 计算当前 y 坐标层级能组成的水平线段数量</span></span><br><span class="line">            <span class="comment"># 即从 c 个点中选 2 个点的组合数：C(c, 2) = c * (c - 1) / 2</span></span><br><span class="line">            k = c * (c - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当前层的 k 条线段，可以与之前累积的 s 条线段任意两两组合</span></span><br><span class="line">            <span class="comment"># 每一对组合都代表一个水平梯形</span></span><br><span class="line">            ans += s * k</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新累积的线段数，将当前层的线段数加入 s</span></span><br><span class="line">            s += k</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans % MOD</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countTrapezoids</span><span class="params">(points [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> MOD = <span class="number">1_000_000_007</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 map 统计每个 y 坐标出现的次数</span></span><br><span class="line">    <span class="comment">// key: y 坐标, value: 该坐标上点的个数</span></span><br><span class="line">    cnt := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> points &#123;</span><br><span class="line">        cnt[p[<span class="number">1</span>]]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ans := <span class="number">0</span> <span class="comment">// 最终结果</span></span><br><span class="line">    s := <span class="number">0</span>   <span class="comment">// 前缀和：记录之前遍历过的层级能构成的水平线段总数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历 map 中的统计值</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> cnt &#123;</span><br><span class="line">        <span class="comment">// 计算当前 y 层级能构成的水平线段数量</span></span><br><span class="line">        <span class="comment">// 公式为组合数 C(c, 2) = c * (c - 1) / 2</span></span><br><span class="line">        k := c * (c - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 核心逻辑：枚举右（当前层），维护左（之前所有层的线段总数 s）</span></span><br><span class="line">        <span class="comment">// 当前层的 k 条线段与之前的 s 条线段两两组合</span></span><br><span class="line">        ans = (ans + s * k) % MOD</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前层的线段数累加到 s 中，供后续层级匹配</span></span><br><span class="line">        s = (s + k) % MOD</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(N)</code><br>其中 <code>N</code> 是数组 <code>points</code> 的长度。我们需要遍历一次数组来统计 <code>y</code> 坐标的频率，然后遍历哈希表的 <code>values</code>。哈希表的大小最多为 <code>N</code>。</p></li><li><p><strong>空间复杂度</strong>: <code>O(N)</code><br>用于存储 <code>y</code> 坐标频率的哈希表。在最坏情况下（所有点 <code>y</code> 坐标都不同），空间复杂度为 <code>O(N)</code>。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 3623 题：&lt;a href=&quot;https://leetcode.cn/problems/count-trapezoids-i/&quot;&gt;统计梯形的数目 I&lt;/a&gt;。&lt;br&gt;这道题核心在于如何利用“水平边”这一特性快速统计符合条件的四边形。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="数学" scheme="http://github.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://github.com/tags/%E5%87%A0%E4%BD%95/"/>
    
    <category term="第459场周赛" scheme="http://github.com/tags/%E7%AC%AC459%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2001 | 可互换矩形的组数</title>
    <link href="http://github.com/posts/leetcode-2001/"/>
    <id>http://github.com/posts/leetcode-2001/</id>
    <published>2025-12-18T01:24:00.000Z</published>
    <updated>2025-12-18T01:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 2001 题：<a href="https://leetcode.cn/problems/number-of-pairs-of-interchangeable-rectangles/">可互换矩形的组数</a>。<br>这是一道结合了哈希表统计与基础数论（最大公约数）的题目，考察如何处理浮点数精度问题以及组合计数的应用。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>用一个下标从 0 开始的二维整数数组 <code>rectangles</code> 来表示 <code>n</code> 个矩形，其中 <code>rectangles[i] = [widthi, heighti]</code> 表示第 <code>i</code> 个矩形的宽度和高度。</p><p>如果两个矩形 <code>i</code> 和 <code>j</code>（<code>i &lt; j</code>）的宽高比相同，则认为这两个矩形 <strong>可互换</strong> 。更规范的说法是，两个矩形满足 <code>widthi/heighti == widthj/heightj</code>（使用实数除法而非整数除法），则认为这两个矩形 <strong>可互换</strong> 。</p><p>计算并返回 <code>rectangles</code> 中有多少对 <strong>可互换</strong> 矩形。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[4,8],[3,6],[10,20],[15,30]]</span><br><span class="line">输出：6</span><br><span class="line">解释：下面按下标（从 0 开始）列出可互换矩形的配对情况：</span><br><span class="line">- 矩形 0 和矩形 1 ：4/8 == 3/6</span><br><span class="line">- 矩形 0 和矩形 2 ：4/8 == 10/20</span><br><span class="line">- 矩形 0 和矩形 3 ：4/8 == 15/30</span><br><span class="line">- 矩形 1 和矩形 2 ：3/6 == 10/20</span><br><span class="line">- 矩形 1 和矩形 3 ：3/6 == 15/30</span><br><span class="line">- 矩形 2 和矩形 3 ：10/20 == 15/30</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[4,5],[7,8]]</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在成对的可互换矩形。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == rectangles.length</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>rectangles[i].length == 2</code></li><li><code>1 &lt;= widthi, heighti &lt;= 10^5</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-浮点数精度的陷阱"><a href="#1-浮点数精度的陷阱" class="headerlink" title="1. 浮点数精度的陷阱"></a>1. 浮点数精度的陷阱</h4><p>题目要求判断两个矩形的宽高比 <code>width / height</code> 是否相等。如果直接使用浮点数除法计算比值，可能会遇到精度问题，导致本该相等的比值被判定为不等（或者反之）。</p><h4 id="2-利用最大公约数-GCD-进行化简"><a href="#2-利用最大公约数-GCD-进行化简" class="headerlink" title="2. 利用最大公约数 (GCD) 进行化简"></a>2. 利用最大公约数 (GCD) 进行化简</h4><p>为了避免浮点数误差，我们可以将宽高比看作一个分数。判断两个分数是否相等，最稳妥的方法是将它们化简为 <strong>最简分数</strong>。<br>例如：矩形 <code>[4, 8]</code> 的比值是 <code>4/8</code>，化简后为 <code>1/2</code>；矩形 <code>[3, 6]</code> 的比值是 <code>3/6</code>，化简后也是 <code>1/2</code>。</p><p>我们可以通过除以分子和分母的最大公约数（Greatest Common Divisor, GCD）来得到最简形式：<br><code>reduced_w = w / gcd(w, h)</code><br><code>reduced_h = h / gcd(w, h)</code></p><p>这样，我们就可以用一个二元组 <code>(reduced_w, reduced_h)</code> 来唯一标识一种宽高比。</p><h4 id="3-哈希表计数与组合数学"><a href="#3-哈希表计数与组合数学" class="headerlink" title="3. 哈希表计数与组合数学"></a>3. 哈希表计数与组合数学</h4><p>算法流程如下：</p><ol><li><strong>遍历与统计</strong>：使用哈希表记录每种“最简宽高比”出现的次数。哈希表的 Key 是化简后的 <code>(宽, 高)</code>，Value 是该比例出现的次数。</li><li><strong>计算对数</strong>：如果某种比例出现了 <code>m</code> 次，那么在这 <code>m</code> 个矩形中，任意选出两个都能组成一对可互换矩形。<br>这是一个组合数问题，即从 <code>m</code> 个元素中选 2 个的组合数：<br><code>Pairs = m * (m - 1) / 2</code></li><li><strong>累加结果</strong>：遍历哈希表，将所有比例对应的组合数累加即为最终答案。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">interchangeableRectangles</span>(<span class="params">self, rectangles: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 导入 gcd 函数，python 3.9+ 也可以使用 math.gcd</span></span><br><span class="line">        <span class="keyword">from</span> math <span class="keyword">import</span> gcd</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建哈希表 cnt 用于存储 &#123;最简宽高比元组: 出现次数&#125;</span></span><br><span class="line">        cnt = &#123;&#125;</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历所有矩形</span></span><br><span class="line">        <span class="keyword">for</span> w, h <span class="keyword">in</span> rectangles:</span><br><span class="line">            <span class="comment"># 计算宽度和高度的最大公约数</span></span><br><span class="line">            g = gcd(w, h)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将宽高分别除以最大公约数，得到最简分数形式</span></span><br><span class="line">            <span class="comment"># 使用元组作为字典的 key</span></span><br><span class="line">            key = (w // g, h // g)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 统计该最简比出现的次数</span></span><br><span class="line">            cnt[key] = cnt.get(key, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 遍历哈希表，计算每种比例贡献的配对数</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> cnt.values():</span><br><span class="line">            <span class="comment"># 从 m 个矩形中任选 2 个的组合数公式：m * (m - 1) / 2</span></span><br><span class="line">            ans += m * (m - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">interchangeableRectangles</span><span class="params">(rectangles [][]<span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 创建哈希表，Key 为长度为2的数组表示最简分数的 [宽, 高]</span></span><br><span class="line">    <span class="comment">// Value 为 int64 类型，记录出现次数</span></span><br><span class="line">    cnt := <span class="keyword">map</span>[[<span class="number">2</span>]<span class="type">int</span>]<span class="type">int64</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> ans <span class="type">int64</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有矩形数据</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> rectangles &#123;</span><br><span class="line">        w, h := p[<span class="number">0</span>], p[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算宽和高的最大公约数</span></span><br><span class="line">        g := gcd(w, h)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将宽和高化简为最简形式，并存入哈希表计数</span></span><br><span class="line">        <span class="comment">// [2]int&#123;w/g, h/g&#125; 作为 Map 的 Key</span></span><br><span class="line">        cnt[[<span class="number">2</span>]<span class="type">int</span>&#123;w/g, h/g&#125;]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历哈希表，根据每种比例出现的次数 m 计算可互换对数</span></span><br><span class="line">    <span class="keyword">for</span> _, m := <span class="keyword">range</span> cnt &#123;</span><br><span class="line">        <span class="comment">// 组合数学公式 C(m, 2) = m * (m - 1) / 2</span></span><br><span class="line">        ans += m * (m - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：计算两个整数的最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> b != <span class="number">0</span> &#123;</span><br><span class="line">        a, b = b, a%b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n * log(C))</code><br>其中 <code>n</code> 是矩形的数量，<code>C</code> 是矩形边长的最大值。我们需要遍历 <code>n</code> 个矩形，每次计算 GCD 的时间复杂度为 <code>O(log(min(w, h)))</code>。</p></li><li><p><strong>空间复杂度</strong>: <code>O(n)</code><br>最坏情况下，所有矩形的宽高比都互不相同，哈希表需要存储 <code>n</code> 个键值对。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 2001 题：&lt;a href=&quot;https://leetcode.cn/problems/number-of-pairs-of-interchangeable-rectangles/&quot;&gt;可互换矩形的组数&lt;/a&gt;。&lt;br&gt;这是一道结合了哈希表统计与基础数论（最大公约数）的题目，考察如何处理浮点数精度问题以及组合计数的应用。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="数学" scheme="http://github.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数论" scheme="http://github.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="计数" scheme="http://github.com/tags/%E8%AE%A1%E6%95%B0/"/>
    
    <category term="第258场周赛" scheme="http://github.com/tags/%E7%AC%AC258%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2260 | 必须拿起的最小连续卡牌数</title>
    <link href="http://github.com/posts/leetcode-2260/"/>
    <id>http://github.com/posts/leetcode-2260/</id>
    <published>2025-12-17T01:20:00.000Z</published>
    <updated>2025-12-17T01:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 2260 题：<a href="https://leetcode.cn/problems/minimum-consecutive-cards-to-pick-up/">必须拿起的最小连续卡牌数</a>。<br>题目考察如何利用哈希表记录元素的索引信息，从而快速计算最短距离。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组 <code>cards</code> ，其中 <code>cards[i]</code> 表示第 <code>i</code> 张卡牌的 <strong>值</strong> 。如果两张卡牌的值相同，则认为这一对卡牌 <strong>匹配</strong> 。</p><p>返回你必须拿起的最小连续卡牌数，以使在拿起的卡牌中有一对匹配的卡牌。如果无法得到一对匹配的卡牌，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cards = [3,4,2,3,4,7]</span><br><span class="line">输出：4</span><br><span class="line">解释：拿起卡牌 [3,4,2,3] 将会包含一对值为 3 的匹配卡牌。注意，拿起 [4,2,3,4] 也是最优方案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cards = [1,0,5,3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：无法找出含一对匹配卡牌的一组连续卡牌。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; cards.length &lt;&#x3D; 10^5</li><li>0 &lt;&#x3D; cards[i] &lt;&#x3D; 10^6</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1. 问题分析"></a>1. 问题分析</h4><p>题目要求找到一对值相同的卡牌，并使它们之间的距离（包含这两张卡牌在内的连续卡牌数）最小。<br>假设两张相同卡牌的下标分别为 <code>j</code> 和 <code>i</code>（其中 <code>j &lt; i</code>），那么连续卡牌数就是 <code>i - j + 1</code>。我们需要最小化这个值。</p><h4 id="2-枚举右，维护左"><a href="#2-枚举右，维护左" class="headerlink" title="2. 枚举右，维护左"></a>2. 枚举右，维护左</h4><p>如果我们遍历数组，将当前遍历到的位置 <code>i</code> 看作是匹配对中的 <strong>右侧</strong> 卡牌，那么我们只需要关心：<strong>在下标 <code>i</code> 之前，最近一次出现相同数值的下标 <code>j</code> 在哪里？</strong></p><p>因为我们要找的是 <strong>最小</strong> 连续卡牌数，对于同一个数值，更靠左的下标（比如 <code>k &lt; j</code>）与 <code>i</code> 组成的距离肯定比 <code>j</code> 与 <code>i</code> 组成的距离远，所以我们只需要记录每个数值 <strong>最后一次出现的位置</strong> 即可。</p><h4 id="3-哈希表解法"><a href="#3-哈希表解法" class="headerlink" title="3. 哈希表解法"></a>3. 哈希表解法</h4><p>我们可以使用哈希表 <code>pos</code> 来记录每个数值最后出现的下标：</p><ul><li><strong>Key</strong>: 卡牌的值 <code>v</code></li><li><strong>Value</strong>: 该值最后出现的下标 <code>i</code></li></ul><p>算法流程如下：</p><ol><li>初始化答案 <code>ans</code> 为一个足够大的数（比如数组长度 + 1）。</li><li>遍历数组 <code>cards</code>，设当前下标为 <code>i</code>，值为 <code>v</code>。</li><li><strong>检查哈希表</strong>：如果 <code>v</code> 已经在 <code>pos</code> 中，说明之前遇到过这张牌。<ul><li>取出 <code>v</code> 上次出现的下标 <code>p</code>。</li><li>计算当前连续卡牌数 <code>current_len = i - p + 1</code>。</li><li>如果 <code>current_len</code> 比当前记录的 <code>ans</code> 更小，则更新 <code>ans</code>。</li></ul></li><li><strong>更新哈希表</strong>：无论是否匹配，都要将 <code>pos[v]</code> 更新为当前下标 <code>i</code>，保证后续计算使用的是最近的距离。</li><li>最后检查 <code>ans</code> 是否被更新过，如果仍是初始值，返回 <code>-1</code>，否则返回 <code>ans</code>。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumCardPickup</span>(<span class="params">self, cards: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化答案为数组长度 + 1，表示无穷大</span></span><br><span class="line">        ans = <span class="built_in">len</span>(cards) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 哈希表 pos 用于记录 &#123;数值: 最近一次出现的下标&#125;</span></span><br><span class="line">        pos = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历数组，获取当前下标 i 和数值 v</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(cards):</span><br><span class="line">            <span class="comment"># 如果 v 已经在哈希表中，说明找到了一对匹配的卡牌</span></span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> pos:</span><br><span class="line">                <span class="comment"># 获取上一次出现的位置 p</span></span><br><span class="line">                p = pos[v]</span><br><span class="line">                <span class="comment"># 计算当前连续长度，并尝试更新最小长度 ans</span></span><br><span class="line">                <span class="keyword">if</span> i - p + <span class="number">1</span> &lt; ans:</span><br><span class="line">                    ans = i - p + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新哈希表，记录 v 最后一次出现的下标为当前 i</span></span><br><span class="line">            pos[v] = i</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果 ans 仍然大于数组长度，说明没有找到匹配对，返回 -1</span></span><br><span class="line">        <span class="keyword">if</span> ans &lt;= <span class="built_in">len</span>(cards):</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minimumCardPickup</span><span class="params">(cards []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化最小连续卡牌数，设为一个不可能达到的最大值</span></span><br><span class="line">ans := <span class="built_in">len</span>(cards) + <span class="number">1</span></span><br><span class="line">    <span class="comment">// pos 用于存储每个卡牌值最后一次出现的下标 map[数值]下标</span></span><br><span class="line">pos := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历卡牌数组</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> cards &#123;</span><br><span class="line">        <span class="comment">// 检查当前卡牌值 v 是否之前出现过</span></span><br><span class="line">        <span class="comment">// 如果出现过，说明构成了一对匹配</span></span><br><span class="line"><span class="keyword">if</span> p, ok := pos[v]; ok &amp;&amp; i-p+<span class="number">1</span> &lt; ans &#123; <span class="comment">// 找最近出现的 v，并判断是否比当前最优解更短</span></span><br><span class="line">ans = i - p + <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 无论是否找到匹配，都更新当前卡牌值 v 的最新下标为 i</span></span><br><span class="line">        <span class="comment">// 这样保证下次遇到 v 时，计算的是最近的距离</span></span><br><span class="line">pos[v] = i</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 ans 没有被更新（仍大于数组长度），说明无解，返回 -1</span></span><br><span class="line"><span class="keyword">if</span> ans &lt;= <span class="built_in">len</span>(cards) &#123;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>我们需要遍历整个数组 <code>cards</code> 一次。在哈希表中进行查找和插入操作的平均时间复杂度为 <code>O(1)</code>。</p></li><li><p><strong>空间复杂度</strong>: <code>O(n)</code><br>最坏情况下，数组中所有元素都不相同，哈希表需要存储 <code>n</code> 个键值对。其中 <code>n</code> 是数组 <code>cards</code> 的长度。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 2260 题：&lt;a href=&quot;https://leetcode.cn/problems/minimum-consecutive-cards-to-pick-up/&quot;&gt;必须拿起的最小连续卡牌数&lt;/a&gt;。&lt;br&gt;题目考察如何利用哈希表记录元素的索引信息，从而快速计算最短距离。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="滑动窗口" scheme="http://github.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="第291场周赛" scheme="http://github.com/tags/%E7%AC%AC291%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1679 | K 和数对的最大数目</title>
    <link href="http://github.com/posts/leetcode-1679/"/>
    <id>http://github.com/posts/leetcode-1679/</id>
    <published>2025-12-16T01:00:00.000Z</published>
    <updated>2025-12-16T01:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1679 题：<a href="https://leetcode.cn/problems/max-number-of-k-sum-pairs/">K 和数对的最大数目</a>。<br>这道题是“两数之和”的进阶版，重点在于统计能组成目标和 k 的<strong>不重复</strong>数对的最大数量。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p><p>每一步操作中，你需要从数组中选出和为 <code>k</code> 的两个整数，并将它们移出数组。</p><p>返回你可以对数组执行的最大操作数。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4], k = 5</span><br><span class="line">输出：2</span><br><span class="line">解释：开始时 nums = [1,2,3,4]：</span><br><span class="line">- 移出 1 和 4 ，之后 nums = [2,3]</span><br><span class="line">- 移出 2 和 3 ，之后 nums = []</span><br><span class="line">不再有和为 5 的数对，因此最多执行 2 次操作。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,1,3,4,3], k = 6</span><br><span class="line">输出：1</span><br><span class="line">解释：开始时 nums = [3,1,3,4,3]：</span><br><span class="line">- 移出前两个 3 ，之后nums = [1,4,3]</span><br><span class="line">不再有和为 6 的数对，因此最多执行 1 次操作。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</li><li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</li><li>1 &lt;&#x3D; k &lt;&#x3D; 10^9</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="哈希表计数-一次遍历"><a href="#哈希表计数-一次遍历" class="headerlink" title="哈希表计数 (一次遍历)"></a>哈希表计数 (一次遍历)</h4><p>这道题的核心是寻找两数之和等于 <code>k</code> 的配对。与经典的“两数之和”不同的是，这里我们需要尽可能多地寻找配对，并且每个数字只能被使用一次。</p><p>我们可以使用哈希表（Python 中的 <code>dict</code> 或 <code>defaultdict</code>，Go 中的 <code>map</code>）来记录遍历过程中未被匹配的数字及其出现的次数。</p><p><strong>算法流程：</strong></p><ol><li>初始化一个哈希表 <code>cnt</code> 用来存储数字出现的次数，初始化结果变量 <code>ans = 0</code>。</li><li>遍历数组 <code>nums</code> 中的每一个数 <code>x</code>。</li><li>对于当前数 <code>x</code>，我们需要寻找是否存在一个之前的数 <code>target = k - x</code>。</li><li><strong>查询与更新</strong>：<ul><li>如果 <code>cnt[k - x]</code> 大于 0，说明之前已经遍历过至少一个 <code>k - x</code>，并且它还在等待配对。<ul><li>我们成功凑成一对 <code>(x, k - x)</code>。</li><li>将 <code>cnt[k - x]</code> 的计数减 1（表示移出了这个数）。</li><li>将操作数 <code>ans</code> 加 1。</li></ul></li><li>如果 <code>cnt[k - x]</code> 等于 0（或不存在），说明当前无法与之前的数凑成和为 <code>k</code> 的数对。<ul><li>我们将当前数 <code>x</code> 放入哈希表中等待后续的数来匹配它，即 <code>cnt[x] + 1</code>。</li></ul></li></ul></li></ol><p>这种“边遍历边匹配”的方法只需要遍历数组一次，能够保证找到最大数量的数对。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用 defaultdict(int) 可以省去判断 key 是否存在的逻辑，默认值为 0</span></span><br><span class="line">        cnt = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历数组中的每个数字</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 检查当前数字 x 的补数 (k - x) 是否在哈希表中</span></span><br><span class="line">            <span class="comment"># 并且该补数的剩余可用数量大于 0</span></span><br><span class="line">            <span class="keyword">if</span> cnt[k-x]:</span><br><span class="line">                <span class="comment"># 如果存在，说明找到了一对和为 k 的数 (x, k-x)</span></span><br><span class="line">                <span class="comment"># 消耗一个补数，将其计数减 1</span></span><br><span class="line">                cnt[k-x] -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 成功操作次数加 1</span></span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果补数不存在（或已被耗尽），则将当前数字 x 存入哈希表</span></span><br><span class="line">                <span class="comment"># 等待后续的数字来与它配对</span></span><br><span class="line">                cnt[x] += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxOperations</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个哈希表，key 为数值，value 为该数值出现的次数</span></span><br><span class="line">    cnt := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历数组中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 检查哈希表中是否存在当前数字的补数 (k - x)</span></span><br><span class="line">        <span class="comment">// 且该补数的数量大于 0</span></span><br><span class="line">        <span class="keyword">if</span> cnt[k-x] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 如果存在，说明找到了一组配对</span></span><br><span class="line">            <span class="comment">// 将补数的计数减 1，表示已使用</span></span><br><span class="line">            cnt[k-x]--</span><br><span class="line">            <span class="comment">// 结果计数器加 1</span></span><br><span class="line">            ans++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果找不到补数，将当前数字 x 加入哈希表</span></span><br><span class="line">            <span class="comment">// 增加其计数，等待后续匹配</span></span><br><span class="line">            cnt[x]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(N)</code><br>其中 <code>N</code> 是数组 <code>nums</code> 的长度。我们需要遍历数组一次，哈希表的插入和查询操作平均时间复杂度为 <code>O(1)</code>。</p></li><li><p><strong>空间复杂度</strong>: <code>O(N)</code><br>最坏情况下（例如数组中所有数都无法配对），哈希表需要存储数组中的所有元素。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1679 题：&lt;a href=&quot;https://leetcode.cn/problems/max-number-of-k-sum-pairs/&quot;&gt;K 和数对的最大数目&lt;/a&gt;。&lt;br&gt;这道题是“两数之和”的进阶版，重点在于统计能组成目标和 k 的&lt;strong&gt;不重复&lt;/strong&gt;数对的最大数量。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="排序" scheme="http://github.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="双指针" scheme="http://github.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="第218场周赛" scheme="http://github.com/tags/%E7%AC%AC218%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1128 | 等价多米诺骨牌对的数量</title>
    <link href="http://github.com/posts/leetcode-1128/"/>
    <id>http://github.com/posts/leetcode-1128/</id>
    <published>2025-12-15T02:02:00.000Z</published>
    <updated>2025-12-15T02:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1128 题：<a href="https://leetcode.cn/problems/number-of-equivalent-domino-pairs/">等价多米诺骨牌对的数量</a>。<br>题目核心在于如何对无序对进行“标准化”处理。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一组多米诺骨牌 <code>dominoes</code> 。</p><p>形式上，<code>dominoes[i] = [a, b]</code> 与 <code>dominoes[j] = [c, d]</code> <strong>等价</strong> 当且仅当 <code>(a == c 且 b == d)</code> 或者 <code>(a == d 且 b == c)</code> 。即一张骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌。</p><p>在 <code>0 &lt;= i &lt; j &lt; dominoes.length</code> 的前提下，找出满足 <code>dominoes[i]</code> 和 <code>dominoes[j]</code> 等价的骨牌对 <code>(i, j)</code> 的数量。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：dominoes = [[1,2],[2,1],[3,4],[5,6]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; dominoes.length &lt;&#x3D; 4 * 10^4</li><li>dominoes[i].length &#x3D;&#x3D; 2</li><li>1 &lt;&#x3D; dominoes[i][j] &lt;&#x3D; 9</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-问题的核心：标准化"><a href="#1-问题的核心：标准化" class="headerlink" title="1. 问题的核心：标准化"></a>1. 问题的核心：标准化</h4><p>题目中定义的“等价”是指两个二元组的元素相同，不考虑顺序。例如 <code>[1, 2]</code> 和 <code>[2, 1]</code> 是等价的。<br>为了能够使用哈希表或者数组来统计数量，我们需要将这种“无序”的特征转化为“有序”或者“标准”的形式。<br>最简单的方法是对每一个骨牌 <code>[a, b]</code> 进行排序。无论输入是 <code>[1, 2]</code> 还是 <code>[2, 1]</code>，排序后都会变成 <code>(1, 2)</code>。这样，所有等价的骨牌都会拥有相同的键值。</p><h4 id="2-枚举右，维护左（一次遍历）"><a href="#2-枚举右，维护左（一次遍历）" class="headerlink" title="2. 枚举右，维护左（一次遍历）"></a>2. 枚举右，维护左（一次遍历）</h4><p>最朴素的做法是两层循环枚举所有的 <code>(i, j)</code> 对，时间复杂度是 O(n^2)，这在数据量达到 4 * 10^4 时会超时。<br>我们可以利用哈希表进行一次遍历优化：</p><ol><li>创建一个哈希表 <code>cnt</code> 用来记录每种（标准化后的）骨牌出现的次数。</li><li>遍历每一个骨牌 <code>d</code>。</li><li>首先对 <code>d</code> 进行标准化（排序）。</li><li>查询哈希表，看这个标准化的骨牌之前出现过几次。假设之前出现了 <code>k</code> 次，那么当前这块骨牌可以和之前的 <code>k</code> 块骨牌分别组成一个等价对，所以将答案加上 <code>k</code>。</li><li>将当前骨牌的计数加 1，存入哈希表，供后续骨牌匹配。</li></ol><p>这种方法只需要遍历一次数组，效率非常高。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numEquivDominoPairs</span>(<span class="params">self, dominoes: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化答案计数器</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 创建一个哈希表用于存储 &#123;标准化后的骨牌: 出现次数&#125;</span></span><br><span class="line">        <span class="comment"># 使用 defaultdict(int) 可以省去检查 key 是否存在的步骤，默认值为 0</span></span><br><span class="line">        cnt = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历每一个骨牌</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> dominoes:</span><br><span class="line">            <span class="comment"># 标准化：将骨牌内的两个数字排序，并转为元组</span></span><br><span class="line">            <span class="comment"># 转为元组是因为列表是不可哈希的，不能作为字典的 key</span></span><br><span class="line">            <span class="comment"># 例如 [2, 1] 和 [1, 2] 都会变成 (1, 2)</span></span><br><span class="line">            d = <span class="built_in">tuple</span>(<span class="built_in">sorted</span>(d))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当前骨牌可以与之前出现过的 cnt[d] 个同类骨牌组成对</span></span><br><span class="line">            <span class="comment"># 将这些对的数量累加到答案中</span></span><br><span class="line">            ans += cnt[d]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新哈希表，记录当前这种骨牌出现的次数加 1</span></span><br><span class="line">            cnt[d] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numEquivDominoPairs</span><span class="params">(dominoes [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化答案</span></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 创建哈希表，key 为长度为 2 的数组（在 Go 中数组可以作为 map 的 key），value 为出现次数</span></span><br><span class="line">    <span class="comment">// [2]int 代表标准化后的骨牌</span></span><br><span class="line">    cnt := <span class="keyword">map</span>[[<span class="number">2</span>]<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历每一个骨牌</span></span><br><span class="line">    <span class="keyword">for</span> _, d := <span class="keyword">range</span> dominoes &#123;</span><br><span class="line">        <span class="comment">// 获取两个数字</span></span><br><span class="line">        a, b := d[<span class="number">0</span>], d[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标准化：确保 a &lt;= b</span></span><br><span class="line">        <span class="comment">// 这样 [1, 2] 和 [2, 1] 都会变成 [1, 2]</span></span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            a, b = b, a</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构造 key</span></span><br><span class="line">        key := [<span class="number">2</span>]<span class="type">int</span>&#123;a, b&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果该 key 存在于 map 中，cnt[key] 就是之前出现的次数</span></span><br><span class="line">        <span class="comment">// 当前骨牌可以与之前每一个相同的骨牌形成一对</span></span><br><span class="line">        ans += cnt[key]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新哈希表中该骨牌的计数</span></span><br><span class="line">        cnt[key]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>其中 <code>n</code> 是 <code>dominoes</code> 的长度。我们只需要遍历一次数组，每次遍历中的排序和哈希表操作都是常数时间 <code>O(1)</code>（因为骨牌只包含 2 个数字）。</p></li><li><p><strong>空间复杂度</strong>: <code>O(1)</code> (基于题目约束)<br>虽然我们使用了哈希表，但根据题目提示 <code>1 &lt;= dominoes[i][j] &lt;= 9</code>，骨牌的组合情况非常有限。可能的组合只有 <code>(1,1), (1,2)...(9,9)</code> 等几十种情况。因此，哈希表的大小有一个很小的上限（最多 45 种组合），可以视为常数空间 <code>O(1)</code>。如果不考虑数值范围限制，空间复杂度为 <code>O(n)</code>。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1128 题：&lt;a href=&quot;https://leetcode.cn/problems/number-of-equivalent-domino-pairs/&quot;&gt;等价多米诺骨牌对的数量&lt;/a&gt;。&lt;br&gt;题目核心在于如何对无序对进行“标准化”处理。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="计数" scheme="http://github.com/tags/%E8%AE%A1%E6%95%B0/"/>
    
    <category term="第146场周赛" scheme="http://github.com/tags/%E7%AC%AC146%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2342 | 数位和相等数对的最大和</title>
    <link href="http://github.com/posts/leetcode-2342/"/>
    <id>http://github.com/posts/leetcode-2342/</id>
    <published>2025-12-14T05:53:00.000Z</published>
    <updated>2025-12-14T05:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 2342 题：<a href="https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/">数位和相等数对的最大和</a>。<br>这是一道考察哈希表（或数组）应用以及“枚举右，维护左”思想的经典题目。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个下标从 0 开始的数组 <code>nums</code> ，数组中的元素都是 <strong>正</strong> 整数。请你选出两个下标 <code>i</code> 和 <code>j</code>（<code>i != j</code>），且 <code>nums[i]</code> 的数位和 与 <code>nums[j]</code> 的数位和相等。</p><p>请你找出所有满足条件的下标 <code>i</code> 和 <code>j</code> ，找出并返回 <code>nums[i] + nums[j]</code> 可以得到的 <strong>最大值</strong>。如果不存在这样的下标对，返回 -1。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [18,43,36,13,7]</span><br><span class="line">输出：54</span><br><span class="line">解释：满足条件的数对 (i, j) 为：</span><br><span class="line">- (0, 2) ，两个数字的数位和都是 9 ，相加得到 18 + 36 = 54 。</span><br><span class="line">- (1, 4) ，两个数字的数位和都是 7 ，相加得到 43 + 7 = 50 。</span><br><span class="line">所以可以获得的最大和是 54 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,12,19,14]</span><br><span class="line">输出：-1</span><br><span class="line">解释：不存在满足条件的数对，返回 -1 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</li><li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-核心思想：枚举右，维护左"><a href="#1-核心思想：枚举右，维护左" class="headerlink" title="1. 核心思想：枚举右，维护左"></a>1. 核心思想：枚举右，维护左</h4><p>题目要求找到数位和相等的两个数，使它们的和最大。<br>我们可以遍历数组，对于当前遍历到的数字 <code>num</code>（我们把它看作是右边的数字），我们希望在之前遍历过的数字中（左边的数字），找到一个数位和与 <code>num</code> 相同的数字，并且这个数字尽可能大。</p><h4 id="2-数位和的计算与范围"><a href="#2-数位和的计算与范围" class="headerlink" title="2. 数位和的计算与范围"></a>2. 数位和的计算与范围</h4><p>首先，我们需要一个辅助逻辑来计算一个整数的数位和。<br>观察数据范围 <code>nums[i] &lt;= 10^9</code>。</p><ul><li>最大可能的数位和出现在 <code>999,999,999</code>，其和为 <code>9 * 9 = 81</code>。</li><li><code>1,000,000,000</code> 的数位和仅为 1。<br>因此，数位和的范围在 0 到 81 之间。这意味着我们可以使用一个长度为 82 的固定数组来代替哈希表，效率更高。</li></ul><h4 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h4><ol><li>初始化一个结果变量 <code>ans = -1</code>。</li><li>初始化一个长度为 82 的数组 <code>mx</code>，<code>mx[s]</code> 用于存储数位和为 <code>s</code> 的所有数字中，<strong>当前遇到的最大值</strong>。</li><li>遍历数组 <code>nums</code> 中的每个元素 <code>num</code>：<ul><li>计算 <code>num</code> 的数位和 <code>s</code>。</li><li>检查 <code>mx[s]</code> 是否非零：<ul><li>如果非零，说明之前已经遇到过数位和同为 <code>s</code> 的数字。此时，<code>mx[s]</code> 是之前遇到的最大的那个数。计算 <code>mx[s] + num</code> 并尝试更新全局最大和 <code>ans</code>。</li></ul></li><li>更新 <code>mx[s]</code>：我们需要维护该数位和下的最大值，以便后续的数字能匹配到最大的“另一半”。即 <code>mx[s] = max(mx[s], num)</code>。</li></ul></li><li>返回 <code>ans</code>。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 数据范围最大为 10^9，最大数位和为 999,999,999 的数位和 81</span></span><br><span class="line">        <span class="comment"># 所以开辟大小为 82 的数组即可代替哈希表</span></span><br><span class="line">        mx = [<span class="number">0</span>] * <span class="number">82</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 计算当前数字的数位和</span></span><br><span class="line">            s = <span class="number">0</span></span><br><span class="line">            x = num</span><br><span class="line">            <span class="keyword">while</span> x:</span><br><span class="line">                s += x % <span class="number">10</span></span><br><span class="line">                x //= <span class="number">10</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果之前已经出现过数位和为 s 的数字</span></span><br><span class="line">            <span class="comment"># mx[s] 存储的是之前遍历过的数位和为 s 的最大值</span></span><br><span class="line">            <span class="keyword">if</span> mx[s]:</span><br><span class="line">                <span class="comment"># 尝试更新最大数对和</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, mx[s] + num)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 维护数位和为 s 的最大值</span></span><br><span class="line">            <span class="comment"># 这样保证了后续匹配时，取到的一定是当前最大的配对数</span></span><br><span class="line">            mx[s] = <span class="built_in">max</span>(mx[s], num)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="number">-1</span></span><br><span class="line">    <span class="comment">// 数据范围最大为 10^9，最大数位和为 81</span></span><br><span class="line">    <span class="comment">// 使用数组作为哈希表，索引为数位和，值为拥有该数位和的最大数字</span></span><br><span class="line">    mx := [<span class="number">82</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 计算当前数字的数位和</span></span><br><span class="line">        s := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x := num; x &gt; <span class="number">0</span>; x /= <span class="number">10</span> &#123;</span><br><span class="line">            s += x % <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 mx[s] &gt; 0，说明之前遇到过数位和为 s 的数字</span></span><br><span class="line">        <span class="keyword">if</span> mx[s] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 计算当前数字与之前遇到的最大数字之和，并更新答案</span></span><br><span class="line">            ans = max(ans, mx[s] + num)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新数位和为 s 的最大值</span></span><br><span class="line">        <span class="comment">// 确保后续如果有数字也为数位和 s，能匹配到目前为止最大的数字</span></span><br><span class="line">        mx[s] = max(mx[s], num)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：返回两个数中的较大值</span></span><br><span class="line"><span class="comment">// 注意：Go 1.21+ 内置了 max 函数，如果使用旧版本需自行实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: O(N * log M)，其中 N 是数组的长度，M 是数组中元素的最大值（本题中为 10^9）。</p><ul><li>我们需要遍历数组一次。</li><li>对于每个数字，计算数位和的时间与数字的位数成正比，即 log10(M)。</li><li>因为 log10(10^9) ≈ 9，是一个很小的常数，所以整体可以看作 O(N)。</li></ul></li><li><p><strong>空间复杂度</strong>: O(D)，其中 D 是可能的数位和的最大种类数。</p><ul><li>本题中最大数位和为 81，所以空间复杂度为 O(1)（固定大小的数组）。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 2342 题：&lt;a href=&quot;https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/&quot;&gt;数位和相等数对的最大和&lt;/a&gt;。&lt;br&gt;这是一道考察哈希表（或数组）应用以及“枚举右，维护左”思想的经典题目。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="排序" scheme="http://github.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="堆（优先队列）" scheme="http://github.com/tags/%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89/"/>
    
    <category term="第302场周赛" scheme="http://github.com/tags/%E7%AC%AC302%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 624 | 数组列表中的最大距离</title>
    <link href="http://github.com/posts/leetcode-624/"/>
    <id>http://github.com/posts/leetcode-624/</id>
    <published>2025-12-13T06:07:00.000Z</published>
    <updated>2025-12-13T06:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 624 题：<a href="https://leetcode.cn/problems/maximum-distance-in-arrays/">数组列表中的最大距离</a>。<br>题目考察如何在多个有序数组中找到满足特定条件（来自不同数组）的最大差值。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定 <code>m</code> 个数组，每个数组都已经按照升序排好序了。</p><p>现在你需要从两个不同的数组中选择两个整数（每个数组选一个）并且计算它们的距离。两个整数 <code>a</code> 和 <code>b</code> 之间的距离定义为它们差的绝对值 <code>|a-b|</code> 。</p><p>返回最大距离。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5],[1,2,3]]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">一种得到答案 4 的方法是从第一个数组或者第三个数组中选择 1，同时从第二个数组中选择 5 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arrays = [[1],[1]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == arrays.length</code></li><li><code>2 &lt;= m &lt;= 10^5</code></li><li><code>1 &lt;= arrays[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= arrays[i][j] &lt;= 10^4</code></li><li><code>arrays[i]</code> 以 <strong>升序</strong> 排序。</li><li>所有数组中最多有 <code>10^5</code> 个整数。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-暴力法的局限性"><a href="#1-暴力法的局限性" class="headerlink" title="1. 暴力法的局限性"></a>1. 暴力法的局限性</h4><p>题目要求从两个 <strong>不同</strong> 的数组中各取一个数，计算它们差值的绝对值。<br>最直观的做法是两层循环枚举所有的数组对，计算它们的最大值和最小值的差。<br>但由于数组数量 <code>m</code> 可达 <code>10^5</code>，<code>O(m^2)</code> 的时间复杂度会超时。</p><h4 id="2-贪心策略-一次遍历"><a href="#2-贪心策略-一次遍历" class="headerlink" title="2. 贪心策略 (一次遍历)"></a>2. 贪心策略 (一次遍历)</h4><p>由于每个数组都是 <strong>升序</strong> 排列的，对于任意一个数组，它的最小值一定是第一个元素，最大值一定是最后一个元素。<br>为了让 <code>|a - b|</code> 最大，我们需要尽可能让一个数大，另一个数小。</p><p>我们可以遍历每一个数组 <code>arrays[i]</code>，并维护在它 <strong>之前</strong> 所有数组中出现过的最小值 <code>mn</code> 和最大值 <code>mx</code>。<br>对于当前数组 <code>arrays[i]</code>，为了保证两个数来自不同的数组，我们可以计算以下两个距离：</p><ol><li>当前数组的最大值 <code>arrays[i][-1]</code> 减去之前所有数组的最小值 <code>mn</code>。</li><li>之前所有数组的最大值 <code>mx</code> 减去当前数组的最小值 <code>arrays[i][0]</code>。</li></ol><p>取这两个值的最大者更新最终答案 <code>ans</code>。<br>计算完成后，再将当前数组的最小值和最大值更新到 <code>mn</code> 和 <code>mx</code> 中，供后续数组使用。</p><p>这样，我们在遍历到第 <code>i</code> 个数组时，<code>mn</code> 和 <code>mx</code> 仅包含前 <code>i-1</code> 个数组的信息，从而保证了计算距离的两个数一定来自不同的数组。</p><p><strong>注意</strong>：</p><ul><li>在 Python 代码中，通常利用无穷大 <code>inf</code> 来初始化。</li><li>在 Go 语言或其他逻辑中，通常可以直接取第一个数组作为初始的 <code>mn</code> 和 <code>mx</code>，然后从第二个数组开始遍历，效果是一样的。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDistance</span>(<span class="params">self, arrays: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 初始化最小值 mn 为正无穷，最大值 mx 为负无穷</span></span><br><span class="line">        <span class="comment"># 注意：这里假设环境中已经引入了 inf，或者使用 float(&#x27;inf&#x27;)</span></span><br><span class="line">        mn, mx = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> arrays:</span><br><span class="line">            <span class="comment"># 计算当前数组与之前遍历过的数组能构成的最大距离</span></span><br><span class="line">            <span class="comment"># 1. 当前数组的最大值 a[-1] - 之前的最小值 mn</span></span><br><span class="line">            <span class="comment"># 2. 之前的最大值 mx - 当前数组的最小值 a[0]</span></span><br><span class="line">            <span class="comment"># 注意：第一次循环时，由于 mn 是正无穷，mx 是负无穷，计算结果对 ans 无影响（ans 保持 0）</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, a[-<span class="number">1</span>] - mn, mx - a[<span class="number">0</span>])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新全局最小值 mn，比较当前数组的最小值 a[0]</span></span><br><span class="line">            mn = <span class="built_in">min</span>(mn, a[<span class="number">0</span>])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新全局最大值 mx，比较当前数组的最大值 a[-1]</span></span><br><span class="line">            mx = <span class="built_in">max</span>(mx, a[-<span class="number">1</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDistance</span><span class="params">(arrays [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 结果初始化为 0</span></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取第一个数组的最小值和最大值作为初始值</span></span><br><span class="line">    <span class="comment">// arrays[i] 是升序的，所以最小值在索引 0，最大值在索引 len-1</span></span><br><span class="line">    minVal := arrays[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    maxVal := arrays[<span class="number">0</span>][<span class="built_in">len</span>(arrays[<span class="number">0</span>])<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从第二个数组开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(arrays); i++ &#123;</span><br><span class="line">        curr := arrays[i]</span><br><span class="line">        currMin := curr[<span class="number">0</span>]</span><br><span class="line">        currMax := curr[<span class="built_in">len</span>(curr)<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算潜在的最大距离</span></span><br><span class="line">        <span class="comment">// 场景 1: 当前数组的最大值 - 之前所有数组的最小值</span></span><br><span class="line">        <span class="keyword">if</span> dist := currMax - minVal; dist &gt; ans &#123;</span><br><span class="line">            ans = dist</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 场景 2: 之前所有数组的最大值 - 当前数组的最小值</span></span><br><span class="line">        <span class="keyword">if</span> dist := maxVal - currMin; dist &gt; ans &#123;</span><br><span class="line">            ans = dist</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新全局最小值</span></span><br><span class="line">        <span class="keyword">if</span> currMin &lt; minVal &#123;</span><br><span class="line">            minVal = currMin</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新全局最大值</span></span><br><span class="line">        <span class="keyword">if</span> currMax &gt; maxVal &#123;</span><br><span class="line">            maxVal = currMax</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(m)</code><br>其中 <code>m</code> 是数组的个数。我们只需要遍历 <code>arrays</code> 一次。每次迭代中的操作（比较、更新）都是 <code>O(1)</code> 的。</p></li><li><p><strong>空间复杂度</strong>: <code>O(1)</code><br>我们只需要常数级别的额外空间来存储 <code>ans</code>, <code>mn</code>, <code>mx</code> 等变量。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 624 题：&lt;a href=&quot;https://leetcode.cn/problems/maximum-distance-in-arrays/&quot;&gt;数组列表中的最大距离&lt;/a&gt;。&lt;br&gt;题目考察如何在多个有序数组中找到满足特定条件（来自不同数组）的最大差值。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="贪心" scheme="http://github.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 121 | 买卖股票的最佳时机</title>
    <link href="http://github.com/posts/leetcode-121/"/>
    <id>http://github.com/posts/leetcode-121/</id>
    <published>2025-12-12T02:52:00.000Z</published>
    <updated>2025-12-12T02:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 121 题：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a>。<br>这是买卖股票系列题目的第一题，也是“枚举右，维护左”思想的经典应用。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; prices.length &lt;&#x3D; 10^5</li><li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 10^4</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-暴力法的局限性"><a href="#1-暴力法的局限性" class="headerlink" title="1. 暴力法的局限性"></a>1. 暴力法的局限性</h4><p>最朴素的想法是两层循环：外层循环枚举买入的那一天，内层循环枚举买入之后的所有天数作为卖出日，计算差值并求最大值。<br>这种方法的时间复杂度是 O(n^2)。面对本题的数据规模（10^5），会导致超时。</p><h4 id="2-一次遍历（贪心-动态规划）"><a href="#2-一次遍历（贪心-动态规划）" class="headerlink" title="2. 一次遍历（贪心&#x2F;动态规划）"></a>2. 一次遍历（贪心&#x2F;动态规划）</h4><p>我们要获取最大利润，本质上是在寻找 <code>prices[j] - prices[i]</code> 的最大值，其中 <code>j &gt; i</code>。</p><p>我们可以换一个角度思考：<br>假设我们在第 <code>i</code> 天卖出股票，那么为了利润最大化，我们必须在第 <code>i</code> 天之前的某一天以 <strong>最低价格</strong> 买入。</p><p>算法流程如下：</p><ol><li><strong>记录最低价格 (<code>mp</code>)</strong>：我们需要维护一个变量，记录“截止到目前为止”遇到的最低股价。初始时，最低价格可以设为第一天的价格。</li><li><strong>枚举卖出价格 (<code>p</code>)</strong>：从头到尾遍历数组，假设当前遍历到的价格 <code>p</code> 就是我们卖出的价格。</li><li><strong>计算利润与更新</strong>：<ul><li><strong>计算当前利润</strong>：使用当前价格 <code>p</code> 减去历史最低价格 <code>mp</code>，得到如果在今天卖出的最大可能利润。</li><li><strong>更新最大利润 (<code>ans</code>)</strong>：比较当前计算的利润和之前记录的最大利润，取较大者。</li><li><strong>更新最低价格 (<code>mp</code>)</strong>：检查当前价格 <code>p</code> 是否比记录的 <code>mp</code> 更低，如果是，则更新 <code>mp</code>，供未来的天数使用。</li></ul></li></ol><p>这种思想通常被称为“枚举右，维护左”：我们在遍历数组时，将当前元素视为右边界（卖出点），同时动态维护左侧的历史信息（最低买入点）。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化最大利润为 0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 初始化最低买入价格 mp (min_price) 为第一天的价格</span></span><br><span class="line">        mp = prices[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历每一天的价格 p</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="comment"># 尝试在今天卖出：</span></span><br><span class="line">            <span class="comment"># 计算当前价格 p 与历史最低价格 mp 的差值</span></span><br><span class="line">            <span class="comment"># 并更新全局最大利润 ans</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, p - mp)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新历史最低价格：</span></span><br><span class="line">            <span class="comment"># 如果当前价格 p 比 mp 更低，则将 mp 更新为 p</span></span><br><span class="line">            mp = <span class="built_in">min</span>(mp, p)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 边界条件处理（虽然题目提示长度 &gt;= 1，但这是一个好习惯）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(prices) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化最大利润为 0</span></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 初始化最低买入价格 mp (min_price) 为第一天的价格</span></span><br><span class="line">    mp := prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每一天的价格 p</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> prices &#123;</span><br><span class="line">        <span class="comment">// 尝试在今天卖出：</span></span><br><span class="line">        <span class="comment">// 如果 (当前价格 - 历史最低价) 大于当前记录的最大利润，则更新</span></span><br><span class="line">        <span class="keyword">if</span> p - mp &gt; ans &#123;</span><br><span class="line">            ans = p - mp</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新历史最低价格：</span></span><br><span class="line">        <span class="comment">// 如果当前价格 p 小于 历史最低价 mp，则更新 mp</span></span><br><span class="line">        <span class="keyword">if</span> p &lt; mp &#123;</span><br><span class="line">            mp = p</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>我们只需要遍历一次 <code>prices</code> 数组即可完成计算。</p></li><li><p><strong>空间复杂度</strong>: <code>O(1)</code><br>只需要常数个变量 (<code>ans</code>, <code>mp</code>) 来存储中间状态，不需要额外的数组空间。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 121 题：&lt;a href=&quot;https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/&quot;&gt;买卖股票的最佳时机&lt;/a&gt;。&lt;br&gt;这是买卖股票系列题目的第一题，也是“枚举右，维护左”思想的经典应用。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="动态规划" scheme="http://github.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2441 | 与对应负数同时存在的最大正整数</title>
    <link href="http://github.com/posts/leetcode-2441/"/>
    <id>http://github.com/posts/leetcode-2441/</id>
    <published>2025-12-11T01:10:00.000Z</published>
    <updated>2025-12-11T01:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 2441 题：<a href="https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/">与对应负数同时存在的最大正整数</a>。<br>题目主要考察如何在遍历过程中快速查找元素的相反数。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个 <strong>不包含</strong> 任何零的整数数组 <code>nums</code> ，找出自身与对应的负数都在数组中存在的最大正整数 <code>k</code> 。</p><p>返回正整数 <code>k</code> ，如果不存在这样的整数，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,2,-3,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：3 是数组中唯一一个满足题目要求的 k 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,10,6,7,-7,1]</span><br><span class="line">输出：7</span><br><span class="line">解释：数组中存在 1 和 7 对应的负数，7 的值更大。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-10,8,6,7,-2,-3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：不存在满足题目要求的 k ，返回 -1 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000</li><li>-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li><li>nums[i] !&#x3D; 0</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="哈希表-一次遍历"><a href="#哈希表-一次遍历" class="headerlink" title="哈希表 (一次遍历)"></a>哈希表 (一次遍历)</h4><p>为了找到同时存在正数和负数的最大整数 <code>k</code>，我们可以利用哈希表（在 Python 中是 <code>set</code>，Go 中是 <code>map</code>）来记录已经遍历过的数字。</p><p>算法流程如下：</p><ol><li><strong>初始化</strong>：设置一个变量 <code>ans</code> 为 -1，用于记录当前找到的满足条件的最大正整数。创建一个空的哈希集合 <code>s</code>。</li><li><strong>遍历数组</strong>：对于数组中的每一个元素 <code>x</code>：<ul><li><strong>检查相反数</strong>：检查 <code>-x</code> 是否已经在集合 <code>s</code> 中。</li><li><strong>更新结果</strong>：如果 <code>-x</code> 存在，说明我们需要的一对正负数 <code>(x, -x)</code> 都出现了。此时，计算 <code>x</code> 的绝对值 <code>abs(x)</code>，并尝试更新 <code>ans</code> 为 <code>max(ans, abs(x))</code>。</li><li><strong>加入集合</strong>：将当前元素 <code>x</code> 加入集合 <code>s</code>，以便后续的元素能找到它。</li></ul></li><li><strong>返回结果</strong>：遍历结束后，返回 <code>ans</code>。</li></ol><p>这种方法的优势在于只需要遍历一次数组，查找操作的时间复杂度为 O(1)。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxK</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化答案为 -1，表示默认未找到</span></span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 创建一个哈希集合，用于存储遍历过的数字</span></span><br><span class="line">        s = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历数组中的每个数字 x</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 检查 x 的相反数 -x 是否已经在集合中</span></span><br><span class="line">            <span class="comment"># 如果在，说明找到了一对互为相反数的数字 (x, -x)</span></span><br><span class="line">            <span class="keyword">if</span> -x <span class="keyword">in</span> s:</span><br><span class="line">                <span class="comment"># 这一对数字对应的正整数是 abs(x)</span></span><br><span class="line">                <span class="comment"># 更新当前找到的最大正整数 k</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">abs</span>(x))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将当前数字 x 加入集合，供后续数字查找</span></span><br><span class="line">            s.add(x)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxK</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化答案为 -1</span></span><br><span class="line">    ans := <span class="number">-1</span></span><br><span class="line">    <span class="comment">// 创建一个 map 作为哈希集合，key 为数值，value 为 bool</span></span><br><span class="line">    s := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 检查 x 的相反数 -x 是否已经在 map 中</span></span><br><span class="line">        <span class="keyword">if</span> s[-x] &#123;</span><br><span class="line">            <span class="comment">// 计算 x 的绝对值</span></span><br><span class="line">            currentK := x</span><br><span class="line">            <span class="keyword">if</span> currentK &lt; <span class="number">0</span> &#123;</span><br><span class="line">                currentK = -currentK</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前的绝对值比已记录的答案更大，则更新</span></span><br><span class="line">            <span class="keyword">if</span> currentK &gt; ans &#123;</span><br><span class="line">                ans = currentK</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前数字 x 存入 map，标记为存在</span></span><br><span class="line">        s[x] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>其中 <code>n</code> 是数组 <code>nums</code> 的长度。我们需要遍历数组一次，每次在哈希表中进行查找和插入操作的平均时间复杂度为 <code>O(1)</code>。</p></li><li><p><strong>空间复杂度</strong>: <code>O(n)</code><br>需要使用哈希表存储数组中的元素，最坏情况下需要存储所有 <code>n</code> 个元素。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 2441 题：&lt;a href=&quot;https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/&quot;&gt;与对应负数同时存在的最大正整数&lt;/a&gt;。&lt;br&gt;题目主要考察如何在遍历过程中快速查找元素的相反数。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="排序" scheme="http://github.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="双指针" scheme="http://github.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="第315场周赛" scheme="http://github.com/tags/%E7%AC%AC315%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1512 | 好数对的数目</title>
    <link href="http://github.com/posts/leetcode-1512/"/>
    <id>http://github.com/posts/leetcode-1512/</id>
    <published>2025-12-10T02:00:00.000Z</published>
    <updated>2025-12-10T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1512 题：<a href="https://leetcode.cn/problems/number-of-good-pairs/">好数对的数目</a>。<br>这是一道考察数组遍历与哈希表计数的简单题目，体现了“枚举右，维护左”的经典思想。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组 <code>nums</code> 。</p><p>如果一组数字 <code>(i,j)</code> 满足 <code>nums[i] == nums[j]</code> 且 <code>i &lt; j</code> ，就可以认为这是一组 <strong>好数对</strong> 。</p><p>返回好数对的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,1,1,3]</span><br><span class="line">输出：4</span><br><span class="line">解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：数组中的每组数字都是好数对</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li><li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1. 暴力法"></a>1. 暴力法</h4><p>最容易想到的方法是使用两层循环遍历所有可能的数对 <code>(i, j)</code>，其中 <code>0 &lt;= i &lt; j &lt; nums.length</code>，并判断 <code>nums[i]</code> 是否等于 <code>nums[j]</code>。<br>这种方法的时间复杂度是 O(n^2)。鉴于本题数据范围较小（n &lt;&#x3D; 100），暴力法也是可以通过的，但不是最优解。</p><h4 id="2-哈希表-一次遍历"><a href="#2-哈希表-一次遍历" class="headerlink" title="2. 哈希表 (一次遍历)"></a>2. 哈希表 (一次遍历)</h4><p>为了优化时间复杂度，我们可以使用哈希表来记录数字出现的频率。<br>这道题的核心思想是 <strong>“枚举右，维护左”</strong>。</p><p>算法流程如下：</p><ol><li>我们从左到右遍历数组 <code>nums</code>。</li><li>对于当前遍历到的数字 <code>x</code>，我们需要知道在它 <strong>之前</strong> 已经出现了多少次 <code>x</code>。</li><li>假设在当前位置之前，<code>x</code> 已经出现了 <code>k</code> 次，那么当前的 <code>x</code> 就可以与前面的 <code>k</code> 个 <code>x</code> 分别组成 <code>k</code> 个好数对。</li><li>因此，我们只需要将哈希表中记录的 <code>x</code> 的次数累加到答案 <code>ans</code> 中，然后更新哈希表中 <code>x</code> 的计数（加 1），以便后续的数字使用。</li></ol><p>通过这种方式，我们只需要遍历一次数组，时间复杂度降低到了 O(n)。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIdenticalPairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># cnt 用于存储每个数字出现的次数 &#123;数值: 出现次数&#125;</span></span><br><span class="line">        cnt = &#123;&#125;</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历数组中的每个数字</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 如果 x 已经在哈希表中，说明之前出现过</span></span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> cnt:</span><br><span class="line">                <span class="comment"># 当前的 x 可以和之前出现的 cnt[x] 个 x 组成好数对</span></span><br><span class="line">                <span class="comment"># 将之前的出现次数累加到结果中</span></span><br><span class="line">                ans += cnt[x]   </span><br><span class="line">                <span class="comment"># 更新当前数字的计数</span></span><br><span class="line">                cnt[x] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 x 第一次出现，初始化计数为 1</span></span><br><span class="line">                cnt[x] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIdenticalPairs</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 创建哈希表，key 为数组元素值，value 为该元素出现的次数</span></span><br><span class="line">    cnt := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 在 Go 语言中，如果 key 不在 map 中，会返回 value 类型的零值（即 0）</span></span><br><span class="line">        <span class="comment">// 如果 x 之前出现过，cnt[x] 即为之前的出现次数</span></span><br><span class="line">        <span class="comment">// 当前的 x 可以与之前所有的 x 组成好数对，累加到 ans</span></span><br><span class="line">        ans += cnt[x]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新当前数字 x 的计数</span></span><br><span class="line">        cnt[x]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>其中 <code>n</code> 为数组 <code>nums</code> 的长度。我们需要遍历一遍数组，哈希表的插入和查询操作平均时间复杂度为 <code>O(1)</code>。</p></li><li><p><strong>空间复杂度</strong>: <code>O(n)</code><br>需要使用哈希表存储数组中不同元素的出现次数。在最坏情况下（数组中所有元素都不同），哈希表的大小为 <code>n</code>。考虑到题目提示中 <code>nums[i] &lt;= 100</code>，实际上空间复杂度也可视为 <code>O(C)</code>，其中 <code>C</code> 为数值范围。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1512 题：&lt;a href=&quot;https://leetcode.cn/problems/number-of-good-pairs/&quot;&gt;好数对的数目&lt;/a&gt;。&lt;br&gt;这是一道考察数组遍历与哈希表计数的简单题目，体现了“枚举右，维护左”的经典思想。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="数学" scheme="http://github.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="第197场周赛" scheme="http://github.com/tags/%E7%AC%AC197%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
    <category term="计数" scheme="http://github.com/tags/%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1 | 两数之和</title>
    <link href="http://github.com/posts/leetcode-1/"/>
    <id>http://github.com/posts/leetcode-1/</id>
    <published>2025-12-09T02:44:00.000Z</published>
    <updated>2025-12-09T02:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1 题：<a href="https://leetcode.cn/problems/two-sum/">两数之和</a>。<br>这是力扣的第一题，也是哈希表应用的经典入门题目。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <code>target</code>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>2 &lt;&#x3D; nums.length &lt;&#x3D; 10^4</li><li>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</li><li>-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9</li><li>只会存在一个有效答案</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-暴力法的局限性"><a href="#1-暴力法的局限性" class="headerlink" title="1. 暴力法的局限性"></a>1. 暴力法的局限性</h4><p>最直观的方法是使用两层循环。第一层循环遍历数组中的每一个数，第二层循环寻找其余数中是否存在与当前数相加等于 <code>target</code> 的数。<br>这种方法的时间复杂度是 O(n^2)。当数组长度较大时（例如达到 10^4），效率较低。</p><h4 id="2-哈希表-空间换时间"><a href="#2-哈希表-空间换时间" class="headerlink" title="2. 哈希表 (空间换时间)"></a>2. 哈希表 (空间换时间)</h4><p>为了降低时间复杂度，我们可以利用哈希表（在 Python 中是字典，Go 中是 Map）来记录已经遍历过的数字及其下标。</p><p>算法流程如下：</p><ol><li><strong>一次遍历</strong>：我们只需要遍历一次数组。</li><li><strong>查找补数</strong>：对于每一个遍历到的元素 <code>x</code>，我们需要寻找的目标是 <code>y = target - x</code>。</li><li><strong>查询与记录</strong>：<ul><li>如果 <code>y</code> 已经在哈希表 <code>mp</code> 中，说明之前已经遍历过了这个数字。此时，<code>mp[y]</code> 是 <code>y</code> 的下标，<code>i</code> 是当前 <code>x</code> 的下标。直接返回 <code>[mp[y], i]</code> 即可。</li><li>如果 <code>y</code> 不在哈希表中，我们将当前数字 <code>x</code> 及其下标 <code>i</code> 存入哈希表 <code>mp[x] = i</code>，以便后续的数字能找到它。</li></ul></li></ol><p>通过这种方式，查找操作的时间复杂度降低到了 O(1)，整体时间复杂度降低到了 O(n)。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 创建一个哈希表用于存储 &#123;数值: 下标&#125;</span></span><br><span class="line">        mp = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历数组，获取当前下标 i 和数值 x</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 计算满足条件的另一个数值 y</span></span><br><span class="line">            y = target - x</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 检查 y 是否已经在哈希表中</span></span><br><span class="line">            <span class="comment"># 如果在，说明之前遍历过 y，直接返回对应的下标和当前下标</span></span><br><span class="line">            <span class="keyword">if</span> y <span class="keyword">in</span> mp:</span><br><span class="line">                <span class="keyword">return</span> [mp[y], i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果不在，将当前数值 x 和下标 i 存入哈希表</span></span><br><span class="line">            <span class="comment"># 供后续的元素查找</span></span><br><span class="line">            mp[x] = i</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 创建哈希表，key 为数组元素值，value 为对应的下标</span></span><br><span class="line">    mp := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 计算需要的补数 y</span></span><br><span class="line">        y := target - x</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查哈希表中是否存在 y</span></span><br><span class="line">        <span class="comment">// 如果存在，说明找到了这两个数，返回它们的下标</span></span><br><span class="line">        <span class="keyword">if</span> idx, ok := mp[y]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;idx, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前元素 x 和下标 i 存入哈希表</span></span><br><span class="line">        mp[x] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>我们只遍历了包含 <code>n</code> 个元素的列表一次。在表中进行的每次查找只花费 <code>O(1)</code> 的时间。</p></li><li><p><strong>空间复杂度</strong>: <code>O(n)</code><br>主要为哈希表的开销。在最坏的情况下（例如，目标元素在数组的最后两个），我们需要将 <code>n - 1</code> 个元素存储在哈希表中。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1 题：&lt;a href=&quot;https://leetcode.cn/problems/two-sum/&quot;&gt;两数之和&lt;/a&gt;。&lt;br&gt;这是力扣的第一题，也是哈希表应用的经典入门题目。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1475 | 商品折扣后的最终价格</title>
    <link href="http://github.com/posts/leetcode-1475/"/>
    <id>http://github.com/posts/leetcode-1475/</id>
    <published>2025-12-08T05:23:00.000Z</published>
    <updated>2025-12-08T05:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1475 题：<a href="https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/">商品折扣后的最终价格</a>。<br>问题的核心是寻找数组中每个元素右侧第一个小于等于它的元素。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是商店里第 <code>i</code> 件商品的价格。</p><p>商店里正在进行促销活动，如果你要买第 <code>i</code> 件商品，那么你可以得到与 <code>prices[j]</code> 相等的折扣，其中 <code>j</code> 是满足 <code>j &gt; i</code> 且 <code>prices[j] &lt;= prices[i]</code> 的 <strong>最小下标</strong> ，如果没有满足条件的 <code>j</code> ，你将没有任何折扣。</p><p>请你返回一个数组，数组中第 <code>i</code> 个元素是折扣后你购买商品 <code>i</code> 最终需要支付的价格。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [8,4,6,2,3]</span><br><span class="line">输出：[4,2,4,2,3]</span><br><span class="line">解释：</span><br><span class="line">商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。</span><br><span class="line">商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。</span><br><span class="line">商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。</span><br><span class="line">商品 3 和 4 都没有折扣。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：[1,2,3,4,5]</span><br><span class="line">解释：在这个例子中，所有商品都没有折扣。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [10,1,1,6]</span><br><span class="line">输出：[9,0,1,6]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; prices.length &lt;&#x3D; 500</li><li>1 &lt;&#x3D; prices[i] &lt;&#x3D; 10^3</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1. 问题分析"></a>1. 问题分析</h4><p>题目要求对于每个商品 <code>i</code>，找到它右边第一个满足 <code>prices[j] &lt;= prices[i]</code> 的价格 <code>prices[j]</code> 作为折扣。如果没有找到，折扣为 0。最终支付价格为 <code>prices[i] - 折扣</code>。</p><p>这是一个典型的 <strong>寻找右侧第一个更小（或相等）元素</strong> 的问题。</p><h4 id="2-单调栈-哨兵技巧"><a href="#2-单调栈-哨兵技巧" class="headerlink" title="2. 单调栈 + 哨兵技巧"></a>2. 单调栈 + 哨兵技巧</h4><p>我们可以使用单调栈来高效解决这个问题。为了方便处理，我们采用 <strong>从后往前</strong> 遍历数组的方式：</p><ol><li><strong>倒序遍历</strong>：从最后一个商品开始向前遍历。这样当我们处理第 <code>i</code> 个商品时，它右边的商品（潜在的折扣选项）已经被处理过并存储在栈中。</li><li><strong>维护单调性</strong>：<ul><li>栈中存储的是右侧的商品价格。</li><li>当我们遇到一个新的价格 <code>p</code> 时，我们查看栈顶元素。</li><li>如果栈顶元素 <strong>大于</strong> <code>p</code>，说明栈顶这个价格太贵了，不满足折扣条件（必须小于等于 <code>p</code>）。而且，由于 <code>p</code> 在栈顶元素的左边且 <code>p</code> 更小，对于 <code>p</code> 左边的任何商品来说，<code>p</code> 都是一个比栈顶元素更优（更小且距离更近）的折扣候选。因此，我们可以放心地将栈顶元素弹出。</li><li>重复弹出操作，直到栈顶元素 <strong>小于等于</strong> <code>p</code>，或者栈为空。</li></ul></li><li><strong>计算结果</strong>：<ul><li>此时，栈顶元素就是 <code>p</code> 右侧第一个满足条件的折扣值。</li><li>如果栈为空，说明右边没有更便宜的价格，折扣为 0。</li></ul></li><li><strong>哨兵优化</strong>：<ul><li>为了避免判断栈是否为空，我们可以预先在栈底放入一个 <strong>哨兵值 0</strong>。</li><li>题目已知 <code>prices[i] &gt;= 1</code>，所以 0 必定小于任何商品价格。</li><li>当栈中只剩下哨兵 0 时，说明没有找到折扣，此时计算 <code>p - 0</code> 刚好等于原价，符合逻辑，且代码更加简洁。</li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">finalPrices</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        ans = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="comment"># 初始化栈，放入哨兵 0</span></span><br><span class="line">        <span class="comment"># 0 比所有有效价格都小，代表“无折扣”的情况</span></span><br><span class="line">        st = [<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从后往前遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            p = prices[i]</span><br><span class="line">            <span class="comment"># 维护单调栈：如果栈顶价格 &gt; 当前价格 p</span></span><br><span class="line">            <span class="comment"># 说明栈顶太贵了，不能作为 p 的折扣</span></span><br><span class="line">            <span class="comment"># 且 p 更小更靠左，会挡住栈顶元素，使其对左边元素无效，故弹出</span></span><br><span class="line">            <span class="keyword">while</span> st[-<span class="number">1</span>] &gt; p:</span><br><span class="line">                st.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 此时栈顶元素 &lt;= p，即为右侧第一个满足条件的折扣</span></span><br><span class="line">            <span class="comment"># 如果没找到，栈顶就是哨兵 0</span></span><br><span class="line">            ans[i] = p - st[-<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将当前价格入栈，作为左边元素的潜在折扣</span></span><br><span class="line">            st.append(p)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finalPrices</span><span class="params">(prices []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(prices)</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="comment">// 哨兵，作为没有折扣时的栈顶值</span></span><br><span class="line">    <span class="comment">// 0 不会影响计算结果 (price - 0 = price)，且总是满足 &lt;= price</span></span><br><span class="line">    st := []<span class="type">int</span>&#123;<span class="number">0</span>&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从后往前遍历</span></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        p := prices[i]</span><br><span class="line">        <span class="comment">// 当栈顶元素大于当前价格 p 时，栈顶元素无法作为折扣，弹出</span></span><br><span class="line">        <span class="comment">// 这一步保证了栈内元素（除哨兵外）对于当前位置是单调递增的</span></span><br><span class="line">        <span class="keyword">for</span> st[<span class="built_in">len</span>(st)<span class="number">-1</span>] &gt; p &#123;</span><br><span class="line">            st = st[:<span class="built_in">len</span>(st)<span class="number">-1</span>] <span class="comment">// p 比栈顶小，比栈顶更能成为左侧元素的折扣值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束后，栈顶的价格 &lt;= p，作为折扣值</span></span><br><span class="line">        <span class="comment">// 如果没有找到真实折扣，栈顶就是哨兵 0</span></span><br><span class="line">        ans[i] = p - st[<span class="built_in">len</span>(st)<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前价格压入栈中</span></span><br><span class="line">        st = <span class="built_in">append</span>(st, p)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: O(n)<br>虽然代码中有嵌套循环，但观察栈的操作可以发现：数组中的每个元素最多入栈一次，最多出栈一次。因此整体操作次数与数组长度呈线性关系。</p></li><li><p><strong>空间复杂度</strong>: O(n)<br>需要一个栈来存储价格。在最坏情况下（例如数组严格单调递增），栈的大小接近 <code>n</code>。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1475 题：&lt;a href=&quot;https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/&quot;&gt;商品折扣后的最终价格&lt;/a&gt;。&lt;br&gt;问题的核心是寻找数组中每个元素右侧第一个小于等于它的元素。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="单调栈" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%8D%95%E8%B0%83%E6%A0%88/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="栈" scheme="http://github.com/tags/%E6%A0%88/"/>
    
    <category term="单调栈" scheme="http://github.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    <category term="第28场双周赛" scheme="http://github.com/tags/%E7%AC%AC28%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
</feed>
