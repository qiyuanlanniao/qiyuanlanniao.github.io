<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Changan&#39;s Blog</title>
  
  
  <link href="http://github.com/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2025-10-28T01:20:00.000Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>Changan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 2576 | 求出最多标记下标</title>
    <link href="http://github.com/posts/leetcode-2576/"/>
    <id>http://github.com/posts/leetcode-2576/</id>
    <published>2025-10-28T01:20:00.000Z</published>
    <updated>2025-10-28T01:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 2576 题：<a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/description/">求出最多标记下标</a>。<br>本题的关键在于通过排序，将问题转化为一个判定问题：我们能否标记出 <code>2*k</code> 个下标？这个判定问题具有单调性，因此可以利用二分查找来高效地找到最大的 <code>k</code>。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目要求我们在一个整数数组 <code>nums</code> 中，尽可能多地标记下标。标记的规则是：每次选择两个未被标记的、不同的下标 <code>i</code> 和 <code>j</code>，如果它们满足 <code>2 * nums[i] &lt;= nums[j]</code>，就可以将这两个下标标记。我们的目标是最大化被标记的下标总数。</p><p>这里的核心约束条件是：</p><ol><li>每次操作选择的 <code>i</code> 和 <code>j</code> 必须是之前未被标记过的。</li><li>必须满足 <code>2 * nums[i] &lt;= nums[j]</code> 的条件。</li><li>目标是让最终被标记的下标数量最多。</li></ol><p>由于被标记的下标总是成对出现的，所以最大化标记下标的数量等价于最大化我们能成功匹配的<strong>配对数</strong>。</p><p>举个例子，<code>nums = [9,2,5,4]</code>。<br>如果我们想匹配，一个很自然的想法是先对数组排序，得到 <code>[2,4,5,9]</code>。这样我们更容易找到满足 <code>2 * x &lt;= y</code> 的数对。<br>排序后，我们尝试配对：</p><ul><li>拿最小的 <code>2</code> 和 <code>4</code> 配对？<code>2 * 2 &lt;= 4</code>，不满足。</li><li>拿最小的 <code>2</code> 和 <code>5</code> 配对？<code>2 * 2 &lt;= 5</code>，满足。我们可以标记 <code>2</code> 和 <code>5</code>。</li><li>剩下 <code>4</code> 和 <code>9</code>。<code>2 * 4 &lt;= 9</code>，满足。我们可以标记 <code>4</code> 和 <code>9</code>。<br>最终，所有数字都被标记了，总共 4 个。</li></ul><p>这个例子启发我们，排序可能是一个关键步骤，并且配对时应该采取某种贪心策略。</p><h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最多能凑成几对”似乎有些复杂。我们可以换一个角度思考：给定一个整数 <code>k</code>，我们能否判断出<strong>是否可以凑成 <code>k</code> 对</strong>？</p><p>这个问题，即“判定问题”，相对更容易解决。如果我们能解决这个判定问题，就可以利用其单调性进行二分查找。</p><p><strong>判定问题：<code>check(k)</code></strong><br>假设我们要判断能否凑成 <code>k</code> 对。为了尽可能地满足 <code>2 * nums[i] &lt;= nums[j]</code> 这个条件，我们应该让 <code>nums[i]</code> 尽可能小，<code>nums[j]</code> 尽可能大。<br>一个最优的贪心策略是：</p><ol><li>首先对数组 <code>nums</code> 进行排序。</li><li>选出数组中最小的 <code>k</code> 个数作为所有 <code>nums[i]</code> 的候选。</li><li>选出数组中最大的 <code>k</code> 个数作为所有 <code>nums[j]</code> 的候选。</li><li>然后进行配对。为了让每个小的数都能配对成功，我们应该用最小的 <code>nums[i]</code>（即 <code>nums[0]</code>）去和最小的可用 <code>nums[j]</code>（即 <code>nums[n-k]</code>）配对，以此类推。</li><li>所以，检查条件就变成了：<code>nums[0]</code> 能否和 <code>nums[n-k]</code> 配对，<code>nums[1]</code> 能否和 <code>nums[n-k+1]</code> 配对，……，<code>nums[k-1]</code> 能否和 <code>nums[n-1]</code> 配对。</li><li>如果 <code>2 * nums[i] &lt;= nums[n-k+i]</code> 对所有的 <code>i</code> in <code>[0, k-1]</code> 都成立，那么我们就能凑成 <code>k</code> 对。</li></ol><p><strong>单调性</strong><br>这个判定结果具有明显的单调性：</p><ul><li>如果我们能成功凑成 <code>k</code> 对，那么我们一定能凑成 <code>k-1</code> 对（因为我们可以直接使用前 <code>k-1</code> 对的方案）。</li><li>如果我们无法凑成 <code>k</code> 对，那么我们更不可能凑成 <code>k+1</code> 对（因为 <code>k+1</code> 对的要求更严格）。</li></ul><p>这种单调性是应用二分查找的完美场景。我们可以对“配对数 <code>k</code>”进行二分查找，来快速定位到那个“最大可行”的临界点。</p><p>二分查找的搜索范围是什么？</p><ul><li><strong>下界 (left)</strong>：最少可以凑成 0 对。</li><li><strong>上界 (right)</strong>：最多可以凑成 <code>n/2</code> 对，因为每对消耗两个数。</li></ul><p>因此，我们就在 <code>[0, n/2]</code> 这个区间内，对配对数 <code>k</code> 进行二分查找。</p><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol><li><p><strong>排序</strong></p><ul><li>首先，对 <code>nums</code> 数组进行升序排序。</li></ul></li><li><p><strong>确定二分查找的范围</strong></p><ul><li><code>left = 0</code>：可能的最小配对数。</li><li><code>right = len(nums) // 2 + 1</code>：配对数的一个开区间上界。我们将搜索区间设为 <code>[left, right)</code>，其中 <code>left</code> 始终是我们已知的可行解。</li></ul></li><li><p><strong>执行二分查找</strong></p><ul><li>当 <code>left + 1 &lt; right</code> 时，循环继续。</li><li>计算中间值 <code>k = (left + right) // 2</code> 作为当前的“猜测配对数”。</li><li>调用判定逻辑 <code>check(k)</code>：<ul><li>遍历 <code>i</code> from <code>0</code> to <code>k-1</code>。</li><li>检查 <code>2 * nums[i]</code> 是否小于等于 <code>nums[len(nums) - k + i]</code>。</li><li>在Python中，<code>nums[len(nums) - k + i]</code> 可以用负数索引 <code>nums[i-k]</code> 巧妙地表示。</li><li><strong>如果 <code>check(k)</code> 为真</strong> (即 <code>k</code> 对是可行的)：<ul><li>说明 <code>k</code> 是一个潜在的答案，但我们想找的是“最大”的 <code>k</code>，所以我们尝试一个更大的值，将搜索范围的下界更新：<code>left = k</code>。</li></ul></li><li><strong>如果 <code>check(k)</code> 为假</strong> (即 <code>k</code> 对是不可行的)：<ul><li>说明 <code>k</code> 太大了，必须减少配对数，所以将搜索范围的上界更新：<code>right = k</code>。</li></ul></li></ul></li></ul></li><li><p><strong>返回结果</strong></p><ul><li>循环结束后，<code>left</code> 中存储的就是满足条件的<strong>最大配对数</strong>。</li><li>题目要求返回最多可以标记的<strong>下标数目</strong>，所以最终结果是 <code>left * 2</code>。</li></ul></li></ol><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxNumOfMarkedIndices</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1：排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2：确定二分查找范围</span></span><br><span class="line">        <span class="comment"># 我们对“可以凑成的配对数 k”进行二分查找</span></span><br><span class="line">        <span class="comment"># left 是已知可行的最大配对数，right 是不可行的最小配对数（开区间）</span></span><br><span class="line">        left, right = <span class="number">0</span>, n // <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3：执行二分查找</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">            <span class="comment"># k 是我们尝试要验证的配对数</span></span><br><span class="line">            k = (left + right) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># check(k): 检查是否能凑成 k 对</span></span><br><span class="line">            <span class="comment"># 贪心策略：用最小的 k 个数 nums[0...k-1]</span></span><br><span class="line">            <span class="comment"># 去匹配最大的 k 个数 nums[n-k...n-1]</span></span><br><span class="line">            <span class="comment"># all() 函数会检查所有条件是否为真</span></span><br><span class="line">            <span class="comment"># nums[i-k] 是 Python 的负数索引，等价于 nums[n + i - k]</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">all</span>(nums[i] * <span class="number">2</span> &lt;= nums[i - k] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)):</span><br><span class="line">                <span class="comment"># 如果可以凑成 k 对，说明 k 是一个可行的解</span></span><br><span class="line">                <span class="comment"># 我们尝试寻找更大的 k，所以更新下界</span></span><br><span class="line">                left = k</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果不行，说明 k 太大了，需要减小 k</span></span><br><span class="line">                <span class="comment"># 更新上界</span></span><br><span class="line">                right = k</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 4：返回结果</span></span><br><span class="line">        <span class="comment"># left 是我们找到的最大可行配对数</span></span><br><span class="line">        <span class="comment"># 总标记数量是配对数的两倍</span></span><br><span class="line">        <span class="keyword">return</span> left * <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(N * log N)。<ul><li>对数组排序需要 O(N log N) 的时间。</li><li>二分查找的范围是 <code>n/2</code>，所以需要 O(log N) 次迭代。</li><li>在每次迭代中，我们的 <code>check</code> 逻辑（即 <code>all(...)</code> 生成器表达式）需要遍历 <code>k</code> 个元素，<code>k</code> 最大为 <code>N/2</code>，所以检查的时间复杂度为 O(N)。</li><li>因此，二分查找部分的总时间是 O(N log N)。</li><li>两者相加，总时间复杂度由排序和二分查找共同决定，为 O(N log N)。</li></ul></li><li><strong>空间复杂度</strong>: O(log N) 或 O(N)。<ul><li>这主要取决于排序算法使用的空间。Python 的 Timsort 在平均情况下的空间复杂度是 O(log N)，最坏情况下是 O(N)。如果我们不考虑排序本身占用的空间，则算法是 O(1) 的。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“二分答案”思想的又一个典型应用。当直接求解一个“最大值”或“最小值”问题比较困难时，我们可以尝试将其转化为一个“判定性”问题。如果这个判定问题对于答案具有单调性，就可以通过二分查找来极大地优化求解过程。这里的关键点在于，为判定问题 <code>check(k)</code> 设计出一个高效的贪心策略，从而确保了整个算法的正确性和效率。效率。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 2576 题：&lt;a href=&quot;https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/description/&quot;&gt;求出最多标记下标&lt;/a&gt;。&lt;br&gt;本题的关键在于通过排序，将问题转化为一个判定问题：我们能否标记出 &lt;code&gt;2*k&lt;/code&gt; 个下标？这个判定问题具有单调性，因此可以利用二分查找来高效地找到最大的 &lt;code&gt;k&lt;/code&gt;。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分答案" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
    <category term="求最大" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/%E6%B1%82%E6%9C%80%E5%A4%A7/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="贪心" scheme="http://github.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="排序" scheme="http://github.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="双指针" scheme="http://github.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="第334场周赛" scheme="http://github.com/tags/%E7%AC%AC334%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 275 | H 指数 II</title>
    <link href="http://github.com/posts/leetcode-275/"/>
    <id>http://github.com/posts/leetcode-275/</id>
    <published>2025-10-27T03:30:00.000Z</published>
    <updated>2025-10-27T03:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 275 题：<a href="https://leetcode.cn/problems/h-index-ii/description/">H 指数 II</a>。<br>本文将深入探讨解决此问题的四种不同二分查找区间写法。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要计算一位研究者的 h 指数。h 指数的定义是：一名科研人员的 n 篇论文中，有<strong>至少</strong> <code>h</code> 篇论文分别被引用了<strong>至少</strong> <code>h</code> 次。</p><p>题目给出了一个整数数组 <code>citations</code>，其中 <code>citations[i]</code> 是第 <code>i</code> 篇论文的被引次数，并且该数组已经<strong>按非降序（升序）排列</strong>。我们的目标是设计一个时间复杂度为对数级别的算法来找出这个 h 指数。</p><p>例如，对于 <code>citations = [0, 1, 3, 5, 6]</code>：</p><ul><li>我们有 5 篇论文。</li><li>检查 h&#x3D;3：是否有至少 3 篇论文的引用次数都 &gt;&#x3D; 3？<ul><li>引用次数最高的 3 篇论文是 <code>[3, 5, 6]</code>。</li><li>这三篇论文的引用次数都满足 &gt;&#x3D; 3 的条件。所以 h&#x3D;3 是一个可能的答案。</li></ul></li><li>检查 h&#x3D;4：是否有至少 4 篇论文的引用次数都 &gt;&#x3D; 4？<ul><li>引用次数最高的 4 篇论文是 <code>[1, 3, 5, 6]</code>。</li><li>其中 <code>1 &lt; 4</code> 且 <code>3 &lt; 4</code>，不满足条件。</li></ul></li><li>因此，最大的满足条件的 h 值是 3，所以 h 指数就是 3。</li></ul><h3 id="核心思路：在“答案”上进行二分查找"><a href="#核心思路：在“答案”上进行二分查找" class="headerlink" title="核心思路：在“答案”上进行二分查找"></a>核心思路：在“答案”上进行二分查找</h3><p>直接寻找这个 h 指数似乎需要逐个尝试。但我们可以观察到答案 <code>h</code> 具有<strong>单调性</strong>：</p><ul><li>如果一个值 <code>h</code> 满足 h 指数的定义，那么所有小于 <code>h</code> 的值（例如 <code>h-1</code>）也一定满足。</li><li>如果一个值 <code>h</code> 不满足 h 指数的定义，那么所有大于 <code>h</code> 的值（例如 <code>h+1</code>）也一定不满足。</li></ul><p>这种单调性是应用二分查找的完美信号。我们可以不直接在 <code>citations</code> 数组的索引上进行二分，而是在<strong>可能的答案 <code>h</code></strong> 上进行二分。<code>h</code> 的取值范围是 <code>[0, n]</code>，其中 <code>n</code> 是论文总数。</p><p>我们的目标就变成了：在 <code>[0, n]</code> 这个答案空间中，找到满足条件的最大的 <code>h</code>。</p><p>为了实现二分查找，我们需要一个<strong>判定函数</strong> <code>check(h)</code>，来判断任意一个猜测的 <code>h</code> 值是否满足条件。</p><ul><li><strong>如何判定 <code>h</code> 是否可行？</strong><ul><li>根据定义，我们需要检查是否存在 <code>h</code> 篇论文，其引用次数都大于或等于 <code>h</code>。</li><li>由于 <code>citations</code> 数组是升序的，引用次数最高的 <code>h</code> 篇论文必然是数组末尾的 <code>h</code> 个元素。</li><li>我们只需要检查这 <code>h</code> 篇论文中被引次数最少的那一篇，即 <code>citations[n-h]</code>，是否满足 <code>&gt;= h</code>。</li><li>如果 <code>citations[n-h] &gt;= h</code>，那么它后面的所有论文引用次数也都大于等于 <code>h</code>，总共就有 <code>h</code> 篇满足条件。</li><li>因此，判定条件可以简化为 <code>citations[n-h] &gt;= mid</code> (其中 <code>mid</code> 是我们猜测的 <code>h</code> 值)。</li></ul></li></ul><p>有了这个 O(1) 的判定函数，我们就可以在 <code>[0, n]</code> 的答案空间内高效地进行二分查找了。</p><h3 id="四种二分算法的-Python-代码实现"><a href="#四种二分算法的-Python-代码实现" class="headerlink" title="四种二分算法的 Python 代码实现"></a>四种二分算法的 Python 代码实现</h3><p>下面将展示四种经典的二分查找区间写法，它们在边界处理和循环条件上略有不同，但最终都能得到正确答案。</p><h4 id="解法一：闭区间-left-right"><a href="#解法一：闭区间-left-right" class="headerlink" title="解法一：闭区间 [left, right]"></a>解法一：闭区间 <code>[left, right]</code></h4><p>这是最常见的一种写法，搜索区间两端都包含在内。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(citations)</span><br><span class="line">        <span class="comment"># 在区间 [left, right] 内询问</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 区间不为空</span></span><br><span class="line">            <span class="comment"># 循环不变量：</span></span><br><span class="line">            <span class="comment"># left-1 的回答一定为「是」（即 h=left-1 满足条件）</span></span><br><span class="line">            <span class="comment"># right+1 的回答一定为「否」（即 h=right+1 不满足条件）</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span>: <span class="comment"># h=0 恒成立，特殊处理或调整 left 初始值</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 检查 h=mid 是否可行：</span></span><br><span class="line">            <span class="comment"># 引用次数最多的 mid 篇论文，其引用次数均需 &gt;= mid</span></span><br><span class="line">            <span class="comment"># 相当于检查第 n-mid 篇论文（引用最少的）是否 citations[n-mid] &gt;= mid</span></span><br><span class="line">            <span class="keyword">if</span> citations[n - mid] &gt;= mid:</span><br><span class="line">                <span class="comment"># mid 可行，尝试更大的 h</span></span><br><span class="line">                left = mid + <span class="number">1</span>  <span class="comment"># 询问范围缩小到 [mid+1, right]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># mid 不可行，需要减小 h</span></span><br><span class="line">                right = mid - <span class="number">1</span>  <span class="comment"># 询问范围缩小到 [left, mid-1]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束后 right 等于 left-1</span></span><br><span class="line">        <span class="comment"># 根据循环不变量，right 现在是最大的回答为「是」的数</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">```**逻辑解读**：当 `check(mid)` 成功时，意味着 `mid` 是一个潜在的答案，但我们想找最大的 `h`，所以我们向右搜索 `[mid+<span class="number">1</span>, right]`；反之，`mid` 太大了，向左搜索 `[left, mid-<span class="number">1</span>]`。循环结束时 `left = right + <span class="number">1</span>`，`right` 指向的是最后一个满足条件的 `h`。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 解法二：左闭右开区间 `[left, right)`</span></span><br><span class="line"></span><br><span class="line">这种写法中，`right` 边界是“开”的，即不包含在搜索区间内。`right` 通常被看作是第一个“不满足”条件的位置。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(citations)</span><br><span class="line">        <span class="comment"># 在区间 [left, right) 内询问</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">            <span class="comment"># 循环不变量：</span></span><br><span class="line">            <span class="comment"># left-1 的回答一定为「是」</span></span><br><span class="line">            <span class="comment"># right 的回答一定为「否」</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span>: <span class="comment"># h=0 恒成立</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 引用次数最多的 mid 篇论文，引用次数均 &gt;= mid</span></span><br><span class="line">            <span class="keyword">if</span> citations[n - mid] &gt;= mid:</span><br><span class="line">                left = mid + <span class="number">1</span>  <span class="comment"># 询问范围缩小到 [mid+1, right)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid  <span class="comment"># 询问范围缩小到 [left, mid)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时 left == right，它指向第一个回答为「否」的数</span></span><br><span class="line">        <span class="comment"># 根据循环不变量，left-1 现在是最大的回答为「是」的数</span></span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>逻辑解读</strong>：当 <code>check(mid)</code> 成功时，我们更新 <code>left = mid + 1</code>，继续向右探索。当 <code>check(mid)</code> 失败时，<code>mid</code> 本身就是一个“不满足”的值，所以我们更新 <code>right = mid</code>，将这个“第一个不满足”的边界向左移动。循环结束时 <code>left</code> 就是那个第一个不满足条件的 <code>h</code>，因此 <code>left - 1</code> 就是答案。</p><hr><h4 id="解法三：左开右闭区间-left-right"><a href="#解法三：左开右闭区间-left-right" class="headerlink" title="解法三：左开右闭区间 (left, right]"></a>解法三：左开右闭区间 <code>(left, right]</code></h4><p>与上一种相反，这种写法的 <code>left</code> 边界是“开”的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(citations)</span><br><span class="line">        <span class="comment"># 在区间 (left, right] 内询问</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">            <span class="comment"># 循环不变量：</span></span><br><span class="line">            <span class="comment"># left 的回答一定为「是」</span></span><br><span class="line">            <span class="comment"># right+1 的回答一定为「否」</span></span><br><span class="line">            mid = (left + right + <span class="number">1</span>) // <span class="number">2</span>  <span class="comment"># 向上取整，避免死循环</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 引用次数最多的 mid 篇论文，引用次数均 &gt;= mid</span></span><br><span class="line">            <span class="keyword">if</span> citations[n - mid] &gt;= mid:</span><br><span class="line">                left = mid  <span class="comment"># 询问范围缩小到 (mid, right]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span>  <span class="comment"># 询问范围缩小到 (left, mid-1]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时 left == right</span></span><br><span class="line">        <span class="comment"># 根据循环不变量，left 现在是最大的回答为「是」的数</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p><strong>逻辑解读</strong>：这里 <code>mid</code> 的计算方式是 <code>(left + right + 1) // 2</code> 向上取整，这是为了防止当 <code>left = right - 1</code> 且 <code>check</code> 成功时，<code>mid</code> 仍等于 <code>left</code> 导致无限循环。当 <code>check(mid)</code> 成功时，<code>mid</code> 成为新的“最后一个满足条件”的候选，所以 <code>left = mid</code>；反之，则收缩右边界 <code>right = mid - 1</code>。循环结束时 <code>left</code> 即为答案。</p><hr><h4 id="解法四：开区间-left-right"><a href="#解法四：开区间-left-right" class="headerlink" title="解法四：开区间 (left, right)"></a>解法四：开区间 <code>(left, right)</code></h4><p>这种写法保证 <code>left</code> 和 <code>right</code> 之间始终有空间，循环条件是 <code>left + 1 &lt; right</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(citations)</span><br><span class="line">        <span class="comment"># 在区间 (left, right) 内询问</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">            <span class="comment"># 循环不变量：</span></span><br><span class="line">            <span class="comment"># left 的回答一定为「是」</span></span><br><span class="line">            <span class="comment"># right 的回答一定为「否」</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 引用次数最多的 mid 篇论文，引用次数均 &gt;= mid</span></span><br><span class="line">            <span class="keyword">if</span> citations[n - mid] &gt;= mid:</span><br><span class="line">                left = mid  <span class="comment"># 询问范围缩小到 (mid, right)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid  <span class="comment"># 询问范围缩小到 (left, mid)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束后 left + 1 == right</span></span><br><span class="line">        <span class="comment"># 根据循环不变量，left 现在是最大的回答为「是」的数</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p><strong>逻辑解读</strong>：<code>left</code> 始终维护“已知的满足条件的最大值”，而 <code>right</code> 始终维护“已知的第一个不满足条件的值”。循环不断地用 <code>mid</code> 来更新这两个边界，直到它们相邻。最终的答案就是 <code>left</code>。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(log N)<ul><li><code>N</code> 是论文的总数 <code>len(citations)</code>。</li><li>二分查找在大小为 <code>N+1</code> 的答案空间 <code>[0, N]</code> 中进行。</li><li>每次迭代，判定函数 <code>check(mid)</code> 的时间复杂度为 O(1)，因为它只需要访问数组中的一个元素。</li><li>因此，总的时间复杂度为 O(log N)。</li></ul></li><li><strong>空间复杂度</strong>: O(1)<ul><li>我们只使用了有限的几个变量（<code>left</code>, <code>right</code>, <code>mid</code>, <code>n</code>），没有使用与输入大小成比例的额外空间。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>H 指数 II 是一个典型的“二分答案”问题。当问题的解具有单调性，并且我们可以高效地对任意一个猜测的解进行“判定”时，就可以考虑使用二分查找。本文通过四种不同的区间写法，展示了二分查找在实现细节上的灵活性。理解每种写法的循环不变量是掌握二分查找、避免边界错误的关键。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 275 题：&lt;a href=&quot;https://leetcode.cn/problems/h-index-ii/description/&quot;&gt;H 指数 II&lt;/a&gt;。&lt;br&gt;本文将深入探讨解决此问题的四种不同二分查找区间写法。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分答案" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
    <category term="求最大" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/%E6%B1%82%E6%9C%80%E5%A4%A7/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 3453 | 分割正方形 I</title>
    <link href="http://github.com/posts/leetcode-3453/"/>
    <id>http://github.com/posts/leetcode-3453/</id>
    <published>2025-10-26T03:20:00.000Z</published>
    <updated>2025-10-26T03:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 3453 题：<a href="https://leetcode.cn/problems/separate-squares-i/description/">分割正方形 I</a>。<br>本题核心在于，看似复杂的面积计算问题，可以通过构建一个单调函数，并利用二分查找，将求解问题优雅地转化为判定问题，从而在连续的浮点数域上高效地逼近答案。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目要求我们找到一条水平线 <code>y = Y</code>，这条线能将所有给定的正方形的总面积精确地平分为两部分：线以上部分的面积等于线以下部分的面积。我们需要返回这个 <code>Y</code> 的最小值。</p><p>这里的核心约束条件是：</p><ol><li>我们得到的是一系列正方形，由左下角坐标 <code>[xi, yi]</code> 和边长 <code>li</code> 定义。</li><li>正方形之间可能重叠，重叠部分的面积需要被多次计算。这反而简化了问题，因为我们只需要独立计算每个正方形被如何分割，然后求和即可，无需处理复杂的几何相交问题。</li><li>我们需要找到满足 <code>线上面积 == 线下面积</code> 的<strong>最小</strong>的 <code>y</code> 坐标。</li><li>答案允许有 <code>10^-5</code> 的误差，这是一个强烈的信号，暗示我们可以使用数值逼近的方法，例如二分查找。</li></ol><p>举个例子，<code>squares = [[0,0,2],[1,1,1]]</code>。</p><ul><li>第一个正方形面积为 <code>2*2=4</code>，y 范围是 <code>[0, 2]</code>。</li><li>第二个正方形面积为 <code>1*1=1</code>，y 范围是 <code>[1, 2]</code>。</li><li>总面积为 <code>4 + 1 = 5</code>。<br>我们的目标是找到一条水平线 <code>y=Y</code>，使得线下和线上的面积都是 <code>2.5</code>。这条线 <code>y</code> 显然会落在 <code>y</code> 坐标有分布的区间内。</li></ul><h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接通过解方程的方式来找到精确的 <code>y</code> 是非常复杂的。因此，我们可以借鉴经典的“二分答案”思想，将问题从“求一个最优值”转化为一个更简单的“判定一个值是否可行”。</p><p>这个判定问题就是：<strong>如果我们任意指定一条水平线 <code>y = Y</code>，我们能否判断出这条线下方的总面积是否大于或等于线上方的总面积？</strong></p><p>这个判定问题是很容易解决的。我们可以写一个辅助函数 <code>check(Y)</code>，来计算并比较面积：</p><ul><li>初始化线下总面积 <code>area_below = 0</code>。</li><li>遍历所有正方形 <code>[xi, yi, li]</code>：<ul><li>如果 <code>Y</code> 完全在正方形上方 (<code>Y &gt;= yi + li</code>)，则整个正方形都在线下方，<code>area_below += li * li</code>。</li><li>如果 <code>Y</code> 完全在正方形下方 (<code>Y &lt;= yi</code>)，则整个正方形都在线上方，对 <code>area_below</code> 没有贡献。</li><li>如果 <code>Y</code> 穿过正方形 (<code>yi &lt; Y &lt; yi + li</code>)，则线下方部分的面积是 <code>li * (Y - yi)</code>，将其累加到 <code>area_below</code>。</li></ul></li><li>计算出总的 <code>area_below</code> 后，我们可以通过预先计算出的所有正方形的总面积 <code>total_area</code>，得到线上方的面积 <code>area_above = total_area - area_below</code>。</li><li>最后，我们比较 <code>area_below</code> 和 <code>area_above</code> 的大小。</li></ul><p>现在，我们有了判定的方法。观察可以发现，这个判定结果具有<strong>单调性</strong>：</p><ul><li>随着我们猜测的 <code>Y</code> 值从下往上增加，<code>area_below(Y)</code> 是一个单调不减的函数（只会增加或不变）。</li><li>同时，<code>area_above(Y)</code> 是一个单调不增的函数。</li><li>因此，<code>diff(Y) = area_below(Y) - area_above(Y)</code> 也是一个单调不减的函数。</li></ul><p>这种单调性是应用二分查找的完美信号。我们可以对 <code>y</code> 的坐标值进行二分查找，来快速定位到那个使得 <code>area_below</code> 和 <code>area_above</code> 最接近（或相等）的临界点。</p><p>二分查找的搜索范围是什么呢？</p><ul><li><strong>下界 (left)</strong>：<code>y</code> 坐标最小可以从 0 开始。</li><li><strong>上界 (right)</strong>：<code>y</code> 坐标最大不会超过所有正方形所能达到的最高点，即 <code>max(yi + li)</code>。</li></ul><p>因此，我们就在 <code>[0, max(yi + li)]</code> 这个浮点数区间内，对 <code>y</code> 进行二分查找。</p><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol><li><p><strong>确定二分查找的范围</strong></p><ul><li><code>left = 0.0</code>：这是可能的 y 坐标下界。</li><li><code>right = max(yi + li)</code> for all squares：这是可能的 y 坐标上界。</li><li>同时，预计算所有正方形的总面积 <code>total_area</code>。</li></ul></li><li><p><strong>执行二分查找</strong></p><ul><li>由于答案是浮点数且有精度要求，我们执行一个固定次数（例如 100 次）的循环，这足以保证精度达到 <code>10^-5</code> 以上。</li><li>计算中间值 <code>mid = left + (right - left) / 2</code> 作为当前的“猜测 <code>y</code> 坐标”。</li><li>调用辅助函数计算在 <code>y = mid</code> 时，所有正方形在线下方的总面积 <code>area_below</code>。</li><li>计算线上的面积 <code>area_above = total_area - area_below</code>。</li><li><strong>如果 <code>area_below &gt;= area_above</code></strong>：<ul><li>说明 <code>mid</code> 这个位置可能就是答案，或者答案在它的下方（我们想找最小的 <code>y</code>）。</li><li>因此，我们将 <code>mid</code> 视为一个潜在的可行解，并尝试在更小的范围 <code>[left, mid]</code> 内继续搜索，即 <code>right = mid</code>。</li></ul></li><li><strong>如果 <code>area_below &lt; area_above</code></strong>：<ul><li>说明 <code>mid</code> 这个位置太低了，导致线下方的面积不足。</li><li>我们需要将线上移来增大下方面积，因此在右半部分 <code>[mid, right]</code> 继续搜索，即 <code>left = mid</code>。</li></ul></li></ul></li><li><p><strong>返回结果</strong></p><ul><li>循环结束后，<code>left</code> 和 <code>right</code> 将会非常接近，它们都是满足精度要求的解。返回 <code>left</code> 即可。</li></ul></li></ol><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">separateSquares</span>(<span class="params">self, squares: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        通过二分查找寻找一个水平线 y，使得线上下方的正方形总面积相等。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 确定二分查找的范围并计算总面积</span></span><br><span class="line">        <span class="comment"># 下界可以是 0</span></span><br><span class="line">        left = <span class="number">0.0</span></span><br><span class="line">        <span class="comment"># 上界是所有正方形能达到的最大 y 坐标</span></span><br><span class="line">        right = <span class="number">0.0</span></span><br><span class="line">        total_area = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> _, y, l <span class="keyword">in</span> squares:</span><br><span class="line">            right = <span class="built_in">max</span>(right, <span class="built_in">float</span>(y + l))</span><br><span class="line">            total_area += <span class="built_in">float</span>(l * l)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 辅助函数：计算在给定水平线 y_line 下，所有正方形位于线下方的总面积</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_area_below</span>(<span class="params">y_line: <span class="built_in">float</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">            area_below = <span class="number">0.0</span></span><br><span class="line">            <span class="keyword">for</span> _, y, l <span class="keyword">in</span> squares:</span><br><span class="line">                <span class="comment"># 计算此正方形被 y_line 分割后，下半部分的高度</span></span><br><span class="line">                <span class="comment"># 高度不能为负，也不能超过正方形自身边长</span></span><br><span class="line">                height_below = <span class="built_in">min</span>(<span class="built_in">float</span>(l), <span class="built_in">max</span>(<span class="number">0.0</span>, y_line - <span class="built_in">float</span>(y)))</span><br><span class="line">                area_below += height_below * <span class="built_in">float</span>(l)</span><br><span class="line">            <span class="keyword">return</span> area_below</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 执行二分查找</span></span><br><span class="line">        <span class="comment"># 迭代 100 次足以满足 10^-5 的精度要求</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid == left <span class="keyword">or</span> mid == right: <span class="comment"># 避免精度问题导致的死循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">            area_below = get_area_below(mid)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 我们要找 area_below == total_area / 2 的点</span></span><br><span class="line">            <span class="comment"># 也就是 area_below &gt;= total_area - area_below 的最小 y</span></span><br><span class="line">            <span class="keyword">if</span> area_below * <span class="number">2</span> &gt;= total_area:</span><br><span class="line">                <span class="comment"># 如果线下方的面积已经足够大 (&gt;= 目标面积)</span></span><br><span class="line">                <span class="comment"># 说明 mid 是一个可能的解，或者真正的解在更下方 (y更小)</span></span><br><span class="line">                <span class="comment"># 我们尝试在 [left, mid] 区间寻找更小的 y</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果线下方的面积太小</span></span><br><span class="line">                <span class="comment"># 说明 y 需要上移，去 [mid, right] 区间寻找</span></span><br><span class="line">                left = mid</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 返回结果</span></span><br><span class="line">        <span class="comment"># 循环结束后，left 和 right 会非常接近，都是满足条件的解</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(N)。<ul><li>虽然代码结构是二分查找，但二分的次数是一个固定的常量（100 次），以保证所需的浮点数精度。</li><li>在每次二分迭代中，我们都需要调用 <code>get_area_below</code> 函数，该函数需要遍历一次 <code>squares</code> 数组，时间复杂度为 O(N)，其中 N 是正方形的数量。</li><li>因此，总时间复杂度是 O(N * 100)，即 O(N)。</li></ul></li><li><strong>空间复杂度</strong>: O(1)。<ul><li>除了输入数组外，我们只使用了几个变量来存储左右边界、中间值和面积计算结果，所以空间复杂度是常数级的。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是二分查找思想在几何问题和浮点数域上的经典应用。它再次展示了当直接求解困难时，如何通过构造一个单调的判定函数，将问题转化为“二分答案”模型。对于涉及连续值（如本题的 <code>y</code> 坐标）和精度要求的问题，使用固定迭代次数或判断区间小于阈值的二分法是一种非常稳定和高效的策略。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 3453 题：&lt;a href=&quot;https://leetcode.cn/problems/separate-squares-i/description/&quot;&gt;分割正方形 I&lt;/a&gt;。&lt;br&gt;本题核心在于，看似复杂的面积计算问题，可以通过构建一个单调函数，并利用二分查找，将求解问题优雅地转化为判定问题，从而在连续的浮点数域上高效地逼近答案。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分答案" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
    <category term="求最小" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/%E6%B1%82%E6%9C%80%E5%B0%8F/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="第150场双周赛" scheme="http://github.com/tags/%E7%AC%AC150%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 3048 | 标记所有下标的最早秒数 I</title>
    <link href="http://github.com/posts/leetcode-3048/"/>
    <id>http://github.com/posts/leetcode-3048/</id>
    <published>2025-10-25T07:40:00.000Z</published>
    <updated>2025-10-25T07:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 3048 题：<a href="https://leetcode.cn/problems/earliest-second-to-mark-indices-i/description/">标记所有下标的最早秒数 I</a>。<br>本题的关键在于识别出答案（秒数）具备单调性，从而可以将求解“最早秒数”这个最优化问题，转化为一个判定“给定秒数是否可行”的问题，并利用二分查找高效求解。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们有两个数组，<code>nums</code> 和 <code>changeIndices</code>，长度分别为 <code>n</code> 和 <code>m</code>。我们的目标是找到一个<strong>最早</strong>的秒数，在此时刻之前（含），能够将 <code>nums</code> 数组的所有 <code>n</code> 个下标都“标记”一遍。</p><p>每一秒，我们有三种选择：</p><ol><li>将任意一个 <code>nums[i]</code> 的值减 1。</li><li>如果 <code>nums[changeIndices[s]-1]</code> 的值恰好为 0，我们可以标记 <code>changeIndices[s]-1</code> 这个下标。</li><li>什么都不做。</li></ol><p>核心约束是：</p><ul><li>标记操作只能在特定秒数 <code>s</code> 对特定的下标 <code>changeIndices[s]-1</code> 进行。</li><li>标记一个下标 <code>i</code> 的前提是 <code>nums[i]</code> 必须已经被减为 0。</li></ul><p>我们需要在 <code>m</code> 秒的时间窗口内，找到满足条件的最小秒数。如果无法完成任务，则返回 -1。</p><h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最早秒数”比较复杂，因为它涉及到一系列操作的最优调度。但这类“求最小值&#x2F;最大值”的问题，通常可以尝试使用二分查找来解决。</p><p>我们可以对<strong>答案（秒数 <code>s</code>）<strong>进行二分查找。为此，我们需要验证答案的</strong>单调性</strong>：</p><ul><li>如果在 <code>s</code> 秒内可以标记所有下标，那么在 <code>s+1</code> 秒内，我们拥有更多的时间和操作机会，必然也可以完成任务。</li><li>反之，如果在 <code>s</code> 秒内无法完成任务，那么在更短的 <code>s-1</code> 秒内，也必然无法完成。</li></ul><p>这种单调性是应用二分查找的完美前提。我们可以将原问题从“找到<strong>最早</strong>的那个秒数”，转化为一个更简单的判定问题：“给定 <code>s</code> 秒，我们能<strong>不能</strong>标记所有下标？”</p><p>我们可以设计一个辅助函数 <code>check(s)</code> 来回答这个判定问题。如果能高效地实现 <code>check(s)</code>，就可以通过二分查找在 <code>[1, m]</code> 的范围内快速定位到最小的可行秒数。</p><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><h4 id="1-确定二分查找的范围"><a href="#1-确定二分查找的范围" class="headerlink" title="1. 确定二分查找的范围"></a>1. 确定二分查找的范围</h4><ul><li><strong>下界 (left)</strong>：至少需要 1 秒，所以下界是 <code>1</code>。</li><li><strong>上界 (right)</strong>：最多有 <code>m</code> 秒可用，所以上界是 <code>m</code>。</li></ul><p>我们就在 <code>[1, m]</code> 这个区间内对秒数 <code>s</code> 进行二分查找。</p><h4 id="2-check-s-函数的设计（贪心策略）"><a href="#2-check-s-函数的设计（贪心策略）" class="headerlink" title="2. check(s) 函数的设计（贪心策略）"></a>2. <code>check(s)</code> 函数的设计（贪心策略）</h4><p><code>check(s)</code> 是整个算法的核心。给定 <code>s</code> 秒，我们如何判断是否能完成任务？这需要一个明智的策略来安排我们的操作。</p><p><strong>核心贪心思想</strong>：对于任何一个需要标记的下标 <code>i</code>，为了给“减 1”操作留出尽可能多的时间，我们应该选择在 <code>s</code> 秒内<strong>最后一次</strong>出现 <code>i</code> 的机会来标记它。这样做可以最大化在该标记操作之前可用的、能够自由支配的“减 1”秒数。</p><p>基于这个思想，<code>check(s)</code> 的步骤如下：</p><ol><li><p><strong>找到最后的标记时机</strong>：</p><ul><li>遍历 <code>changeIndices</code> 的前 <code>s</code> 个元素（即从第 1 秒到第 <code>s</code> 秒）。</li><li>使用一个哈希表或数组 <code>last_pos</code>，记录每个下标 <code>i</code> (1 到 n) 在这 <code>s</code> 秒内最后一次出现的时间点。</li><li>如果在遍历后，发现某个下标 <code>i</code> 从未在 <code>changeIndices</code> 的前 <code>s</code> 秒中出现过，那么它就不可能被标记，<code>check(s)</code> 直接返回 <code>False</code>。</li></ul></li><li><p><strong>模拟过程，检查资源是否足够</strong>：</p><ul><li>我们从第 1 秒开始，一直模拟到第 <code>s</code> 秒。维护一个计数器 <code>ops</code>，表示我们积累了多少可以自由使用的“减 1”操作次数。</li><li>在第 <code>t</code> 秒 (<code>1 &lt;= t &lt;= s</code>)：<ul><li>查看 <code>changeIndices</code> 在这一秒指向的下标 <code>idx</code>。</li><li>判断当前秒 <code>t</code> 是否是 <code>idx</code> 的预定标记时间（即 <code>t == last_pos[idx]</code>）。<ul><li><strong>如果是</strong>：我们必须在这一秒标记 <code>idx</code>。为此，我们需要确保 <code>nums[idx-1]</code> 已经归零。这需要 <code>nums[idx-1]</code> 次“减 1”操作。我们检查积累的 <code>ops</code> 是否足够（<code>ops &gt;= nums[idx-1]</code>）。<ul><li>如果不够，说明时间不够，<code>check(s)</code> 返回 <code>False</code>。</li><li>如果足够，我们就“消耗”掉这些操作次数：<code>ops -= nums[idx-1]</code>。</li></ul></li><li><strong>如果不是</strong>：这一秒不是 <code>idx</code> 的最后标记机会。根据我们的贪心策略，我们不会在此时标记它，而是将这一秒视为一个宝贵的、可用于“减 1”的空闲时间。因此，<code>ops</code> 加 1。</li></ul></li></ul></li></ul></li><li><p><strong>返回结果</strong>：</p><ul><li>如果整个模拟过程（从第 1 秒到第 <code>s</code> 秒）都能顺利进行，没有因为 <code>ops</code> 不足而提前退出，那么就说明 <code>s</code> 秒是可行的，<code>check(s)</code> 返回 <code>True</code>。</li></ul></li></ol><h4 id="3-执行二分查找"><a href="#3-执行二分查找" class="headerlink" title="3. 执行二分查找"></a>3. 执行二分查找</h4><ul><li>当 <code>left &lt;= right</code> 时，循环继续。</li><li>计算中间值 <code>mid = left + (right - left) // 2</code> 作为当前的“猜测秒数”。</li><li>调用 <code>check(mid)</code> 来判定：<ul><li><strong>如果 <code>check(mid)</code> 返回 <code>True</code></strong>：说明 <code>mid</code> 秒是可行的。这可能是答案，但我们还想找一个更早的时间。因此，我们记录 <code>ans = mid</code>，并尝试在左半部分继续寻找：<code>right = mid - 1</code>。</li><li><strong>如果 <code>check(mid)</code> 返回 <code>False</code></strong>：说明 <code>mid</code> 秒不够，我们需要更多的时间。因此，去右半部分寻找：<code>left = mid + 1</code>。</li></ul></li><li>循环结束后，<code>ans</code> 中存储的就是满足条件的最早秒数。</li></ul><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">earliestSecondToMarkIndices</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], changeIndices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        m = <span class="built_in">len</span>(changeIndices)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># check(s) 函数用于判断在 s 秒内是否能完成所有标记任务</span></span><br><span class="line">        <span class="comment"># s 是秒数 (1-based), 对应 changeIndices 的前 s 个元素 (0-indexed: 0 to s-1)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">s: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># last[i] 记录下标 i (1-based) 在前 s 秒内最后一次出现的时间点 (0-indexed)</span></span><br><span class="line">            last = [-<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(s):</span><br><span class="line">                <span class="comment"># changeIndices 中的值是 1-based 的</span></span><br><span class="line">                last[changeIndices[t]] = t</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果在前 s 秒内，有的下标从未出现过，则不可能被标记</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> last[i] == -<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># ops 记录可用于“减 1”操作的空闲秒数</span></span><br><span class="line">            ops = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 遍历前 s 秒</span></span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(s):</span><br><span class="line">                idx = changeIndices[t]</span><br><span class="line">                <span class="comment"># 如果当前时间 t 是标记下标 idx 的最后时机</span></span><br><span class="line">                <span class="keyword">if</span> t == last[idx]:</span><br><span class="line">                    <span class="comment"># 获取将 nums[idx-1] 降为 0 所需的“减 1”操作次数</span></span><br><span class="line">                    cost = nums[idx - <span class="number">1</span>]</span><br><span class="line">                    <span class="comment"># 如果空闲操作数不够，则 s 秒内无法完成任务</span></span><br><span class="line">                    <span class="keyword">if</span> ops &lt; cost:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    <span class="comment"># 消耗掉 cost 次空闲操作</span></span><br><span class="line">                    ops -= cost</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果当前时间 t 不是最后标记时机，则可视为一次空闲操作</span></span><br><span class="line">                    ops += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果成功遍历完 s 秒，说明 s 秒是可行的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找答案</span></span><br><span class="line">        <span class="comment"># 搜索范围是 [1, m]，即最早可能的时间和最晚可能的时间</span></span><br><span class="line">        left, right = <span class="number">1</span>, m</span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 秒可行，说明它是一个潜在的答案</span></span><br><span class="line">                <span class="comment"># 我们尝试寻找更早的时间，所以向左收缩范围</span></span><br><span class="line">                ans = mid</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 秒不可行，说明时间太少，需要更多时间</span></span><br><span class="line">                <span class="comment"># 向右收缩范围</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O((N + M) * log(M))。<ul><li><code>N</code> 是 <code>nums</code> 的长度，<code>M</code> 是 <code>changeIndices</code> 的长度。</li><li>二分查找的搜索空间大小为 <code>M</code>，因此需要 <code>log(M)</code> 次迭代。</li><li>在每次迭代中，我们调用 <code>check(s)</code> 函数。该函数需要遍历 <code>changeIndices</code> 的前 <code>s</code> 个元素（最多 <code>M</code> 个）和 <code>n</code> 个下标，时间复杂度为 O(N + s)，即 O(N + M)。</li><li>因此，总时间复杂度是这两者的乘积。</li></ul></li><li><strong>空间复杂度</strong>: O(N)。<ul><li>在 <code>check</code> 函数中，我们使用了 <code>last</code> 数组来存储每个下标的最后出现位置，其大小为 <code>N+1</code>。因此空间复杂度为 O(N)。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“二分答案”思想的又一个经典应用。当问题的目标是求解一个符合条件的“最小值”或“最大值”，并且该问题的可行性具有单调性时，我们应该优先考虑能否将其转化为一个判定问题，并通过二分查找来加速求解。本题的难点在于设计 <code>check</code> 函数，通过采用“将困难的标记操作尽可能延后”的贪心策略，我们可以高效地判断出在给定的时间限制下任务是否可行。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 3048 题：&lt;a href=&quot;https://leetcode.cn/problems/earliest-second-to-mark-indices-i/description/&quot;&gt;标记所有下标的最早秒数 I&lt;/a&gt;。&lt;br&gt;本题的关键在于识别出答案（秒数）具备单调性，从而可以将求解“最早秒数”这个最优化问题，转化为一个判定“给定秒数是否可行”的问题，并利用二分查找高效求解。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分答案" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
    <category term="求最小" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/%E6%B1%82%E6%9C%80%E5%B0%8F/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="贪心" scheme="http://github.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="第386场周赛" scheme="http://github.com/tags/%E7%AC%AC386%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 3639 | 变为活跃状态的最小时间</title>
    <link href="http://github.com/posts/leetcode-3639/"/>
    <id>http://github.com/posts/leetcode-3639/</id>
    <published>2025-10-25T02:20:00.000Z</published>
    <updated>2025-10-25T02:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 3639 题：<a href="https://leetcode.cn/problems/minimum-time-to-activate-string/description/">变为活跃状态的最小时间</a>。<br>本题的核心在于识别出答案的单调性，并将一个求解最优值（最小时间）的问题，巧妙地转化为一个判定性的问题（在给定时间t，字符串是否活跃？），从而利用二分查找在对数时间内高效求解。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要找到一个最小的时间 <code>t</code>，在这个时间点，字符串 <code>s</code> 中“有效子字符串”的总数首次达到或超过一个给定的阈值 <code>k</code>。</p><p>这里的核心概念是：</p><ol><li><strong>变化过程</strong>：从 <code>t = 0</code> 开始，每个时间点 <code>t</code> 都会有一个指定位置 <code>order[t]</code> 的字符变成 <code>&#39;*&#39;</code>。</li><li><strong>有效子字符串</strong>：只要一个子字符串里包含了至少一个 <code>&#39;*&#39;</code>，它就是有效的。</li><li><strong>活跃状态</strong>：当整个字符串中有效子字符串的总数大于或等于 <code>k</code> 时，字符串就处于活跃状态。</li></ol><p>我们的目标是找出进入“活跃状态”的那个<strong>最小</strong>的时间点 <code>t</code>。</p><p>举个例子，<code>s = &quot;abc&quot;</code>, <code>order = [1,0,2]</code>, <code>k = 2</code>。</p><ul><li>在 <code>t = 0</code> 时，<code>s</code> 变为 <code>&quot;a*c&quot;</code>。包含 <code>&#39;*&#39;</code> 的子字符串有 <code>&quot;*&quot;</code>、<code>&quot;a*&quot;</code>、<code>&quot;*c&quot;</code>、<code>&quot;a*c&quot;</code>，共 4 个。因为 <code>4 &gt;= k</code>，此时字符串已经活跃。因此最小时间是 0。</li></ul><p>这暗示了随着时间 <code>t</code> 的增加，<code>&#39;*&#39;</code> 的数量也在增加，从而导致有效子字符串的数量只增不减。</p><h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最小时间”似乎很困难。一个更直接的想法是：如果我们<strong>假定</strong>一个时间 <code>t</code>，我们能否判断出在这个时刻，字符串是否已经“活跃”？</p><p>这个判定问题相对简单。我们可以设计一个辅助函数 <code>check(t)</code>：</p><ol><li>首先，确定在时间 <code>t</code> 时，哪些位置的字符变成了 <code>&#39;*&#39;</code>。这包括 <code>order[0]</code> 到 <code>order[t]</code> 的所有位置。</li><li>然后，计算此时有效子字符串的总数。直接计算可能比较复杂，但我们可以反向思考：<strong>有效子字符串数 &#x3D; 总子字符串数 - 无效子字符串数</strong>。</li><li>“无效子字符串”就是那些<strong>完全不包含</strong> <code>&#39;*&#39;</code> 的子字符串。它们是由原字符串中连续的、未被修改的字符组成的。</li><li>我们可以遍历一遍字符串，找出所有连续的、未被 <code>&#39;*&#39;</code> 打断的段。如果一个段的长度是 <code>L</code>，那么它能构成的无效子字符串数量就是 <code>L * (L + 1) / 2</code>。</li><li>将所有这些段产生的无效子字符串数量加起来，就得到了总的无效数。</li><li>最后，用总子字符串数 <code>n * (n + 1) / 2</code> 减去这个总无效数，得到有效子字符串数。我们判断这个数是否 <code>&gt;= k</code>。</li></ol><p>现在，我们有了一个判定的方法。观察可以发现，这个判定结果具有<strong>单调性</strong>：</p><ul><li>如果字符串在时间 <code>t</code> 是活跃的，那么在任何更晚的时间 <code>t&#39; &gt; t</code>，<code>&#39;*&#39;</code> 只会更多，有效子字符串也只会更多（或不变），所以字符串必然也还是活跃的。</li><li>反之，如果 <code>t</code> 时刻还不够活跃，那么在任何更早的时间，<code>&#39;*&#39;</code> 更少，也必然不活跃。</li></ul><p>这种单调性是应用二分查找的完美信号。 我们可以对“时间 <code>t</code>”这个值进行二分查找，来快速定位到那个“最小可行”的临界点。</p><p>这个二分查找的搜索范围是什么呢？</p><ul><li><strong>下界 (left)</strong>：最早可能的时间是 <code>t = 0</code>。</li><li><strong>上界 (right)</strong>：最晚的时间是所有字符都变完，即 <code>t = n - 1</code>。</li></ul><p>因此，我们就在 <code>[0, n - 1]</code> 这个区间内，对时间 <code>t</code> 进行二分查找。</p><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol><li><p><strong>确定二分查找的范围</strong></p><ul><li><code>left = 0</code>：最早的时间。</li><li><code>right = n - 1</code>：最晚的时间。</li><li><code>ans</code> 初始化为 <code>-1</code>，用来记录我们找到的可行解。</li></ul></li><li><p><strong>预处理和边缘情况</strong></p><ul><li>计算出总的子字符串数量 <code>total = n * (n + 1) / 2</code>。</li><li>如果 <code>k</code> 比 <code>total</code> 还大，那么永远不可能满足条件，直接返回 <code>-1</code>。</li></ul></li><li><p><strong>执行二分查找</strong></p><ul><li>当 <code>left &lt;= right</code> 时，循环继续。</li><li>计算中间值 <code>mid_t = left + (right - left) // 2</code> 作为当前的“猜测时间”。</li><li>调用辅助函数 <code>check(mid_t)</code> 来判定这个猜测值是否可行。<ul><li><strong>如果 <code>check(mid_t)</code> 返回 <code>True</code></strong> (即在 <code>mid_t</code> 时刻已达到活跃状态)：<ul><li>说明 <code>mid_t</code> 是一个潜在的答案，我们记录下来 <code>ans = mid_t</code>。</li><li>但是我们想找的是“最小”时间，所以我们尝试一个更早的时间，将搜索范围缩小到左半边：<code>right = mid_t - 1</code>。</li></ul></li><li><strong>如果 <code>check(mid_t)</code> 返回 <code>False</code></strong> (即在 <code>mid_t</code> 时刻还未活跃)：<ul><li>说明我们需要更多的时间，将搜索范围缩小到右半边：<code>left = mid_t + 1</code>。</li></ul></li></ul></li></ul></li><li><p><strong>返回结果</strong></p><ul><li>循环结束后，<code>ans</code> 中存储的就是满足条件的最小时间。</li></ul></li></ol><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minTime</span>(<span class="params">self, s: <span class="built_in">str</span>, order: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 字符串中所有可能的子字符串总数</span></span><br><span class="line">        total_substrings = n * (n + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果 k 大于可能的最大值，则永远无法达到，返回 -1</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; total_substrings:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判定函数 check(t): 检查在时间 t 时，字符串是否已变为“活跃”状态</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            is_star = [<span class="literal">False</span>] * n</span><br><span class="line">            <span class="comment"># 将前 t+1 个要改变的字符位置标记为 True</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(t + <span class="number">1</span>):</span><br><span class="line">                is_star[order[i]] = <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            invalid_count = <span class="number">0</span></span><br><span class="line">            current_block_length = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 遍历整个字符串，计算由非&#x27;*&#x27;字符组成的“无效”子字符串的数量</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> is_star[i]:</span><br><span class="line">                    current_block_length += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> current_block_length &gt; <span class="number">0</span>:</span><br><span class="line">                        invalid_count += current_block_length * (current_block_length + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">                    current_block_length = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 处理末尾可能存在的最后一个非&#x27;*&#x27;块</span></span><br><span class="line">            <span class="keyword">if</span> current_block_length &gt; <span class="number">0</span>:</span><br><span class="line">                invalid_count += current_block_length * (current_block_length + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            valid_count = total_substrings - invalid_count</span><br><span class="line">            <span class="keyword">return</span> valid_count &gt;= k</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对时间 t 进行二分查找，范围是 [0, n-1]</span></span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid_t = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid_t):</span><br><span class="line">                <span class="comment"># mid_t 可行，尝试更小的时间</span></span><br><span class="line">                ans = mid_t</span><br><span class="line">                right = mid_t - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># mid_t 不可行，需要更多时间</span></span><br><span class="line">                left = mid_t + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(N * log(N))。<ul><li><code>N</code> 是字符串 <code>s</code> 的长度。</li><li>二分查找本身需要 <code>log(N)</code> 次迭代，因为搜索范围是 <code>[0, n-1]</code>。</li><li>在每次迭代中，我们都需要调用 <code>check</code> 函数。该函数需要初始化一个大小为 <code>N</code> 的数组，并遍历一次，时间复杂度为 O(N)。</li><li>因此，总时间复杂度是这两者的乘积。</li></ul></li><li><strong>空间复杂度</strong>: O(N)。<ul><li>在 <code>check</code> 函数中，我们使用了一个大小为 <code>N</code> 的布尔数组 <code>is_star</code> 来标记 <code>&#39;*&#39;</code> 的位置。因此，空间复杂度是 O(N)。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是二分查找思想应用的经典范例，也称为“二分答案”。它教会我们当遇到求解“最小的XXX使其满足条件”这类问题时，可以尝试将其转化为一个更简单的“判定性”问题。如果这个判定问题（即 <code>check</code> 函数）的结果随自变量（本题中的 <code>t</code>）呈单调性，那么就可以利用二分查找，将搜索范围不断折半，从而在对数级别的时间复杂度内找到最优解，这比线性地从 <code>t=0</code> 开始逐个检查要高效得多。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 3639 题：&lt;a href=&quot;https://leetcode.cn/problems/minimum-time-to-activate-string/description/&quot;&gt;变为活跃状态的最小时间&lt;/a&gt;。&lt;br&gt;本题的核心在于识别出答案的单调性，并将一个求解最优值（最小时间）的问题，巧妙地转化为一个判定性的问题（在给定时间t，字符串是否活跃？），从而利用二分查找在对数时间内高效求解。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分答案" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
    <category term="求最小" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/%E6%B1%82%E6%9C%80%E5%B0%8F/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="第461场周赛" scheme="http://github.com/tags/%E7%AC%AC461%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 3296 | 移山所需的最少秒数</title>
    <link href="http://github.com/posts/leetcode-3296/"/>
    <id>http://github.com/posts/leetcode-3296/</id>
    <published>2025-10-24T12:30:00.000Z</published>
    <updated>2025-10-24T12:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 3296 题：<a href="https://leetcode.cn/problems/minimum-number-of-seconds-to-make-mountain-height-zero/description/">移山所需的最少秒数</a>。<br>本题的关键在于识别出答案（最少秒数）具有单调性，从而将一个求解最小值的问题，转化为一个“判定”问题，并利用二分查找高效地找到答案的临界点。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要计算，在一群工人同时工作的情况下，将一座给定高度 <code>mountainHeight</code> 的山夷为平地（高度降为 0），所需要的最少时间是多少秒。</p><p>每个工人的工作效率不同，由 <code>workerTimes</code> 数组定义。工人 <code>i</code> 降低山 <code>x</code> 高度所花费的时间是一个等差数列的和：<code>workerTimes[i] * (1 + 2 + ... + x)</code>，也就是 <code>workerTimes[i] * x * (x + 1) / 2</code>。</p><p>这里的核心约束条件是：</p><ol><li>所有工人<strong>同时</strong>开始工作。</li><li>总的耗时由工作最久的那个工人决定。换句话说，如果我们设定一个总时间 <code>T</code>，那么所有工人都在这 <code>T</code> 秒内尽其所能地降低山的高度。</li><li>所有工人降低的高度之和必须至少等于 <code>mountainHeight</code>。</li></ol><p>我们的目标是找到满足条件的<strong>最小</strong>时间 <code>T</code>。</p><p>举个例子，<code>mountainHeight = 4</code>, <code>workerTimes = [2,1,1]</code>。<br>假设我们给工人们 3 秒钟。</p><ul><li>对于工人 0 (<code>wt=2</code>)：在 3 秒内，他最多能降低多少高度？<ul><li>降低 1，耗时 <code>2*1 = 2 &lt;= 3</code> (可行)。</li><li>降低 2，耗时 <code>2*(1+2) = 6 &gt; 3</code> (不可行)。所以他最多降低 1。</li></ul></li><li>对于工人 1 (<code>wt=1</code>)：在 3 秒内，他最多能降低多少高度？<ul><li>降低 1，耗时 <code>1*1 = 1 &lt;= 3</code>。</li><li>降低 2，耗时 <code>1*(1+2) = 3 &lt;= 3</code> (可行)。</li><li>降低 3，耗时 <code>1*(1+2+3) = 6 &gt; 3</code> (不可行)。所以他最多降低 2。</li></ul></li><li>对于工人 2 (<code>wt=1</code>)：同理，最多能降低 2。</li></ul><p>在 3 秒内，总降低高度为 <code>1 + 2 + 2 = 5</code>，因为 <code>5 &gt;= mountainHeight(4)</code>，所以 3 秒是一个可行的时间。我们的任务就是找到这样的可行时间中的最小值。</p><h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最少秒数”非常棘手。但我们可以换一个角度：如果我们<strong>假设</strong>一个工作时间 <code>T</code>，能否判断出所有工人能否在这段时间内完成任务？</p><p>这个“判定”问题相对简单。我们可以写一个辅助函数 <code>can_finish(T)</code>：<br>对于任意一个工人 <code>i</code>，在给定的时间 <code>T</code> 内，他能降低的最大高度 <code>x</code> 满足不等式：<br><code>workerTimes[i] * x * (x + 1) / 2 &lt;= T</code></p><p>这是一个关于 <code>x</code> 的一元二次不等式：<code>workerTimes[i]*x^2 + workerTimes[i]*x - 2*T &lt;= 0</code>。通过求解对应的二次方程，我们可以找到 <code>x</code> 的最大整数解。<br>更简单地，可以变形为 <code>x^2 + x - (2*T / workerTimes[i]) &lt;= 0</code>。利用求根公式 <code>x = (-b ± sqrt(b^2 - 4ac)) / 2a</code>，我们可以得到 <code>x</code> 的最大值为 <code>floor((-1 + sqrt(1 + 8*T / workerTimes[i])) / 2)</code>。</p><p>得到每个工人在 <code>T</code> 时间内能降低的最大高度后，我们将它们全部加起来，得到总降低高度 <code>total_reduction</code>。如果 <code>total_reduction &gt;= mountainHeight</code>，那么时间 <code>T</code> 就是一个可行解。</p><p>现在，我们有了一个判定方法。并且可以发现，这个判定结果具有<strong>单调性</strong>：</p><ul><li>如果时间 <code>T</code> 内可以完成任务，那么任何大于 <code>T</code> 的时间 <code>T&#39;</code> 也一定可以完成。</li><li>反之，如果 <code>T</code> 内无法完成，任何小于 <code>T</code> 的时间也必然无法完成。</li></ul><p>这种单调性正是应用二分查找的绝佳场景。我们可以对“时间 <code>T</code>”进行二分查找，来快速定位到那个“最小可行”的临界点。</p><p>二分查找的搜索范围是什么呢？</p><ul><li><strong>下界 (l)</strong>：最少是 0 秒。</li><li><strong>上界 (r)</strong>：一个足够大的数。在最坏的情况下，只有一个工人，<code>workerTimes</code> 和 <code>mountainHeight</code> 都很大。例如 <code>wt=10^6</code>, <code>mh=10^5</code>，所需时间大约是 <code>10^6 * (10^5)^2 / 2</code>，这是一个非常大的数字（约为 <code>5 * 10^15</code>）。为了保险起见，我们可以选择一个更大的上界，比如 <code>2 * 10^16</code>。</li></ul><p>因此，我们就在 <code>[0, 2 * 10^16]</code> 这个巨大的区间内，对时间 <code>T</code> 进行二分查找。</p><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol><li><p><strong>确定二分查找的范围</strong></p><ul><li><code>l = 0</code>：可能的最小时间。</li><li><code>r = 2 * 10^16</code>：一个足够大的、确保能完成任务的时间上界。</li><li><code>ans</code> 初始化为 <code>r</code>，用来记录我们找到的可行解。</li></ul></li><li><p><strong>执行二分查找</strong></p><ul><li>当 <code>l &lt;= r</code> 时，循环继续。</li><li>计算中间值 <code>mid = l + (r - l) // 2</code> 作为当前的“猜测时间”。</li><li>调用辅助函数 <code>can_finish(mid)</code> 来判定这个猜测值是否可行。<ul><li><strong>如果 <code>can_finish(mid)</code> 返回 <code>True</code></strong> (即 <code>mid</code> 秒内可以完成任务)：<ul><li>说明 <code>mid</code> 是一个潜在的答案，我们记录下来 <code>ans = mid</code>。</li><li>但我们想找的是“最少”时间，所以我们尝试一个更小的值，将搜索范围缩小到左半边：<code>r = mid - 1</code>。</li></ul></li><li><strong>如果 <code>can_finish(mid)</code> 返回 <code>False</code></strong> (即 <code>mid</code> 秒不够)：<ul><li>说明我们需要更多的时间，将搜索范围缩小到右半边：<code>l = mid + 1</code>。</li></ul></li></ul></li></ul></li><li><p><strong>返回结果</strong></p><ul><li>循环结束后，<code>ans</code> 中存储的就是满足条件的最少秒数。</li></ul></li></ol><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minNumberOfSeconds</span>(<span class="params">self, mountainHeight: <span class="built_in">int</span>, workerTimes: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 辅助函数：判定在 T 秒内能否完成任务</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">can_finish</span>(<span class="params">T: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            total_reduction = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> T &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算每个工人在 T 秒内能降低的最大高度</span></span><br><span class="line">            <span class="keyword">for</span> wt <span class="keyword">in</span> workerTimes:</span><br><span class="line">                <span class="comment"># 求解 x^2 + x - 2*T/wt &lt;= 0 的最大整数解 x</span></span><br><span class="line">                <span class="comment"># 对应的一元二次方程求根公式为 x = (-1 + sqrt(1 + 8*T/wt)) / 2</span></span><br><span class="line">                val = <span class="number">1</span> + <span class="number">8</span> * T / wt</span><br><span class="line">                reduction = <span class="built_in">int</span>((-<span class="number">1</span> + math.sqrt(val)) / <span class="number">2</span>)</span><br><span class="line">                total_reduction += reduction</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 提前剪枝：如果已经满足要求，无需继续计算</span></span><br><span class="line">                <span class="keyword">if</span> total_reduction &gt;= mountainHeight:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> total_reduction &gt;= mountainHeight</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确定二分查找的左右边界</span></span><br><span class="line">        <span class="comment"># 下限为 0</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">2</span> * <span class="number">10</span>**<span class="number">16</span>  <span class="comment"># 上限为一个足够大的数</span></span><br><span class="line">        ans = r</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 二分查找</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> can_finish(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 可行，它可能就是答案，</span></span><br><span class="line">                <span class="comment"># 或者还有更小的可行值，所以我们记录答案并尝试在左半部分继续寻找</span></span><br><span class="line">                ans = mid </span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 不可行，说明时间太少，</span></span><br><span class="line">                <span class="comment"># 必须增加时间，所以去右半部分寻找</span></span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(L * log(R))。<ul><li><code>L</code> 是工人数量，即 <code>len(workerTimes)</code>。</li><li><code>R</code> 是二分查找的搜索空间大小 (约为 <code>2 * 10^16</code>)。</li><li>二分查找本身需要 <code>log(R)</code> 次迭代。</li><li>在每次迭代中，我们都需要调用 <code>can_finish</code> 函数，该函数需要遍历一次 <code>workerTimes</code> 数组，时间复杂度为 O(L)。</li><li>因此，总时间复杂度是这两者的乘积。</li></ul></li><li><strong>空间复杂度</strong>: O(1)。<ul><li>我们只使用了几个变量来存储边界、中间值和计算结果，没有使用与输入规模相关的额外空间。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“二分答案”思想的典型应用。当我们面对一个求解“最小可能值”或“最大可能值”的问题，并且答案满足单调性时，就可以考虑使用二分查找。通过将原始的求解问题转化为一个更简单的、可以在多项式时间内解决的“判定问题”，我们可以将巨大的搜索空间不断折半，从而在对数级别的时间复杂度内锁定最终的答案，这是一种非常强大且高效的算法思想。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 3296 题：&lt;a href=&quot;https://leetcode.cn/problems/minimum-number-of-seconds-to-make-mountain-height-zero/description/&quot;&gt;移山所需的最少秒数&lt;/a&gt;。&lt;br&gt;本题的关键在于识别出答案（最少秒数）具有单调性，从而将一个求解最小值的问题，转化为一个“判定”问题，并利用二分查找高效地找到答案的临界点。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分答案" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
    <category term="求最小" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/%E6%B1%82%E6%9C%80%E5%B0%8F/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="贪心" scheme="http://github.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="数学" scheme="http://github.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="堆（优先队列）" scheme="http://github.com/tags/%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89/"/>
    
    <category term="第416场周赛" scheme="http://github.com/tags/%E7%AC%AC416%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1011 | 在 D 天内送达包裹的能力</title>
    <link href="http://github.com/posts/leetcode-1011/"/>
    <id>http://github.com/posts/leetcode-1011/</id>
    <published>2025-10-24T02:20:00.000Z</published>
    <updated>2025-10-24T02:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1011 题：<a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/description/">在 D 天内送达包裹的能力</a>。<br>本题的核心在于识别出答案的单调性，并将一个求解最优值的问题，巧妙地转化为一个判定性的问题，从而利用二分查找在对数时间内高效求解。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要找到一艘船的最低运载能力，这艘船需要把传送带上的一系列包裹，在指定的天数 <code>days</code> 内，从一个港口运送到另一个港口。</p><p>这里的核心约束条件是：</p><ol><li>包裹必须按照 <code>weights</code> 数组给出的顺序装运，不能打乱。</li><li>每天装载的包裹总重量不能超过船的运载能力。</li><li>必须在 <code>days</code> 天（含）之内完成所有包裹的运输。</li></ol><p>我们的目标是找出满足这些条件的<strong>最低</strong>运载能力。</p><p>举个例子，<code>weights = [1,2,3,4,5,6,7,8,9,10]</code>, <code>days = 5</code>。<br>如果船的运载能力是 10，我们需要的天数会超过 5 天。而如果运载能力是 55（所有包裹总和），我们只需要 1 天就能运完。这暗示了运载能力和所需天数之间存在一种反比关系：运载能力越大，所需天数越少。</p><p>我们的任务就是在所有可行的运载能力中，找到那个最小的值。</p><h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最低运载能力”似乎很困难。一个更直接的想法是：如果我们<strong>假定</strong>一个运载能力 <code>c</code>，我们能否判断出这个能力是否足够在 <code>days</code> 天内运完所有货物？</p><p>这个判定问题就简单多了。我们可以写一个辅助函数 <code>canShip(capacity)</code>，贪心地模拟装载过程：</p><ul><li>初始化天数 <code>d = 1</code>，当前船上已装载重量 <code>current_weight = 0</code>。</li><li>按顺序遍历 <code>weights</code> 数组中的每个包裹：<ul><li>如果 <code>current_weight</code> 加上当前包裹的重量 <code>w</code> 不超过 <code>capacity</code>，则继续装载，<code>current_weight += w</code>。</li><li>否则，说明今天装不下了，需要新的一天。我们让天数 <code>d</code> 增加 1，然后将当前包裹装上新船，<code>current_weight = w</code>。</li></ul></li><li>遍历结束后，得到的 <code>d</code> 就是在运载能力为 <code>capacity</code> 时，运完所有货物所需的最少天数。</li><li>最后，我们比较这个 <code>d</code> 和题目给定的 <code>days</code>。如果 <code>d &lt;= days</code>，说明 <code>capacity</code> 是一个可行的运载能力。</li></ul><p>现在，我们有了一个判定的方法。观察可以发现，这个判定结果具有<strong>单调性</strong>：</p><ul><li>如果一个运载能力 <code>c</code> 可以在 <code>days</code> 天内完成任务，那么任何大于 <code>c</code> 的运载能力 <code>c&#39;</code> 也一定可以完成。</li><li>反之，如果 <code>c</code> 无法完成，任何小于 <code>c</code> 的能力也必然无法完成。</li></ul><p>这种单调性是应用二分查找的完美信号。 我们可以对“运载能力”这个值进行二分查找，来快速定位到那个“最低可行”的临界点。</p><p>这个二分查找的搜索范围是什么呢？</p><ul><li><strong>下界 (left)</strong>：船的运载能力至少要能装下最重的那一个包裹，所以下界是 <code>max(weights)</code>。</li><li><strong>上界 (right)</strong>：在最极端的情况下，我们可以用一天把所有包裹都运走，此时需要的运载能力是所有包裹的重量之和，即 <code>sum(weights)</code>。</li></ul><p>因此，我们就在 <code>[max(weights), sum(weights)]</code> 这个区间内，对运载能力进行二分查找。</p><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol><li><p><strong>确定二分查找的范围</strong></p><ul><li><code>left = max(weights)</code>：这是可能的最低运载能力。</li><li><code>right = sum(weights)</code>：这是可能的最高运载能力。</li><li><code>ans</code> 初始化为 <code>right</code>，用来记录我们找到的可行解。</li></ul></li><li><p><strong>执行二分查找</strong></p><ul><li>当 <code>left &lt;= right</code> 时，循环继续。</li><li>计算中间值 <code>mid = left + (right - left) // 2</code> 作为当前的“猜测运载能力”。</li><li>调用辅助函数 <code>canShip(mid)</code> 来判定这个猜测值是否可行。<ul><li><strong>如果 <code>canShip(mid)</code> 返回 <code>True</code></strong> (即 <code>mid</code> 这个运载能力可以在 <code>days</code> 天内运完)：<ul><li>说明 <code>mid</code> 是一个潜在的答案，我们记录下来 <code>ans = mid</code>。</li><li>但是我们想找的是“最低”运载能力，所以我们尝试一个更小的值，将搜索范围缩小到左半边：<code>right = mid - 1</code>。</li></ul></li><li><strong>如果 <code>canShip(mid)</code> 返回 <code>False</code></strong> (即 <code>mid</code> 这个运载能力不够)：<ul><li>说明我们需要更大的运载能力，将搜索范围缩小到右半边：<code>left = mid + 1</code>。</li></ul></li></ul></li></ul></li><li><p><strong>返回结果</strong></p><ul><li>循环结束后，<code>ans</code> 中存储的就是满足条件的最低运载能力。在我们的实现中，最后返回 <code>left</code> 也是等价的。</li></ul></li></ol><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shipWithinDays</span>(<span class="params">self, weights: <span class="type">List</span>[<span class="built_in">int</span>], days: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 确定二分查找的左右边界</span></span><br><span class="line">        <span class="comment"># 运载能力的下限是单个包裹的最大重量</span></span><br><span class="line">        left = <span class="built_in">max</span>(weights)</span><br><span class="line">        <span class="comment"># 运载能力的上限是所有包裹的总重量</span></span><br><span class="line">        right = <span class="built_in">sum</span>(weights)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 辅助函数：检查在给定的运载能力 capacity 下，能否在 days 天内运完</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">can_ship</span>(<span class="params">capacity: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            days_needed = <span class="number">1</span></span><br><span class="line">            current_weight = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> weights:</span><br><span class="line">                <span class="keyword">if</span> current_weight + w &gt; capacity:</span><br><span class="line">                    <span class="comment"># 当前船装不下了，需要新的一天</span></span><br><span class="line">                    days_needed += <span class="number">1</span></span><br><span class="line">                    current_weight = w</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 继续装货</span></span><br><span class="line">                    current_weight += w</span><br><span class="line">            <span class="keyword">return</span> days_needed &lt;= days</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> can_ship(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 可行，说明它可能就是答案，</span></span><br><span class="line">                <span class="comment"># 或者还有更小的可行值，所以我们尝试在左半部分继续寻找</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 不可行，说明运载能力太小，</span></span><br><span class="line">                <span class="comment"># 必须增大，所以去右半部分寻找</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时，left 就是满足条件的最低运载能力</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(N * log(S))。<ul><li><code>N</code> 是包裹数组 <code>weights</code> 的长度。</li><li><code>S</code> 是 <code>sum(weights) - max(weights)</code>，即二分查找的搜索空间大小。</li><li>二分查找本身需要 <code>log(S)</code> 次迭代。</li><li>在每次迭代中，我们都需要调用 <code>can_ship</code> 函数，该函数需要遍历一次 <code>weights</code> 数组，时间复杂度为 O(N)。</li><li>因此，总时间复杂度是这两者的乘积。</li></ul></li><li><strong>空间复杂度</strong>: O(1)。<ul><li>除了输入数组外，我们只使用了几个变量来存储左右边界、中间值和模拟过程中的状态，所以空间复杂度是常数级的。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是二分查找思想应用的经典范例。它教会我们当遇到求解“最小值中的最大值”或者“最大值中的最小值”这类问题时，可以尝试将其转化为一个更简单的“判定性”问题。如果这个判定问题具有单调性，那么就可以利用二分查找，将搜索范围不断折半，从而在对数级别的时间复杂度内找到最优解，这比线性扫描所有可能的答案要高效得多。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1011 题：&lt;a href=&quot;https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/description/&quot;&gt;在 D 天内送达包裹的能力&lt;/a&gt;。&lt;br&gt;本题的核心在于识别出答案的单调性，并将一个求解最优值的问题，巧妙地转化为一个判定性的问题，从而利用二分查找在对数时间内高效求解。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分答案" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
    <category term="求最小" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/%E6%B1%82%E6%9C%80%E5%B0%8F/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="贪心" scheme="http://github.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="第128场周赛" scheme="http://github.com/tags/%E7%AC%AC128%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1283 | 二分查找解决“使结果不超过阈值的最小除数”</title>
    <link href="http://github.com/posts/leetcode-1283/"/>
    <id>http://github.com/posts/leetcode-1283/</id>
    <published>2025-10-23T12:20:00.000Z</published>
    <updated>2025-10-23T12:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1283 题：<a href="https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/description/">使结果不超过阈值的最小除数</a>。<br>本题的核心在于识别出“除数”与“结果和”之间的单调性，从而将问题转化为一个经典的“在答案空间上进行二分查找”的场景。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目要求我们寻找一个<strong>最小的正整数除数</strong>，用这个除数去除数组 <code>nums</code> 中的每个元素，并将所有结果<strong>向上取整</strong>后求和。最终，这个和必须小于或等于给定的 <code>threshold</code>。</p><p>关键点在于“向上取整”。例如，<code>7 / 3 = 2.33...</code>，向上取整后是 <code>3</code>；<code>10 / 2 = 5</code>，向上取整后还是 <code>5</code>。</p><p>我们来看一个例子：<code>nums = [1,2,5,9], threshold = 6</code>。</p><ul><li>如果选择除数为 1，和为 <code>ceil(1/1) + ceil(2/1) + ceil(5/1) + ceil(9/1) = 1 + 2 + 5 + 9 = 17</code>。<code>17 &gt; 6</code>，不满足条件。</li><li>如果选择除数为 4，和为 <code>ceil(1/4) + ceil(2/4) + ceil(5/4) + ceil(9/4) = 1 + 1 + 2 + 3 = 7</code>。<code>7 &gt; 6</code>，不满足条件。</li><li>如果选择除数为 5，和为 <code>ceil(1/5) + ceil(2/5) + ceil(5/5) + ceil(9/5) = 1 + 1 + 1 + 2 = 5</code>。<code>5 &lt;= 6</code>，满足条件。</li></ul><p>我们找到了一个满足条件的除数 <code>5</code>。但题目要求的是<strong>最小</strong>的那个。我们可以继续验证，发现除数 <code>4</code> 不满足条件，因此 <code>5</code> 就是我们要找的最小除数。</p><h3 id="核心思路：在答案上进行二分查找"><a href="#核心思路：在答案上进行二分查找" class="headerlink" title="核心思路：在答案上进行二分查找"></a>核心思路：在答案上进行二分查找</h3><p>一个朴素的想法是，从除数 <code>d = 1</code> 开始，逐个向上尝试，计算每次的和，直到找到第一个满足 <code>sum &lt;= threshold</code> 的除数。然而，<code>nums</code> 中的元素最大可达 <code>10^6</code>，这意味着除数的取值范围也可能很大，线性遍历非常耗时，可能会超时。</p><p>这时，我们需要观察问题是否存在某种<strong>单调性</strong>。</p><ul><li>当<strong>除数增大</strong>时，数组中每个元素 <code>num / divisor</code> 的结果会减小或不变。</li><li>因此，所有结果向上取整后的<strong>总和也会减小或不变</strong>。</li></ul><p>这种“除数”与“总和”之间的单调递减关系，是使用<strong>二分查找</strong>的绝佳信号。我们可以对<strong>答案（也就是除数）本身</strong>进行二分查找。</p><ol><li><p><strong>确定搜索范围</strong>：</p><ul><li>除数最小也得是 <code>1</code>，这是我们的左边界。</li><li>除数最大是多少呢？如果除数等于 <code>max(nums)</code>，那么每个数相除的结果向上取整后不是 <code>1</code> 就是 <code>0</code>（正整数没有0），所以和最大是 <code>len(nums)</code>。如果除数比 <code>max(nums)</code> 还大，和依然是 <code>len(nums)</code>。因此，将搜索范围的右边界设为 <code>max(nums)</code> 是一个合理的上界。</li></ul></li><li><p><strong>二分过程</strong>：</p><ul><li>取搜索范围 <code>[left, right]</code> 的中间值 <code>mid</code> 作为候选的除数。</li><li>计算当除数为 <code>mid</code> 时的总和。</li><li>如果 <code>sum &lt;= threshold</code>，说明 <code>mid</code> 是一个<strong>可能</strong>的解，但我们想找更小的，所以我们尝试在 <code>[left, mid]</code> 这个更小的区间里继续寻找。</li><li>如果 <code>sum &gt; threshold</code>，说明 <code>mid</code> 这个除数太小了，导致和超标了。我们需要一个更大的除数，所以在 <code>[mid + 1, right]</code> 区间里继续寻找。</li></ul></li></ol><p>通过不断缩小搜索范围，我们最终可以锁定满足条件的最小除数。</p><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol><li><p><strong>确定二分边界</strong></p><ul><li>左边界 <code>l</code>：最小可能的除数是 <code>1</code>。</li><li>右边界 <code>r</code>：最大可能的除数是 <code>max(nums)</code>。</li><li><em>注意</em>：代码实现中 <code>l</code> 从 <code>0</code> 开始，但因为 <code>mid</code> 的计算和 <code>l</code> 的更新方式，<code>mid</code> 永远不会是 <code>0</code>，不影响结果。</li></ul></li><li><p><strong>编写 <code>check</code> 函数（求和逻辑）</strong></p><ul><li>这是二分查找的核心判断条件。给定一个除数 <code>d</code>，我们需要计算 <code>sum(ceil(x/d) for x in nums)</code>。</li><li>在整数运算中，<code>ceil(x/d)</code> 有一个巧妙的等价转换：<code>(x + d - 1) // d</code>。</li><li>代码中使用了另一个更精妙的转换：<code>ceil(x/d) = (x - 1) // d + 1</code>。</li><li>因此，<code>sum(ceil(x/d))</code> 等于 <code>sum((x - 1) // d + 1)</code>，进一步等于 <code>sum((x - 1) // d) + len(nums)</code>。</li><li>所以，判断条件 <code>sum(ceil(x/d)) &lt;= threshold</code> 就等价于 <code>sum((x - 1) // d) + len(nums) &lt;= threshold</code>，即 <code>sum((x - 1) // d) &lt;= threshold - len(nums)</code>。这正是代码中所使用的判断逻辑，它通过预先减掉 <code>len(nums)</code> 使得循环内的计算更简洁。</li></ul></li><li><p><strong>循环二分</strong></p><ul><li>采用 <code>while l + 1 &lt; r</code> 的二分模板。这个模板的循环终止条件是 <code>l</code> 和 <code>r</code> 相邻。</li><li>在循环中，计算 <code>mid = (l + r) // 2</code>。</li><li>如果 <code>mid</code> 满足条件（和小于等于阈值），说明 <code>mid</code> 是一个潜在的答案，或者还有更小的答案。我们将上界收缩到 <code>mid</code>，即 <code>r = mid</code>，去左半边寻找更优解。</li><li>如果 <code>mid</code> 不满足条件，说明 <code>mid</code> 太小了，必须选择一个更大的除数。我们将下界提升到 <code>mid</code>，即 <code>l = mid</code>，去右半边寻找解。</li><li>循环结束后，<code>r</code> 就指向了满足条件的最小除数。</li></ul></li></ol><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestDivisor</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], threshold: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1: 确定二分查找的边界</span></span><br><span class="line">        <span class="comment"># 左边界 l 可以从 0 或 1 开始，因为除数最小为 1。</span></span><br><span class="line">        <span class="comment"># 右边界 r 是数组中的最大值，更大的除数不会产生更小的和。</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">max</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 循环二分</span></span><br><span class="line">        <span class="comment"># 采用 l + 1 &lt; r 的模板，循环直到 l 和 r 相邻</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 防止除以 0 的情况</span></span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span>:</span><br><span class="line">                l = mid</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 2: check 函数逻辑</span></span><br><span class="line">            <span class="comment"># 计算以 mid 为除数时的总和</span></span><br><span class="line">            <span class="comment"># ceil(x/mid) 等价于 (x-1)//mid + 1</span></span><br><span class="line">            <span class="comment"># sum((x-1)//mid + 1) &lt;= threshold 变形为:</span></span><br><span class="line">            <span class="comment"># sum((x-1)//mid) &lt;= threshold - len(nums)</span></span><br><span class="line">            current_sum = <span class="built_in">sum</span>((x - <span class="number">1</span>) // mid <span class="keyword">for</span> x <span class="keyword">in</span> nums)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> current_sum &lt;= threshold - <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="comment"># 如果和满足条件，说明 mid 是一个可能的解</span></span><br><span class="line">                <span class="comment"># 我们尝试寻找更小的解，所以收缩上界</span></span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果和不满足条件，说明 mid 太小了</span></span><br><span class="line">                <span class="comment"># 我们需要更大的除数，所以收缩下界</span></span><br><span class="line">                l = mid</span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 循环结束时, r 是满足条件的最小除数</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: O(N * log K)</p><ul><li>其中 <code>N</code> 是数组 <code>nums</code> 的长度，<code>K</code> 是 <code>nums</code> 数组中的最大值。</li><li>二分查找的搜索空间大小为 <code>K</code>，因此二分过程需要进行 O(log K) 次迭代。</li><li>在每一次迭代中，我们都需要遍历整个 <code>nums</code> 数组来计算总和，这个操作的复杂度是 O(N)。</li><li>因此，总的时间复杂度是 O(N * log K)。</li></ul></li><li><p><strong>空间复杂度</strong>: O(1)</p><ul><li>算法在执行过程中只使用了有限的几个变量（如 <code>l</code>, <code>r</code>, <code>mid</code>, <code>current_sum</code>），没有使用额外的、与输入规模相关的存储空间。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是二分查找思想的一个典型应用，但它并非直接在输入数组上进行查找，而是在**可能解的范围（答案空间）**上进行查找。解决这类问题的关键在于：</p><ol><li>分析问题，发现输入与输出之间的单调关系。</li><li>确定这个单调关系的定义域，即二分查找的上下边界。</li><li>将原问题转化为一个“判定问题”（Check 函数）：给定一个候选解 <code>mid</code>，能否在 O(N) 时间内判断它是否满足条件？</li></ol><p>一旦这三步完成，就可以套用二分查找模板来高效地解决问题，将时间复杂度从可能的 O(N<em>K) 优化到 O(N</em>log K)。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1283 题：&lt;a href=&quot;https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/description/&quot;&gt;使结果不超过阈值的最小除数&lt;/a&gt;。&lt;br&gt;本题的核心在于识别出“除数”与“结果和”之间的单调性，从而将问题转化为一个经典的“在答案空间上进行二分查找”的场景。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分答案" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
    <category term="求最小" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/%E6%B1%82%E6%9C%80%E5%B0%8F/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="第166场周赛" scheme="http://github.com/tags/%E7%AC%AC166%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1287 | 有序数组中出现次数超过四分之一的元素</title>
    <link href="http://github.com/posts/leetcode-1287/"/>
    <id>http://github.com/posts/leetcode-1287/</id>
    <published>2025-10-23T02:20:00.000Z</published>
    <updated>2025-10-23T02:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1287 题：<a href="https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/description/">有序数组中出现次数超过四分之一的元素</a>。<br>这道题的优雅解法，完美诠释了如何利用问题的内在约束（“超过25%”）和数据特性（“有序”），将一个看似需要线性扫描的问题，转化为仅需常数次检查的对数级别算法。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="算法优化特性：从-O-n-到-O-log-n-的飞跃"><a href="#算法优化特性：从-O-n-到-O-log-n-的飞跃" class="headerlink" title="算法优化特性：从 O(n) 到 O(log n) 的飞跃"></a>算法优化特性：从 O(n) 到 O(log n) 的飞跃</h3><p>面对这个问题，最直观的想法是遍历整个数组，使用哈希表或计数器来统计每个数字的出现次数，时间复杂度为 O(n)。但题目给出了一个至关重要的线索：<strong>数组是有序的</strong>。这个特性让我们有机会使用二分查找来进行优化。</p><p>然而，对谁进行二分查找呢？我们不可能对每个元素都去计算其出现次数，这样效率会更低。</p><p>关键的优化点来自对 <strong>“超过 25%”</strong> 这个条件的深度挖掘。如果一个元素在长度为 <code>n</code> 的数组中出现次数超过 <code>n/4</code> 次，那么这个元素的分佈必然具有一个非常特殊的性质，这使得我们<strong>不需要检查所有元素</strong>，而只需要检查<strong>几个固定的“候选”位置</strong>即可。</p><p>这个思想将遍历所有元素的 O(n) 思路，降维成了检查常数个候选元素，每次检查使用二分查找，最终实现了 O(log n) 的时间复杂度。</p><h3 id="正确性证明：为何只需检查几个点？"><a href="#正确性证明：为何只需检查几个点？" class="headerlink" title="正确性证明：为何只需检查几个点？"></a>正确性证明：为何只需检查几个点？</h3><p>算法的核心是基于一个类似<strong>鸽巢原理</strong>的简单证明：一个长度超过 <code>n/4</code> 的连续区块，不可能完全“躲藏”在数组的四个“角落”里，它必然会跨越我们设定的几个关键“检查点”。</p><p>下面我们来严谨地证明这一点。</p><ol><li><p><strong>定义问题</strong></p><ul><li>设数组 <code>arr</code> 的长度为 <code>n</code>。</li><li>我们要找的特殊整数为 <code>x</code>，其出现次数为 <code>k</code>。</li><li>根据题意，<code>k &gt; n / 4</code>。由于 <code>k</code> 是整数，这等价于 <code>k &gt;= floor(n / 4) + 1</code>。</li></ul></li><li><p><strong>利用有序性</strong></p><ul><li>因为数组是<strong>非递减</strong>的，所有 <code>k</code> 个 <code>x</code> 必定是<strong>连续排列</strong>的。它们会形成一个长度为 <code>k</code> 的连续区块。</li></ul></li><li><p><strong>设置检查点</strong></p><ul><li>我们可以将数组从概念上分为四段。最直观的分割点（即我们的“检查点”）是位于 <code>n/4</code>, <code>n/2</code>, 和 <code>3n/4</code> 位置上的元素。</li><li>为了方便，我们考虑下取整的索引：<code>idx_1 = n // 4</code>, <code>idx_2 = n // 2</code>, <code>idx_3 = 3 * n // 4</code>。</li><li>我们的论点是：特殊整数 <code>x</code> <strong>必然</strong>是 <code>arr[idx_1]</code>, <code>arr[idx_2]</code>, <code>arr[idx_3]</code> 中的一个。</li></ul></li><li><p><strong>反证法证明</strong></p><ul><li>假设特殊整数 <code>x</code> <strong>不是</strong>这三个检查点中的任何一个。</li><li>那么，<code>x</code> 所形成的长度为 <code>k</code> 的连续区块，必须完整地存在于由这些检查点分割出的四个“间隙”之一中：<ol><li><code>[0, idx_1 - 1]</code></li><li><code>[idx_1 + 1, idx_2 - 1]</code></li><li><code>[idx_2 + 1, idx_3 - 1]</code></li><li><code>[idx_3 + 1, n - 1]</code></li></ol></li><li>现在我们来计算这些“间隙”的最大长度。最长的间隙是第一个，其长度为 <code>(idx_1 - 1) - 0 + 1 = idx_1 = n // 4</code>。其他间隙的长度都不会超过 <code>n // 4</code>。</li><li>我们得到一个结论：任何不包含检查点的连续区间，其长度<strong>最大为 <code>n // 4</code></strong>。</li><li>这与我们已知的事实——<code>x</code> 的连续区块长度 <code>k</code> <strong>严格大于 <code>n / 4</code></strong>——产生了矛盾！</li><li>因此，最初的假设（<code>x</code> 不是任何一个检查点元素）是错误的。</li></ul></li></ol><p><strong>结论：</strong> 特殊整数 <code>x</code> 必然是 <code>arr[n//4]</code>, <code>arr[n//2]</code>, 或 <code>arr[3*n//4]</code> 中的一个（或多个）。我们只需要将这三个位置的元素作为候选者，验证它们中哪一个的出现次数超过 <code>n/4</code> 即可。</p><h3 id="巧妙的实现"><a href="#巧妙的实现" class="headerlink" title="巧妙的实现"></a>巧妙的实现</h3><p>验证一个候选者 <code>cand</code> 的次数，最直接的方法是找到它的左右边界：<code>count = bisect_right(arr, cand) - bisect_left(arr, cand)</code>。</p><p>而下列代码则采用了一种更精炼的“前向检查”技巧，避免了第二次二分查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSpecialInteger</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="comment"># 任何出现次数 &gt; n/4 的元素，其个数至少为 m + 1</span></span><br><span class="line">        m = n // <span class="number">4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 候选检查点的索引。其原理是：长度 &gt; m 的连续块必然会跨过这些点之一。</span></span><br><span class="line">        <span class="comment"># 这里选择的点集 (m, 2m+1, ...) 也能起到分割作用，确保间隙长度不大于 m</span></span><br><span class="line">        candidates_indices = (m, m * <span class="number">2</span> + <span class="number">1</span>, m * <span class="number">3</span> + <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> candidates_indices:</span><br><span class="line">            <span class="comment"># 数组边界保护</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= n:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            candidate = arr[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 1. 找到该候选者第一次出现的位置</span></span><br><span class="line">            first_occurrence_idx = bisect.bisect_left(arr, candidate)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 2. 精髓：从第一次出现的位置向后数 m 个位置</span></span><br><span class="line">            <span class="comment"># 如果目标索引仍在数组界内，并且其值仍然是 candidate</span></span><br><span class="line">            <span class="comment"># 则证明从 first_occurrence_idx 到 first_occurrence_idx + m</span></span><br><span class="line">            <span class="comment"># 这 m + 1 个元素都是 candidate，计数达标。</span></span><br><span class="line">            target_idx = first_occurrence_idx + m</span><br><span class="line">            <span class="keyword">if</span> target_idx &lt; n <span class="keyword">and</span> arr[target_idx] == candidate:</span><br><span class="line">                <span class="keyword">return</span> candidate</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 基于题目“恰好有一个”答案的保证，在大多数情况下循环会提前返回。</span></span><br><span class="line">        <span class="comment"># 为覆盖所有边界情况（例如数组长度很短），返回 arr[0] 作为保底。</span></span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码的巧妙之处在于：</p><ol><li><strong>高效验证</strong>：通过 <code>bisect_left</code> 找到起始点 <code>j</code>，然后直接检查 <code>arr[j + m]</code> 的值。如果它仍然是我们的候选者，就意味着从 <code>j</code> 到 <code>j+m</code>（共 <code>m+1</code> 个）都是同一个数，直接满足了 <code>&gt; n/4</code> 的条件。这比“找左边界再找右边界”的方式更高效。</li><li><strong>候选者选择</strong>：选择 <code>m</code>, <code>2m+1</code>, <code>3m+2</code> 等作为检查点索引，同样可以保证覆盖所有可能性，因为它们之间的间隔小于等于 <code>m+1</code>，而目标元素的区块长度大于 <code>m</code>。</li><li><strong>确定性</strong>：由于题目保证了答案“恰好有一个”，所以我们测试的几个候选者中必然会有一个满足条件并被返回。</li></ol><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(logn)，其中 n 是 arr 的长度。</li><li><strong>空间复杂度</strong>: O(1)。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1287 题：&lt;a href=&quot;https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/description/&quot;&gt;有序数组中出现次数超过四分之一的元素&lt;/a&gt;。&lt;br&gt;这道题的优雅解法，完美诠释了如何利用问题的内在约束（“超过25%”）和数据特性（“有序”），将一个看似需要线性扫描的问题，转化为仅需常数次检查的对数级别算法。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分查找" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="鸽巢原理" scheme="http://github.com/tags/%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86/"/>
    
    <category term="第15场双周赛" scheme="http://github.com/tags/%E7%AC%AC15%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode LCP 08 | 前缀和与二分查找解决“剧情触发时间”</title>
    <link href="http://github.com/posts/leetcode-lcp-08/"/>
    <id>http://github.com/posts/leetcode-lcp-08/</id>
    <published>2025-10-23T01:20:00.000Z</published>
    <updated>2025-10-23T01:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode LCP 08 题：<a href="https://leetcode.cn/problems/ju-qing-hong-fa-shi-jian/">剧情触发时间</a>。<br>当游戏属性随时间单调递增时，寻找满足条件的“最早时刻”是一个经典的二分查找应用场景。通过预计算前缀和，我们可以将每次判断的复杂度降为常数级别，从而高效地解决问题。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目模拟了一个游戏过程，其中有三种核心属性：文明等级（C）、资源储备（R）和人口数量（H）。所有属性初始值（第 0 天）都为 0。</p><p>游戏每天都会进行，三种属性会根据一个给定的 <code>increase</code> 数组增长。<code>increase[i]</code> 代表第 <code>i+1</code> 天 C, R, H 的增量。</p><p>同时，有一系列剧情，它们的触发条件由 <code>requirements</code> 数组给出。每个 <code>requirement[j]</code> 包含一个 <code>[c, r, h]</code> 的阈值，当玩家的属性 C, R, H 同时大于或等于这些阈值时，该剧情就会被触发。</p><p>我们的任务是，对于每一个剧情，计算它被触发的最早是哪一天。如果某个剧情永远无法被触发，则记为 -1。</p><p>例如，<code>increase = [[2,8,4],[2,5,0],[10,9,8]]</code>，<code>requirements = [[2,11,3]]</code>：</p><ul><li>初始状态 (第 0 天): C&#x3D;0, R&#x3D;0, H&#x3D;0。</li><li>第 1 天结束: C&#x3D;2, R&#x3D;8, H&#x3D;4。此时不满足 R&gt;&#x3D;11。</li><li>第 2 天结束: C&#x3D;2+2&#x3D;4, R&#x3D;8+5&#x3D;13, H&#x3D;4+0&#x3D;4。此时 C&gt;&#x3D;2, R&gt;&#x3D;11, H&gt;&#x3D;3 全部满足。</li><li>因此，该剧情的触发时间是第 2 天。</li></ul><h3 id="核心思路：前缀和-二分查找"><a href="#核心思路：前缀和-二分查找" class="headerlink" title="核心思路：前缀和 + 二分查找"></a>核心思路：前缀和 + 二分查找</h3><p>一个朴素的解法是：对每一个 <code>requirement</code>，我们都从第 1 天开始，一天天模拟属性的增长，直到满足条件为止。如果 <code>increase</code> 的长度为 D，<code>requirements</code> 的长度为 Q，这种暴力解法的时间复杂度大约是 O(Q * D)，在 D 和 Q 都达到 10^5 的情况下，计算量过大，会导致超时。</p><p>我们可以进行优化。注意到，对于任何一个剧情，它能否在第 <code>k</code> 天被触发，取决于到第 <code>k</code> 天为止累积的 C, R, H 总量。这个“累积总量”可以通过<strong>前缀和</strong>来快速计算。我们可以先对 <code>increase</code> 数组预处理，得到一个 <code>prefix_sum</code> 数组，其中 <code>prefix_sum[k]</code> 存储了到第 <code>k</code> 天结束时 C, R, H 的总值。这样，查询任意一天的属性状态就变成了 O(1) 的操作。</p><p>更重要的是，随着天数 <code>d</code> 的增加，C, R, H 的总量是<strong>单调不减</strong>的。这意味着，如果一个剧情在第 <code>d</code> 天可以被触发，那么在 <code>d</code> 之后的所有天也一定可以被触发。这个单调性是使用<strong>二分查找</strong>的关键信号。</p><p>因此，对于每个 <code>requirement</code>，问题就转化为：<strong>在 <code>[0, 1, ..., D]</code> 这些天中，找到满足触发条件的最小天数 <code>d</code>。</strong> 这是一个典型的二分查找“寻找下界”的问题。</p><p>优化的思路分为两步：</p><ol><li><strong>预计算前缀和</strong>：遍历一次 <code>increase</code> 数组，计算出每一天结束时 C, R, H 的累积总量，存入前缀和数组。</li><li><strong>二分查找</strong>：对每一个 <code>requirement</code>，在 <code>[0, D]</code> 的天数范围内进行二分查找，快速定位到最早的触发时间。</li></ol><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol><li><p><strong>预处理 <code>increase</code> 数组</strong></p><ul><li>创建一个前缀和数组 <code>prefix_sum</code>，长度比 <code>increase</code> 大 1。<code>prefix_sum[i]</code> 用于存储到第 <code>i</code> 天结束时的总属性值。</li><li><code>prefix_sum[0]</code> 初始化为 <code>[0, 0, 0]</code>，代表第 0 天的初始状态。</li><li>遍历 <code>increase</code> 数组，从 <code>i = 1</code> 到 <code>D</code>，计算 <code>prefix_sum[i] = prefix_sum[i-1] + increase[i-1]</code>。</li></ul></li><li><p><strong>处理 <code>requirements</code> 数组</strong></p><ul><li>创建一个空的答案数组 <code>ans</code>。</li><li>遍历 <code>requirements</code> 中的每一个 <code>req = [c, r, h]</code>：<ul><li>首先做一个快速判断：如果到游戏最后一天，总属性值都无法满足 <code>req</code>，那么这个剧情永远不会触发。即 <code>prefix_sum[D]</code> 的三项均小于 <code>req</code> 的对应项，则直接将 -1 加入答案，并继续下一个 <code>req</code>。</li><li>设定二分查找的范围 <code>left = 0</code>, <code>right = D</code>。我们的目标是在这个范围内找到满足条件的最小天数。</li><li>进入二分循环 (<code>while left &lt;= right</code>)：<ul><li>取中间天数 <code>mid = left + (right - left) // 2</code>。</li><li>检查在第 <code>mid</code> 天结束时，属性是否满足 <code>req</code>，即 <code>prefix_sum[mid][0] &gt;= c</code>, <code>prefix_sum[mid][1] &gt;= r</code>, 并且 <code>prefix_sum[mid][2] &gt;= h</code>。</li><li>如果满足条件：说明第 <code>mid</code> 天或更早的天数是可能的答案。我们记录下 <code>mid</code>，并尝试在更早的时间里寻找，即 <code>right = mid - 1</code>。</li><li>如果不满足条件：说明第 <code>mid</code> 天太早了，需要更多时间积累属性，因此需要在之后的时间里寻找，即 <code>left = mid + 1</code>。</li></ul></li><li>循环结束后，记录下的那个满足条件的 <code>mid</code> 就是最早的触发时间。将其加入 <code>ans</code> 数组。</li><li>特殊情况：对于 <code>[0,0,0]</code> 的需求，第 0 天即可满足，需要单独处理或确保二分查找的逻辑能覆盖。</li></ul></li></ul></li><li><p><strong>返回结果</strong></p><ul><li>遍历结束后，返回 <code>ans</code> 数组。</li></ul></li></ol><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getTriggerTime</span>(<span class="params">self, increase: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], requirements: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(increase)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1: 预处理 increase 数组，计算前缀和</span></span><br><span class="line">        <span class="comment"># prefix_sum[i] 表示第 i 天结束时的总属性 (i 从 1 开始)</span></span><br><span class="line">        <span class="comment"># prefix_sum[0] 表示第 0 天的初始状态</span></span><br><span class="line">        prefix_sum = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            prefix_sum[i+<span class="number">1</span>][<span class="number">0</span>] = prefix_sum[i][<span class="number">0</span>] + increase[i][<span class="number">0</span>]</span><br><span class="line">            prefix_sum[i+<span class="number">1</span>][<span class="number">1</span>] = prefix_sum[i][<span class="number">1</span>] + increase[i][<span class="number">1</span>]</span><br><span class="line">            prefix_sum[i+<span class="number">1</span>][<span class="number">2</span>] = prefix_sum[i][<span class="number">2</span>] + increase[i][<span class="number">2</span>]</span><br><span class="line">            </span><br><span class="line">        ans = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2: 处理 requirements 数组</span></span><br><span class="line">        <span class="keyword">for</span> req <span class="keyword">in</span> requirements:</span><br><span class="line">            c, r, h = req[<span class="number">0</span>], req[<span class="number">1</span>], req[<span class="number">2</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 特殊情况：0 需求</span></span><br><span class="line">            <span class="keyword">if</span> c == <span class="number">0</span> <span class="keyword">and</span> r == <span class="number">0</span> <span class="keyword">and</span> h == <span class="number">0</span>:</span><br><span class="line">                ans.append(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 剪枝：如果最后一天都无法满足，则永远无法触发</span></span><br><span class="line">            <span class="keyword">if</span> prefix_sum[n][<span class="number">0</span>] &lt; c <span class="keyword">or</span> prefix_sum[n][<span class="number">1</span>] &lt; r <span class="keyword">or</span> prefix_sum[n][<span class="number">2</span>] &lt; h:</span><br><span class="line">                ans.append(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 二分查找：在 [1, n] 的天数范围内寻找最早的触发时间</span></span><br><span class="line">            left, right = <span class="number">1</span>, n</span><br><span class="line">            res = -<span class="number">1</span> <span class="comment"># 用于记录满足条件的最早天数</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                mid = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="comment"># 检查第 mid 天的属性是否满足要求</span></span><br><span class="line">                <span class="keyword">if</span> prefix_sum[mid][<span class="number">0</span>] &gt;= c <span class="keyword">and</span> prefix_sum[mid][<span class="number">1</span>] &gt;= r <span class="keyword">and</span> prefix_sum[mid][<span class="number">2</span>] &gt;= h:</span><br><span class="line">                    <span class="comment"># 如果满足，mid 是一个可能的答案，尝试寻找更早的</span></span><br><span class="line">                    res = mid</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果不满足，说明 mid 太早，需要在之后的天数里找</span></span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            ans.append(res)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 3: 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(D + Q * log D)<ul><li><code>D</code> 是 <code>increase</code> 的长度 (总天数)，<code>Q</code> 是 <code>requirements</code> 的长度。</li><li>计算前缀和数组需要遍历一次 <code>increase</code>，复杂度为 O(D)。</li><li>对于 <code>Q</code> 个剧情中的每一个，我们都执行一次二分查找。查找的范围是 <code>[1, D]</code>，所以单次二分查找的复杂度是 O(log D)。</li><li>总时间复杂度为 O(D + Q * log D)。</li></ul></li><li><strong>空间复杂度</strong>: O(D)<ul><li>我们需要一个额外的前缀和数组 <code>prefix_sum</code> 来存储 <code>D+1</code> 天的属性状态。</li><li>返回的答案数组需要 O(Q) 的空间，但通常不计入额外空间复杂度。因此，主要额外空间开销是前缀和数组。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预处理 + 二分查找”模式的又一个绝佳示例。题目的核心特征是状态（玩家属性）随一个维度（时间）的推移而单调变化。当我们需要在这个单调变化的序列中寻找第一个满足特定条件的点时，二分查找就是最高效的算法。通过前缀和将“检查任意一点状态”的成本从 O(D) 降至 O(1)，是让二分查找得以高效应用的关键所在。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode LCP 08 题：&lt;a href=&quot;https://leetcode.cn/problems/ju-qing-hong-fa-shi-jian/&quot;&gt;剧情触发时间&lt;/a&gt;。&lt;br&gt;当游戏属性随时间单调递增时，寻找满足条件的“最早时刻”是一个经典的二分查找应用场景。通过预计算前缀和，我们可以将每次判断的复杂度降为常数级别，从而高效地解决问题。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分查找" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="排序" scheme="http://github.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 911 | 二分查找解决“在线选举”问题</title>
    <link href="http://github.com/posts/leetcode-911/"/>
    <id>http://github.com/posts/leetcode-911/</id>
    <published>2025-10-23T00:20:00.000Z</published>
    <updated>2025-10-23T00:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 911 题：<a href="https://leetcode.cn/problems/online-election/">在线选举</a>。<br>这道题完美地展示了“预计算+二分查找”的设计模式。通过在初始化时处理好所有时间点的选举结果，我们可以将每次查询的复杂度从线性降低到对数级别，从而高效地响应大量查询。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目模拟了一个实时选举过程。我们有两个数组 <code>persons</code> 和 <code>times</code>，表示在 <code>times[i]</code> 时刻，候选人 <code>persons[i]</code> 获得了一张选票。我们需要实现一个查询功能 <code>q(t)</code>，它能返回在任意给定时刻 <code>t</code>，谁是当前的领先者。</p><p>领先者的判断规则有两点：</p><ol><li>获得票数最多的候选人领先。</li><li>如果票数出现平局，那么<strong>最近一次</strong>获得投票的候选人领先。</li></ol><p>举个例子，<code>persons = [0, 1, 1]</code>, <code>times = [0, 5, 10]</code>：</p><ul><li><strong>时刻 0 到 4</strong>：只有 <code>[0]</code> 投给了候选人 <code>0</code>。票数 <code>&#123;0: 1&#125;</code>。领先者是 <code>0</code>。</li><li><strong>时刻 5 到 9</strong>：<code>[0, 1]</code> 分别投给了 <code>0</code> 和 <code>1</code>。票数 <code>&#123;0: 1, 1: 1&#125;</code>。出现平局，但候选人 <code>1</code> 是在时刻 5 最近获得投票的，所以领先者是 <code>1</code>。</li><li><strong>时刻 10 及以后</strong>：<code>[0, 1, 1]</code>。票数 <code>&#123;0: 1, 1: 2&#125;</code>。领先者是 <code>1</code>。</li></ul><p>因此，<code>q(3)</code> 返回 <code>0</code>，<code>q(8)</code> 返回 <code>1</code>，<code>q(25)</code> 也返回 <code>1</code>。</p><h3 id="核心思路：预计算-二分查找"><a href="#核心思路：预计算-二分查找" class="headerlink" title="核心思路：预计算 + 二分查找"></a>核心思路：预计算 + 二分查找</h3><p>一个最直接的想法是，每当调用一次 <code>q(t)</code>，我们就遍历所有在 <code>t</code> 时刻之前的投票，模拟计票过程，找出当时的领先者。但如果查询次数非常多，这种方法的效率会很低，因为每次查询都需要重复计算。</p><p>注意到，选举的结果（谁是领先者）只在发生投票的那些特定时间点 (<code>times</code> 数组中的值) 才<strong>可能</strong>发生变化。在两次投票之间的时间段里，领先者是固定不变的。</p><p>这启发我们采用一种<strong>预计算</strong>的策略来优化查询：</p><ol><li><p><strong>预计算</strong>：在对象初始化阶段，我们先遍历一遍 <code>times</code> 和 <code>persons</code> 数组。因为 <code>times</code> 是严格递增的，我们可以按照时间顺序，计算出<strong>每一个投票时间点</strong>的选举结果（即谁是当时的领先者），然后将这些结果按时间顺序存入一个列表，例如 <code>leaders</code>。<code>leaders[i]</code> 就代表在 <code>times[i]</code> 时刻的领先者。</p></li><li><p><strong>二分查找</strong>：完成预计算后，对于任何查询 <code>q(t)</code>，问题就转化为：在 <code>times</code> 这个有序数组中，找到最后一个不大于 <code>t</code> 的时间点 <code>times[i]</code>。那么 <code>t</code> 时刻的领先者就等于 <code>times[i]</code> 时刻的领先者，也就是我们预先算好的 <code>leaders[i]</code>。在一个有序数组中查找一个值，正是二分查找的经典应用场景。</p></li></ol><p>通过这种方式，我们将复杂的、重复的计票逻辑集中在只需执行一次的初始化阶段，而将频繁调用的查询操作优化为一次高效的二分查找。</p><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol><li><p><strong>初始化 <code>__init__</code></strong></p><ul><li>我们需要一个列表 <code>leaders</code> 来存储每个投票时间点对应的领先者。</li><li>我们还需要一个哈希表 <code>counts</code> 来实时追踪每个候选人的得票数。</li><li>遍历 <code>persons</code> 和 <code>times</code> 数组（从索引 <code>0</code> 到 <code>n-1</code>）。</li><li>在每一步 <code>i</code>：<ul><li>给 <code>persons[i]</code> 增加一票。</li><li>检查 <code>persons[i]</code> 的票数是否大于或等于当前记录的最高票数。如果是，则更新领先者为 <code>persons[i]</code>。这里的 <code>&gt;=</code> 判断巧妙地处理了平局规则：因为我们是按时间顺序处理的，当票数相等时，当前的投票者 <code>persons[i]</code> 自然就是“最近获得投票”的候选人。</li><li>将当前这位领先者存入 <code>leaders</code> 列表的末尾。</li></ul></li><li>最后，我们将 <code>times</code> 数组和 <code>leaders</code> 列表保存为类的成员变量。</li></ul></li><li><p><strong>查询 <code>q(t)</code></strong></p><ul><li>该函数接收一个查询时刻 <code>t</code>。</li><li>我们的目标是在 <code>self.times</code> 数组中找到一个索引 <code>i</code>，使得 <code>self.times[i] &lt;= t</code> 且 <code>self.times[i+1] &gt; t</code>（或者是最后一个元素）。</li><li>这可以通过二分查找来实现。Python 的 <code>bisect.bisect_right(array, value)</code> 函数能找到 <code>value</code> 在 <code>array</code> 中的插入点，使得插入后数组仍然有序。这个插入点的索引 <code>idx</code> 左边的所有元素都 <code>&lt;= value</code>。</li><li>因此，我们需要的那个时间点的索引就是 <code>idx - 1</code>。</li><li>返回 <code>self.leaders[idx - 1]</code> 即可。</li></ul></li></ol><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TopVotedCandidate</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, persons: <span class="type">List</span>[<span class="built_in">int</span>], times: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="variable language_">self</span>.times = times</span><br><span class="line">        <span class="variable language_">self</span>.leaders = []</span><br><span class="line">        counts = &#123;&#125;</span><br><span class="line">        leader = -<span class="number">1</span></span><br><span class="line">        max_votes = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 1: 预计算每个时间点的领先者</span></span><br><span class="line">        <span class="keyword">for</span> person <span class="keyword">in</span> persons:</span><br><span class="line">            counts[person] = counts.get(person, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> counts[person] &gt;= max_votes:</span><br><span class="line">                max_votes = counts[person]</span><br><span class="line">                leader = person</span><br><span class="line">            <span class="variable language_">self</span>.leaders.append(leader)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">q</span>(<span class="params">self, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 2: 使用二分查找定位时间点</span></span><br><span class="line">        <span class="comment"># bisect_right 找到第一个 &gt; t 的元素的位置</span></span><br><span class="line">        idx = bisect.bisect_right(<span class="variable language_">self</span>.times, t)</span><br><span class="line">        <span class="comment"># 我们需要的是 &lt;= t 的最后一个元素，其索引为 idx - 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.leaders[idx - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>:<ul><li><code>__init__</code>: O(N)。其中 N 是 <code>persons</code> 数组的长度。我们需要遍历一次所有投票来预计算领先者列表。哈希表的读写操作平均为 O(1)。</li><li><code>q</code>: O(log N)。每次查询都是对长度为 N 的 <code>times</code> 数组进行一次二分查找。</li></ul></li><li><strong>空间复杂度</strong>: O(N)。我们需要 O(N) 的空间来存储 <code>times</code> 数组和 <code>leaders</code> 列表。在初始化过程中，计票的哈希表 <code>counts</code> 最多也可能存储 N 个候选人，因此也需要 O(N) 的空间。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预计算 + 高效查询”设计模式的典范。当面对一个固定数据集和大量后续查询的场景时，我们应首先思考是否可以通过一次性的预处理（如排序、计算前缀和、建立状态列表等）来换取后续每次查询的效率提升。二分查找作为在有序数据上进行快速定位的利器，常常在这种模式中扮演关键角色。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 911 题：&lt;a href=&quot;https://leetcode.cn/problems/online-election/&quot;&gt;在线选举&lt;/a&gt;。&lt;br&gt;这道题完美地展示了“预计算+二分查找”的设计模式。通过在初始化时处理好所有时间点的选举结果，我们可以将每次查询的复杂度从线性降低到对数级别，从而高效地响应大量查询。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分查找" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="设计" scheme="http://github.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="第103场周赛" scheme="http://github.com/tags/%E7%AC%AC103%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1818 | 二分查找优化绝对差值和</title>
    <link href="http://github.com/posts/leetcode-1818/"/>
    <id>http://github.com/posts/leetcode-1818/</id>
    <published>2025-10-22T12:20:00.000Z</published>
    <updated>2025-10-22T12:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1818 题：<a href="https://leetcode.cn/problems/minimum-absolute-sum-difference/">绝对差值和</a>。<br>本题的关键在于，将问题转化为寻找最大“收益”的单次替换。通过对<code>nums1</code>排序并利用二分查找，我们可以高效地为<code>nums2</code>中的每个元素找到最佳匹配，从而将寻找最优解的复杂度从 O(n²) 优化到 O(n log n)。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们两个长度相等的正整数数组 <code>nums1</code> 和 <code>nums2</code>。首先，我们需要理解“绝对差值和”的定义，即 <code>sum(|nums1[i] - nums2[i]|)</code>。</p><p>核心任务是：我们可以对 <code>nums1</code> 进行<strong>至多一次</strong>修改，即用 <code>nums1</code> 中的<strong>任意</strong>一个元素替换 <code>nums1</code> 中的某个元素，目标是让这个“绝对差值和”变得尽可能小。最后返回这个最小的和，并对 <code>10^9 + 7</code> 取余。</p><p>举个例子，<code>nums1 = [1,7,5]</code>, <code>nums2 = [2,3,5]</code>：</p><ul><li><strong>不替换</strong>：初始的绝对差值和是 <code>|1-2| + |7-3| + |5-5| = 1 + 4 + 0 = 5</code>。</li><li><strong>尝试替换</strong>：我们希望通过一次替换来最大化地减小这个和。<ul><li>观察到 <code>|7-3|=4</code> 是最大的差值项。如果我们能将 <code>nums1[1]</code>（值为7）换成一个更接近 <code>nums2[1]</code>（值为3）的数，收益可能最大。</li><li><code>nums1</code> 中有哪些元素可选？有 <code>1</code> 和 <code>5</code>。</li><li>如果用 <code>1</code> 替换 <code>7</code>，新 <code>nums1</code> 为 <code>[1,1,5]</code>。差值和变为 <code>|1-2| + |1-3| + |5-5| = 1 + 2 + 0 = 3</code>。</li><li>如果用 <code>5</code> 替换 <code>7</code>，新 <code>nums1</code> 为 <code>[1,5,5]</code>。差值和变为 <code>|1-2| + |5-3| + |5-5| = 1 + 2 + 0 = 3</code>。</li></ul></li><li><strong>结论</strong>：最小的绝对差值和是 3。</li></ul><h3 id="核心思路：贪心-二分查找"><a href="#核心思路：贪心-二分查找" class="headerlink" title="核心思路：贪心 + 二分查找"></a>核心思路：贪心 + 二分查找</h3><p>问题的本质是找到一个最优的替换方案。对于 <code>n</code> 个位置中的每一个 <code>i</code>，我们都有机会将其 <code>nums1[i]</code> 替换掉，从而改变 <code>|nums1[i] - nums2[i]|</code> 这一项。我们的目标是让这次替换带来的<strong>收益</strong>（即差值和的减少量）最大化。</p><p>对于任意一个位置 <code>i</code>，其原始差值为 <code>diff_i = |nums1[i] - nums2[i]|</code>。如果我们用 <code>nums1</code> 中的某个值 <code>val</code> 来替换 <code>nums1[i]</code>，那么新的差值变为 <code>new_diff_i = |val - nums2[i]|</code>。这次替换带来的收益就是 <code>reduction = diff_i - new_diff_i</code>。</p><p>要想让 <code>reduction</code> 最大，我们就必须让 <code>new_diff_i</code> 最小。这意味着，对于当前的 <code>nums2[i]</code>，我们需要在整个 <code>nums1</code> 数组中，找到一个与它最接近的数。</p><p><strong>如何高效地找到这个“最接近的数”？</strong><br>如果我们对每一个 <code>nums2[i]</code> 都遍历一遍 <code>nums1</code> 来寻找最接近的值，那么单次查找的时间复杂度是 O(n)，总时间复杂度将是 O(n²)，对于 n 高达 10^5 的情况，这显然会超时。</p><p>注意到 <code>nums1</code> 数组是固定的。我们可以先对其进行<strong>排序</strong>。在一个有序数组中查找一个数，或者查找与它最接近的数，正是<strong>二分查找</strong>的经典应用场景。</p><p>因此，我们的整体策略是：</p><ol><li><strong>预处理</strong>：先对 <code>nums1</code> 进行排序，得到一个有序版本 <code>sorted_nums1</code>。</li><li><strong>计算初始值</strong>：计算不做任何替换时的原始绝对差值和 <code>total_diff</code>。</li><li><strong>寻找最大收益</strong>：遍历 <code>i</code> 从 <code>0</code> 到 <code>n-1</code>，对于每一个 <code>nums2[i]</code>，利用二分查找在 <code>sorted_nums1</code> 中找到与它最接近的数。从而计算出替换 <code>nums1[i]</code> 能带来的最大收益 <code>max_reduction</code>。</li><li><strong>计算最终结果</strong>：最终的最小绝对差值和就是 <code>total_diff - max_reduction</code>。</li></ol><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol><li><p><strong>计算初始总和</strong></p><ul><li>定义模 <code>MOD = 10^9 + 7</code>。</li><li>遍历 <code>nums1</code> 和 <code>nums2</code>，累加 <code>|nums1[i] - nums2[i]|</code> 得到初始总和 <code>total_diff</code>。</li></ul></li><li><p><strong>排序 <code>nums1</code></strong></p><ul><li>创建一个 <code>nums1</code> 的副本并对其进行升序排序，得到 <code>sorted_nums1</code>。</li></ul></li><li><p><strong>寻找最大可减少量 (max_reduction)</strong></p><ul><li>初始化 <code>max_reduction = 0</code>。</li><li>再次遍历两个数组，对于每个索引 <code>i</code>：<ul><li>获取原始差值 <code>original_diff = |nums1[i] - nums2[i]|</code>。</li><li>以 <code>target = nums2[i]</code> 为目标，在 <code>sorted_nums1</code> 中执行二分查找。</li><li>二分查找会返回一个插入点 <code>j</code>。<code>target</code> 最接近的两个候选值就是 <code>sorted_nums1[j]</code> (如果 <code>j</code> 没越界) 和 <code>sorted_nums1[j-1]</code> (如果 <code>j &gt; 0</code>)。</li><li>计算 <code>target</code> 与这两个候选值的差的绝对值，取其中较小的一个作为 <code>min_new_diff</code>。</li><li>当前位置 <code>i</code> 能产生的最大收益为 <code>reduction = original_diff - min_new_diff</code>。</li><li>更新全局最大收益：<code>max_reduction = max(max_reduction, reduction)</code>。</li></ul></li></ul></li><li><p><strong>返回结果</strong></p><ul><li>最终的答案是 <code>(total_diff - max_reduction) % MOD</code>。为了防止结果为负（在某些语言的取模运算中），可以使用 <code>(total_diff - max_reduction + MOD) % MOD</code> 来保证结果非负。</li></ul></li></ol><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minAbsoluteSumDiff</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums1)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 1: 创建 nums1 的排序副本</span></span><br><span class="line">        sorted_nums1 = <span class="built_in">sorted</span>(nums1)</span><br><span class="line"></span><br><span class="line">        total_diff = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 步骤 2: 计算原始的绝对差值和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            total_diff += <span class="built_in">abs</span>(nums1[i] - nums2[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> total_diff == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        max_reduction = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 步骤 3: 遍历查找最大的可减少量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            original_diff = <span class="built_in">abs</span>(nums1[i] - nums2[i])</span><br><span class="line">            target = nums2[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 4: 使用二分查找在 sorted_nums1 中寻找最接近 target 的值</span></span><br><span class="line">            j = bisect.bisect_left(sorted_nums1, target)</span><br><span class="line">            </span><br><span class="line">            min_new_diff = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 候选1: 插入点右侧（或本身）的元素</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; n:</span><br><span class="line">                min_new_diff = <span class="built_in">min</span>(min_new_diff, <span class="built_in">abs</span>(sorted_nums1[j] - target))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 候选2: 插入点左侧的元素</span></span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                min_new_diff = <span class="built_in">min</span>(min_new_diff, <span class="built_in">abs</span>(sorted_nums1[j-<span class="number">1</span>] - target))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算当前替换能带来的收益</span></span><br><span class="line">            reduction = original_diff - min_new_diff</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新全局最大收益</span></span><br><span class="line">            max_reduction = <span class="built_in">max</span>(max_reduction, reduction)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 5: 从原始总和中减去最大收益并取模</span></span><br><span class="line">        result = (total_diff - max_reduction + MOD) % MOD</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n log n)。<ul><li><code>n</code> 是数组的长度。</li><li>对 <code>nums1</code> 排序需要 O(n log n)。</li><li>计算初始的 <code>total_diff</code> 需要 O(n)。</li><li>主循环执行 <code>n</code> 次，每次循环内部执行一次二分查找，需要 O(log n)。这部分总共是 O(n log n)。</li><li>因此，总的时间复杂度由排序和主循环决定，为 O(n log n)。</li></ul></li><li><strong>空间复杂度</strong>: O(n)。<ul><li>我们需要一个额外的数组 <code>sorted_nums1</code> 来存储 <code>nums1</code> 的排序副本，占用了 O(n) 的空间。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是一个很好的例子，展示了如何通过<strong>预处理</strong>和<strong>数据结构&#x2F;算法</strong>的选择来优化暴力解法。通过贪心地锁定“最大化收益”这一目标，我们将一个复杂的替换问题简化为了一系列查找问题。而排序和二分查找这对经典组合，则为我们提供了高效完成查找任务的强大工具，使得算法的性能满足了题目的要求。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1818 题：&lt;a href=&quot;https://leetcode.cn/problems/minimum-absolute-sum-difference/&quot;&gt;绝对差值和&lt;/a&gt;。&lt;br&gt;本题的关键在于，将问题转化为寻找最大“收益”的单次替换。通过对&lt;code&gt;nums1&lt;/code&gt;排序并利用二分查找，我们可以高效地为&lt;code&gt;nums2&lt;/code&gt;中的每个元素找到最佳匹配，从而将寻找最优解的复杂度从 O(n²) 优化到 O(n log n)。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分查找" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="排序" scheme="http://github.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="有序集合" scheme="http://github.com/tags/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"/>
    
    <category term="第235场周赛" scheme="http://github.com/tags/%E7%AC%AC235%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 3508 | 设计路由器：双端队列与二分查找的高效结合</title>
    <link href="http://github.com/posts/leetcode-3508/"/>
    <id>http://github.com/posts/leetcode-3508/</id>
    <published>2025-10-22T02:20:00.000Z</published>
    <updated>2025-10-22T02:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 3508 题：<a href="https://leetcode.cn/problems/implement-router/solutions/3641772/mo-ni-ha-xi-biao-dui-lie-er-fen-cha-zhao-y7l7/">设计路由器</a>。<br>本题要求设计一个数据结构，高效地模拟路由器的行为。解法的关键在于为不同的操作需求选择最合适的数据结构，特别是利用题目中时间戳的有序性，通过二分查找优化范围查询的性能。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要设计并实现一个 <code>Router</code> 类，它能模拟网络路由器处理数据包的基本功能。这个类需要支持三个核心操作：</p><ol><li><p><code>Router(int memoryLimit)</code>: 构造函数，初始化一个有固定内存上限 <code>memoryLimit</code> 的路由器。路由器中存储的数据包数量不能超过这个限制。</p></li><li><p><code>bool addPacket(int source, int destination, int timestamp)</code>: 添加一个数据包。</p><ul><li>每个数据包由来源、目的地和时间戳唯一标识。如果一个完全相同的数据包已经存在，则视为重复，添加失败。</li><li>如果内存已满（达到 <code>memoryLimit</code>），在添加新数据包前，必须先将<strong>最旧的</strong>一个数据包转发出去，以腾出空间。</li><li>一个关键信息是：<code>addPacket</code> 的调用会按照 <code>timestamp</code> 的<strong>非递减顺序</strong>进行。</li></ul></li><li><p><code>int[] forwardPacket()</code>: 转发数据包。</p><ul><li>遵循<strong>先进先出 (FIFO)</strong> 原则，移除并返回存储在路由器中<strong>最旧</strong>的数据包。</li><li>如果没有数据包，返回空数组。</li></ul></li><li><p><code>int getCount(int destination, int startTime, int endTime)</code>: 计数查询。</p><ul><li>返回当前路由器中，目的地为 <code>destination</code> 且时间戳在 <code>[startTime, endTime]</code> 闭区间内的数据包数量。</li></ul></li></ol><h3 id="核心思路：组合数据结构-二分查找"><a href="#核心思路：组合数据结构-二分查找" class="headerlink" title="核心思路：组合数据结构 + 二分查找"></a>核心思路：组合数据结构 + 二分查找</h3><p>这是一个典型的系统设计题，需要我们为不同的需求选择最优的数据结构。</p><ol><li><p><strong>处理 FIFO 和内存限制</strong>：<code>addPacket</code> 和 <code>forwardPacket</code> 方法共同描述了一个先进先出 (FIFO) 的队列行为。当队列满了之后，需要从队头移除元素。Python 中的 <code>collections.deque</code> (双端队列) 是实现这种操作的完美选择，它支持 O(1) 时间复杂度的队头移除和队尾添加。我们将用一个 <code>deque</code> 来存储所有的数据包，记为 <code>pq</code>。</p></li><li><p><strong>处理重复数据包</strong>：<code>addPacket</code> 方法要求我们能快速判断一个数据包 <code>(source, destination, timestamp)</code> 是否已经存在。为了实现 O(1) 级别的平均查找效率，哈希集合 <code>set</code> 是不二之选。我们将用一个 <code>set</code> 来存储所有当前存在的数据包，记为 <code>ps</code>。</p></li><li><p><strong>处理计数查询</strong>：<code>getCount</code> 是本题的性能关键点。对于一个给定的 <code>destination</code>，我们需要快速统计出在 <code>[startTime, endTime]</code> 时间范围内的数据包数量。</p><ul><li>一个朴素的想法是遍历整个 <code>pq</code> 队列，检查每个数据包的目的地和时间戳，但这样做的时间复杂度是 O(L)（L 为 <code>memoryLimit</code>），在大量调用下会超时。</li><li>更好的方法是将数据包按目的地进行分组。我们可以使用一个哈希表（<code>defaultdict</code>），键是 <code>destination</code>，值是一个列表，存储该目的地的所有数据包的时间戳。</li><li>注意到题目给出的关键线索：“<code>addPacket</code> 的查询，<code>timestamp</code> 按非递减顺序给出”。这意味着，当我们向某个目的地的列表中添加时间戳时，这个列表天然就是<strong>有序的</strong>！</li><li>对于一个有序的列表，查找某个范围内元素的个数，正是<strong>二分查找</strong>的经典应用场景。我们可以通过 <code>bisect_left</code> 找到范围的左边界，通过 <code>bisect_right</code> 找到范围的右边界，两者相减即可得到结果，时间复杂度为 O(log K)，其中 K 是该目的地的数据包数量。</li></ul></li></ol><p>综上，我们的整体方案是：</p><ul><li>使用 <code>deque</code> (<code>pq</code>) 维护数据包的 FIFO 顺序。</li><li>使用 <code>set</code> (<code>ps</code>) 快速检查数据包是否重复。</li><li>使用 <code>defaultdict(deque)</code> (<code>dt</code>) 将时间戳按目的地分组并保持有序，以供二分查找。</li></ul><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol><li><p><strong>初始化 <code>__init__</code></strong></p><ul><li><code>self.limit</code>: 存储内存限制。</li><li><code>self.pq = deque()</code>: 主队列，按到达顺序存储 <code>(source, destination, timestamp)</code> 元组，用于 FIFO 转发。</li><li><code>self.ps = set()</code>: 集合，同样存储元组，用于 O(1) 去重。</li><li><code>self.dt = defaultdict(deque)</code>: 字典，<code>key</code> 为 <code>destination</code>，<code>value</code> 为一个 <code>deque</code>，按顺序存储该目的地的所有时间戳。</li></ul></li><li><p><strong><code>addPacket</code> 方法</strong></p><ul><li>将传入的参数构造成 <code>packet</code> 元组。</li><li>检查 <code>packet</code> 是否在 <code>self.ps</code> 中，若存在则为重复，返回 <code>False</code>。</li><li>如果不是重复包，将其加入 <code>self.ps</code>。</li><li>检查 <code>len(self.pq)</code> 是否等于 <code>self.limit</code>。如果是，则调用 <code>self.forwardPacket()</code> 移除最旧的数据包。</li><li>将新 <code>packet</code> 添加到 <code>self.pq</code> 的队尾。</li><li>将 <code>packet</code> 的 <code>timestamp</code> 添加到 <code>self.dt[destination]</code> 的队尾。</li><li>返回 <code>True</code>。</li></ul></li><li><p><strong><code>forwardPacket</code> 方法</strong></p><ul><li>检查 <code>self.pq</code> 是否为空，若为空则返回 <code>[]</code>。</li><li>从 <code>self.pq</code> 的队首弹出一个最旧的 <code>packet</code>。</li><li>将该 <code>packet</code> 从 <code>self.ps</code> 中移除。</li><li>从 <code>self.dt[packet[1]]</code> (即该包的目的地对应的时间戳队列) 的队首弹出一个时间戳。</li><li>返回这个 <code>packet</code>。</li></ul></li><li><p><strong><code>getCount</code> 方法</strong></p><ul><li>通过 <code>self.dt[destination]</code> 获取目标地址所有的时间戳队列 <code>timestamp</code>。</li><li>使用 <code>bisect_left(timestamp, startTime)</code> 查找第一个大于等于 <code>startTime</code> 的元素索引 <code>l</code>。</li><li>使用 <code>bisect_right(timestamp, endTime)</code> 查找第一个严格大于 <code>endTime</code> 的元素索引 <code>r</code>。</li><li><code>r - l</code> 的值即为时间戳在 <code>[startTime, endTime]</code> 区间内的元素数量。返回这个差值。</li></ul></li></ol><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque, defaultdict</span><br><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left, bisect_right</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, memoryLimit: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># 内存限制</span></span><br><span class="line">        <span class="variable language_">self</span>.limit = memoryLimit</span><br><span class="line">        <span class="comment"># 主队列，维护所有数据包的FIFO顺序</span></span><br><span class="line">        <span class="variable language_">self</span>.pq = deque()</span><br><span class="line">        <span class="comment"># 集合，用于快速去重</span></span><br><span class="line">        <span class="variable language_">self</span>.ps = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># 按目的地分组的时间戳队列，用于高效范围查询</span></span><br><span class="line">        <span class="variable language_">self</span>.dt = defaultdict(deque)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addPacket</span>(<span class="params">self, source: <span class="built_in">int</span>, destination: <span class="built_in">int</span>, timestamp: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        packet = (source, destination, timestamp)</span><br><span class="line">        <span class="comment"># 检查是否重复</span></span><br><span class="line">        <span class="keyword">if</span> packet <span class="keyword">in</span> <span class="variable language_">self</span>.ps:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.ps.add(packet)</span><br><span class="line">        <span class="comment"># 如果内存已满，转发最旧的数据包</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.pq) == <span class="variable language_">self</span>.limit:</span><br><span class="line">            <span class="variable language_">self</span>.forwardPacket()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 添加新数据包到各个数据结构</span></span><br><span class="line">        <span class="variable language_">self</span>.pq.append(packet)</span><br><span class="line">        <span class="variable language_">self</span>.dt[destination].append(timestamp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forwardPacket</span>(<span class="params">self</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.pq:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从队首取出最旧的数据包</span></span><br><span class="line">        packet = <span class="variable language_">self</span>.pq.popleft()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从所有数据结构中移除该包的信息</span></span><br><span class="line">        <span class="variable language_">self</span>.ps.remove(packet)</span><br><span class="line">        <span class="variable language_">self</span>.dt[packet[<span class="number">1</span>]].popleft()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(packet)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getCount</span>(<span class="params">self, destination: <span class="built_in">int</span>, startTime: <span class="built_in">int</span>, endTime: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 获取该目的地对应的有序时间戳列表</span></span><br><span class="line">        timestamp_q = <span class="variable language_">self</span>.dt[destination]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用二分查找定位区间的左右边界</span></span><br><span class="line">        <span class="comment"># l 是第一个 &gt;= startTime 的位置</span></span><br><span class="line">        l = bisect_left(timestamp_q, startTime)</span><br><span class="line">        <span class="comment"># r 是第一个 &gt; endTime 的位置</span></span><br><span class="line">        r = bisect_right(timestamp_q, endTime)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># r - l 即为区间内元素个数</span></span><br><span class="line">        <span class="keyword">return</span> r - l</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>:<code>O(log(min(q, memoryLimit)))</code>，其中 q 是 <code>addPacket</code> 的总调用次数。</p></li><li><p><strong>空间复杂度</strong>: <code>O(min(q, memoryLimit))</code></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是一个优秀的数据结构设计问题，它考验了我们根据不同操作需求选择和组合多种数据结构的能力。通过使用 <code>deque</code> 满足 FIFO 要求，使用 <code>set</code> 实现快速去重，并巧妙地利用题目中“时间戳非递减”这一隐藏条件，将目的地的时间戳维护成一个有序序列，最终通过二分查找将最复杂的范围查询操作优化到了对数时间复杂度。这个思路清晰地展示了如何通过分析问题特性来设计高效的算法。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 3508 题：&lt;a href=&quot;https://leetcode.cn/problems/implement-router/solutions/3641772/mo-ni-ha-xi-biao-dui-lie-er-fen-cha-zhao-y7l7/&quot;&gt;设计路由器&lt;/a&gt;。&lt;br&gt;本题要求设计一个数据结构，高效地模拟路由器的行为。解法的关键在于为不同的操作需求选择最合适的数据结构，特别是利用题目中时间戳的有序性，通过二分查找优化范围查询的性能。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分查找" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="设计" scheme="http://github.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="有序集合" scheme="http://github.com/tags/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"/>
    
    <category term="队列" scheme="http://github.com/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="第444场周赛" scheme="http://github.com/tags/%E7%AC%AC444%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1146 | 二分查找实现“快照数组”</title>
    <link href="http://github.com/posts/leetcode-1146/"/>
    <id>http://github.com/posts/leetcode-1146/</id>
    <published>2025-10-21T03:20:00.000Z</published>
    <updated>2025-10-21T03:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1146 题：<a href="https://leetcode.cn/problems/snapshot-array/">快照数组</a>。<br>通过为每个数组索引维护一个历史记录列表，并利用二分查找，我们可以在 O(log K) 的时间内高效地获取任意历史快照中的值。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>这道题要求我们设计一个名为 <code>SnapshotArray</code> 的类，它模拟一个数组，但增加了“快照”功能。具体来说，需要实现以下几个接口：</p><ul><li><code>SnapshotArray(int length)</code>：构造函数，初始化一个长度为 <code>length</code> 的数组，所有元素的初始值都为 0。</li><li><code>void set(index, val)</code>：将当前数组在 <code>index</code> 位置的元素值修改为 <code>val</code>。</li><li><code>int snap()</code>：对当前数组的状态进行一次“快照”，并返回这次快照的唯一标识 <code>snap_id</code>。这个 ID 是从 0 开始递增的。</li><li><code>int get(index, snap_id)</code>：获取在 <code>snap_id</code> 这次快照时，<code>index</code> 位置上元素的值。</li></ul><p>举个例子来理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SnapshotArray snapshotArr = new SnapshotArray(3); // 数组为 [0, 0, 0]</span><br><span class="line">snapshotArr.set(0, 5);  // 当前数组为 [5, 0, 0]</span><br><span class="line">snapshotArr.snap();     // 拍了一张快照，snap_id = 0。这张快照记录了 [5, 0, 0] 的状态</span><br><span class="line">snapshotArr.set(0, 6);  // 当前数组为 [6, 0, 0]</span><br><span class="line">snapshotArr.get(0, 0);  // 获取 snap_id=0 的快照中，索引0的值。当时的值是 5，所以返回 5。</span><br></pre></td></tr></table></figure><h3 id="核心思路：空间换时间-二分查找"><a href="#核心思路：空间换时间-二分查找" class="headerlink" title="核心思路：空间换时间 + 二分查找"></a>核心思路：空间换时间 + 二分查找</h3><p>一个最直观但效率低下的想法是，每次调用 <code>snap()</code> 时，都完整地复制一份当前数组的全部内容并存储起来。如果数组长度为 <code>L</code>，调用 <code>snap()</code> 的次数为 <code>S</code>，这种方法的空间复杂度将高达 O(L * S)，在 <code>L</code> 和 <code>S</code> 都很大时会消耗巨量内存。同时，<code>snap()</code> 操作本身的时间复杂度也是 O(L)，效率堪忧。</p><p>我们可以进行优化。实际上，每次调用 <code>set</code> 时，只有单个元素的值发生了改变。我们没有必要为整个数组创建副本，而只需要记录<strong>哪个元素，在哪个时刻（snap_id），变成了什么值</strong>。</p><p>基于这个想法，我们可以为数组的<strong>每一个索引</strong>都维护一个独立的修改历史列表。这个列表里存储的是一个个的 <code>(snap_id, value)</code> 对。</p><p>例如，<code>history[0] = [(0, 5), (2, 8)]</code> 就表示：</p><ul><li>在 <code>snap_id = 0</code> 时，索引 <code>0</code> 的值被设置为了 <code>5</code>。</li><li>在 <code>snap_id = 2</code> 时，索引 <code>0</code> 的值被更新为了 <code>8</code>。</li></ul><p>当我们要调用 <code>get(index, snap_id)</code> 时，问题就转变成了：<strong>在 <code>index</code> 的历史记录中，找到在小于等于 <code>snap_id</code> 的所有记录里，离 <code>snap_id</code> 最近的那一条记录的值。</strong></p><p>由于我们是按时间顺序调用 <code>set</code> 和 <code>snap</code> 的，所以每个索引的历史记录中，<code>snap_id</code> 自然是单调递增的。这就为我们使用<strong>二分查找</strong>创造了完美的条件，从而可以快速地定位到目标记录。</p><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol><li><p><strong>数据结构设计</strong></p><ul><li>我们需要一个变量 <code>csi</code> (current snap id) 来记录当前的快照编号，初始为 0。</li><li>我们需要一个核心数据结构来存储每个索引的历史变更。这里使用一个哈希表（在 Python 中是 <code>defaultdict</code>），键是数组的 <code>index</code>，值是一个列表，列表里存放 <code>(snap_id, val)</code> 的元组。例如：<code>self.history = &#123;0: [(0, 5), (2, 8)], 1: [(0, 4)]&#125;</code>。</li></ul></li><li><p><strong><code>__init__(self, length)</code></strong></p><ul><li>初始化 <code>csi = 0</code>。</li><li>初始化 <code>self.history = defaultdict(list)</code>。</li></ul></li><li><p><strong><code>set(self, index, val)</code></strong></p><ul><li>向 <code>index</code> 对应的历史记录列表中追加一个新的元组 <code>(self.csi, val)</code>。这表示在当前的快照时间点，<code>index</code> 的值被设置为了 <code>val</code>。</li><li><em>优化提示</em>: 如果 <code>index</code> 对应的历史列表不为空，且最后一条记录的 <code>snap_id</code> 与当前的 <code>csi</code> 相同，说明在同一次快照内对同一位置进行了多次 <code>set</code>。此时可以直接覆盖最后一条记录的值，而不是追加，可以节省一点空间。但直接追加在逻辑上也是完全正确的。</li></ul></li><li><p><strong><code>snap(self)</code></strong></p><ul><li>这个操作非常简单，只需将 <code>csi</code> 加一，并返回加一之前的旧值即可，即 <code>self.csi - 1</code>。</li></ul></li><li><p><strong><code>get(self, index, snap_id)</code></strong></p><ul><li>这是算法的核心。首先获取 <code>index</code> 对应的历史记录列表 <code>history[index]</code>。</li><li>我们需要在这个列表中找到满足 <code>记录的snap_id &lt;= 给定的snap_id</code> 的最右侧（即 <code>snap_id</code> 最大）的那条记录。</li><li>我们可以使用二分查找来高效地完成这个任务。具体来说，我们查找第一个 <code>snap_id &gt; 给定的snap_id</code> 的位置。这个位置的前一个元素，就是我们想要的答案。</li><li>Python 的 <code>bisect_left</code> 或 <code>bisect_right</code> 模块非常适合这个场景。<code>bisect_left(history[index], (snap_id + 1, ))</code> 会找到 <code>(snap_id + 1, )</code> 这个元组应该插入的位置，这个位置索引 <code>j</code> 正是第一条 <code>snap_id</code> 大于 <code>snap_id</code> 的记录。</li><li>因此，<code>j - 1</code> 就是我们目标记录的索引。</li><li>需要处理边界情况：<ul><li>如果 <code>j - 1</code> 为负数，说明 <code>history[index]</code> 中所有的记录 <code>snap_id</code> 都大于给定的 <code>snap_id</code>，或者这个索引从未被 <code>set</code> 过。根据题意，此时应返回初始值 0。</li><li>否则，返回 <code>history[index][j-1]</code> 中存储的值即可。</li></ul></li></ul></li></ol><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SnapshotArray</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, length: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># csi: current snap id, 当前快照编号</span></span><br><span class="line">        <span class="variable language_">self</span>.csi = <span class="number">0</span></span><br><span class="line">        <span class="comment"># history: 使用哈希表存储每个索引的历史记录</span></span><br><span class="line">        <span class="comment"># key: 数组索引, value: [(snap_id, val), ...] 列表</span></span><br><span class="line">        <span class="variable language_">self</span>.history = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 在当前快照时间点，记录 index 处的值</span></span><br><span class="line">        <span class="comment"># 如果历史记录的最后一次快照ID和当前ID相同，可以优化为覆盖，但追加更简单且正确</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.history[index] <span class="keyword">and</span> <span class="variable language_">self</span>.history[index][-<span class="number">1</span>][<span class="number">0</span>] == <span class="variable language_">self</span>.csi:</span><br><span class="line">            <span class="variable language_">self</span>.history[index][-<span class="number">1</span>] = (<span class="variable language_">self</span>.csi, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.history[index].append((<span class="variable language_">self</span>.csi, val))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">snap</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 快照数加一，并返回旧的 snap_id</span></span><br><span class="line">        <span class="variable language_">self</span>.csi += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.csi - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index: <span class="built_in">int</span>, snap_id: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 在 index 的历史记录中，二分查找 snap_id</span></span><br><span class="line">        <span class="comment"># 目标是找到 &lt;= snap_id 的最大快照记录</span></span><br><span class="line">        records = <span class="variable language_">self</span>.history[index]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># bisect_left 寻找插入 (snap_id + 1, ) 的位置</span></span><br><span class="line">        <span class="comment"># 这个位置的左边所有元素的 snap_id 都 &lt;= snap_id</span></span><br><span class="line">        <span class="comment"># 因为元组比较时会先比较第一个元素</span></span><br><span class="line">        j = bisect_left(records, (snap_id + <span class="number">1</span>,)) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果 j &gt;= 0，说明找到了一个有效的历史记录</span></span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> records[j][<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 否则，说明在该快照或之前，该索引从未被 set 过，返回初始值 0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><code>N</code> 是数组的长度, <code>C</code> 是 <code>set</code> 操作的总调用次数。</li><li><strong>时间复杂度</strong>:<ul><li><code>__init__</code>: O(1)。<code>defaultdict</code> 的初始化是常数时间。</li><li><code>set</code>: O(1)。向列表末尾追加元素是摊还 O(1) 的时间复杂度。</li><li><code>snap</code>: O(1)。仅涉及一次整数自增操作。</li><li><code>get</code>: O(log K)。其中 <code>K</code> 是对 <code>index</code> 调用 <code>set</code> 的次数。在最坏的情况下，所有的 <code>set</code> 操作都作用于同一个 <code>index</code>，此时 <code>K</code> 等于 <code>C</code>，所以最坏时间复杂度为 O(log C)。</li></ul></li><li><strong>空间复杂度</strong>: O(C)。我们存储了每一次 <code>set</code> 操作的数据。每次 <code>set</code> 都会创建一个 <code>(snap_id, val)</code> 元组，所以总的空间消耗与 <code>set</code> 的调用次数成正比。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预处理 + 二分查找”模式的一个经典应用，同时也考察了数据结构设计的能力。面对可能导致巨大时空开销的朴素解法，我们应该思考<strong>变化的是什么，不变的是什么</strong>。在这里，数组的大部分内容在快照之间是不变的，只有被 <code>set</code> 的部分才变化。抓住这一关键点，通过只记录增量变化（即历史记录）的方式，成功地用可控的空间换取了极高的查询效率。而二分查找，正是利用历史记录中 <code>snap_id</code> 的有序性来实现高效查询的利器。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1146 题：&lt;a href=&quot;https://leetcode.cn/problems/snapshot-array/&quot;&gt;快照数组&lt;/a&gt;。&lt;br&gt;通过为每个数组索引维护一个历史记录列表，并利用二分查找，我们可以在 O(log K) 的时间内高效地获取任意历史快照中的值。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分查找" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="设计" scheme="http://github.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="第148场周赛" scheme="http://github.com/tags/%E7%AC%AC148%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2070 | 二分查找解决“每一个查询的最大美丽值”</title>
    <link href="http://github.com/posts/leetcode-2070/"/>
    <id>http://github.com/posts/leetcode-2070/</id>
    <published>2025-10-21T01:30:00.000Z</published>
    <updated>2025-10-21T01:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 2070 题：<a href="https://leetcode.cn/problems/most-beautiful-item-for-each-query/description/">每一个查询的最大美丽值</a>。<br>对于每个价格查询，如何高效找到符合条件物品中的最大美丽值？通过预处理和二分查找，我们可以将问题迎刃而解。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个二维数组 <code>items</code>，其中每个元素 <code>items[i] = [price_i, beauty_i]</code> 代表一件物品的价格和美丽值。同时，我们还有一个查询数组 <code>queries</code>，里面包含了一系列的价格。</p><p>我们的任务是，对于 <code>queries</code> 中的每一个价格 <code>q</code>，找出所有价格<strong>小于或等于</strong> <code>q</code> 的物品中，<strong>美丽值最大</strong>的是多少。如果不存在价格小于或等于 <code>q</code> 的物品，那么该查询的结果就是 0。最终，我们需要返回一个包含所有查询结果的数组。</p><p>举个例子，<code>items = [[1,2],[3,2],[2,4],[5,6],[3,5]]</code>, <code>queries = [1,2,3,4,5,6]</code>：</p><ul><li>对于查询 <code>q = 1</code>：只有 <code>[1,2]</code> 的价格 <code>&lt;= 1</code>。最大美丽值是 2。</li><li>对于查询 <code>q = 2</code>：有 <code>[1,2]</code> 和 <code>[2,4]</code> 的价格 <code>&lt;= 2</code>。最大美丽值是 4。</li><li>对于查询 <code>q = 3</code>：有 <code>[1,2]</code>, <code>[2,4]</code>, <code>[3,2]</code>, <code>[3,5]</code> 的价格 <code>&lt;= 3</code>。它们中的最大美丽值是 5。</li><li>对于查询 <code>q = 4</code>：符合条件的物品和 <code>q=3</code> 时一样，最大美丽值仍然是 5。</li><li>对于查询 <code>q = 5</code> 和 <code>q = 6</code>：所有物品都符合条件，最大美丽值是 6。</li><li>因此，最终答案是 <code>[2,4,5,5,6,6]</code>。</li></ul><h3 id="核心思路：预处理-二分查找"><a href="#核心思路：预处理-二分查找" class="headerlink" title="核心思路：预处理 + 二分查找"></a>核心思路：预处理 + 二分查找</h3><p>一个显而易见的暴力解法是：对每一个 <code>query</code>，都完整遍历一次 <code>items</code> 数组，筛选出所有价格符合条件的物品，然后找到其中的最大美丽值。如果 <code>queries</code> 的长度是 M，<code>items</code> 的长度是 N，这种方法的时间复杂度将是 O(M * N)，在 N 和 M 都达到 10^5 的情况下，计算量过大，会导致超时。</p><p>注意到，<code>items</code> 数组是固定不变的，而查询是多次的。这提示我们可以对 <code>items</code> 进行<strong>预处理</strong>，以加速后续的查询过程。</p><p>优化的核心思路是：</p><ol><li><strong>排序</strong>：如果我们按价格对 <code>items</code> 数组进行升序排序，那么对于一个查询价格 <code>q</code>，所有符合条件的物品都会集中在数组的开头部分。</li><li><strong>预计算最大美丽值</strong>：仅仅排序还不够，因为我们仍然需要遍历这个开头部分来找最大美丽值。关键的优化在于，我们可以在排序后再次遍历 <code>items</code> 数组，将每个物品的美丽值更新为<strong>到它为止（包括它自己）所有物品中的最大美丽值</strong>。也就是说，<code>items[i][1]</code> 将存储价格不高于 <code>items[i][0]</code> 的所有物品中的最大美丽值。</li><li><strong>二分查找</strong>：完成预处理后，对于每个查询 <code>q</code>，问题就变成了：在排序好的 <code>items</code> 数组中，找到价格 <code>&lt;= q</code> 的最后一个物品。由于我们已经预处理了最大美丽值，这个物品所存储的美丽值就是该查询的最终答案。这个查找过程可以通过高效的二分查找来完成。</li></ol><p>通过这种“预处理 + 二分查找”的模式，每次查询的时间复杂度可以从 O(N) 降低到 O(log N)，从而极大地提升了算法的整体性能。</p><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><h4 id="解法一：原地更新最大美丽值"><a href="#解法一：原地更新最大美丽值" class="headerlink" title="解法一：原地更新最大美丽值"></a>解法一：原地更新最大美丽值</h4><ol><li><p><strong>排序</strong>：</p><ul><li>首先，按价格（<code>item[0]</code>）对 <code>items</code> 数组进行升序排序。</li></ul></li><li><p><strong>预处理 <code>items</code> 数组</strong>：</p><ul><li>遍历排序后的 <code>items</code> 数组，从第二个元素开始（索引为 1）。</li><li>将当前物品 <code>items[i]</code> 的美丽值更新为它自身美丽值与前一个物品 <code>items[i-1]</code> 美丽值的较大者，即 <code>items[i][1] = max(items[i][1], items[i-1][1])</code>。</li><li>这次遍历完成后，<code>items[i][1]</code> 就代表了在价格不超过 <code>items[i][0]</code> 的所有物品里，能找到的最大美丽值。</li></ul></li><li><p><strong>处理 <code>queries</code> 数组</strong>：</p><ul><li>遍历 <code>queries</code> 中的每一个查询价格 <code>q</code>。</li><li>使用二分查找（例如 Python 的 <code>bisect_right</code>）在 <code>items</code> 数组中查找 <code>q</code>。<code>bisect_right</code> 会返回一个插入点索引 <code>j</code>，这个索引是第一个价格<strong>严格大于</strong> <code>q</code> 的物品的位置。</li><li>因此，所有价格小于或等于 <code>q</code> 的物品的索引范围是 <code>0</code> 到 <code>j-1</code>。</li><li>如果 <code>j</code> 为 0，表示没有物品的价格小于等于 <code>q</code>，答案为 0。</li><li>否则，价格小于等于 <code>q</code> 的最后一个物品是 <code>items[j-1]</code>。根据我们的预处理，<code>items[j-1][1]</code> 就是我们想要的答案。</li></ul></li><li><p><strong>返回结果</strong>：</p><ul><li>将所有查询的结果收集起来并返回。</li></ul></li></ol><h4 id="解法二：压缩数组（空间优化）"><a href="#解法二：压缩数组（空间优化）" class="headerlink" title="解法二：压缩数组（空间优化）"></a>解法二：压缩数组（空间优化）</h4><p>这种解法在思路上与解法一类似，但在预处理阶段有所不同。它不是更新每一个物品的美丽值，而是创建一个“浓缩”版的 <code>items</code> 列表，只保留那些有意义的物品。一个物品 <code>items[i]</code> 如果其价格更高但美丽值却不比前面的物品更高，那么它对于寻找最大美丽值是没有贡献的。</p><ol><li><p><strong>排序</strong>：</p><ul><li>同解法一，按价格对 <code>items</code> 数组进行升序排序。</li></ul></li><li><p><strong>预处理（压缩数组）</strong>：</p><ul><li>使用一个指针 <code>k</code> 来记录有效物品列表的末尾（初始为 0）。</li><li>遍历排序后的 <code>items</code> 数组（从索引 1 开始）。如果当前物品 <code>items[i]</code> 的美丽值大于 <code>items[k]</code> 的美丽值，说明这是一个更优的选择，我们将其保留下来，更新 <code>k</code> 并将 <code>items[i]</code> 移动到 <code>k</code> 的位置：<code>k += 1; items[k] = items[i]</code>。</li><li>这样，我们就原地生成了一个长度为 <code>k+1</code> 的有效物品列表，其中价格和美丽值都是单调递增的。</li></ul></li><li><p><strong>查询与返回</strong>：</p><ul><li>对每个查询 <code>q</code>，在这个长度为 <code>k+1</code> 的有效列表上执行二分查找。其余逻辑与解法一完全相同。</li></ul></li></ol><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumBeauty</span>(<span class="params">self, items: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], queries: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">      <span class="comment"># 步骤 1: 按价格排序</span></span><br><span class="line">      items.sort(key=<span class="keyword">lambda</span> item:item[<span class="number">0</span>])</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 步骤 2: 预处理，更新每个物品为其价格及以下的最大美丽值</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(items)):</span><br><span class="line">        items[i][<span class="number">1</span>] = <span class="built_in">max</span>(items[i][<span class="number">1</span>], items[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">      </span><br><span class="line">      ans = []</span><br><span class="line">      <span class="comment"># 步骤 3 &amp; 4: 对每个查询进行二分查找</span></span><br><span class="line">      <span class="keyword">for</span> q <span class="keyword">in</span> queries:</span><br><span class="line">        <span class="comment"># 找到第一个价格 &gt; q 的物品的索引 j</span></span><br><span class="line">        j = bisect.bisect_right(items, q, key=<span class="keyword">lambda</span> item:item[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 如果 j &gt; 0, 那么 items[j-1] 就是价格 &lt;= q 的物品中美丽值最大的</span></span><br><span class="line">        <span class="comment"># 这个美丽值已经是我们预处理好的前缀最大值</span></span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">          ans.append(items[j-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          <span class="comment"># 没有物品价格 &lt;= q</span></span><br><span class="line">          ans.append(<span class="number">0</span>)</span><br><span class="line">          </span><br><span class="line">      <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumBeauty</span>(<span class="params">self, items: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], queries: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 步骤 1: 按价格排序</span></span><br><span class="line">        items.sort(key=<span class="keyword">lambda</span> t: t[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2: 预处理，原地压缩数组，只保留美丽值递增的项</span></span><br><span class="line">        k = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(items)):</span><br><span class="line">            <span class="keyword">if</span> items[i][<span class="number">1</span>] &gt; items[k][<span class="number">1</span>]:</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">                items[k] = items[i]</span><br><span class="line">        </span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 步骤 3 &amp; 4: 在压缩后的数组部分进行二分查找</span></span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> queries:</span><br><span class="line">            <span class="comment"># 在 items[0...k] 范围内查找</span></span><br><span class="line">            j = bisect.bisect_right(items, q, hi=k+<span class="number">1</span>, key=<span class="keyword">lambda</span> t: t[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">              ans.append(items[j-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              ans.append(<span class="number">0</span>)</span><br><span class="line">              </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>令 <code>N</code> 为 <code>items</code> 数组的长度，<code>M</code> 为 <code>queries</code> 数组的长度。</p><ul><li><p><strong>时间复杂度</strong>: O((N+M)log N)</p><ul><li>对 <code>items</code> 数组进行排序所需时间为 O(N log N)。</li><li>预处理阶段（无论是更新美丽值还是压缩数组）都只需要一次线性遍历，时间复杂度为 O(N)。</li><li>处理 <code>M</code> 个查询，每个查询都进行一次二分查找，目标数组长度为 <code>N</code>（或压缩后的 <code>k+1</code>，最坏情况也是 <code>N</code>），所以二分查找的时间复杂度是 O(log N)。<code>M</code> 次查询总共是 O(M log N)。</li><li>因此，总的时间复杂度为 O(N log N + N + M log N)，简化后为 O(N log N + M log N)。</li></ul></li><li><p><strong>空间复杂度</strong>: O(1)</p><ul><li>两种解法都是在输入数组 <code>items</code> 上进行原地修改。</li><li>如果不考虑排序算法本身可能使用的栈空间（或少量临时空间），我们没有创建任何与输入规模 <code>N</code> 或 <code>M</code> 成正比的额外数据结构。</li><li>返回的答案数组 <code>ans</code> 所占用的空间通常不计入额外空间复杂度。</li><li>因此，忽略排序的栈开销，额外空间复杂度为 O(1)。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预处理 + 二分查找”模式的一个典型应用。当题目涉及到对一个静态数据集进行多次范围性（如“小于等于”）查询时，应首先考虑是否能通过排序来建立有序性。在此基础上，通过一次线性扫描进行预处理（如计算前缀和、前缀最大&#x2F;最小值等），可以将每次查询的复杂度从线性降低到对数级别。二分查找正是利用数据有序性来实现高效查询的利器。两种解法在核心思想和复杂度上没有本质区别，都出色地解决了问题。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 2070 题：&lt;a href=&quot;https://leetcode.cn/problems/most-beautiful-item-for-each-query/description/&quot;&gt;每一个查询的最大美丽值&lt;/a&gt;。&lt;br&gt;对于每个价格查询，如何高效找到符合条件物品中的最大美丽值？通过预处理和二分查找，我们可以将问题迎刃而解。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分查找" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="排序" scheme="http://github.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="第65场双周赛" scheme="http://github.com/tags/%E7%AC%AC65%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 3488 | BS解决“距离最小相等元素查询”</title>
    <link href="http://github.com/posts/leetcode-3488/"/>
    <id>http://github.com/posts/leetcode-3488/</id>
    <published>2025-10-20T07:20:00.000Z</published>
    <updated>2025-10-20T07:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 3488 题：<a href="https://leetcode.cn/problems/closest-equal-element-queries/">距离最小相等元素查询</a>。<br>本题巧妙地结合了哈希表预处理和二分查找，高效解决环形数组中的距离查询问题，是“预处理+查询”思想的经典体现。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个 <strong>环形</strong> 数组 <code>nums</code> 和一个查询数组 <code>queries</code>。对于 <code>queries</code> 中的每一个下标 <code>queries[i]</code>，我们需要在 <code>nums</code> 数组中找到另一个下标 <code>j</code>，满足 <code>nums[j]</code> 与 <code>nums[queries[i]]</code> 的值相等，并且 <code>j</code> 与 <code>queries[i]</code> 之间的距离是所有满足条件的下标中最小的。</p><p>这里的 <strong>距离</strong> 需要特别注意，因为数组是环形的。两个下标 <code>i</code> 和 <code>j</code> 在一个长度为 <code>n</code> 的环形数组中的距离是 <code>min(|i - j|, n - |i - j|)</code>。如果找不到任何其他具有相同值的下标，那么该查询的结果就是 -1。</p><p>我们最后需要返回一个答案数组 <code>answer</code>，其中 <code>answer[i]</code> 对应第 <code>i</code> 个查询的结果。</p><p>举个例子，<code>nums = [1,3,1,4,1,3,2]</code>, <code>queries = [0,3,5]</code>, 数组长度 <code>n=7</code>：</p><ul><li>对于查询 <code>queries[0] = 0</code>：<ul><li><code>nums[0]</code> 的值是 1。 <code>nums</code> 中其他值为 1 的下标有 2 和 4。</li><li>到下标 2 的距离是 <code>min(|0-2|, 7-|0-2|) = min(2, 5) = 2</code>。</li><li>到下标 4 的距离是 <code>min(|0-4|, 7-|0-4|) = min(4, 3) = 3</code>。</li><li>最小距离是 2。</li></ul></li><li>对于查询 <code>queries[1] = 3</code>：<ul><li><code>nums[3]</code> 的值是 4。 <code>nums</code> 中没有其他值为 4 的元素。</li><li>结果为 -1。</li></ul></li><li>对于查询 <code>queries[2] = 5</code>：<ul><li><code>nums[5]</code> 的值是 3。<code>nums</code> 中另一个值为 3 的下标是 1。</li><li>距离是 <code>min(|5-1|, 7-|5-1|) = min(4, 3) = 3</code>。</li></ul></li><li>因此，最终答案是 <code>[2, -1, 3]</code>。</li></ul><h3 id="核心思路：预处理-二分查找"><a href="#核心思路：预处理-二分查找" class="headerlink" title="核心思路：预处理 + 二分查找"></a>核心思路：预处理 + 二分查找</h3><p>一个直接的想法是，对每个查询 <code>q_idx</code>，我们都遍历整个 <code>nums</code> 数组，找出所有值与 <code>nums[q_idx]</code> 相等的下标，然后逐一计算环形距离并取最小值。如果 <code>queries</code> 的长度是 Q，<code>nums</code> 的长度是 N，这种暴力解法的时间复杂度是 O(Q * N)，在 N 和 Q 都达到 10^5 的情况下，将会超时。</p><p>为了优化查询，我们可以对 <code>nums</code> 数组进行 <strong>预处理</strong>。</p><p>整个优化的思路分为两步：</p><ol><li><p><strong>预处理与分组</strong>：我们可以使用一个哈希表（在 Python 中是字典），将 <code>nums</code> 中相同值的元素的 <strong>下标</strong> 聚合在一起。哈希表的键（key）是 <code>nums</code> 中的值，值（value）是一个包含该值所有出现位置下标的列表。因为我们是按顺序遍历 <code>nums</code> 来构建这个哈希表的，所以每个下标列表天然就是 <strong>有序的</strong>。</p></li><li><p><strong>高效查询</strong>：完成预处理后，对于每个查询的下标 <code>q_idx</code>，我们先找到它的值 <code>val = nums[q_idx]</code>。然后，我们从哈希表中取出 <code>val</code> 对应的有序下标列表 <code>indices</code>。问题就转化成了：<strong>在一个排好序的数组 <code>indices</code> 中，找到离 <code>q_idx</code> 最近的两个邻居</strong>。<br>这正是二分查找的用武之地。我们可以通过二分查找，在 <code>indices</code> 列表中快速定位到 <code>q_idx</code> 自己的位置。它的前一个元素和后一个元素（需要考虑环绕情况）就是距离最近的候选者。</p></li></ol><p>通过这种方式，每次查询我们不再需要遍历整个 <code>nums</code> 数组，而只需要在对应的小得多的下标列表上进行一次二分查找，时间复杂度从 O(N) 降到了 O(log K)（K 是某个值出现的次数，K ≤ N），显著提高了算法的整体效率。</p><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol><li><p><strong>预处理 <code>nums</code> 数组</strong></p><ul><li>创建一个哈希表 <code>value_to_indices</code>，用于存储值到其下标列表的映射。</li><li>遍历 <code>nums</code> 数组，对于每个元素 <code>nums[i]</code>，将其下标 <code>i</code> 添加到 <code>value_to_indices[nums[i]]</code> 对应的列表中。</li></ul></li><li><p><strong>处理 <code>queries</code> 数组</strong></p><ul><li>创建一个空的答案数组 <code>ans</code>。</li><li>获取 <code>nums</code> 的长度 <code>n</code>，这在计算环形距离时会用到。</li><li>遍历 <code>queries</code> 中的每一个 <code>q_idx</code>：<ul><li>获取其值 <code>val = nums[q_idx]</code> 和对应的下标列表 <code>indices = value_to_indices[val]</code>。</li><li>如果 <code>indices</code> 的长度小于等于 1，说明没有其他相等的元素，将 -1 添加到 <code>ans</code> 中。</li><li>否则，使用二分查找（在 Python 中是 <code>bisect.bisect_left</code>）在 <code>indices</code> 中找到 <code>q_idx</code> 的位置 <code>pos</code>。</li><li><code>q_idx</code> 在 <code>indices</code> 中的逻辑前驱下标是 <code>prev_idx = indices[(pos - 1 + len(indices)) % len(indices)]</code>。</li><li><code>q_idx</code> 在 <code>indices</code> 中的逻辑后继下标是 <code>next_idx = indices[(pos + 1) % len(indices)]</code>。这里的取模运算优雅地处理了列表首尾的环绕情况。</li><li>分别计算 <code>q_idx</code> 到 <code>prev_idx</code> 和 <code>next_idx</code> 的环形距离。<ul><li><code>dist_prev = min(abs(q_idx - prev_idx), n - abs(q_idx - prev_idx))</code></li><li><code>dist_next = min(abs(q_idx - next_idx), n - abs(q_idx - next_idx))</code></li></ul></li><li>将 <code>min(dist_prev, dist_next)</code> 添加到 <code>ans</code> 数组中。</li></ul></li></ul></li><li><p><strong>返回结果</strong></p><ul><li>遍历结束后，返回 <code>ans</code> 数组。</li></ul></li></ol><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveQueries</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], queries: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1: 预处理 nums 数组</span></span><br><span class="line">        <span class="comment"># 使用哈希表存储每个值及其出现的所有下标</span></span><br><span class="line">        value_to_indices = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            value_to_indices[num].append(i)</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 步骤 2: 处理 queries 数组</span></span><br><span class="line">        <span class="keyword">for</span> q_idx <span class="keyword">in</span> queries:</span><br><span class="line">            val = nums[q_idx]</span><br><span class="line">            indices = value_to_indices[val]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果该值只出现一次，没有其他相等元素</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(indices) &lt;= <span class="number">1</span>:</span><br><span class="line">                ans.append(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 使用二分查找在下标列表中定位当前查询的下标</span></span><br><span class="line">            <span class="comment"># bisect_left 会找到 q_idx 在列表中的位置</span></span><br><span class="line">            pos = bisect.bisect_left(indices, q_idx)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 找到逻辑上的前一个和后一个下标</span></span><br><span class="line">            <span class="comment"># (pos - 1 + len(indices)) % len(indices) 是一种处理负数取模的通用技巧</span></span><br><span class="line">            prev_idx = indices[(pos - <span class="number">1</span> + <span class="built_in">len</span>(indices)) % <span class="built_in">len</span>(indices)]</span><br><span class="line">            <span class="comment"># (pos + 1) % len(indices) 用于处理列表末尾的环绕</span></span><br><span class="line">            next_idx = indices[(pos + <span class="number">1</span>) % <span class="built_in">len</span>(indices)]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算到前一个和后一个元素的环形距离</span></span><br><span class="line">            dist_prev = <span class="built_in">min</span>(<span class="built_in">abs</span>(q_idx - prev_idx), n - <span class="built_in">abs</span>(q_idx - prev_idx))</span><br><span class="line">            dist_next = <span class="built_in">min</span>(<span class="built_in">abs</span>(q_idx - next_idx), n - <span class="built_in">abs</span>(q_idx - next_idx))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 取两者中的较小值</span></span><br><span class="line">            ans.append(<span class="built_in">min</span>(dist_prev, dist_next))</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 3: 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(N + Q * log N)。<ul><li><code>N</code> 是 <code>nums</code> 的长度, <code>Q</code> 是 <code>queries</code> 的长度。</li><li>构建哈希表 <code>value_to_indices</code> 需要 O(N) 的时间。</li><li>对于每个查询，哈希表查找的平均时间是 O(1)，二分查找的时间是 O(log K)，其中 K 是相同元素的数量（K ≤ N）。因此，处理所有查询的总时间是 O(Q * log N)。</li></ul></li><li><strong>空间复杂度</strong>: O(N)。<ul><li>在最坏的情况下（<code>nums</code> 中所有元素都不同），哈希表 <code>value_to_indices</code> 需要存储 N 个键和 N 个单元素列表，总空间消耗为 O(N)。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预处理 + 高效查询”设计模式的一个绝佳范例。当面对需要对一个静态数据集进行多次查询的场景时，我们应首先考虑是否可以通过一次性的预处理（如排序、分组、构建特定数据结构等）来优化后续的查询操作。哈希表用于快速分组，而二分查找则利用了数据的有序性，两者的结合为解决这类问题提供了强大而高效的工具。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 3488 题：&lt;a href=&quot;https://leetcode.cn/problems/closest-equal-element-queries/&quot;&gt;距离最小相等元素查询&lt;/a&gt;。&lt;br&gt;本题巧妙地结合了哈希表预处理和二分查找，高效解决环形数组中的距离查询问题，是“预处理+查询”思想的经典体现。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分查找" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="第441场周赛" scheme="http://github.com/tags/%E7%AC%AC441%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1170 | 二分查找解决“比较字符串最小字母出现频次”</title>
    <link href="http://github.com/posts/leetcode-1170/"/>
    <id>http://github.com/posts/leetcode-1170/</id>
    <published>2025-10-19T03:20:00.000Z</published>
    <updated>2025-10-19T03:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1170 题：<a href="https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/">比较字符串最小字母出现频次</a>。<br>通过对词汇表进行预处理和排序，我们可以利用二分查找将查询效率从线性级别优化到对数级别。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目首先定义了一个函数 <code>f(s)</code>，它的功能是计算一个非空字符串 <code>s</code> 中，按字典序最小的那个字母出现的次数。例如，对于 <code>s = &quot;dcce&quot;</code>，最小的字母是 ‘c’，它出现了 2 次，所以 <code>f(&quot;dcce&quot;) = 2</code>。</p><p>接着，题目给了我们两个字符串数组：一个查询数组 <code>queries</code> 和一个词汇表数组 <code>words</code>。我们的任务是，对于 <code>queries</code> 中的每一个查询字符串 <code>queries[i]</code>，都要计算出在 <code>words</code> 数组中有多少个单词 <code>W</code> 满足 <code>f(queries[i]) &lt; f(W)</code>。最后，返回一个整数数组 <code>answer</code>，其中 <code>answer[i]</code> 就是第 <code>i</code> 次查询的结果。</p><p>举个例子，<code>queries = [&quot;bbb&quot;,&quot;cc&quot;]</code>, <code>words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]</code>：</p><ul><li>对于第一个查询 “bbb”：<ul><li>最小字母是 ‘b’，出现 3 次，所以 <code>f(&quot;bbb&quot;) = 3</code>。</li><li>我们需要在 <code>words</code> 中找到 <code>f(W) &gt; 3</code> 的单词。</li><li><code>f(&quot;a&quot;)=1</code>, <code>f(&quot;aa&quot;)=2</code>, <code>f(&quot;aaa&quot;)=3</code>, <code>f(&quot;aaaa&quot;)=4</code>。只有一个 “aaaa” 满足条件。所以结果是 1。</li></ul></li><li>对于第二个查询 “cc”：<ul><li>最小字母是 ‘c’，出现 2 次，所以 <code>f(&quot;cc&quot;) = 2</code>。</li><li>我们需要在 <code>words</code> 中找到 <code>f(W) &gt; 2</code> 的单词。</li><li>“aaa” 和 “aaaa” 满足条件。所以结果是 2。</li></ul></li><li>因此，最终答案是 <code>[1, 2]</code>。</li></ul><h3 id="核心思路：预计算-二分查找"><a href="#核心思路：预计算-二分查找" class="headerlink" title="核心思路：预计算 + 二分查找"></a>核心思路：预计算 + 二分查找</h3><p>一个直观的想法是，对每个 <code>query</code>，我们都遍历一遍 <code>words</code> 数组，计算每个 <code>word</code> 的 <code>f</code> 值并进行比较。如果 <code>queries</code> 的长度是 N，<code>words</code> 的长度是 M，那么这种暴力解法的时间复杂度大约是 O(N * M)，在 N 和 M 都达到 2000 的情况下，可能会超时。</p><p>注意到，<code>words</code> 数组是固定不变的。我们可以对其进行<strong>预处理</strong>，来加速后续的查询过程。</p><p>整个优化的思路分为两步：</p><ol><li><p><strong>预计算与排序</strong>：我们先遍历一次 <code>words</code> 数组，计算出其中每个单词 <code>W</code> 的 <code>f(W)</code> 值，并将这些频率值存入一个新数组 <code>word_freqs</code> 中。为了能够快速查找，我们对 <code>word_freqs</code> 进行升序排序。</p></li><li><p><strong>高效查询</strong>：完成预处理后，对于每个 <code>query</code>，我们先计算出它的频率 <code>q_freq</code>。然后，问题就转化成了：<strong>在一个排好序的数组 <code>word_freqs</code> 中，有多少个元素大于 <code>q_freq</code>？</strong> 这是一个典型的二分查找应用场景。我们可以通过二分查找，快速定位到第一个大于 <code>q_freq</code> 的元素的位置。一旦找到了这个位置，那么它后面的所有元素都满足条件，我们就能立刻得到答案。</p></li></ol><p>通过这种方式，每次查询的时间复杂度从 O(M) 降到了 O(log M)，从而显著提高了算法的整体效率。</p><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol><li><p><strong>定义辅助函数 <code>f(s)</code></strong></p><ul><li>这个函数接收一个字符串 <code>s</code>。</li><li>找到 <code>s</code> 中的最小字符 <code>min_char</code>。</li><li>返回 <code>min_char</code> 在 <code>s</code> 中出现的次数。</li></ul></li><li><p><strong>预处理 <code>words</code> 数组</strong></p><ul><li>创建一个整数数组 <code>word_freqs</code>。</li><li>遍历 <code>words</code> 中的每一个 <code>word</code>，调用 <code>f(word)</code> 计算其频率，并将结果添加到 <code>word_freqs</code> 中。</li><li>对 <code>word_freqs</code> 数组进行升序排序。</li></ul></li><li><p><strong>处理 <code>queries</code> 数组</strong></p><ul><li>创建一个空的答案数组 <code>ans</code>。</li><li>遍历 <code>queries</code> 中的每一个 <code>query</code>：<ul><li>计算其频率 <code>q_freq = f(query)</code>。</li><li>在排好序的 <code>word_freqs</code> 数组上执行二分查找，目标是找到第一个<strong>严格大于</strong> <code>q_freq</code> 的元素的索引。</li><li>在 Python 中，<code>bisect.bisect_right(array, value)</code> 函数可以完美地实现这个功能。它会返回 <code>value</code> 在 <code>array</code> 中的插入点索引，这个索引恰好是数组中大于 <code>value</code> 的第一个元素的位置。</li><li>假设 <code>word_freqs</code> 的长度为 <code>n</code>，找到的索引为 <code>index</code>，那么 <code>word_freqs</code> 中大于 <code>q_freq</code> 的元素个数就是 <code>n - index</code>。</li><li>将这个计数结果添加到 <code>ans</code> 数组中。</li></ul></li></ul></li><li><p><strong>返回结果</strong></p><ul><li>遍历结束后，返回 <code>ans</code> 数组。</li></ul></li></ol><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSmallerByFrequency</span>(<span class="params">self, queries: <span class="type">List</span>[<span class="built_in">str</span>], words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1: 定义辅助函数 f(s)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            min_char = <span class="built_in">min</span>(s)</span><br><span class="line">            <span class="keyword">return</span> s.count(min_char)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2: 预处理 words 数组</span></span><br><span class="line">        <span class="comment"># 计算 words 中每个单词的频率并排序</span></span><br><span class="line">        word_freqs = <span class="built_in">sorted</span>([f(word) <span class="keyword">for</span> word <span class="keyword">in</span> words])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 处理 queries 数组</span></span><br><span class="line">        ans = []</span><br><span class="line">        n = <span class="built_in">len</span>(word_freqs)</span><br><span class="line">        <span class="keyword">for</span> query <span class="keyword">in</span> queries:</span><br><span class="line">            q_freq = f(query)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 使用二分查找找到第一个 &gt; q_freq 的元素的位置</span></span><br><span class="line">            <span class="comment"># n - (该位置的索引) 即为满足条件的单词数量</span></span><br><span class="line">            index = bisect.bisect_right(word_freqs, q_freq)</span><br><span class="line">            count = n - index</span><br><span class="line">            ans.append(count)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 4: 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(M * Lw + M log M + N * (Lq + log M))。<ul><li><code>N</code> 是 <code>queries</code> 的长度, <code>M</code> 是 <code>words</code> 的长度。</li><li><code>Lq</code> 和 <code>Lw</code> 分别是 <code>queries</code> 和 <code>words</code> 中字符串的最大长度。</li><li>计算 <code>word_freqs</code> 需要 O(M * Lw)。</li><li>排序 <code>word_freqs</code> 需要 O(M log M)。</li><li>对于每个查询，计算 <code>f(query)</code> 需要 O(Lq)，二分查找需要 O(log M)。总共是 O(N * (Lq + log M))。</li></ul></li><li><strong>空间复杂度</strong>: O(M)。我们需要一个额外的数组 <code>word_freqs</code> 来存储 <code>words</code> 数组中每个单词的频率。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预处理 + 二分查找”模式的一个经典应用。当题目要求对一个固定的数据集进行多次查询时，我们应该优先考虑是否能通过对数据集进行一次性的预处理（例如计算、排序等），来为后续的查询操作提供便利，从而将整体复杂度降低一个量级。二分查找正是利用了数据的有序性来实现高效查询的强大工具。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1170 题：&lt;a href=&quot;https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/&quot;&gt;比较字符串最小字母出现频次&lt;/a&gt;。&lt;br&gt;通过对词汇表进行预处理和排序，我们可以利用二分查找将查询效率从线性级别优化到对数级别。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分查找" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="字符串" scheme="http://github.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="排序" scheme="http://github.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="第151场周赛" scheme="http://github.com/tags/%E7%AC%AC151%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 34 | 二分寻找元素的起始与结束位置</title>
    <link href="http://github.com/posts/leetcode-34/"/>
    <id>http://github.com/posts/leetcode-34/</id>
    <published>2025-10-18T04:05:00.000Z</published>
    <updated>2025-10-18T04:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 34 题：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a>。<br>本题是二分查找算法的经典应用。标准的二分查找只能告诉我们元素是否存在，而这道题要求我们精确定位目标值连续出现的“左边界”和“右边界”。这需要我们对二分查找的细节进行巧妙的改造。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给定一个按非递减顺序（即升序）排列的整数数组 <code>nums</code> 和一个目标值 <code>target</code>。我们需要找到 <code>target</code> 在数组中出现的起始位置和结束位置。</p><p>核心要求：</p><ol><li>如果 <code>target</code> 存在，返回一个包含起始和结束索引的数组 <code>[start, end]</code>。</li><li>如果 <code>target</code> 不存在，返回 <code>[-1, -1]</code>。</li><li>算法的时间复杂度必须是 <strong>O(log n)</strong>，这强烈暗示了我们必须使用二分查找。</li></ol><p>例如：</p><ul><li>对于 <code>nums = [5,7,7,8,8,10]</code>, <code>target = 8</code>，<code>8</code> 第一次出现在索引 3，最后一次出现在索引 4，所以返回 <code>[3,4]</code>。</li><li>对于 <code>nums = [5,7,7,8,8,10]</code>, <code>target = 6</code>，<code>6</code> 不存在于数组中，所以返回 <code>[-1,-1]</code>。</li></ul><h3 id="核心思路：寻找边界"><a href="#核心思路：寻找边界" class="headerlink" title="核心思路：寻找边界"></a>核心思路：寻找边界</h3><p>直接用一次二分查找找到 <code>target</code> 是不够的，因为我们无法确定找到的是第一个、最后一个还是中间的某一个。</p><p>一个直观的想法是进行两次二分查找：</p><ol><li>一次查找 <code>target</code> 的<strong>第一个</strong>出现位置（左边界）。</li><li>另一次查找 <code>target</code> 的<strong>最后一个</strong>出现位置（右边界）。</li></ol><p>一个更优雅且统一的思路是，将问题转化为寻找“<strong>下界（Lower Bound）</strong>”。所谓“下界”，指的是数组中第一个大于或等于目标值的元素的位置。</p><ul><li><code>target</code> 的<strong>起始位置</strong>，恰好就是 <code>target</code> 的下界。</li><li><code>target</code> 的<strong>结束位置</strong>，可以通过寻找 <code>target + 1</code> 的下界来间接得到。<code>target + 1</code> 的下界索引减去 1，就是 <code>target</code> 的最后一个出现位置。</li></ul><p>例如，在 <code>[5,7,7,8,8,10]</code> 中：</p><ul><li><code>target = 8</code> 的下界是索引 3。</li><li><code>target + 1 = 9</code> 的下界是索引 5（第一个 <code>&gt;=9</code> 的元素是 <code>10</code>，其索引为 5）。</li><li>因此，<code>8</code> 的结束位置就是 <code>5 - 1 = 4</code>。</li></ul><p>这样，我们就把问题统一为了实现一个可靠的“下界”二分查找函数。二分查找的实现有多种区间定义方式，常见的有“左闭右闭”、“左闭右开”和“全开”区间，它们在循环条件和边界更新上略有不同，但都能解决问题。下面我们分别探讨这三种写法的实现。</p><h3 id="算法详解与代码实现"><a href="#算法详解与代码实现" class="headerlink" title="算法详解与代码实现"></a>算法详解与代码实现</h3><h4 id="解法一：闭区间写法-l-r"><a href="#解法一：闭区间写法-l-r" class="headerlink" title="解法一：闭区间写法 [l, r]"></a>解法一：闭区间写法 <code>[l, r]</code></h4><p>这是最常见和直观的写法。搜索区间 <code>[l, r]</code> 的定义是两端都包含，因此循环条件是 <code>l &lt;= r</code>。</p><ul><li><strong>初始化</strong>：<code>l = 0</code>, <code>r = len(nums) - 1</code>。</li><li><strong>循环条件</strong>：<code>while l &lt;= r</code>，当 <code>l &gt; r</code> 时，区间为空，循环结束。</li><li><strong>逻辑</strong>：<ul><li><code>nums[mid] &gt;= target</code>：<code>mid</code> 可能是我们寻找的下界，或者下界在 <code>mid</code> 的左侧。因此，我们不能排除 <code>mid</code>，需要向左收缩搜索范围，令 <code>r = mid - 1</code>。</li><li><code>nums[mid] &lt; target</code>：<code>mid</code> 一定不是下界，下界必然在 <code>mid</code> 的右侧。令 <code>l = mid + 1</code>。</li></ul></li><li><strong>返回值</strong>：循环结束后，<code>l</code> 指向的就是第一个大于或等于 <code>target</code> 的位置。</li></ul><p><strong>Python 代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 闭区间 [l, r] 写法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lb</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l  <span class="comment"># 最终 l 就是下界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 寻找 target 的下界作为起始位置</span></span><br><span class="line">        s = <span class="variable language_">self</span>.lb(nums, target)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果起始位置越界，或者该位置的值不为 target，说明 target 不存在</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[s] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 寻找 target+1 的下界，其前一个位置就是 target 的结束位置</span></span><br><span class="line">        e = <span class="variable language_">self</span>.lb(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [s, e]</span><br></pre></td></tr></table></figure><h4 id="解法二：左闭右开区间写法-l-r"><a href="#解法二：左闭右开区间写法-l-r" class="headerlink" title="解法二：左闭右开区间写法 [l, r)"></a>解法二：左闭右开区间写法 <code>[l, r)</code></h4><p>这种写法的搜索区间 <code>[l, r)</code> 左端包含，右端不包含。这在处理边界时非常方便，也是很多语言标准库（如 C++ STL）中 <code>lower_bound</code> 的实现方式。</p><ul><li><strong>初始化</strong>：<code>l = 0</code>, <code>r = len(nums)</code>。注意 <code>r</code> 的初始值。</li><li><strong>循环条件</strong>：<code>while l &lt; r</code>，当 <code>l == r</code> 时，区间 <code>[l, l)</code> 为空，循环结束。</li><li><strong>逻辑</strong>：<ul><li><code>nums[mid] &gt;= target</code>：<code>mid</code> 可能是下界，或者下界在 <code>mid</code> 左侧。由于右边界 <code>r</code> 是开区间，我们可以安全地将 <code>r</code> 设置为 <code>mid</code>，即新的搜索区间是 <code>[l, mid)</code>。</li><li><code>nums[mid] &lt; target</code>：<code>mid</code> 以及其左侧所有元素都小于 <code>target</code>，下界一定在 <code>mid</code> 右侧。令 <code>l = mid + 1</code>。</li></ul></li><li><strong>返回值</strong>：循环结束后，<code>l</code> 和 <code>r</code> 相遇，指向的就是下界。</li></ul><p><strong>Python 代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 左闭右开区间 [l, r) 写法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lb</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l <span class="comment"># 最终 l (或 r) 就是下界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        s = <span class="variable language_">self</span>.lb(nums, target)</span><br><span class="line">        <span class="keyword">if</span> s == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[s] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        e = <span class="variable language_">self</span>.lb(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [s, e]</span><br></pre></td></tr></table></figure><h4 id="解法三：开区间写法-l-r"><a href="#解法三：开区间写法-l-r" class="headerlink" title="解法三：开区间写法 (l, r)"></a>解法三：开区间写法 <code>(l, r)</code></h4><p>这种写法将 <code>l</code> 和 <code>r</code> 视为“哨兵”，搜索区间是它们之间的 <code>(l, r)</code>。</p><ul><li><strong>初始化</strong>：<code>l = -1</code>, <code>r = len(nums)</code>。</li><li><strong>循环条件</strong>：<code>while l + 1 &lt; r</code>，确保 <code>l</code> 和 <code>r</code> 之间至少有一个元素，当它们相邻时循环结束。</li><li><strong>逻辑</strong>：<ul><li><code>nums[mid] &gt;= target</code>：<code>mid</code> 可能是下界，或者下界在 <code>mid</code> 左侧。我们将右哨兵移动到 <code>mid</code>，即 <code>r = mid</code>。</li><li><code>nums[mid] &lt; target</code>：<code>mid</code> 一定不是下界，下界在 <code>mid</code> 右侧。我们将左哨兵移动到 <code>mid</code>，即 <code>l = mid</code>。</li></ul></li><li><strong>返回值</strong>：循环结束后，<code>l</code> 和 <code>r</code> 相邻，而 <code>r</code> 正是我们寻找的下界。</li></ul><p><strong>Python 代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 开区间 (l, r) 写法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lb</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = -<span class="number">1</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid</span><br><span class="line">        <span class="keyword">return</span> r <span class="comment"># 最终 r 就是下界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        s = <span class="variable language_">self</span>.lb(nums, target)</span><br><span class="line">        <span class="keyword">if</span> s == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[s] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        e = <span class="variable language_">self</span>.lb(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [s, e]</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: <strong>O(log N)</strong>。我们调用了两次二分查找函数，每次耗时 O(log N)，因此总时间复杂度为 O(2 * log N)，即 O(log N)。</li><li><strong>空间复杂度</strong>: <strong>O(1)</strong>。我们只使用了常数级别的额外空间。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题通过将“寻找起始和结束位置”巧妙地转化为两次“寻找下界”的操作，统一并简化了问题。同时，我们展示了解决同一问题的三种不同二分查找区间写法：闭区间 <code>[l, r]</code>，左闭右开区间 <code>[l, r)</code>，以及开区间 <code>(l, r)</code>。</p><ul><li><strong>闭区间法</strong>：最传统，容易理解，但边界更新时 <code>+1</code>&#x2F;<code>-1</code> 需要格外小心。</li><li><strong>左闭右开法</strong>：在处理循环不变量和边界时非常优雅，是现代编程实践中较为推崇的写法。</li><li><strong>开区间法</strong>：将 <code>l</code> 和 <code>r</code> 作为哨兵，逻辑也十分清晰。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 34 题：&lt;a href=&quot;https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/&quot;&gt;在排序数组中查找元素的第一个和最后一个位置&lt;/a&gt;。&lt;br&gt;本题是二分查找算法的经典应用。标准的二分查找只能告诉我们元素是否存在，而这道题要求我们精确定位目标值连续出现的“左边界”和“右边界”。这需要我们对二分查找的细节进行巧妙的改造。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分查找" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1156 | 滑动窗口求解“单字符重复子串的最大长度”</title>
    <link href="http://github.com/posts/leetcode-1156/"/>
    <id>http://github.com/posts/leetcode-1156/</id>
    <published>2025-10-17T02:30:00.000Z</published>
    <updated>2025-10-17T02:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1156 题：<a href="https://leetcode.cn/problems/swap-for-longest-repeated-character-substring/">单字符重复子串的最大长度</a>。<br>这道题的有趣之处在于“一次交换”这个操作。它给了我们一次修正错误的机会，让原本不连续的相同字符子串，有了连接起来的可能。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个字符串 <code>text</code>，我们有一次机会可以交换字符串中的任意两个字符（也可以选择不交换）。我们的目标是，在这次操作后，找到一个最长的、只包含同一种字符的子串，并返回其长度。</p><p>我们来分析一下“一次交换”能带来什么：</p><ol><li><strong>修复一个“缺口”</strong>：在一个几乎全是 <code>a</code> 的子串中，如果有一个字符不是 <code>a</code>，例如 <code>&quot;aaabaaa&quot;</code>，我们可以从字符串的其他地方找一个 <code>a</code> 换掉那个 <code>b</code>。</li><li><strong>连接两个“断崖”</strong>：如果一个子串像 <code>&quot;aaaa&quot;</code> 这样已经很完美，我们可以尝试从别处找一个 <code>a</code>，换到这个子串的旁边，让它变得更长，例如变成 <code>&quot;aaaaa&quot;</code>。</li></ol><p>举个例子，对于 <code>text = &quot;aaabaaa&quot;</code>：</p><ul><li>我们关注字符 <code>a</code>。字符串里总共有 6 个 <code>a</code>。</li><li>有一个子串 <code>&quot;aaabaaa&quot;</code>，它的长度是 7，其中包含一个 <code>b</code>。</li><li>我们可以用一次交换机会把 <code>b</code> 换成 <code>a</code>。但是，我们需要从字符串的其他位置找到一个 <code>a</code> 来交换。在这个例子里，除了这 6 个 <code>a</code> 之外，没有多余的 <code>a</code> 可以换过来。</li><li>因此，即使我们换掉了 <code>b</code>，最多也只能形成一个长度为 6 的 <code>a</code> 串（因为总共就 6 个 <code>a</code>）。所以最大长度是 6。</li></ul><p>对于 <code>text = &quot;ababa&quot;</code>:</p><ul><li>我们关注字符 <code>a</code>。总共有 3 个 <code>a</code>。</li><li>子串 <code>&quot;ababa&quot;</code> 中，<code>a</code> 被 <code>b</code> 隔开。</li><li>我们可以把中间的 <code>b</code> 和末尾的 <code>a</code> 交换，字符串变为 <code>&quot;aaabb&quot;</code>。这样我们就得到了一个长度为 3 的 <code>a</code> 串 <code>&quot;aaa&quot;</code>。</li><li>因为总共只有 3 个 <code>a</code>，所以长度 3 就是 <code>a</code> 能达到的极限。</li></ul><h3 id="核心思路：枚举字符-滑动窗口"><a href="#核心思路：枚举字符-滑动窗口" class="headerlink" title="核心思路：枚举字符 + 滑动窗口"></a>核心思路：枚举字符 + 滑动窗口</h3><p>问题的关键是找到“最长的”单字符重复子串。一个直接的想法是，我们可以对每一种可能出现的字符（<code>a</code> 到 <code>z</code>）都计算一次它能形成的最长子串长度，然后取其中的最大值。</p><p>当我们聚焦于某一个特定字符 <code>ch</code> 时，问题就转化为：<strong>只考虑字符 <code>ch</code>，通过一次交换能得到的最长 <code>ch</code> 子串是多长？</strong></p><p>这个问题非常适合用<strong>滑动窗口</strong>来解决。我们可以用一个窗口 <code>[l, r]</code> 在字符串上滑动，这个窗口代表我们希望最终全是 <code>ch</code> 的目标子串。因为我们只有一次交换机会，所以这个窗口内最多只能容忍一个“杂质”（即不是 <code>ch</code> 的字符）。</p><p>于是，我们的策略是：</p><ol><li><strong>预处理</strong>：先用哈希表（<code>Counter</code>）统计出整个字符串中每个字符的总数。这个信息至关重要，因为它决定了我们能用来“填补”窗口的原材料上限。</li><li><strong>主循环</strong>：遍历从 <code>a</code> 到 <code>z</code> 的每一个字符 <code>ch</code>，将其作为目标字符。</li><li><strong>滑动窗口</strong>：<ul><li>维护一个窗口 <code>[l, r]</code> 和一个杂质计数器 <code>occ</code>。</li><li>当右指针 <code>r</code> 扩张时，如果 <code>text[r]</code> 不是 <code>ch</code>，就增加 <code>occ</code>。</li><li>如果 <code>occ</code> 超过 1，说明窗口内的杂质太多，一次交换已经无法修复，必须从左侧 <code>l</code> 收缩窗口，直到 <code>occ</code> 恢复到 1 或 0。</li></ul></li><li><strong>更新答案</strong>：在每一步窗口扩张后，我们都计算当前窗口能形成的最长 <code>ch</code> 子串长度，并更新全局最大值 <code>ans</code>。这里有两种情况：<ul><li><strong>情况一：窗口内没有杂质（<code>occ == 0</code>）</strong><ul><li>窗口内的子串已经是完美的 <code>ch</code> 串，如 <code>&quot;aaaa&quot;</code>。长度为 <code>w = r-l+1</code>。</li><li>我们能否让它更长？可以！如果字符串中还有其他的 <code>ch</code>（即 <code>ch</code> 的总数 <code>tc</code> &gt; <code>w</code>），我们就可以把其中一个 <code>ch</code> 换到窗口旁边，使其长度加一。</li><li>所以，这种情况下能达到的最大长度是 <code>w + 1</code>（前提是 <code>tc &gt; w</code>），否则就是 <code>w</code>。</li></ul></li><li><strong>情况二：窗口内有一个杂质（<code>occ == 1</code>）</strong><ul><li>窗口内的子串有一个缺口，如 <code>&quot;aaabaa&quot;</code>。长度为 <code>w</code>。</li><li>我们可以用一次交换把杂质换成 <code>ch</code>。但这需要我们有足够的 <code>ch</code> 来填充。</li><li>我们最多能形成多长的 <code>ch</code> 串，取决于我们拥有的 <code>ch</code> 的总数 <code>tc</code>。我们不可能创造出比 <code>tc</code> 更长的 <code>ch</code> 串。</li><li>所以，这种情况下能达到的最大长度是 <code>min(w, tc)</code>。</li></ul></li></ul></li></ol><p>对所有 26 个字母执行上述过程，记录下的最大值就是最终答案。</p><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol><li><p><strong>第一步：预计算字符总数</strong></p><ul><li>使用 <code>collections.Counter</code> 对 <code>text</code> 进行计数，得到每个字符的总出现次数 <code>cnt</code>。</li></ul></li><li><p><strong>第二步：遍历所有可能的字符</strong></p><ul><li>循环遍历从 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 的所有字符 <code>ch</code>。如果某个字符在 <code>text</code> 中不存在，直接跳过。</li></ul></li><li><p><strong>第三步：针对每个字符ch，使用滑动窗口计算最大长度</strong></p><ul><li>初始化左指针 <code>l = 0</code> 和杂质计数器 <code>occ = 0</code>。</li><li>用右指针 <code>r</code> 遍历字符串 <code>text</code> (从 <code>0</code> 到 <code>n-1</code>)。</li><li>在循环中，如果 <code>text[r]</code> 不是我们当前关注的字符 <code>ch</code>，则 <code>occ += 1</code>。</li><li>检查 <code>occ</code> 是否大于 1。如果是，则不断地收缩左边界：如果 <code>text[l]</code> 是一个杂质，则 <code>occ -= 1</code>，然后 <code>l += 1</code>。</li><li>计算当前窗口 <code>[l, r]</code> 的大小 <code>w = r - l + 1</code>。</li><li>根据杂质数量 <code>occ</code> 更新答案：<ul><li>如果 <code>occ == 0</code>，我们有一个纯 <code>ch</code> 窗口。如果 <code>ch</code> 的总数 <code>tc</code> 大于当前窗口大小 <code>w</code>，我们就可以从别处“借”一个 <code>ch</code> 来加长它。所以，候选长度为 <code>w + (1 if tc &gt; w else 0)</code>。</li><li>如果 <code>occ == 1</code>，我们有一个带杂质的窗口。我们可以用一个 <code>ch</code> 来替换这个杂质。我们最多能得到的长度受限于 <code>ch</code> 的总数 <code>tc</code>。所以，候选长度为 <code>min(w, tc)</code>。</li></ul></li><li>用计算出的候选长度更新全局最大值 <code>ans</code>。</li></ul></li><li><p><strong>第四步：返回结果</strong></p><ul><li>遍历完所有字符后，<code>ans</code> 中存储的就是最终答案。</li></ul></li></ol><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxRepOpt1</span>(<span class="params">self, text: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1: 预计算每个字符的总数</span></span><br><span class="line">        cnt = Counter(text)</span><br><span class="line">        n = <span class="built_in">len</span>(text)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2: 遍历 &#x27;a&#x27; 到 &#x27;z&#x27;，对每个字符ch进行分析</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>), <span class="built_in">ord</span>(<span class="string">&#x27;z&#x27;</span>) + <span class="number">1</span>):</span><br><span class="line">            ch = <span class="built_in">chr</span>(c)</span><br><span class="line">            tc = cnt[ch] <span class="comment"># 当前关注字符的总数</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果该字符不存在，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> tc == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 步骤 3: 滑动窗口</span></span><br><span class="line">            l = occ = <span class="number">0</span> <span class="comment"># l是左指针，occ是窗口内“杂质”的数量</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> text[r] != ch:</span><br><span class="line">                    occ += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 当杂质多于1个时，收缩左边界</span></span><br><span class="line">                <span class="keyword">while</span> occ &gt; <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> text[l] != ch:</span><br><span class="line">                        occ -= <span class="number">1</span></span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 步骤 4: 更新答案</span></span><br><span class="line">                w = r - l + <span class="number">1</span> <span class="comment"># 当前窗口大小</span></span><br><span class="line">                <span class="keyword">if</span> occ == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 情况一：窗口内没有杂质</span></span><br><span class="line">                    <span class="comment"># 如果字符串中还有多余的ch，可以换过来一个，长度+1</span></span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, w + (<span class="number">1</span> <span class="keyword">if</span> tc &gt; w <span class="keyword">else</span> <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># occ == 1</span></span><br><span class="line">                    <span class="comment"># 情况二：窗口内有一个杂质</span></span><br><span class="line">                    <span class="comment"># 用一个ch替换杂质，最大长度不能超过ch的总数</span></span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(w, tc))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(N)。虽然代码有两层循环，但外层循环是常数 26 次。对于内层的滑动窗口，每个字符作为目标时，<code>l</code> 和 <code>r</code> 指针都只会从头到尾遍历字符串一次。因此总的时间复杂度是 O(26 * N) &#x3D; O(N)。</li><li><strong>空间复杂度</strong>: O(Σ)。其中 Σ 是字符集的大小，这里是 26。我们用了一个 <code>Counter</code> 来存储字符频率，空间是常数级别的，所以是 O(1)。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想的一个巧妙应用。通过将问题分解为“为每个字符寻找最优解”，我们将一个复杂问题转化为了 26 个独立的、更简单的子问题。在解决子问题时，滑动窗口是处理连续子数组&#x2F;子串问题的利器。本题的难点在于，更新答案时需要细致地分情况讨论：窗口是“完美的”还是“有缺陷的”，并结合字符总数这一全局信息，来判断一次交换到底能带来多大的收益。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1156 题：&lt;a href=&quot;https://leetcode.cn/problems/swap-for-longest-repeated-character-substring/&quot;&gt;单字符重复子串的最大长度&lt;/a&gt;。&lt;br&gt;这道题的有趣之处在于“一次交换”这个操作。它给了我们一次修正错误的机会，让原本不连续的相同字符子串，有了连接起来的可能。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="滑动窗口与双指针" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="不定长滑动窗口" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    
    <category term="字符串" scheme="http://github.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="滑动窗口" scheme="http://github.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="第149场周赛" scheme="http://github.com/tags/%E7%AC%AC149%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2401 | 滑动窗口求解“最长优雅子数组”</title>
    <link href="http://github.com/posts/leetcode-2401/"/>
    <id>http://github.com/posts/leetcode-2401/</id>
    <published>2025-10-17T02:21:00.000Z</published>
    <updated>2025-10-17T02:21:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 2401 题：<a href="https://leetcode.cn/problems/longest-nice-subarray/description/">最长优雅子数组</a>。<br>该题要求寻找一个最长的子数组，其中任意两个元素的按位与（AND）都为 0。这是一个非常适合使用滑动窗口解决的问题，关键在于如何高效地维护窗口的“优雅”属性。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个正整数组成的数组 <code>nums</code>，需要我们找到一个<strong>最长</strong>的<strong>连续子数组</strong>，这个子数组被称为“优雅的”。</p><p>一个子数组是“优雅的”，当且仅当其中任意两个不同位置的数字，它们的按位与（AND）运算结果都等于 0。这意味着，在一个优雅子数组中，所有数字的二进制表示里，任意一个为 ‘1’ 的 bit 位，在其他所有数字的对应 bit 位上都必须是 ‘0’。</p><p>举个例子，对于 <code>nums = [1,3,8,48,10]</code>：</p><ul><li>我们来看子数组 <code>[3, 8, 48]</code>：<ul><li>3 的二进制是 <code>00011</code></li><li>8 的二进制是 <code>01000</code></li><li>48 的二进制是 <code>110000</code></li></ul></li><li>检查任意一对：<ul><li><code>3 &amp; 8</code> &#x3D; <code>00011 &amp; 01000</code> &#x3D; <code>0</code></li><li><code>3 &amp; 48</code> &#x3D; <code>00011 &amp; 110000</code> &#x3D; <code>0</code></li><li><code>8 &amp; 48</code> &#x3D; <code>01000 &amp; 110000</code> &#x3D; <code>0</code></li></ul></li><li>所有配对的按位与结果都为 0，所以 <code>[3, 8, 48]</code> 是一个优雅子数组，长度为 3。题目要求我们返回这个最长的长度。</li></ul><p>如果用暴力法枚举所有子数组，再对子数组里的每一对数字进行检查，时间复杂度会非常高，无法通过。我们需要一种更高效的方法。</p><h3 id="核心思路：滑动窗口与位运算"><a href="#核心思路：滑动窗口与位运算" class="headerlink" title="核心思路：滑动窗口与位运算"></a>核心思路：滑动窗口与位运算</h3><p>这道题的“连续子数组”和“最长”两个关键词强烈地指向了<strong>滑动窗口</strong>算法。我们可以维护一个窗口 <code>[l, r]</code>，确保这个窗口内的子数组始终是“优雅的”，然后不断尝试扩大这个窗口，并记录其最大长度。</p><p>问题的关键在于：当窗口右边界 <code>r</code> 纳入一个新元素 <code>nums[r]</code> 时，我们如何快速判断窗口 <code>[l, r]</code> 是否仍然优雅？</p><p>如果逐一检查 <code>nums[r]</code> 与窗口内 <code>nums[l]</code> 到 <code>nums[r-1]</code> 的每一个数，效率依然很低。这里有一个重要的转换：<strong>一个子数组是优雅的，等价于这个子数组中所有元素的按位或（OR）结果等于它们的按位异或（XOR）结果，也等价于所有元素的按位或（OR）结果等于它们的和</strong>。</p><p>一个更直接的判断方法是：如果我们将窗口内已有元素 <code>nums[l...r-1]</code> 的所有 bit 位 ‘1’ 合并成一个集合（通过按位或运算），那么新元素 <code>nums[r]</code> 要能被加入窗口，当且仅当 <code>nums[r]</code> 的所有 bit 位 ‘1’ 在这个集合中都没有出现过。</p><p>这可以用一个简单的位运算来检查：<br><code>(窗口内所有元素的 OR 值) &amp; (新元素 nums[r]) == 0</code></p><p>基于这个思想，我们的滑动窗口策略就变得清晰了：</p><ol><li>维护一个变量 <code>or_sum</code>，它存储了当前窗口 <code>[l, r]</code> 内所有数字的按位或（OR）结果。</li><li>当右指针 <code>r</code> 向右移动，我们考虑加入新元素 <code>x = nums[r]</code>。</li><li>我们检查 <code>or_sum &amp; x</code> 是否为 0。<ul><li>如果不为 0，说明 <code>x</code> 的某个 bit 位在 <code>or_sum</code> 中已经存在，产生了冲突。此时，我们需要从左边收缩窗口，即<code>l++</code>。在收缩时，需要将 <code>nums[l]</code> 的影响从 <code>or_sum</code> 中移除。因为优雅子数组中所有数的 bit 位都不同，OR 和 XOR 的效果是一样的，所以我们可以通过 <code>or_sum ^= nums[l]</code> 来移除 <code>nums[l]</code> 的 bit 位。我们重复此过程，直到 <code>or_sum &amp; x</code> 等于 0 为止。</li><li>如果为 0（或者经过收缩后变为 0），说明 <code>x</code> 可以安全地加入窗口。我们更新 <code>or_sum</code>，<code>or_sum |= x</code>，将 <code>x</code> 的 bit 位合并进来。</li></ul></li><li>每一次成功扩大窗口后，我们用当前的窗口长度 <code>r - l + 1</code> 来更新最终答案。</li></ol><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol><li><p><strong>初始化</strong>:</p><ul><li><code>ans = 0</code>: 存储最长优雅子数组的长度。</li><li><code>l = 0</code>: 滑动窗口的左边界。</li><li><code>or_sum = 0</code> (在代码中用 <code>_</code> 表示): 存储当前窗口内所有元素的按位或结果。</li></ul></li><li><p><strong>遍历与窗口移动</strong>:</p><ul><li>使用 <code>for</code> 循环，让右边界 <code>r</code> 从 0 遍历到数组末尾，<code>x</code> 为当前元素 <code>nums[r]</code>。</li><li><strong>检查冲突与收缩窗口</strong>：用一个 <code>while</code> 循环检查 <code>(or_sum &amp; x) != 0</code>。只要存在冲突：<ul><li>从 <code>or_sum</code> 中移除最左侧元素 <code>nums[l]</code> 的影响：<code>or_sum ^= nums[l]</code>。</li><li>将左边界右移：<code>l += 1</code>。</li></ul></li><li><strong>扩大窗口</strong>：<code>while</code> 循环结束后，说明冲突已解决，新元素 <code>x</code> 可以加入。更新 <code>or_sum</code>：<code>or_sum |= x</code>。</li><li><strong>更新答案</strong>：此时的窗口 <code>[l, r]</code> 是优雅的，其长度为 <code>r - l + 1</code>。更新 <code>ans = max(ans, r - l + 1)</code>。</li></ul></li><li><p><strong>返回结果</strong>:</p><ul><li>遍历结束后，<code>ans</code> 即为所求。</li></ul></li></ol><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><p>下面是题目给出的 Python 代码，逻辑清晰地实现了上述思路。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestNiceSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = l = _ = <span class="number">0</span> <span class="comment"># _ 用来存储窗口内元素的按位或(OR)结果</span></span><br><span class="line">        <span class="keyword">for</span> r,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 当新元素 x 与窗口内已有元素的 OR 结果有重叠的 bit 位时</span></span><br><span class="line">            <span class="keyword">while</span> _ &amp; x:</span><br><span class="line">                <span class="comment"># 从窗口左侧移出元素 nums[l]</span></span><br><span class="line">                <span class="comment"># 因为在优雅子数组中，OR 和 XOR 效果相同，所以用 XOR 移除</span></span><br><span class="line">                _ ^= nums[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将新元素 x 的 bit 位加入到集合中</span></span><br><span class="line">            _ |= x</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新最长长度</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans,r-l+<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(N)。其中 N 是 <code>nums</code> 的长度。虽然代码中有 <code>while</code> 循环嵌套在 <code>for</code> 循环中，但左右两个指针 <code>l</code> 和 <code>r</code> 都始终只向右移动，不回退。每个元素最多被右指针访问一次，被左指针访问一次。因此，总的时间复杂度是线性的。</li><li><strong>空间复杂度</strong>: O(1)。我们只使用了几个额外的变量 (<code>ans</code>, <code>l</code>, <code>_</code>)，占用的空间是常数级别的。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题巧妙地将一个看似复杂的子数组性质判断问题，通过<strong>位运算</strong>的洞察，转化成了一个可以在 O(1) 时间内完成的状态检查。这使得标准的<strong>滑动窗口</strong>算法得以高效应用。它是一个很好的例子，展示了如何利用问题的数学或逻辑特性来优化算法，将一个暴力解法可能会达到 O(N³) 的问题，降维到 O(N) 解决。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 2401 题：&lt;a href=&quot;https://leetcode.cn/problems/longest-nice-subarray/description/&quot;&gt;最长优雅子数组&lt;/a&gt;。&lt;br&gt;该题要求寻找一个最长的子数组，其中任意两个元素的按位与（AND）都为 0。这是一个非常适合使用滑动窗口解决的问题，关键在于如何高效地维护窗口的“优雅”属性。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="滑动窗口与双指针" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="不定长滑动窗口" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="位运算" scheme="http://github.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="滑动窗口" scheme="http://github.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="第309场周赛" scheme="http://github.com/tags/%E7%AC%AC309%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
</feed>
