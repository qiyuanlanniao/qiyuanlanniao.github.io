<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Changan&#39;s Blog</title>
  
  
  <link href="http://github.com/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2025-12-14T05:53:00.000Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>Changan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 2342 | 数位和相等数对的最大和</title>
    <link href="http://github.com/posts/leetcode-2342/"/>
    <id>http://github.com/posts/leetcode-2342/</id>
    <published>2025-12-14T05:53:00.000Z</published>
    <updated>2025-12-14T05:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 2342 题：<a href="https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/">数位和相等数对的最大和</a>。<br>这是一道考察哈希表（或数组）应用以及“枚举右，维护左”思想的经典题目。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个下标从 0 开始的数组 <code>nums</code> ，数组中的元素都是 <strong>正</strong> 整数。请你选出两个下标 <code>i</code> 和 <code>j</code>（<code>i != j</code>），且 <code>nums[i]</code> 的数位和 与 <code>nums[j]</code> 的数位和相等。</p><p>请你找出所有满足条件的下标 <code>i</code> 和 <code>j</code> ，找出并返回 <code>nums[i] + nums[j]</code> 可以得到的 <strong>最大值</strong>。如果不存在这样的下标对，返回 -1。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [18,43,36,13,7]</span><br><span class="line">输出：54</span><br><span class="line">解释：满足条件的数对 (i, j) 为：</span><br><span class="line">- (0, 2) ，两个数字的数位和都是 9 ，相加得到 18 + 36 = 54 。</span><br><span class="line">- (1, 4) ，两个数字的数位和都是 7 ，相加得到 43 + 7 = 50 。</span><br><span class="line">所以可以获得的最大和是 54 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,12,19,14]</span><br><span class="line">输出：-1</span><br><span class="line">解释：不存在满足条件的数对，返回 -1 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</li><li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-核心思想：枚举右，维护左"><a href="#1-核心思想：枚举右，维护左" class="headerlink" title="1. 核心思想：枚举右，维护左"></a>1. 核心思想：枚举右，维护左</h4><p>题目要求找到数位和相等的两个数，使它们的和最大。<br>我们可以遍历数组，对于当前遍历到的数字 <code>num</code>（我们把它看作是右边的数字），我们希望在之前遍历过的数字中（左边的数字），找到一个数位和与 <code>num</code> 相同的数字，并且这个数字尽可能大。</p><h4 id="2-数位和的计算与范围"><a href="#2-数位和的计算与范围" class="headerlink" title="2. 数位和的计算与范围"></a>2. 数位和的计算与范围</h4><p>首先，我们需要一个辅助逻辑来计算一个整数的数位和。<br>观察数据范围 <code>nums[i] &lt;= 10^9</code>。</p><ul><li>最大可能的数位和出现在 <code>999,999,999</code>，其和为 <code>9 * 9 = 81</code>。</li><li><code>1,000,000,000</code> 的数位和仅为 1。<br>因此，数位和的范围在 0 到 81 之间。这意味着我们可以使用一个长度为 82 的固定数组来代替哈希表，效率更高。</li></ul><h4 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h4><ol><li>初始化一个结果变量 <code>ans = -1</code>。</li><li>初始化一个长度为 82 的数组 <code>mx</code>，<code>mx[s]</code> 用于存储数位和为 <code>s</code> 的所有数字中，<strong>当前遇到的最大值</strong>。</li><li>遍历数组 <code>nums</code> 中的每个元素 <code>num</code>：<ul><li>计算 <code>num</code> 的数位和 <code>s</code>。</li><li>检查 <code>mx[s]</code> 是否非零：<ul><li>如果非零，说明之前已经遇到过数位和同为 <code>s</code> 的数字。此时，<code>mx[s]</code> 是之前遇到的最大的那个数。计算 <code>mx[s] + num</code> 并尝试更新全局最大和 <code>ans</code>。</li></ul></li><li>更新 <code>mx[s]</code>：我们需要维护该数位和下的最大值，以便后续的数字能匹配到最大的“另一半”。即 <code>mx[s] = max(mx[s], num)</code>。</li></ul></li><li>返回 <code>ans</code>。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 数据范围最大为 10^9，最大数位和为 999,999,999 的数位和 81</span></span><br><span class="line">        <span class="comment"># 所以开辟大小为 82 的数组即可代替哈希表</span></span><br><span class="line">        mx = [<span class="number">0</span>] * <span class="number">82</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 计算当前数字的数位和</span></span><br><span class="line">            s = <span class="number">0</span></span><br><span class="line">            x = num</span><br><span class="line">            <span class="keyword">while</span> x:</span><br><span class="line">                s += x % <span class="number">10</span></span><br><span class="line">                x //= <span class="number">10</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果之前已经出现过数位和为 s 的数字</span></span><br><span class="line">            <span class="comment"># mx[s] 存储的是之前遍历过的数位和为 s 的最大值</span></span><br><span class="line">            <span class="keyword">if</span> mx[s]:</span><br><span class="line">                <span class="comment"># 尝试更新最大数对和</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, mx[s] + num)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 维护数位和为 s 的最大值</span></span><br><span class="line">            <span class="comment"># 这样保证了后续匹配时，取到的一定是当前最大的配对数</span></span><br><span class="line">            mx[s] = <span class="built_in">max</span>(mx[s], num)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="number">-1</span></span><br><span class="line">    <span class="comment">// 数据范围最大为 10^9，最大数位和为 81</span></span><br><span class="line">    <span class="comment">// 使用数组作为哈希表，索引为数位和，值为拥有该数位和的最大数字</span></span><br><span class="line">    mx := [<span class="number">82</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 计算当前数字的数位和</span></span><br><span class="line">        s := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x := num; x &gt; <span class="number">0</span>; x /= <span class="number">10</span> &#123;</span><br><span class="line">            s += x % <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 mx[s] &gt; 0，说明之前遇到过数位和为 s 的数字</span></span><br><span class="line">        <span class="keyword">if</span> mx[s] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 计算当前数字与之前遇到的最大数字之和，并更新答案</span></span><br><span class="line">            ans = max(ans, mx[s] + num)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新数位和为 s 的最大值</span></span><br><span class="line">        <span class="comment">// 确保后续如果有数字也为数位和 s，能匹配到目前为止最大的数字</span></span><br><span class="line">        mx[s] = max(mx[s], num)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：返回两个数中的较大值</span></span><br><span class="line"><span class="comment">// 注意：Go 1.21+ 内置了 max 函数，如果使用旧版本需自行实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: O(N * log M)，其中 N 是数组的长度，M 是数组中元素的最大值（本题中为 10^9）。</p><ul><li>我们需要遍历数组一次。</li><li>对于每个数字，计算数位和的时间与数字的位数成正比，即 log10(M)。</li><li>因为 log10(10^9) ≈ 9，是一个很小的常数，所以整体可以看作 O(N)。</li></ul></li><li><p><strong>空间复杂度</strong>: O(D)，其中 D 是可能的数位和的最大种类数。</p><ul><li>本题中最大数位和为 81，所以空间复杂度为 O(1)（固定大小的数组）。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 2342 题：&lt;a href=&quot;https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/&quot;&gt;数位和相等数对的最大和&lt;/a&gt;。&lt;br&gt;这是一道考察哈希表（或数组）应用以及“枚举右，维护左”思想的经典题目。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="排序" scheme="http://github.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="堆（优先队列）" scheme="http://github.com/tags/%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89/"/>
    
    <category term="第302场周赛" scheme="http://github.com/tags/%E7%AC%AC302%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 624 | 数组列表中的最大距离</title>
    <link href="http://github.com/posts/leetcode-624/"/>
    <id>http://github.com/posts/leetcode-624/</id>
    <published>2025-12-13T06:07:00.000Z</published>
    <updated>2025-12-13T06:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 624 题：<a href="https://leetcode.cn/problems/maximum-distance-in-arrays/">数组列表中的最大距离</a>。<br>题目考察如何在多个有序数组中找到满足特定条件（来自不同数组）的最大差值。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定 <code>m</code> 个数组，每个数组都已经按照升序排好序了。</p><p>现在你需要从两个不同的数组中选择两个整数（每个数组选一个）并且计算它们的距离。两个整数 <code>a</code> 和 <code>b</code> 之间的距离定义为它们差的绝对值 <code>|a-b|</code> 。</p><p>返回最大距离。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5],[1,2,3]]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">一种得到答案 4 的方法是从第一个数组或者第三个数组中选择 1，同时从第二个数组中选择 5 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arrays = [[1],[1]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == arrays.length</code></li><li><code>2 &lt;= m &lt;= 10^5</code></li><li><code>1 &lt;= arrays[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= arrays[i][j] &lt;= 10^4</code></li><li><code>arrays[i]</code> 以 <strong>升序</strong> 排序。</li><li>所有数组中最多有 <code>10^5</code> 个整数。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-暴力法的局限性"><a href="#1-暴力法的局限性" class="headerlink" title="1. 暴力法的局限性"></a>1. 暴力法的局限性</h4><p>题目要求从两个 <strong>不同</strong> 的数组中各取一个数，计算它们差值的绝对值。<br>最直观的做法是两层循环枚举所有的数组对，计算它们的最大值和最小值的差。<br>但由于数组数量 <code>m</code> 可达 <code>10^5</code>，<code>O(m^2)</code> 的时间复杂度会超时。</p><h4 id="2-贪心策略-一次遍历"><a href="#2-贪心策略-一次遍历" class="headerlink" title="2. 贪心策略 (一次遍历)"></a>2. 贪心策略 (一次遍历)</h4><p>由于每个数组都是 <strong>升序</strong> 排列的，对于任意一个数组，它的最小值一定是第一个元素，最大值一定是最后一个元素。<br>为了让 <code>|a - b|</code> 最大，我们需要尽可能让一个数大，另一个数小。</p><p>我们可以遍历每一个数组 <code>arrays[i]</code>，并维护在它 <strong>之前</strong> 所有数组中出现过的最小值 <code>mn</code> 和最大值 <code>mx</code>。<br>对于当前数组 <code>arrays[i]</code>，为了保证两个数来自不同的数组，我们可以计算以下两个距离：</p><ol><li>当前数组的最大值 <code>arrays[i][-1]</code> 减去之前所有数组的最小值 <code>mn</code>。</li><li>之前所有数组的最大值 <code>mx</code> 减去当前数组的最小值 <code>arrays[i][0]</code>。</li></ol><p>取这两个值的最大者更新最终答案 <code>ans</code>。<br>计算完成后，再将当前数组的最小值和最大值更新到 <code>mn</code> 和 <code>mx</code> 中，供后续数组使用。</p><p>这样，我们在遍历到第 <code>i</code> 个数组时，<code>mn</code> 和 <code>mx</code> 仅包含前 <code>i-1</code> 个数组的信息，从而保证了计算距离的两个数一定来自不同的数组。</p><p><strong>注意</strong>：</p><ul><li>在 Python 代码中，通常利用无穷大 <code>inf</code> 来初始化。</li><li>在 Go 语言或其他逻辑中，通常可以直接取第一个数组作为初始的 <code>mn</code> 和 <code>mx</code>，然后从第二个数组开始遍历，效果是一样的。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDistance</span>(<span class="params">self, arrays: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 初始化最小值 mn 为正无穷，最大值 mx 为负无穷</span></span><br><span class="line">        <span class="comment"># 注意：这里假设环境中已经引入了 inf，或者使用 float(&#x27;inf&#x27;)</span></span><br><span class="line">        mn, mx = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> arrays:</span><br><span class="line">            <span class="comment"># 计算当前数组与之前遍历过的数组能构成的最大距离</span></span><br><span class="line">            <span class="comment"># 1. 当前数组的最大值 a[-1] - 之前的最小值 mn</span></span><br><span class="line">            <span class="comment"># 2. 之前的最大值 mx - 当前数组的最小值 a[0]</span></span><br><span class="line">            <span class="comment"># 注意：第一次循环时，由于 mn 是正无穷，mx 是负无穷，计算结果对 ans 无影响（ans 保持 0）</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, a[-<span class="number">1</span>] - mn, mx - a[<span class="number">0</span>])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新全局最小值 mn，比较当前数组的最小值 a[0]</span></span><br><span class="line">            mn = <span class="built_in">min</span>(mn, a[<span class="number">0</span>])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新全局最大值 mx，比较当前数组的最大值 a[-1]</span></span><br><span class="line">            mx = <span class="built_in">max</span>(mx, a[-<span class="number">1</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDistance</span><span class="params">(arrays [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 结果初始化为 0</span></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取第一个数组的最小值和最大值作为初始值</span></span><br><span class="line">    <span class="comment">// arrays[i] 是升序的，所以最小值在索引 0，最大值在索引 len-1</span></span><br><span class="line">    minVal := arrays[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    maxVal := arrays[<span class="number">0</span>][<span class="built_in">len</span>(arrays[<span class="number">0</span>])<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从第二个数组开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(arrays); i++ &#123;</span><br><span class="line">        curr := arrays[i]</span><br><span class="line">        currMin := curr[<span class="number">0</span>]</span><br><span class="line">        currMax := curr[<span class="built_in">len</span>(curr)<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算潜在的最大距离</span></span><br><span class="line">        <span class="comment">// 场景 1: 当前数组的最大值 - 之前所有数组的最小值</span></span><br><span class="line">        <span class="keyword">if</span> dist := currMax - minVal; dist &gt; ans &#123;</span><br><span class="line">            ans = dist</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 场景 2: 之前所有数组的最大值 - 当前数组的最小值</span></span><br><span class="line">        <span class="keyword">if</span> dist := maxVal - currMin; dist &gt; ans &#123;</span><br><span class="line">            ans = dist</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新全局最小值</span></span><br><span class="line">        <span class="keyword">if</span> currMin &lt; minVal &#123;</span><br><span class="line">            minVal = currMin</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新全局最大值</span></span><br><span class="line">        <span class="keyword">if</span> currMax &gt; maxVal &#123;</span><br><span class="line">            maxVal = currMax</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(m)</code><br>其中 <code>m</code> 是数组的个数。我们只需要遍历 <code>arrays</code> 一次。每次迭代中的操作（比较、更新）都是 <code>O(1)</code> 的。</p></li><li><p><strong>空间复杂度</strong>: <code>O(1)</code><br>我们只需要常数级别的额外空间来存储 <code>ans</code>, <code>mn</code>, <code>mx</code> 等变量。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 624 题：&lt;a href=&quot;https://leetcode.cn/problems/maximum-distance-in-arrays/&quot;&gt;数组列表中的最大距离&lt;/a&gt;。&lt;br&gt;题目考察如何在多个有序数组中找到满足特定条件（来自不同数组）的最大差值。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="贪心" scheme="http://github.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 121 | 买卖股票的最佳时机</title>
    <link href="http://github.com/posts/leetcode-121/"/>
    <id>http://github.com/posts/leetcode-121/</id>
    <published>2025-12-12T02:52:00.000Z</published>
    <updated>2025-12-12T02:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 121 题：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a>。<br>这是买卖股票系列题目的第一题，也是“枚举右，维护左”思想的经典应用。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; prices.length &lt;&#x3D; 10^5</li><li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 10^4</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-暴力法的局限性"><a href="#1-暴力法的局限性" class="headerlink" title="1. 暴力法的局限性"></a>1. 暴力法的局限性</h4><p>最朴素的想法是两层循环：外层循环枚举买入的那一天，内层循环枚举买入之后的所有天数作为卖出日，计算差值并求最大值。<br>这种方法的时间复杂度是 O(n^2)。面对本题的数据规模（10^5），会导致超时。</p><h4 id="2-一次遍历（贪心-动态规划）"><a href="#2-一次遍历（贪心-动态规划）" class="headerlink" title="2. 一次遍历（贪心&#x2F;动态规划）"></a>2. 一次遍历（贪心&#x2F;动态规划）</h4><p>我们要获取最大利润，本质上是在寻找 <code>prices[j] - prices[i]</code> 的最大值，其中 <code>j &gt; i</code>。</p><p>我们可以换一个角度思考：<br>假设我们在第 <code>i</code> 天卖出股票，那么为了利润最大化，我们必须在第 <code>i</code> 天之前的某一天以 <strong>最低价格</strong> 买入。</p><p>算法流程如下：</p><ol><li><strong>记录最低价格 (<code>mp</code>)</strong>：我们需要维护一个变量，记录“截止到目前为止”遇到的最低股价。初始时，最低价格可以设为第一天的价格。</li><li><strong>枚举卖出价格 (<code>p</code>)</strong>：从头到尾遍历数组，假设当前遍历到的价格 <code>p</code> 就是我们卖出的价格。</li><li><strong>计算利润与更新</strong>：<ul><li><strong>计算当前利润</strong>：使用当前价格 <code>p</code> 减去历史最低价格 <code>mp</code>，得到如果在今天卖出的最大可能利润。</li><li><strong>更新最大利润 (<code>ans</code>)</strong>：比较当前计算的利润和之前记录的最大利润，取较大者。</li><li><strong>更新最低价格 (<code>mp</code>)</strong>：检查当前价格 <code>p</code> 是否比记录的 <code>mp</code> 更低，如果是，则更新 <code>mp</code>，供未来的天数使用。</li></ul></li></ol><p>这种思想通常被称为“枚举右，维护左”：我们在遍历数组时，将当前元素视为右边界（卖出点），同时动态维护左侧的历史信息（最低买入点）。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化最大利润为 0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 初始化最低买入价格 mp (min_price) 为第一天的价格</span></span><br><span class="line">        mp = prices[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历每一天的价格 p</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="comment"># 尝试在今天卖出：</span></span><br><span class="line">            <span class="comment"># 计算当前价格 p 与历史最低价格 mp 的差值</span></span><br><span class="line">            <span class="comment"># 并更新全局最大利润 ans</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, p - mp)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新历史最低价格：</span></span><br><span class="line">            <span class="comment"># 如果当前价格 p 比 mp 更低，则将 mp 更新为 p</span></span><br><span class="line">            mp = <span class="built_in">min</span>(mp, p)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 边界条件处理（虽然题目提示长度 &gt;= 1，但这是一个好习惯）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(prices) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化最大利润为 0</span></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 初始化最低买入价格 mp (min_price) 为第一天的价格</span></span><br><span class="line">    mp := prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每一天的价格 p</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> prices &#123;</span><br><span class="line">        <span class="comment">// 尝试在今天卖出：</span></span><br><span class="line">        <span class="comment">// 如果 (当前价格 - 历史最低价) 大于当前记录的最大利润，则更新</span></span><br><span class="line">        <span class="keyword">if</span> p - mp &gt; ans &#123;</span><br><span class="line">            ans = p - mp</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新历史最低价格：</span></span><br><span class="line">        <span class="comment">// 如果当前价格 p 小于 历史最低价 mp，则更新 mp</span></span><br><span class="line">        <span class="keyword">if</span> p &lt; mp &#123;</span><br><span class="line">            mp = p</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>我们只需要遍历一次 <code>prices</code> 数组即可完成计算。</p></li><li><p><strong>空间复杂度</strong>: <code>O(1)</code><br>只需要常数个变量 (<code>ans</code>, <code>mp</code>) 来存储中间状态，不需要额外的数组空间。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 121 题：&lt;a href=&quot;https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/&quot;&gt;买卖股票的最佳时机&lt;/a&gt;。&lt;br&gt;这是买卖股票系列题目的第一题，也是“枚举右，维护左”思想的经典应用。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="动态规划" scheme="http://github.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2441 | 与对应负数同时存在的最大正整数</title>
    <link href="http://github.com/posts/leetcode-2441/"/>
    <id>http://github.com/posts/leetcode-2441/</id>
    <published>2025-12-11T01:10:00.000Z</published>
    <updated>2025-12-11T01:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 2441 题：<a href="https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/">与对应负数同时存在的最大正整数</a>。<br>题目主要考察如何在遍历过程中快速查找元素的相反数。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个 <strong>不包含</strong> 任何零的整数数组 <code>nums</code> ，找出自身与对应的负数都在数组中存在的最大正整数 <code>k</code> 。</p><p>返回正整数 <code>k</code> ，如果不存在这样的整数，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,2,-3,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：3 是数组中唯一一个满足题目要求的 k 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,10,6,7,-7,1]</span><br><span class="line">输出：7</span><br><span class="line">解释：数组中存在 1 和 7 对应的负数，7 的值更大。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-10,8,6,7,-2,-3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：不存在满足题目要求的 k ，返回 -1 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000</li><li>-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li><li>nums[i] !&#x3D; 0</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="哈希表-一次遍历"><a href="#哈希表-一次遍历" class="headerlink" title="哈希表 (一次遍历)"></a>哈希表 (一次遍历)</h4><p>为了找到同时存在正数和负数的最大整数 <code>k</code>，我们可以利用哈希表（在 Python 中是 <code>set</code>，Go 中是 <code>map</code>）来记录已经遍历过的数字。</p><p>算法流程如下：</p><ol><li><strong>初始化</strong>：设置一个变量 <code>ans</code> 为 -1，用于记录当前找到的满足条件的最大正整数。创建一个空的哈希集合 <code>s</code>。</li><li><strong>遍历数组</strong>：对于数组中的每一个元素 <code>x</code>：<ul><li><strong>检查相反数</strong>：检查 <code>-x</code> 是否已经在集合 <code>s</code> 中。</li><li><strong>更新结果</strong>：如果 <code>-x</code> 存在，说明我们需要的一对正负数 <code>(x, -x)</code> 都出现了。此时，计算 <code>x</code> 的绝对值 <code>abs(x)</code>，并尝试更新 <code>ans</code> 为 <code>max(ans, abs(x))</code>。</li><li><strong>加入集合</strong>：将当前元素 <code>x</code> 加入集合 <code>s</code>，以便后续的元素能找到它。</li></ul></li><li><strong>返回结果</strong>：遍历结束后，返回 <code>ans</code>。</li></ol><p>这种方法的优势在于只需要遍历一次数组，查找操作的时间复杂度为 O(1)。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxK</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化答案为 -1，表示默认未找到</span></span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 创建一个哈希集合，用于存储遍历过的数字</span></span><br><span class="line">        s = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历数组中的每个数字 x</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 检查 x 的相反数 -x 是否已经在集合中</span></span><br><span class="line">            <span class="comment"># 如果在，说明找到了一对互为相反数的数字 (x, -x)</span></span><br><span class="line">            <span class="keyword">if</span> -x <span class="keyword">in</span> s:</span><br><span class="line">                <span class="comment"># 这一对数字对应的正整数是 abs(x)</span></span><br><span class="line">                <span class="comment"># 更新当前找到的最大正整数 k</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">abs</span>(x))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将当前数字 x 加入集合，供后续数字查找</span></span><br><span class="line">            s.add(x)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxK</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化答案为 -1</span></span><br><span class="line">    ans := <span class="number">-1</span></span><br><span class="line">    <span class="comment">// 创建一个 map 作为哈希集合，key 为数值，value 为 bool</span></span><br><span class="line">    s := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 检查 x 的相反数 -x 是否已经在 map 中</span></span><br><span class="line">        <span class="keyword">if</span> s[-x] &#123;</span><br><span class="line">            <span class="comment">// 计算 x 的绝对值</span></span><br><span class="line">            currentK := x</span><br><span class="line">            <span class="keyword">if</span> currentK &lt; <span class="number">0</span> &#123;</span><br><span class="line">                currentK = -currentK</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前的绝对值比已记录的答案更大，则更新</span></span><br><span class="line">            <span class="keyword">if</span> currentK &gt; ans &#123;</span><br><span class="line">                ans = currentK</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前数字 x 存入 map，标记为存在</span></span><br><span class="line">        s[x] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>其中 <code>n</code> 是数组 <code>nums</code> 的长度。我们需要遍历数组一次，每次在哈希表中进行查找和插入操作的平均时间复杂度为 <code>O(1)</code>。</p></li><li><p><strong>空间复杂度</strong>: <code>O(n)</code><br>需要使用哈希表存储数组中的元素，最坏情况下需要存储所有 <code>n</code> 个元素。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 2441 题：&lt;a href=&quot;https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/&quot;&gt;与对应负数同时存在的最大正整数&lt;/a&gt;。&lt;br&gt;题目主要考察如何在遍历过程中快速查找元素的相反数。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="排序" scheme="http://github.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="双指针" scheme="http://github.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="第315场周赛" scheme="http://github.com/tags/%E7%AC%AC315%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1512 | 好数对的数目</title>
    <link href="http://github.com/posts/leetcode-1512/"/>
    <id>http://github.com/posts/leetcode-1512/</id>
    <published>2025-12-10T02:00:00.000Z</published>
    <updated>2025-12-10T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1512 题：<a href="https://leetcode.cn/problems/number-of-good-pairs/">好数对的数目</a>。<br>这是一道考察数组遍历与哈希表计数的简单题目，体现了“枚举右，维护左”的经典思想。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组 <code>nums</code> 。</p><p>如果一组数字 <code>(i,j)</code> 满足 <code>nums[i] == nums[j]</code> 且 <code>i &lt; j</code> ，就可以认为这是一组 <strong>好数对</strong> 。</p><p>返回好数对的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,1,1,3]</span><br><span class="line">输出：4</span><br><span class="line">解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：数组中的每组数字都是好数对</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li><li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1. 暴力法"></a>1. 暴力法</h4><p>最容易想到的方法是使用两层循环遍历所有可能的数对 <code>(i, j)</code>，其中 <code>0 &lt;= i &lt; j &lt; nums.length</code>，并判断 <code>nums[i]</code> 是否等于 <code>nums[j]</code>。<br>这种方法的时间复杂度是 O(n^2)。鉴于本题数据范围较小（n &lt;&#x3D; 100），暴力法也是可以通过的，但不是最优解。</p><h4 id="2-哈希表-一次遍历"><a href="#2-哈希表-一次遍历" class="headerlink" title="2. 哈希表 (一次遍历)"></a>2. 哈希表 (一次遍历)</h4><p>为了优化时间复杂度，我们可以使用哈希表来记录数字出现的频率。<br>这道题的核心思想是 <strong>“枚举右，维护左”</strong>。</p><p>算法流程如下：</p><ol><li>我们从左到右遍历数组 <code>nums</code>。</li><li>对于当前遍历到的数字 <code>x</code>，我们需要知道在它 <strong>之前</strong> 已经出现了多少次 <code>x</code>。</li><li>假设在当前位置之前，<code>x</code> 已经出现了 <code>k</code> 次，那么当前的 <code>x</code> 就可以与前面的 <code>k</code> 个 <code>x</code> 分别组成 <code>k</code> 个好数对。</li><li>因此，我们只需要将哈希表中记录的 <code>x</code> 的次数累加到答案 <code>ans</code> 中，然后更新哈希表中 <code>x</code> 的计数（加 1），以便后续的数字使用。</li></ol><p>通过这种方式，我们只需要遍历一次数组，时间复杂度降低到了 O(n)。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIdenticalPairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># cnt 用于存储每个数字出现的次数 &#123;数值: 出现次数&#125;</span></span><br><span class="line">        cnt = &#123;&#125;</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历数组中的每个数字</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 如果 x 已经在哈希表中，说明之前出现过</span></span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> cnt:</span><br><span class="line">                <span class="comment"># 当前的 x 可以和之前出现的 cnt[x] 个 x 组成好数对</span></span><br><span class="line">                <span class="comment"># 将之前的出现次数累加到结果中</span></span><br><span class="line">                ans += cnt[x]   </span><br><span class="line">                <span class="comment"># 更新当前数字的计数</span></span><br><span class="line">                cnt[x] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 x 第一次出现，初始化计数为 1</span></span><br><span class="line">                cnt[x] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIdenticalPairs</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 创建哈希表，key 为数组元素值，value 为该元素出现的次数</span></span><br><span class="line">    cnt := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 在 Go 语言中，如果 key 不在 map 中，会返回 value 类型的零值（即 0）</span></span><br><span class="line">        <span class="comment">// 如果 x 之前出现过，cnt[x] 即为之前的出现次数</span></span><br><span class="line">        <span class="comment">// 当前的 x 可以与之前所有的 x 组成好数对，累加到 ans</span></span><br><span class="line">        ans += cnt[x]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新当前数字 x 的计数</span></span><br><span class="line">        cnt[x]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>其中 <code>n</code> 为数组 <code>nums</code> 的长度。我们需要遍历一遍数组，哈希表的插入和查询操作平均时间复杂度为 <code>O(1)</code>。</p></li><li><p><strong>空间复杂度</strong>: <code>O(n)</code><br>需要使用哈希表存储数组中不同元素的出现次数。在最坏情况下（数组中所有元素都不同），哈希表的大小为 <code>n</code>。考虑到题目提示中 <code>nums[i] &lt;= 100</code>，实际上空间复杂度也可视为 <code>O(C)</code>，其中 <code>C</code> 为数值范围。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1512 题：&lt;a href=&quot;https://leetcode.cn/problems/number-of-good-pairs/&quot;&gt;好数对的数目&lt;/a&gt;。&lt;br&gt;这是一道考察数组遍历与哈希表计数的简单题目，体现了“枚举右，维护左”的经典思想。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="数学" scheme="http://github.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="第197场周赛" scheme="http://github.com/tags/%E7%AC%AC197%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
    <category term="计数" scheme="http://github.com/tags/%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1 | 两数之和</title>
    <link href="http://github.com/posts/leetcode-1/"/>
    <id>http://github.com/posts/leetcode-1/</id>
    <published>2025-12-09T02:44:00.000Z</published>
    <updated>2025-12-09T02:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1 题：<a href="https://leetcode.cn/problems/two-sum/">两数之和</a>。<br>这是力扣的第一题，也是哈希表应用的经典入门题目。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <code>target</code>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>2 &lt;&#x3D; nums.length &lt;&#x3D; 10^4</li><li>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</li><li>-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9</li><li>只会存在一个有效答案</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-暴力法的局限性"><a href="#1-暴力法的局限性" class="headerlink" title="1. 暴力法的局限性"></a>1. 暴力法的局限性</h4><p>最直观的方法是使用两层循环。第一层循环遍历数组中的每一个数，第二层循环寻找其余数中是否存在与当前数相加等于 <code>target</code> 的数。<br>这种方法的时间复杂度是 O(n^2)。当数组长度较大时（例如达到 10^4），效率较低。</p><h4 id="2-哈希表-空间换时间"><a href="#2-哈希表-空间换时间" class="headerlink" title="2. 哈希表 (空间换时间)"></a>2. 哈希表 (空间换时间)</h4><p>为了降低时间复杂度，我们可以利用哈希表（在 Python 中是字典，Go 中是 Map）来记录已经遍历过的数字及其下标。</p><p>算法流程如下：</p><ol><li><strong>一次遍历</strong>：我们只需要遍历一次数组。</li><li><strong>查找补数</strong>：对于每一个遍历到的元素 <code>x</code>，我们需要寻找的目标是 <code>y = target - x</code>。</li><li><strong>查询与记录</strong>：<ul><li>如果 <code>y</code> 已经在哈希表 <code>mp</code> 中，说明之前已经遍历过了这个数字。此时，<code>mp[y]</code> 是 <code>y</code> 的下标，<code>i</code> 是当前 <code>x</code> 的下标。直接返回 <code>[mp[y], i]</code> 即可。</li><li>如果 <code>y</code> 不在哈希表中，我们将当前数字 <code>x</code> 及其下标 <code>i</code> 存入哈希表 <code>mp[x] = i</code>，以便后续的数字能找到它。</li></ul></li></ol><p>通过这种方式，查找操作的时间复杂度降低到了 O(1)，整体时间复杂度降低到了 O(n)。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 创建一个哈希表用于存储 &#123;数值: 下标&#125;</span></span><br><span class="line">        mp = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历数组，获取当前下标 i 和数值 x</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 计算满足条件的另一个数值 y</span></span><br><span class="line">            y = target - x</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 检查 y 是否已经在哈希表中</span></span><br><span class="line">            <span class="comment"># 如果在，说明之前遍历过 y，直接返回对应的下标和当前下标</span></span><br><span class="line">            <span class="keyword">if</span> y <span class="keyword">in</span> mp:</span><br><span class="line">                <span class="keyword">return</span> [mp[y], i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果不在，将当前数值 x 和下标 i 存入哈希表</span></span><br><span class="line">            <span class="comment"># 供后续的元素查找</span></span><br><span class="line">            mp[x] = i</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 创建哈希表，key 为数组元素值，value 为对应的下标</span></span><br><span class="line">    mp := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 计算需要的补数 y</span></span><br><span class="line">        y := target - x</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查哈希表中是否存在 y</span></span><br><span class="line">        <span class="comment">// 如果存在，说明找到了这两个数，返回它们的下标</span></span><br><span class="line">        <span class="keyword">if</span> idx, ok := mp[y]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;idx, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前元素 x 和下标 i 存入哈希表</span></span><br><span class="line">        mp[x] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>我们只遍历了包含 <code>n</code> 个元素的列表一次。在表中进行的每次查找只花费 <code>O(1)</code> 的时间。</p></li><li><p><strong>空间复杂度</strong>: <code>O(n)</code><br>主要为哈希表的开销。在最坏的情况下（例如，目标元素在数组的最后两个），我们需要将 <code>n - 1</code> 个元素存储在哈希表中。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1 题：&lt;a href=&quot;https://leetcode.cn/problems/two-sum/&quot;&gt;两数之和&lt;/a&gt;。&lt;br&gt;这是力扣的第一题，也是哈希表应用的经典入门题目。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="常用数据结构" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="常用枚举技巧" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/"/>
    
    <category term="枚举右，维护左" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7/%E6%9E%9A%E4%B8%BE%E5%8F%B3%EF%BC%8C%E7%BB%B4%E6%8A%A4%E5%B7%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1475 | 商品折扣后的最终价格</title>
    <link href="http://github.com/posts/leetcode-1475/"/>
    <id>http://github.com/posts/leetcode-1475/</id>
    <published>2025-12-08T05:23:00.000Z</published>
    <updated>2025-12-08T05:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1475 题：<a href="https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/">商品折扣后的最终价格</a>。<br>问题的核心是寻找数组中每个元素右侧第一个小于等于它的元素。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是商店里第 <code>i</code> 件商品的价格。</p><p>商店里正在进行促销活动，如果你要买第 <code>i</code> 件商品，那么你可以得到与 <code>prices[j]</code> 相等的折扣，其中 <code>j</code> 是满足 <code>j &gt; i</code> 且 <code>prices[j] &lt;= prices[i]</code> 的 <strong>最小下标</strong> ，如果没有满足条件的 <code>j</code> ，你将没有任何折扣。</p><p>请你返回一个数组，数组中第 <code>i</code> 个元素是折扣后你购买商品 <code>i</code> 最终需要支付的价格。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [8,4,6,2,3]</span><br><span class="line">输出：[4,2,4,2,3]</span><br><span class="line">解释：</span><br><span class="line">商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。</span><br><span class="line">商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。</span><br><span class="line">商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。</span><br><span class="line">商品 3 和 4 都没有折扣。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：[1,2,3,4,5]</span><br><span class="line">解释：在这个例子中，所有商品都没有折扣。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [10,1,1,6]</span><br><span class="line">输出：[9,0,1,6]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; prices.length &lt;&#x3D; 500</li><li>1 &lt;&#x3D; prices[i] &lt;&#x3D; 10^3</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1. 问题分析"></a>1. 问题分析</h4><p>题目要求对于每个商品 <code>i</code>，找到它右边第一个满足 <code>prices[j] &lt;= prices[i]</code> 的价格 <code>prices[j]</code> 作为折扣。如果没有找到，折扣为 0。最终支付价格为 <code>prices[i] - 折扣</code>。</p><p>这是一个典型的 <strong>寻找右侧第一个更小（或相等）元素</strong> 的问题。</p><h4 id="2-单调栈-哨兵技巧"><a href="#2-单调栈-哨兵技巧" class="headerlink" title="2. 单调栈 + 哨兵技巧"></a>2. 单调栈 + 哨兵技巧</h4><p>我们可以使用单调栈来高效解决这个问题。为了方便处理，我们采用 <strong>从后往前</strong> 遍历数组的方式：</p><ol><li><strong>倒序遍历</strong>：从最后一个商品开始向前遍历。这样当我们处理第 <code>i</code> 个商品时，它右边的商品（潜在的折扣选项）已经被处理过并存储在栈中。</li><li><strong>维护单调性</strong>：<ul><li>栈中存储的是右侧的商品价格。</li><li>当我们遇到一个新的价格 <code>p</code> 时，我们查看栈顶元素。</li><li>如果栈顶元素 <strong>大于</strong> <code>p</code>，说明栈顶这个价格太贵了，不满足折扣条件（必须小于等于 <code>p</code>）。而且，由于 <code>p</code> 在栈顶元素的左边且 <code>p</code> 更小，对于 <code>p</code> 左边的任何商品来说，<code>p</code> 都是一个比栈顶元素更优（更小且距离更近）的折扣候选。因此，我们可以放心地将栈顶元素弹出。</li><li>重复弹出操作，直到栈顶元素 <strong>小于等于</strong> <code>p</code>，或者栈为空。</li></ul></li><li><strong>计算结果</strong>：<ul><li>此时，栈顶元素就是 <code>p</code> 右侧第一个满足条件的折扣值。</li><li>如果栈为空，说明右边没有更便宜的价格，折扣为 0。</li></ul></li><li><strong>哨兵优化</strong>：<ul><li>为了避免判断栈是否为空，我们可以预先在栈底放入一个 <strong>哨兵值 0</strong>。</li><li>题目已知 <code>prices[i] &gt;= 1</code>，所以 0 必定小于任何商品价格。</li><li>当栈中只剩下哨兵 0 时，说明没有找到折扣，此时计算 <code>p - 0</code> 刚好等于原价，符合逻辑，且代码更加简洁。</li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">finalPrices</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        ans = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="comment"># 初始化栈，放入哨兵 0</span></span><br><span class="line">        <span class="comment"># 0 比所有有效价格都小，代表“无折扣”的情况</span></span><br><span class="line">        st = [<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从后往前遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            p = prices[i]</span><br><span class="line">            <span class="comment"># 维护单调栈：如果栈顶价格 &gt; 当前价格 p</span></span><br><span class="line">            <span class="comment"># 说明栈顶太贵了，不能作为 p 的折扣</span></span><br><span class="line">            <span class="comment"># 且 p 更小更靠左，会挡住栈顶元素，使其对左边元素无效，故弹出</span></span><br><span class="line">            <span class="keyword">while</span> st[-<span class="number">1</span>] &gt; p:</span><br><span class="line">                st.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 此时栈顶元素 &lt;= p，即为右侧第一个满足条件的折扣</span></span><br><span class="line">            <span class="comment"># 如果没找到，栈顶就是哨兵 0</span></span><br><span class="line">            ans[i] = p - st[-<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将当前价格入栈，作为左边元素的潜在折扣</span></span><br><span class="line">            st.append(p)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finalPrices</span><span class="params">(prices []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(prices)</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="comment">// 哨兵，作为没有折扣时的栈顶值</span></span><br><span class="line">    <span class="comment">// 0 不会影响计算结果 (price - 0 = price)，且总是满足 &lt;= price</span></span><br><span class="line">    st := []<span class="type">int</span>&#123;<span class="number">0</span>&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从后往前遍历</span></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        p := prices[i]</span><br><span class="line">        <span class="comment">// 当栈顶元素大于当前价格 p 时，栈顶元素无法作为折扣，弹出</span></span><br><span class="line">        <span class="comment">// 这一步保证了栈内元素（除哨兵外）对于当前位置是单调递增的</span></span><br><span class="line">        <span class="keyword">for</span> st[<span class="built_in">len</span>(st)<span class="number">-1</span>] &gt; p &#123;</span><br><span class="line">            st = st[:<span class="built_in">len</span>(st)<span class="number">-1</span>] <span class="comment">// p 比栈顶小，比栈顶更能成为左侧元素的折扣值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束后，栈顶的价格 &lt;= p，作为折扣值</span></span><br><span class="line">        <span class="comment">// 如果没有找到真实折扣，栈顶就是哨兵 0</span></span><br><span class="line">        ans[i] = p - st[<span class="built_in">len</span>(st)<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前价格压入栈中</span></span><br><span class="line">        st = <span class="built_in">append</span>(st, p)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: O(n)<br>虽然代码中有嵌套循环，但观察栈的操作可以发现：数组中的每个元素最多入栈一次，最多出栈一次。因此整体操作次数与数组长度呈线性关系。</p></li><li><p><strong>空间复杂度</strong>: O(n)<br>需要一个栈来存储价格。在最坏情况下（例如数组严格单调递增），栈的大小接近 <code>n</code>。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1475 题：&lt;a href=&quot;https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/&quot;&gt;商品折扣后的最终价格&lt;/a&gt;。&lt;br&gt;问题的核心是寻找数组中每个元素右侧第一个小于等于它的元素。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="单调栈" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%8D%95%E8%B0%83%E6%A0%88/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="栈" scheme="http://github.com/tags/%E6%A0%88/"/>
    
    <category term="单调栈" scheme="http://github.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    <category term="第28场双周赛" scheme="http://github.com/tags/%E7%AC%AC28%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 739 | 每日温度</title>
    <link href="http://github.com/posts/leetcode-739/"/>
    <id>http://github.com/posts/leetcode-739/</id>
    <published>2025-12-07T09:02:00.000Z</published>
    <updated>2025-12-07T09:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 739 题：<a href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a>。<br>问题的核心是寻找数组中每个元素右侧第一个比它大的元素。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p><strong>示例 1:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [30,40,50,60]</span><br><span class="line">输出: [1,1,1,0]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [30,60,90]</span><br><span class="line">输出: [1,1,0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; temperatures.length &lt;&#x3D; 10^5</li><li>30 &lt;&#x3D; temperatures[i] &lt;&#x3D; 100</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-暴力法的局限性"><a href="#1-暴力法的局限性" class="headerlink" title="1. 暴力法的局限性"></a>1. 暴力法的局限性</h4><p>对于每一天，如果我们都向后遍历去寻找第一个比它温度高的日子，最坏情况下的时间复杂度是 O(n^2)。当数组长度达到 10^5 时，这种做法会超时。我们需要一种 O(n) 的解法。</p><h4 id="2-单调栈"><a href="#2-单调栈" class="headerlink" title="2. 单调栈"></a>2. 单调栈</h4><p>这类“寻找下一个更大元素”的问题是单调栈的典型应用场景。</p><p>我们可以维护一个存储下标的栈。在本题的解法中，我们采用 <strong>从后往前</strong> 遍历数组的方式：</p><ol><li><strong>倒序遍历</strong>：从最后一天向第一天遍历。因为对于第 <code>i</code> 天来说，我们需要知道的是它“未来”的信息。倒序遍历可以让我们先把未来的数据处理好放入栈中。</li><li><strong>栈的作用</strong>：栈中存储的是“未来”日期的下标。这些下标对应的温度，在栈中保持 <strong>从栈顶到栈底递增</strong>。</li><li><strong>核心逻辑</strong>：<ul><li>当我们遍历到第 <code>i</code> 天，温度为 <code>t</code> 时，我们查看栈顶的日期。</li><li>如果栈顶日期的温度 <strong>小于等于</strong> 当前温度 <code>t</code>，说明栈顶的那个日子对于第 <code>i</code> 天来说没有任何意义（因为它不够热），而且对于 <code>i</code> 之前的日子也没意义（因为第 <code>i</code> 天距离更近且温度更高，完全遮挡了栈顶那个日子的作用）。所以，我们可以把栈顶元素 <strong>弹出</strong>。</li><li>重复上述操作，直到栈为空或者栈顶日期的温度 <strong>大于</strong> <code>t</code>。</li><li>此时，如果栈不为空，栈顶的下标就是第 <code>i</code> 天右侧第一个比它热的日子。计算距离 <code>st[-1] - i</code> 存入结果。</li><li>最后，将当前第 <code>i</code> 天的下标入栈，因为它可能是更前面的日子的“下一个更高温度”。</li></ul></li></ol><p>通过这种方式，每个元素最多入栈一次、出栈一次，时间复杂度被优化到了 O(n)。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">        ans = [<span class="number">0</span>] * n</span><br><span class="line">        st = []  <span class="comment"># 栈，用于存储下标</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从后往前遍历 (n-1 到 0)</span></span><br><span class="line">        <span class="comment"># 这样栈里存的都是当前位置之后的一天</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            t = temperatures[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 维护单调栈：如果栈顶元素的温度 &lt;= 当前温度</span></span><br><span class="line">            <span class="comment"># 说明栈顶这天不可能是“下一个更高温度”，弹出</span></span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> t &gt;= temperatures[st[-<span class="number">1</span>]]:</span><br><span class="line">                st.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果栈不为空，说明找到了右边第一个比当前高的温度</span></span><br><span class="line">            <span class="keyword">if</span> st:</span><br><span class="line">                ans[i] = st[-<span class="number">1</span>] - i</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将当前下标入栈，供前面的元素查找</span></span><br><span class="line">            st.append(i)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;slices&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dailyTemperatures</span><span class="params">(temperatures []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(temperatures))</span><br><span class="line">    st := []<span class="type">int</span>&#123;&#125; <span class="comment">// 栈，存储下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 slices.Backward 进行倒序遍历 (Go 1.23+)</span></span><br><span class="line">    <span class="keyword">for</span> i, t := <span class="keyword">range</span> slices.Backward(temperatures) &#123;</span><br><span class="line">        <span class="comment">// 当栈不为空，且当前温度 &gt;= 栈顶下标对应的温度时</span></span><br><span class="line">        <span class="comment">// 栈顶元素对于前面的日子已经没有价值了（被当前更高的温度挡住了），弹出</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(st) &gt; <span class="number">0</span> &amp;&amp; t &gt;= temperatures[st[<span class="built_in">len</span>(st)<span class="number">-1</span>]] &#123;</span><br><span class="line">            st = st[:<span class="built_in">len</span>(st)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果栈还有元素，栈顶就是右侧第一个比当前温度高的位置</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(st) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            ans[i] = st[<span class="built_in">len</span>(st)<span class="number">-1</span>] - i</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前位置推入栈中</span></span><br><span class="line">        st = <span class="built_in">append</span>(st, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>虽然代码中包含两层循环（外层 <code>for</code> 和内层 <code>while</code>），但观察栈的操作可以发现：数组中的每个元素的下标最多被压入栈一次，也最多被弹出栈一次。因此整体操作次数是线性的。</p></li><li><p><strong>空间复杂度</strong>: <code>O(n)</code><br>我们需要一个栈来存储下标以及一个数组来存储结果。在最坏情况下（例如数组是单调递减的），栈的大小可以达到 <code>n</code>。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 739 题：&lt;a href=&quot;https://leetcode.cn/problems/daily-temperatures/&quot;&gt;每日温度&lt;/a&gt;。&lt;br&gt;问题的核心是寻找数组中每个元素右侧第一个比它大的元素。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="单调栈" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    <category term="基础" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%8D%95%E8%B0%83%E6%A0%88/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="栈" scheme="http://github.com/tags/%E6%A0%88/"/>
    
    <category term="单调栈" scheme="http://github.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 4 | 寻找两个正序数组的中位数</title>
    <link href="http://github.com/posts/leetcode-4/"/>
    <id>http://github.com/posts/leetcode-4/</id>
    <published>2025-12-05T03:30:00.000Z</published>
    <updated>2025-12-05T03:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 4 题：<a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a>。<br>题目要求算法的时间复杂度为 O(log (m+n))。通常涉及数组的题目如果要求对数级复杂度，核心思路大概率是 <strong>二分查找</strong>。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong>。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>nums1.length &#x3D;&#x3D; m</li><li>nums2.length &#x3D;&#x3D; n</li><li>0 &lt;&#x3D; m &lt;&#x3D; 1000</li><li>0 &lt;&#x3D; n &lt;&#x3D; 1000</li><li>1 &lt;&#x3D; m + n &lt;&#x3D; 2000</li><li>-10^6 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 10^6</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-核心思想：划分数组"><a href="#1-核心思想：划分数组" class="headerlink" title="1. 核心思想：划分数组"></a>1. 核心思想：划分数组</h4><p>要在两个有序数组中找到中位数，本质上是要将两个数组分别切成两部分（左半部分和右半部分），满足以下两个条件：</p><ol><li><strong>数量平衡</strong>：左半部分的总元素个数等于右半部分（或者比右半部分多 1 个）。</li><li><strong>交叉有序</strong>：左半部分的所有元素都要小于等于右半部分的所有元素。即：<code>Left_Part_Max ≤ Right_Part_Min</code>。</li></ol><h4 id="2-处理边界问题的技巧（哨兵法）"><a href="#2-处理边界问题的技巧（哨兵法）" class="headerlink" title="2. 处理边界问题的技巧（哨兵法）"></a>2. 处理边界问题的技巧（哨兵法）</h4><p>在常规解法中，处理数组下标越界（例如切分点在数组开头或结尾）是非常繁琐的。<br>本题解采用了一种巧妙的 <strong>预处理</strong> 方式：</p><ul><li>在两个数组的首尾分别加上 <strong>负无穷 (-inf)</strong> 和 <strong>正无穷 (inf)</strong>。</li><li>这样不仅避免了下标越界的判断，还保证了数组长度永远够用，逻辑更加统一。</li></ul><h4 id="3-二分查找切分点"><a href="#3-二分查找切分点" class="headerlink" title="3. 二分查找切分点"></a>3. 二分查找切分点</h4><p>我们只需要对长度较短的那个数组进行二分查找。假设我们在短数组 <code>A</code> 中切一刀，下标为 <code>i</code>，那么为了满足“数量平衡”，长数组 <code>B</code> 的切分位置 <code>j</code> 也就确定了：<code>j = (m + n + 1) / 2 - i</code></p><p>我们需要找到一个 <code>i</code>，使得 <code>A[i] ≤ B[j+1]</code> 且 <code>B[j] ≤ A[i+1]</code>。<br>由于数组是有序的，我们只需要通过二分调整 <code>i</code> 的位置即可。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedianSortedArrays</span>(<span class="params">self, a: <span class="type">List</span>[<span class="built_in">int</span>], b: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="comment"># 确保 a 是较短的数组，这样可以缩短二分查找的区间，优化性能</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(a) &gt; <span class="built_in">len</span>(b):</span><br><span class="line">            a, b = b, a</span><br><span class="line">        </span><br><span class="line">        m, n = <span class="built_in">len</span>(a), <span class="built_in">len</span>(b)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 技巧：在数组首尾添加无穷小和无穷大作为哨兵</span></span><br><span class="line">        <span class="comment"># 这样可以避免处理边界情况（如切分点在数组最左或最右侧时）</span></span><br><span class="line">        <span class="comment"># inf 表示正无穷，-inf 表示负无穷</span></span><br><span class="line">        inf = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        a = [-inf] + a + [inf]</span><br><span class="line">        b = [-inf] + b + [inf]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 二分查找的范围：在处理后的数组 a 中寻找分割点</span></span><br><span class="line">        <span class="comment"># l 和 r 是基于开区间的二分查找 (l, r)</span></span><br><span class="line">        l, r = <span class="number">0</span>, m + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 开始二分查找</span></span><br><span class="line">        <span class="comment"># 目标是找到一个位置 i，使得 a[i] &lt;= b[j+1]</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            i = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 计算 b 数组对应的分割点 j</span></span><br><span class="line">            <span class="comment"># (m + n + 1) // 2 是左半部分需要的总元素个数（不含哨兵的逻辑）</span></span><br><span class="line">            <span class="comment"># 这里的下标计算考虑了前面的哨兵位</span></span><br><span class="line">            j = (m + n + <span class="number">1</span>) // <span class="number">2</span> - i</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 判断交叉条件：a 的左侧最大值是否小于等于 b 的右侧最小值</span></span><br><span class="line">            <span class="keyword">if</span> a[i] &lt;= b[j+<span class="number">1</span>]:</span><br><span class="line">                l = i <span class="comment"># i 可能是合法的，尝试向右找更大的 i</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = i <span class="comment"># i 太大了，需要向左找</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时，l 就是我们要找的分割点 i</span></span><br><span class="line">        i = l</span><br><span class="line">        j = (m + n + <span class="number">1</span>) // <span class="number">2</span> - i</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># max1：左半部分的最大值（取 a[i] 和 b[j] 较大的那个）</span></span><br><span class="line">        max1 = <span class="built_in">max</span>(a[i], b[j])</span><br><span class="line">        <span class="comment"># min2：右半部分的最小值（取 a[i+1] 和 b[j+1] 较小的那个）</span></span><br><span class="line">        min2 = <span class="built_in">min</span>(a[i+<span class="number">1</span>], b[j+<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果总长度是奇数，中位数就是左半部分的最大值</span></span><br><span class="line">        <span class="comment"># 如果总长度是偶数，中位数是左侧最大值和右侧最小值的平均数</span></span><br><span class="line">        <span class="keyword">return</span> max1 <span class="keyword">if</span> (m + n) % <span class="number">2</span> <span class="keyword">else</span> (max1 + min2) / <span class="number">2</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="comment">// 确保 nums1 是较短的数组</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums1) &gt; <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">        nums1, nums2 = nums2, nums1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m, n := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造带哨兵的新数组</span></span><br><span class="line">    <span class="comment">// 使用 int64 的极值来模拟 inf 和 -inf</span></span><br><span class="line">    <span class="comment">// 注意：题目范围值在 -10^6 到 10^6 之间，所以使用 int 极值是安全的</span></span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, m+<span class="number">2</span>)</span><br><span class="line">    a = <span class="built_in">append</span>(a, math.MinInt) <span class="comment">// -inf</span></span><br><span class="line">    a = <span class="built_in">append</span>(a, nums1...)</span><br><span class="line">    a = <span class="built_in">append</span>(a, math.MaxInt) <span class="comment">// inf</span></span><br><span class="line"></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n+<span class="number">2</span>)</span><br><span class="line">    b = <span class="built_in">append</span>(b, math.MinInt) <span class="comment">// -inf</span></span><br><span class="line">    b = <span class="built_in">append</span>(b, nums2...)</span><br><span class="line">    b = <span class="built_in">append</span>(b, math.MaxInt) <span class="comment">// inf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找范围</span></span><br><span class="line">    l, r := <span class="number">0</span>, m+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l+<span class="number">1</span> &lt; r &#123;</span><br><span class="line">        i := (l + r) / <span class="number">2</span></span><br><span class="line">        <span class="comment">// 计算 nums2 对应的分割点 j</span></span><br><span class="line">        j := (m+n+<span class="number">1</span>)/<span class="number">2</span> - i</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查左边部分是否小于等于右边部分</span></span><br><span class="line">        <span class="keyword">if</span> a[i] &lt;= b[j+<span class="number">1</span>] &#123;</span><br><span class="line">            l = i</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i := l</span><br><span class="line">    j := (m+n+<span class="number">1</span>)/<span class="number">2</span> - i</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取左半部分的最大值</span></span><br><span class="line">    max1 := max(a[i], b[j])</span><br><span class="line">    <span class="comment">// 获取右半部分的最小值</span></span><br><span class="line">    min2 := min(a[i+<span class="number">1</span>], b[j+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据总长度奇偶性返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (m+n)%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">float64</span>(max1)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>(max1+min2) / <span class="number">2.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：求最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：求最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(log (min(m, n)))</code><br>我们只对长度较短的数组进行二分查找，循环次数与短数组长度的对数成正比。</p></li><li><p><strong>空间复杂度</strong>: <code>O(m + n)</code><br>为了简化边界判断，本解法创建了包含哨兵的新数组，使用了线性的额外空间。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 4 题：&lt;a href=&quot;https://leetcode.cn/problems/median-of-two-sorted-arrays/&quot;&gt;寻找两个正序数组的中位数&lt;/a&gt;。&lt;br&gt;题目要求算法的时间复杂度为 O(log (m+n))。通常涉及数组的题目如果要求对数级复杂度，核心思路大概率是 &lt;strong&gt;二分查找&lt;/strong&gt;。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="其他" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="分治" scheme="http://github.com/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 81 | 搜索旋转排序数组 II</title>
    <link href="http://github.com/posts/leetcode-81/"/>
    <id>http://github.com/posts/leetcode-81/</id>
    <published>2025-12-04T02:04:00.000Z</published>
    <updated>2025-12-04T02:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 81 题：<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">搜索旋转排序数组 II</a>。<br>该题难点在于数组中可能包含 <strong>重复元素</strong>，这破坏了原本二分查找中严格的单调性判断。当左右边界和中间值相等时，我们无法确定哪一半是有序的，必须退化为线性查找。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>已知存在一个按非降序排列的整数数组 <code>nums</code>，数组中的值不必互不相同。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。</p><p>例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 5 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code>。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code>，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,5,6,0,0,1,2], target = 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,5,6,0,0,1,2], target = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000</li><li>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4</li><li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li><li>-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-旋转数组的特性"><a href="#1-旋转数组的特性" class="headerlink" title="1. 旋转数组的特性"></a>1. 旋转数组的特性</h4><p>旋转后的数组会被分割成两段有序区间：</p><ol><li><strong>左半段（上半段）</strong>：数值较大，且 <code>nums[i] &gt;= nums[0]</code>。</li><li><strong>右半段（下半段）</strong>：数值较小，且 <code>nums[i] &lt;= nums[n-1]</code>。</li></ol><h4 id="2-处理重复元素（核心难点）"><a href="#2-处理重复元素（核心难点）" class="headerlink" title="2. 处理重复元素（核心难点）"></a>2. 处理重复元素（核心难点）</h4><p>在没有重复元素的第 33 题中，我们可以通过比较 <code>nums[mid]</code> 和 <code>nums[r]</code>（或 <code>nums[l]</code>）来确定 <code>mid</code> 落在左半段还是右半段。</p><p>但是，当 <code>nums[mid] == nums[r]</code> 时，我们无法区分 <code>mid</code> 是在左半段（例如 <code>[2, 2, ..., 2, 0, 1]</code>）还是在右半段（例如 <code>[2, 0, 1, 2, ..., 2]</code>）。<br>此时，唯一的办法是 <strong>缩小区间</strong>，将右边界 <code>r</code> 向左移动一位 (<code>r -= 1</code>)，跳过这个重复值，然后再继续二分。这会导致最坏情况下的时间复杂度退化为 O(N)。</p><h4 id="3-二分逻辑（check-函数）"><a href="#3-二分逻辑（check-函数）" class="headerlink" title="3. 二分逻辑（check 函数）"></a>3. 二分逻辑（check 函数）</h4><p>我们将二分判定逻辑封装在 <code>check(i)</code> 函数中，该函数用于判断 <strong>目标值 target 是否可能落在左侧区间 [l, mid] 中</strong>（即是否应该让 <code>r = mid</code>）。</p><p>判定依据如下：</p><ul><li><p><strong>Case 1: <code>nums[mid] &gt; nums[r]</code></strong><br>说明 <code>mid</code> 落在 <strong>左半段</strong>（数值较大的那一段）。</p><ul><li>如果 <code>target &gt; nums[r]</code>（说明 target 也在左半段）且 <code>nums[mid] &gt;= target</code>，则 target 在 <code>mid</code> 的左侧，我们需要向左收缩 (<code>r = mid</code>)。</li></ul></li><li><p><strong>Case 2: <code>nums[mid] &lt;= nums[r]</code></strong><br>说明 <code>mid</code> 落在 <strong>右半段</strong>（数值较小的那一段）或者区间本身是有序的。</p><ul><li>如果 <code>target &gt; nums[r]</code>，说明 target 实际上是在左半段（数值非常大），而当前 <code>mid</code> 在右半段，所以 target 肯定在 <code>mid</code> 的左侧（逻辑上的左侧，其实是回绕过去了），需要向左收缩。</li><li>或者，如果 <code>nums[mid] &gt;= target</code>，说明 target 在右半段且比 <code>mid</code> 小，也需要向左收缩。</li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>这里采用了开区间二分模板 <code>(l, r)</code>，循环条件为 <code>l + 1 &lt; r</code>。</p><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># check 函数判断是否需要向左收缩区间 (让 r = mid)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            x = nums[i]</span><br><span class="line">            <span class="comment"># 情况 1: mid 在左半段（大数值段）</span></span><br><span class="line">            <span class="comment"># 因为旋转特性，左半段的所有值都应该大于 nums[r]（除非没旋转，但逻辑通用）</span></span><br><span class="line">            <span class="keyword">if</span> x &gt; nums[r]:</span><br><span class="line">                <span class="comment"># 如果 target 也在左半段 (target &gt; nums[r]) 并且 target 小于等于 x</span></span><br><span class="line">                <span class="comment"># 说明 target 在 [l...mid] 范围内</span></span><br><span class="line">                <span class="keyword">return</span> target &gt; nums[r] <span class="keyword">and</span> x &gt;= target</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情况 2: mid 在右半段（小数值段）</span></span><br><span class="line">            <span class="comment"># 此时我们要找的情况是：什么时候 target 会在 mid 的左边？</span></span><br><span class="line">            <span class="comment"># 1. target 实际上在左半段 (target &gt; nums[r])，而 mid 在右半段，所以 target 在 mid 左侧</span></span><br><span class="line">            <span class="comment"># 2. target 在右半段，且 x &gt;= target，说明 target 在 [l...mid] 范围内</span></span><br><span class="line">            <span class="keyword">return</span> target &gt; nums[r] <span class="keyword">or</span> x &gt;= target</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 定义二分查找的左右边界（开区间写法）</span></span><br><span class="line">        <span class="comment"># l 是左边界的左侧一位，r 是右边界</span></span><br><span class="line">        l, r = -<span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 核心去重逻辑：</span></span><br><span class="line">            <span class="comment"># 如果中点值等于右边界值，无法判断在左段还是右段</span></span><br><span class="line">            <span class="comment"># 只能线性排除右边界</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == nums[r]:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果 check 返回 True，说明 target 可能在左侧，收缩右边界</span></span><br><span class="line">            <span class="keyword">elif</span> check(mid):</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="comment"># 否则，target 在右侧，收缩左边界</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid</span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 循环结束后，r 指向的位置就是可能的答案</span></span><br><span class="line">        <span class="comment"># 检查 nums[r] 是否等于 target</span></span><br><span class="line">        <span class="keyword">return</span> nums[r] == target</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 定义 check 函数 logic</span></span><br><span class="line">    <span class="comment">// 返回 true 表示 target 可能在 [l, mid] 范围内，需要 r = mid</span></span><br><span class="line">    check := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, r <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        x := nums[i]</span><br><span class="line">        <span class="comment">// Case 1: mid 在左半段 (值较大的一侧)</span></span><br><span class="line">        <span class="keyword">if</span> x &gt; nums[r] &#123;</span><br><span class="line">            <span class="comment">// target 必须也在左半段，且小于等于 mid 的值</span></span><br><span class="line">            <span class="keyword">return</span> target &gt; nums[r] &amp;&amp; x &gt;= target</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Case 2: mid 在右半段 (值较小的一侧)</span></span><br><span class="line">        <span class="comment">// 满足以下任一条件则说明 target 在 mid 的左侧：</span></span><br><span class="line">        <span class="comment">// 1. target &gt; nums[r]: target 实际上在左半段，而 mid 在右半段</span></span><br><span class="line">        <span class="comment">// 2. x &gt;= target: target 在右半段且小于等于 mid</span></span><br><span class="line">        <span class="keyword">return</span> target &gt; nums[r] || x &gt;= target</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化左右指针，使用开区间 (l, r] 的思路</span></span><br><span class="line">    <span class="comment">// l 初始为 -1, r 初始为 len-1</span></span><br><span class="line">    l, r := <span class="number">-1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l+<span class="number">1</span> &lt; r &#123;</span><br><span class="line">        mid := l + (r-l)/<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 mid 和 r 指向的值相同，无法判断区间有序性</span></span><br><span class="line">        <span class="comment">// 此时只能将 r 向左移动一位，退化为线性操作</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == nums[r] &#123;</span><br><span class="line">            r--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> check(mid, r) &#123;</span><br><span class="line">            <span class="comment">// 满足 check 条件，说明 target 在左侧，移动 r</span></span><br><span class="line">            r = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则 target 在右侧，移动 l</span></span><br><span class="line">            l = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终检查 r 指向的位置是否为 target</span></span><br><span class="line">    <span class="comment">// 注意：如果是空数组或越界情况需额外处理，但题目保证 1 &lt;= nums.length</span></span><br><span class="line">    <span class="keyword">return</span> nums[r] == target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>:<ul><li><strong>平均情况</strong>: <code>O(log N)</code>。当数组中重复元素较少时，主要进行二分查找。</li><li><strong>最坏情况</strong>: <code>O(N)</code>。当数组中包含大量重复元素（例如 <code>[1, 1, 1, ..., 1]</code>）时，每次 <code>nums[mid] == nums[r]</code> 都会导致 <code>r</code> 仅减小 1，退化为线性遍历。</li></ul></li><li><strong>空间复杂度</strong>: <code>O(1)</code>。仅使用了常数个变量存储指针和中间值。</li></ul><pre><code></code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 81 题：&lt;a href=&quot;https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/&quot;&gt;搜索旋转排序数组 II&lt;/a&gt;。&lt;br&gt;该题难点在于数组中可能包含 &lt;strong&gt;重复元素&lt;/strong&gt;，这破坏了原本二分查找中严格的单调性判断。当左右边界和中间值相等时，我们无法确定哪一半是有序的，必须退化为线性查找。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="其他" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 154 | 寻找旋转排序数组中的最小值 II</title>
    <link href="http://github.com/posts/leetcode-154/"/>
    <id>http://github.com/posts/leetcode-154/</id>
    <published>2025-12-03T01:36:00.000Z</published>
    <updated>2025-12-03T01:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 154 题：<a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">寻找旋转排序数组中的最小值 II</a>。<br>该题难点在于数组中可能存在 <strong>重复元素</strong>。这破坏了二分查找原本严格的单调性，使得我们需要特殊处理相等的情况。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 1 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。<br>例如，原数组 <code>nums = [0,1,4,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 4 次，则可以得到 <code>[4,5,6,7,0,1,4]</code></li><li>若旋转 7 次，则可以得到 <code>[0,1,4,4,5,6,7]</code></li></ul><p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>nums</code>，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong>。</p><p>你必须尽可能减少整个过程的操作步骤。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,5]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li><li><code>nums</code>原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-旋转数组的性质"><a href="#1-旋转数组的性质" class="headerlink" title="1. 旋转数组的性质"></a>1. 旋转数组的性质</h4><p>旋转排序数组（Rotated Sorted Array）通常可以看作是被分割成了两个有序的子数组。例如 <code>[4,5,6,7,0,1,2]</code>，左半部分 <code>[4,5,6,7]</code> 和右半部分 <code>[0,1,2]</code> 都是有序的，且右半部分的元素通常小于等于左半部分的元素（除非未旋转）。最小值就是右半部分的第一个元素。</p><h4 id="2-二分查找策略"><a href="#2-二分查找策略" class="headerlink" title="2. 二分查找策略"></a>2. 二分查找策略</h4><p>我们的目标是找到旋转点（最小值）。在标准的二分查找中（没有重复元素），我们通常比较 <code>nums[mid]</code> 和 <code>nums[right]</code>：</p><ul><li>如果 <code>nums[mid] &lt; nums[right]</code>：说明 <code>mid</code> 到 <code>right</code> 这部分是有序的，最小值肯定在 <code>mid</code> 左边或者就是 <code>mid</code> 自己。因此区间缩小为 <code>[left, mid]</code>。</li><li>如果 <code>nums[mid] &gt; nums[right]</code>：说明 <code>mid</code> 处于左半段较大的有序部分，最小值一定在 <code>mid</code> 的右边。因此区间缩小为 <code>[mid + 1, right]</code>。</li></ul><h4 id="3-处理重复元素"><a href="#3-处理重复元素" class="headerlink" title="3. 处理重复元素"></a>3. 处理重复元素</h4><p>本题的难点在于 <strong>重复元素</strong>，即 <code>nums[mid] == nums[right]</code> 的情况。<br>例如：</p><ul><li>情况 A: <code>[1, 0, 1, 1, 1]</code>，<code>mid</code> 为 2，<code>nums[mid] = 1</code>，<code>nums[right] = 1</code>。最小值 0 在左边。</li><li>情况 B: <code>[1, 1, 1, 0, 1]</code>，<code>mid</code> 为 2，<code>nums[mid] = 1</code>，<code>nums[right] = 1</code>。最小值 0 在右边。</li></ul><p>当 <code>nums[mid] == nums[right]</code> 时，我们无法判断最小值是在 <code>mid</code> 的左边还是右边。<br>但是，由于 <code>nums[mid]</code> 和 <code>nums[right]</code> 相等，我们可以确定的是：<strong>哪怕我们忽略掉 <code>nums[right]</code> 这个位置，最小值的候选人 <code>nums[mid]</code> 依然保留在搜索范围内</strong>。<br>所以，安全的做法是将右边界 <code>right</code> 向左移动一位（<code>right--</code>），逐步缩小范围，直到打破相等的状态。</p><h4 id="4-开区间二分法"><a href="#4-开区间二分法" class="headerlink" title="4. 开区间二分法"></a>4. 开区间二分法</h4><p>在提供的代码中，使用的是 <code>(l, r)</code> 开区间（或者说 <code>l</code> 是非解集边界，<code>r</code> 是解集边界）的写法：</p><ul><li><code>l</code> 初始化为 <code>-1</code>。</li><li><code>r</code> 初始化为 <code>len(nums) - 1</code>。</li><li>循环条件 <code>l + 1 &lt; r</code>。</li><li>最终返回 <code>nums[r]</code>。</li></ul><p>这种写法下，<code>r</code> 始终指向“可能是最小值”的位置，而 <code>l</code> 指向“必定不是最小值”或“旋转点左侧的大值部分”的位置。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化左右指针</span></span><br><span class="line">        <span class="comment"># 采用开区间写法，l 初始为 -1，r 初始为最后一个元素下标</span></span><br><span class="line">        l, r = -<span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当 l 和 r 相邻时停止循环，此时 r 指向最小值</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = (r + l) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情况 1: 中间值等于右边界值</span></span><br><span class="line">            <span class="comment"># 无法确定最小值在左还是右，但由于 nums[mid] == nums[r]，</span></span><br><span class="line">            <span class="comment"># 我们可以安全地排除 nums[r]，因为即使它是最小值，nums[mid] 还在范围内</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == nums[r]:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情况 2: 中间值小于右边界值</span></span><br><span class="line">            <span class="comment"># 说明 mid 到 r 区间是有序的（未旋转或旋转点在 mid 左侧）</span></span><br><span class="line">            <span class="comment"># 最小值可能是 mid 自己，或者是 mid 左边的元素</span></span><br><span class="line">            <span class="comment"># 收缩右边界到 mid</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; nums[r]:</span><br><span class="line">                r = mid</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情况 3: 中间值大于右边界值</span></span><br><span class="line">            <span class="comment"># 说明 mid 在左半段较大的有序区间内</span></span><br><span class="line">            <span class="comment"># 最小值一定在 mid 的右侧</span></span><br><span class="line">            <span class="comment"># 收缩左边界到 mid</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid</span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 循环结束时，r 指向最小值的位置</span></span><br><span class="line">        <span class="keyword">return</span> nums[r]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化左右指针</span></span><br><span class="line">    <span class="comment">// l 表示左边界（不包含），r 表示右边界（包含）</span></span><br><span class="line">    l, r := <span class="number">-1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保持 l 和 r 之间至少有一个元素</span></span><br><span class="line">    <span class="keyword">for</span> l+<span class="number">1</span> &lt; r &#123;</span><br><span class="line">        mid := l + (r-l)/<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 情况 1: 遇到重复元素</span></span><br><span class="line">        <span class="comment">// 无法判断最小值方位，只能线性缩减右边界</span></span><br><span class="line">        <span class="comment">// 这是一个安全操作，因为 nums[mid] 和 nums[r] 值相同</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == nums[r] &#123;</span><br><span class="line">            r--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; nums[r] &#123;</span><br><span class="line">            <span class="comment">// 情况 2: 右半部分有序</span></span><br><span class="line">            <span class="comment">// 最小值在 [l+1, mid] 范围内（包括 mid）</span></span><br><span class="line">            r = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 情况 3: nums[mid] &gt; nums[r]</span></span><br><span class="line">            <span class="comment">// 左半部分有序且值较大，最小值肯定在右边</span></span><br><span class="line">            <span class="comment">// 最小值在 [mid+1, r] 范围内</span></span><br><span class="line">            l = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// r 最终停留在最小值的索引上</span></span><br><span class="line">    <span class="keyword">return</span> nums[r]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>:<ul><li><strong>平均情况</strong>: <code>O(log n)</code>。当数组中重复元素较少时，主要逻辑类似于二分查找。</li><li><strong>最坏情况</strong>: <code>O(n)</code>。当数组中包含大量重复元素（例如 <code>[1, 1, 1, 1]</code>）时，每次循环只能将 <code>r</code> 减少 1，退化为线性查找。</li></ul></li><li><strong>空间复杂度</strong>: <code>O(1)</code>。只使用了常数个变量。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 154 题：&lt;a href=&quot;https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/&quot;&gt;寻找旋转排序数组中的最小值 II&lt;/a&gt;。&lt;br&gt;该题难点在于数组中可能存在 &lt;strong&gt;重复元素&lt;/strong&gt;。这破坏了二分查找原本严格的单调性，使得我们需要特殊处理相等的情况。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="其他" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1901 | 寻找峰值 II</title>
    <link href="http://github.com/posts/leetcode-1901/"/>
    <id>http://github.com/posts/leetcode-1901/</id>
    <published>2025-12-02T11:20:00.000Z</published>
    <updated>2025-12-02T11:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1901 题：<a href="https://leetcode.cn/problems/find-a-peak-element-ii/">寻找峰值 II</a>。<br>题目要求时间复杂度为 O(m log n) 或 O(n log m)，这提示我们需要在一个维度上进行二分查找，在另一个维度上进行线性扫描。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>一个 2D 网格中的 <strong>峰值</strong> 是指那些 <strong>严格大于</strong> 其相邻格子(上、下、左、右)的元素。</p><p>给你一个 从 0 开始编号 的 <code>m x n</code> 矩阵 <code>mat</code> ，其中任意两个相邻格子的值都 <strong>不相同</strong> 。找出 <strong>任意一个</strong> 峰值 <code>mat[i][j]</code> 并 返回其位置 <code>[i,j]</code> 。</p><p>你可以假设整个矩阵周边环绕着一圈值为 -1 的格子。</p><p><strong>示例 1:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: mat = [[1,4],[3,2]]</span><br><span class="line">输出: [0,1]</span><br><span class="line">解释: 3 和 4 都是峰值，所以[1,0]和[0,1]都是可接受的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: mat = [[10,20,15],[21,30,14],[7,16,32]]</span><br><span class="line">输出: [1,1]</span><br><span class="line">解释: 30 和 32 都是峰值，所以[1,1]和[2,2]都是可接受的答案。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>m &#x3D;&#x3D; mat.length</li><li>n &#x3D;&#x3D; mat[i].length</li><li>1 &lt;&#x3D; m, n &lt;&#x3D; 500</li><li>1 &lt;&#x3D; mat[i][j] &lt;&#x3D; 10^5</li><li>任意两个相邻元素均不相等</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-为什么不能暴力遍历？"><a href="#1-为什么不能暴力遍历？" class="headerlink" title="1. 为什么不能暴力遍历？"></a>1. 为什么不能暴力遍历？</h4><p>如果直接遍历整个矩阵寻找峰值，时间复杂度是 O(m * n)。虽然对于 500x500 的数据规模来说可以通过，但题目明确要求 O(m log n) 或 O(n log m) 的复杂度，这意味着我们必须利用二分查找的思想。</p><h4 id="2-行二分查找策略"><a href="#2-行二分查找策略" class="headerlink" title="2. 行二分查找策略"></a>2. 行二分查找策略</h4><p>我们可以对 <strong>行</strong> 进行二分查找，具体步骤如下：</p><ol><li><strong>二分行号</strong>：在行索引 <code>0</code> 到 <code>m-1</code> 之间进行二分，设当前中间行为 <code>i</code>。</li><li><strong>寻找行最大值</strong>：在第 <code>i</code> 行中找到最大值 <code>mat[i][j]</code>。<ul><li>为什么找行最大值？因为如果一个位置是该行的最大值，那么它一定严格大于它的左边和右边（如果存在）。此时要判断它是不是峰值，只需要看它的 <strong>上</strong> 和 <strong>下</strong> 两个邻居。</li></ul></li><li><strong>比较相邻行</strong>：将 <code>mat[i][j]</code> 与它下方的元素 <code>mat[i+1][j]</code> 进行比较：<ul><li><strong>情况 A</strong>：<code>mat[i][j] &gt; mat[i+1][j]</code>。<br>说明从第 <code>i</code> 行往下走是“下坡”。根据爬坡理论，如果我们往数值大的方向走一定能找到峰值。既然下方变小了，说明峰值不可能在下方（或者说上方一定存在一个峰值，可能是 <code>mat[i][j]</code> 自己，也可能是更上面的某处）。因此，我们可以舍弃 <code>i</code> 下面的所有行，将搜索范围缩小到上这半部分（包含第 <code>i</code> 行）。</li><li><strong>情况 B</strong>：<code>mat[i][j] &lt; mat[i+1][j]</code>。<br>说明从第 <code>i</code> 行往下走是“上坡”。这意味着第 <code>i</code> 行肯定不是峰值所在行（因为有个邻居比它大），且下方一定存在一个峰值。因此，我们将搜索范围缩小到 <code>i</code> 的下方。</li></ul></li></ol><h4 id="3-算法复杂度"><a href="#3-算法复杂度" class="headerlink" title="3. 算法复杂度"></a>3. 算法复杂度</h4><ul><li><strong>二分过程</strong>：我们对行号 <code>0</code> 到 <code>m-1</code> 进行二分，次数为 O(log m)。</li><li><strong>查找最大值</strong>：每次二分内部，我们需要遍历当前行的 <code>n</code> 个元素找到最大值，耗时 O(n)。</li><li><strong>总复杂度</strong>：O(n log m)。这完全符合题目要求。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findPeakGrid</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 二分查找的上下界</span></span><br><span class="line">        <span class="comment"># 采用开区间写法 (l, r)，l 和 r 分别是这一轮不可能的边界和可能的边界</span></span><br><span class="line">        <span class="comment"># 初始 l = -1 (假想的上边界), r = len(mat) - 1 (最后一行索引)</span></span><br><span class="line">        l, r = -<span class="number">1</span>, <span class="built_in">len</span>(mat) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当 l + 1 &lt; r 时，说明区间内至少还有一个待检查的元素</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            <span class="comment"># 取中间行</span></span><br><span class="line">            i = (l + r) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 找到第 i 行的最大值</span></span><br><span class="line">            <span class="comment"># 时间复杂度 O(n)</span></span><br><span class="line">            mx = <span class="built_in">max</span>(mat[i])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 找到最大值所在的列索引</span></span><br><span class="line">            j = mat[i].index(mx)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 比较当前行最大值与下一行对应位置的值</span></span><br><span class="line">            <span class="comment"># 如果当前行最大值 &gt; 下一行对应值，说明峰值在当前行或上方</span></span><br><span class="line">            <span class="comment"># 注意：i 是二分的中点，由于 l+1 &lt; r，i 至少比 r 小 1，</span></span><br><span class="line">            <span class="comment"># 只有当 len(mat) &gt; 1 时才会进入循环，此时 i+1 不会越界</span></span><br><span class="line">            <span class="comment"># 实际上若只有一行，循环不执行，直接返回第0行结果</span></span><br><span class="line">            <span class="keyword">if</span> mx &gt; mat[i+<span class="number">1</span>][j]:</span><br><span class="line">                r = i  <span class="comment"># 峰值行号 &lt;= i，缩小右边界</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = i  <span class="comment"># 峰值行号 &gt; i，缩小左边界（mat[i][j] &lt; mat[i+1][j]）</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 循环结束后，r 指向满足条件的行</span></span><br><span class="line">        <span class="comment"># 重新找到该行的最大值位置并返回</span></span><br><span class="line">        <span class="keyword">return</span> [r, mat[r].index(<span class="built_in">max</span>(mat[r]))]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findPeakGrid</span><span class="params">(mat [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化二分查找的上下边界</span></span><br><span class="line">    <span class="comment">// left 为开区间左边界（不包含），right 为闭区间右边界（包含）</span></span><br><span class="line">    left, right := <span class="number">-1</span>, <span class="built_in">len</span>(mat)<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开区间二分查找模板</span></span><br><span class="line">    <span class="keyword">for</span> left+<span class="number">1</span> &lt; right &#123;</span><br><span class="line">        <span class="comment">// 计算中间行索引</span></span><br><span class="line">        i := left + (right-left)/<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到第 i 行最大值的列索引 j</span></span><br><span class="line">        j := indexOfMax(mat[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 比较当前值与它下方邻居的值</span></span><br><span class="line">        <span class="comment">// 注意：由于是向下取整且 left+1 &lt; right，i+1 不会越界</span></span><br><span class="line">        <span class="keyword">if</span> mat[i][j] &gt; mat[i+<span class="number">1</span>][j] &#123;</span><br><span class="line">            right = i <span class="comment">// 当前值更大，说明峰值可能在第 i 行或其上方</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = i <span class="comment">// 下方值更大，说明第 i 行不是峰值行，峰值在下方</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// right 最终指向峰值所在的行</span></span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;right, indexOfMax(mat[right])&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：返回切片中最大值的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexOfMax</span><span class="params">(a []<span class="type">int</span>)</span></span> (idx <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">        <span class="keyword">if</span> x &gt; a[idx] &#123;</span><br><span class="line">            idx = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n log m)</code><br>我们需要对 <code>m</code> 行进行二分查找，这需要 <code>log m</code> 次迭代。在每一次迭代中，我们需要遍历一行 <code>n</code> 个元素来找到最大值。因此总的时间复杂度是 <code>n * log m</code>。</p></li><li><p><strong>空间复杂度</strong>: <code>O(1)</code><br>我们只使用了常数个变量（如 <code>left</code>, <code>right</code>, <code>i</code>, <code>mx</code> 等）来存储状态，不需要额外的存储空间（除了输入矩阵本身）。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1901 题：&lt;a href=&quot;https://leetcode.cn/problems/find-a-peak-element-ii/&quot;&gt;寻找峰值 II&lt;/a&gt;。&lt;br&gt;题目要求时间复杂度为 O(m log n) 或 O(n log m)，这提示我们需要在一个维度上进行二分查找，在另一个维度上进行线性扫描。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="其他" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="矩阵" scheme="http://github.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 74 | 搜索二维矩阵</title>
    <link href="http://github.com/posts/leetcode-74/"/>
    <id>http://github.com/posts/leetcode-74/</id>
    <published>2025-12-01T01:32:00.000Z</published>
    <updated>2025-12-01T01:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 74 题：<a href="https://leetcode.cn/problems/search-a-2d-matrix/">搜索二维矩阵</a>。<br>利用矩阵“行首大于前一行行尾”的特性，将其逻辑上展开为一个有序的一维数组，直接使用二分查找即可解决。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p><ol><li>每行中的整数从左到右按非严格递增顺序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ol><p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong><br><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt="示例1"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>m &#x3D;&#x3D; matrix.length</li><li>n &#x3D;&#x3D; matrix[i].length</li><li>1 &lt;&#x3D; m, n &lt;&#x3D; 100</li><li>-10^4 &lt;&#x3D; matrix[i][j], target &lt;&#x3D; 10^4</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-矩阵特性分析"><a href="#1-矩阵特性分析" class="headerlink" title="1. 矩阵特性分析"></a>1. 矩阵特性分析</h4><p>题目给出的两个条件非常关键：</p><ul><li>行内递增。</li><li>下一行的第一个元素大于上一行的最后一个元素。</li></ul><p>这意味着，如果我们把每一行首尾相连拼接起来，这个矩阵在逻辑上就是一个<strong>严格单调递增的一维数组</strong>。</p><p>例如矩阵：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[1, 3, 5, 7],</span><br><span class="line"> [10, 11, 16, 20],</span><br><span class="line"> [23, 30, 34, 60]]</span><br></pre></td></tr></table></figure><p>展开后变为：<br><code>[1, 3, 5, 7, 10, 11, 16, 20, 23, 30, 34, 60]</code></p><h4 id="2-坐标映射"><a href="#2-坐标映射" class="headerlink" title="2. 坐标映射"></a>2. 坐标映射</h4><p>既然可以看作一维数组，我们就可以直接对在这个逻辑一维数组上进行<strong>二分查找</strong>。</p><p>假设矩阵有 <code>m</code> 行 <code>n</code> 列，总元素个数为 <code>m * n</code>。<br>对于范围在 <code>[0, m * n - 1]</code> 内的一维数组索引 <code>idx</code>，可以通过以下公式映射回二维矩阵的坐标 <code>(row, col)</code>：</p><ul><li><code>row = idx / n</code> (整除)</li><li><code>col = idx % n</code> (取模)</li></ul><h4 id="3-二分查找实现"><a href="#3-二分查找实现" class="headerlink" title="3. 二分查找实现"></a>3. 二分查找实现</h4><p>我们使用左开右开区间 <code>(l, r)</code> 的二分模板：</p><ul><li>初始左边界 <code>l = -1</code></li><li>初始右边界 <code>r = m * n</code></li><li>当 <code>l + 1 &lt; r</code> 时循环，计算 <code>mid</code>，映射坐标取值并与 <code>target</code> 比较。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 获取矩阵的行数 m 和列数 n</span></span><br><span class="line">        m,n=<span class="built_in">len</span>(matrix),<span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将二维矩阵视为长度为 m*n 的一维有序数组</span></span><br><span class="line">        <span class="comment"># 定义二分查找的区间为左开右开 (-1, m*n)</span></span><br><span class="line">        l,r = -<span class="number">1</span>,m*n</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l+<span class="number">1</span>&lt;r:</span><br><span class="line">            mid= (l+r)//<span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 核心步骤：坐标映射</span></span><br><span class="line">            <span class="comment"># 将一维索引 mid 转换为二维坐标 [row][col]</span></span><br><span class="line">            <span class="comment"># 行索引 = mid // 列数</span></span><br><span class="line">            <span class="comment"># 列索引 = mid % 列数</span></span><br><span class="line">            x = matrix[mid//n][mid%n]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> x==target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 标准二分逻辑</span></span><br><span class="line">            <span class="keyword">if</span> x&lt;target:</span><br><span class="line">                <span class="comment"># 目标值在右侧（较大值方向）</span></span><br><span class="line">                l=mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 目标值在左侧（较小值方向）</span></span><br><span class="line">                r = mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 获取矩阵维度</span></span><br><span class="line">    m,n:=<span class="built_in">len</span>(matrix),<span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化二分查找的左右边界</span></span><br><span class="line">    <span class="comment">// 使用开区间 (-1, m*n)，对应虚拟一维数组的索引范围</span></span><br><span class="line">    l,r:=<span class="number">-1</span>,m*n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> l+<span class="number">1</span>&lt;r&#123;</span><br><span class="line">        mid :=l+(r-l)/<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 坐标转换：将一维索引 mid 映射回二维矩阵坐标</span></span><br><span class="line">        <span class="comment">// 行下标 = mid / 列数</span></span><br><span class="line">        <span class="comment">// 列下标 = mid % 列数</span></span><br><span class="line">        x:=matrix[mid/n][mid%n]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> x==target&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> x&lt;target&#123;</span><br><span class="line">            <span class="comment">// 当前值小于目标值，说明目标在右半部分，移动左边界</span></span><br><span class="line">            l = mid</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 当前值大于目标值，说明目标在左半部分，移动右边界</span></span><br><span class="line">            r = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(log(mn))</code><br>我们将二维矩阵视作长度为 <code>mn</code> 的一维数组进行二分查找，每次比较操作大大缩小搜索范围，时间复杂度为对数级别。</p></li><li><p><strong>空间复杂度</strong>: <code>O(1)</code><br>只使用了常数个变量（<code>l</code>, <code>r</code>, <code>mid</code>, <code>x</code> 等）来存储索引和中间值，没有使用额外的线性空间。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 74 题：&lt;a href=&quot;https://leetcode.cn/problems/search-a-2d-matrix/&quot;&gt;搜索二维矩阵&lt;/a&gt;。&lt;br&gt;利用矩阵“行首大于前一行行尾”的特性，将其逻辑上展开为一个有序的一维数组，直接使用二分查找即可解决。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="其他" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="矩阵" scheme="http://github.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1515 | 服务中心的最佳位置</title>
    <link href="http://github.com/posts/leetcode-1515/"/>
    <id>http://github.com/posts/leetcode-1515/</id>
    <published>2025-12-01T01:10:00.000Z</published>
    <updated>2025-12-01T01:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1515 题：<a href="https://leetcode.cn/problems/best-position-for-a-service-centre/">服务中心的最佳位置</a>。<br>我们需要找到一个点，使其到所有给定点的欧几里得距离之和最小。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>一家快递公司希望在新城市建立新的服务中心。公司统计了该城市所有客户在二维地图上的坐标 <code>positions</code>，其中 <code>positions[i] = [xi, yi]</code>。</p><p>请你为服务中心选址 <code>[xcentre, ycentre]</code>，使服务中心到所有客户的 <strong>欧几里得距离的总和最小</strong>。</p><p>返回该最小距离总和。答案与真实值误差在 <code>10^-5</code> 之内的将被视作正确答案。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：positions = [[0,1],[1,0],[1,2],[2,1]]</span><br><span class="line">输出：4.00000</span><br><span class="line">解释：选 [1, 1] 作为新中心的位置，到每个客户的距离都是 1，总和为 4。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-几何重心-vs-几何中位数"><a href="#1-几何重心-vs-几何中位数" class="headerlink" title="1. 几何重心 vs 几何中位数"></a>1. 几何重心 vs 几何中位数</h4><ul><li><strong>几何重心（Centroid）</strong>：是所有点坐标的平均值 <code>(sum(x)/n, sum(y)/n)</code>。它最小化的是到所有点的<strong>距离平方和</strong>。</li><li><strong>几何中位数（Geometric Median）</strong>：最小化的是到所有点的<strong>欧几里得距离之和</strong>。</li></ul><p>本题要求的是后者。不幸的是，当点的数量 <code>n &gt; 4</code> 时，不存在通用的封闭公式（即无法直接用公式算出来）。我们需要使用<strong>迭代近似</strong>的方法。</p><h4 id="2-凸函数的性质"><a href="#2-凸函数的性质" class="headerlink" title="2. 凸函数的性质"></a>2. 凸函数的性质</h4><p>目标函数 <code>f(x, y) = Σ sqrt((xi-x)^2 + (yi-y)^2)</code> 是一个<strong>凸函数</strong>。<br>这意味着：</p><ol><li>它形状像一个碗，只有一个最低点（局部最小值即全局最小值）。</li><li>我们可以使用**梯度下降（Gradient Descent）<strong>或</strong>爬山法（Hill Climbing）**等迭代算法，从任意初始点出发，一步步逼近最低点。</li></ol><h4 id="3-求解方法"><a href="#3-求解方法" class="headerlink" title="3. 求解方法"></a>3. 求解方法</h4><ul><li><strong>Python (SciPy)</strong>: 题目允许使用数值优化库，Python 的 <code>scipy.optimize</code> 模块提供了现成的最小化函数求解器，非常适合处理这类非线性优化问题。</li><li><strong>Go (手动迭代)</strong>: 由于标准库通常不包含此类高级数学优化器，我们可以手写一个简单的<strong>步长衰减法</strong>（类似梯度下降或三分法的变种）：<ol><li><strong>初始化</strong>：将中心点设为所有点的重心（平均值），这是一个很好的起始猜测。</li><li><strong>迭代</strong>：尝试向 上、下、左、右 四个方向移动。</li><li><strong>贪心策略</strong>：如果移动后的新位置能使总距离变小，就更新中心点到新位置。</li><li><strong>衰减步长</strong>：如果四个方向都不能使距离变小，说明当前步长太大，需要减小步长（例如除以 2）以进行微调。</li><li><strong>终止</strong>：当步长非常小（如小于 <code>1e-7</code>）时停止。</li></ol></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> dist</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMinDistSum</span>(<span class="params">self, positions: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="comment"># 使用 SciPy 的 minimize 函数进行数值优化</span></span><br><span class="line">        <span class="comment"># minimize 寻找目标函数的最小值</span></span><br><span class="line">        <span class="comment"># 参数 1: lambda t ... : 目标函数。输入是点 t (x, y)，输出是 t 到所有 positions 的欧几里得距离之和</span></span><br><span class="line">        <span class="comment"># 参数 2: (0, 0) : 初始猜测值 (x0, y0)。虽然重心是更好的猜测，但 (0,0) 对于凸函数也能收敛</span></span><br><span class="line">        <span class="comment"># 返回值: minimize 返回一个对象，[&#x27;fun&#x27;] 属性包含了目标函数的最小值</span></span><br><span class="line">        <span class="keyword">return</span> minimize(<span class="keyword">lambda</span> t: <span class="built_in">sum</span>([dist(p, t) <span class="keyword">for</span> p <span class="keyword">in</span> positions]), (<span class="number">0</span>, <span class="number">0</span>))[<span class="string">&#x27;fun&#x27;</span>]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMinDistSum</span><span class="params">(positions [][]<span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="comment">// 辅助函数：计算点 (xc, yc) 到所有点的欧几里得距离之和</span></span><br><span class="line">    getSum := <span class="function"><span class="keyword">func</span><span class="params">(xc, yc <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">        sum := <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> _, pos := <span class="keyword">range</span> positions &#123;</span><br><span class="line">            <span class="comment">// dist = sqrt((x1-x2)^2 + (y1-y2)^2)</span></span><br><span class="line">            sum += math.Sqrt(math.Pow(<span class="type">float64</span>(pos[<span class="number">0</span>])-xc, <span class="number">2</span>) + math.Pow(<span class="type">float64</span>(pos[<span class="number">1</span>])-yc, <span class="number">2</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 初始化中心点 (x, y) 为几何重心（平均值）</span></span><br><span class="line">    <span class="comment">// 这是一个很好的起始位置，比 (0,0) 更接近答案</span></span><br><span class="line">    x, y := <span class="number">0.0</span>, <span class="number">0.0</span></span><br><span class="line">    n := <span class="type">float64</span>(<span class="built_in">len</span>(positions))</span><br><span class="line">    <span class="keyword">for</span> _, pos := <span class="keyword">range</span> positions &#123;</span><br><span class="line">        x += <span class="type">float64</span>(pos[<span class="number">0</span>])</span><br><span class="line">        y += <span class="type">float64</span>(pos[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    x /= n</span><br><span class="line">    y /= n</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 迭代参数设置</span></span><br><span class="line">    <span class="comment">// 初始步长，由于坐标范围是 0-100，步长设为 1 比较合理</span></span><br><span class="line">    step := <span class="number">1.0</span> </span><br><span class="line">    <span class="comment">// 精度控制，题目要求 10^-5，我们设置得更小一点以保证准确度</span></span><br><span class="line">    epsilon := <span class="number">1e-7</span> </span><br><span class="line">    <span class="comment">// 衰减率，每次无法移动时步长缩小的比例</span></span><br><span class="line">    decay := <span class="number">0.5</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义四个移动方向：左、右、下、上</span></span><br><span class="line">    dirs := [<span class="number">4</span>][<span class="number">2</span>]<span class="type">float64</span>&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前的最小距离和</span></span><br><span class="line">    minDist := getSum(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 开始迭代，直到步长小于阈值</span></span><br><span class="line">    <span class="keyword">for</span> step &gt; epsilon &#123;</span><br><span class="line">        foundBetter := <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试往四个方向走一步</span></span><br><span class="line">        <span class="keyword">for</span> _, d := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">            nx := x + d[<span class="number">0</span>]*step</span><br><span class="line">            ny := y + d[<span class="number">1</span>]*step</span><br><span class="line">            </span><br><span class="line">            newDist := getSum(nx, ny)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果新位置的距离和更小，则移动中心点</span></span><br><span class="line">            <span class="keyword">if</span> newDist &lt; minDist &#123;</span><br><span class="line">                minDist = newDist</span><br><span class="line">                x = nx</span><br><span class="line">                y = ny</span><br><span class="line">                foundBetter = <span class="literal">true</span></span><br><span class="line">                <span class="comment">// 这里可以选择 break 也可以不 break</span></span><br><span class="line">                <span class="comment">// 不 break 意味着一轮可能移动多次，通常不 break 收敛更快</span></span><br><span class="line">                <span class="keyword">break</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果四个方向都不能优化结果，说明当前步长太大，需要缩小步长</span></span><br><span class="line">        <span class="keyword">if</span> !foundBetter &#123;</span><br><span class="line">            step *= decay</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minDist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>:<ul><li><strong>Python</strong>: 取决于 SciPy 内部优化算法（通常是 BFGS 或类似算法），一般迭代次数不多。</li><li><strong>Go</strong>: <code>O(N * K)</code>，其中 <code>N</code> 是点的数量，<code>K</code> 是迭代次数。迭代次数与 <code>step</code> 从 1 衰减到 <code>1e-7</code> 的过程有关，约为 <code>log(1/epsilon)</code>。由于目标函数是凸的，收敛速度非常快。</li></ul></li><li><strong>空间复杂度</strong>: <code>O(1)</code>，只需要常数级别的变量存储坐标和距离。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>Python 环境</strong>: <code>scipy</code> 是第三方科学计算库，在标准的 LeetCode 在线环境中<strong>通常不可用</strong>（除非是特定的支持全库的比赛环境）。Python 解法在本地环境或支持 <code>scipy</code> 的 OJ 上非常方便，但在标准 LeetCode 环境下，建议使用类似 Go 语言解法中的模拟退火或梯度下降逻辑来实现 Python 版本。</li><li><strong>局部最优即全局最优</strong>: 因为距离和函数是<strong>凸函数</strong>，所以我们不需要担心算法陷入局部最优解，简单的贪心移动策略配合步长衰减一定能找到全局最优解。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1515 题：&lt;a href=&quot;https://leetcode.cn/problems/best-position-for-a-service-centre/&quot;&gt;服务中心的最佳位置&lt;/a&gt;。&lt;br&gt;我们需要找到一个点，使其到所有给定点的欧几里得距离之和最小。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="三分法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%B8%89%E5%88%86%E6%B3%95/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="数学" scheme="http://github.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://github.com/tags/%E5%87%A0%E4%BD%95/"/>
    
    <category term="随机化" scheme="http://github.com/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"/>
    
    <category term="第197场周赛" scheme="http://github.com/tags/%E7%AC%AC197%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 3134 | 找出唯一性数组的中位数</title>
    <link href="http://github.com/posts/leetcode-3134/"/>
    <id>http://github.com/posts/leetcode-3134/</id>
    <published>2025-11-30T09:00:00.000Z</published>
    <updated>2025-11-30T09:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 3134 题：<a href="https://leetcode.cn/problems/find-the-median-of-the-uniqueness-array/">找出唯一性数组的中位数</a>。<br>我们需要在 O(N²) 的子数组空间中，高效地找到第 K 小的唯一性计数。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个整数数组 <code>nums</code>。<br>数组的 <strong>唯一性数组</strong> 是一个数组，包含 <code>nums</code> 的所有非空子数组中不同元素的个数。<br>换句话说，对于 <code>nums</code> 的每一个子数组，计算其不同元素的个数，将这些值收集起来形成一个新的数组。</p><p>需要返回这个 <strong>唯一性数组</strong> 的 <strong>中位数</strong>。</p><p>注意：</p><ul><li>子数组是数组中连续的一段。</li><li>如果数组长度为偶数，中位数是排序后中间两个数的较小者（即第 <code>(total + 1) / 2</code> 个数，向上取整的逻辑）。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1, 2, 3]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">子数组及其不同元素个数：</span><br><span class="line">[1]: 1</span><br><span class="line">[2]: 1</span><br><span class="line">[3]: 1</span><br><span class="line">[1, 2]: 2</span><br><span class="line">[2, 3]: 2</span><br><span class="line">[1, 2, 3]: 3</span><br><span class="line">唯一性数组为 [1, 1, 1, 2, 2, 3]。</span><br><span class="line">排序后为 [1, 1, 1, 2, 2, 3]，中位数是 1。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-问题转化：二分答案"><a href="#1-问题转化：二分答案" class="headerlink" title="1. 问题转化：二分答案"></a>1. 问题转化：二分答案</h4><p>直接暴力生成所有子数组的唯一性值需要 O(N²) 的时间，这在 <code>N = 10^5</code> 的数据规模下是不可接受的。<br>我们需要找到一个数 <code>x</code>，使得唯一性数组中 <strong>小于等于</strong> <code>x</code> 的元素个数至少占总数的一半。</p><p>这就具备了单调性：</p><ul><li>如果我们允许子数组包含更多种类的元素（即 <code>x</code> 变大），那么满足条件的子数组数量一定会增加或持平。</li></ul><p>因此，我们可以对答案（即子数组中不同元素的个数）进行 <strong>二分查找</strong>。<br>答案的范围是 <code>[1, N]</code>（或者更精确地说是 <code>[1, len(set(nums))]</code>）。</p><h4 id="2-中位数的定义"><a href="#2-中位数的定义" class="headerlink" title="2. 中位数的定义"></a>2. 中位数的定义</h4><p>对于长度为 <code>n</code> 的数组，非空子数组的总数 <code>Total</code> 为 <code>n * (n + 1) / 2</code>。<br>题目要求的中位数，本质上是求第 <code>k</code> 小的数，其中 <code>k = (Total + 1) / 2</code>（整数除法）。</p><p>我们需要找到最小的 <code>limit</code>，使得：<br><strong>不同元素个数 ≤ limit 的子数组数量 ≥ k</strong></p><h4 id="3-计数检查：滑动窗口（双指针）"><a href="#3-计数检查：滑动窗口（双指针）" class="headerlink" title="3. 计数检查：滑动窗口（双指针）"></a>3. 计数检查：滑动窗口（双指针）</h4><p>核心问题变成了：如何快速计算“不同元素个数 ≤ limit”的子数组有多少个？<br>我们可以使用 <strong>滑动窗口</strong> 在 O(N) 时间内完成统计：</p><ol><li>维护一个窗口 <code>[l, r]</code> 和一个哈希表 <code>freq</code> 记录窗口内元素的出现次数。</li><li>遍历右端点 <code>r</code>，将 <code>nums[r]</code> 加入窗口。</li><li>如果窗口内不同元素的个数（即 <code>len(freq)</code>）超过了 <code>limit</code>，则移动左端点 <code>l</code>，直到窗口恢复合法。</li><li>对于当前固定的右端点 <code>r</code>，所有以 <code>r</code> 结尾且起始位置在 <code>[l, r]</code> 之间的子数组都是合法的。这样的子数组个数为 <code>r - l + 1</code>。</li><li>累加这些个数。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">medianOfUniquenessArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 计算子数组总数 n*(n+1)/2，并确定中位数的位置 k</span></span><br><span class="line">        <span class="comment"># 这里使用的是向上取整的逻辑，即第 (Total + 1) // 2 小的数</span></span><br><span class="line">        k = (n * (n + <span class="number">1</span>) // <span class="number">2</span> + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 核心校验函数：检查是否存在至少 k 个子数组，</span></span><br><span class="line">        <span class="comment"># 其不同元素个数小于等于 upper</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">upper: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            cnt = l = <span class="number">0</span></span><br><span class="line">            freq = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">            <span class="keyword">for</span> r, in_ <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">                freq[in_] += <span class="number">1</span>  <span class="comment"># 移入右端点，更新计数</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 当窗口内不同元素的个数超过上限时，收缩左边界</span></span><br><span class="line">                <span class="keyword">while</span> <span class="built_in">len</span>(freq) &gt; upper:  <span class="comment"># 窗口内元素过多</span></span><br><span class="line">                    out = nums[l]</span><br><span class="line">                    freq[out] -= <span class="number">1</span>  <span class="comment"># 移出左端点</span></span><br><span class="line">                    <span class="keyword">if</span> freq[out] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">del</span> freq[out] <span class="comment"># 如果次数归零，从 map 中移除，len(freq) 会减少</span></span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 对于当前的右端点 r，合法的左端点范围是 [l, r]</span></span><br><span class="line">                <span class="comment"># 因此以 r 结尾且满足条件的子数组个数为 r - l + 1</span></span><br><span class="line">                cnt += r - l + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 剪枝：如果计数已经达到 k，提前返回 True</span></span><br><span class="line">                <span class="keyword">if</span> cnt &gt;= k:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在 [1, len(set(nums))] 范围内二分查找</span></span><br><span class="line">        <span class="comment"># bisect_left 会寻找第一个使得 check(val) 为 True 的值</span></span><br><span class="line">        <span class="comment"># range 的范围需要覆盖可能的解空间</span></span><br><span class="line">        <span class="keyword">return</span> bisect_left(<span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">set</span>(nums))), <span class="literal">True</span>, <span class="number">1</span>, key=check)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">medianOfUniquenessArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">// 计算中位数是第 k 小的数</span></span><br><span class="line">    <span class="comment">// 总子数组数为 n*(n+1)/2</span></span><br><span class="line">k := (n*(n+<span class="number">1</span>)/<span class="number">2</span> + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 sort.Search 进行二分查找</span></span><br><span class="line">    <span class="comment">// Search(n) 会在 [0, n) 范围内查找，我们查找的实际范围与数组长度相关</span></span><br><span class="line">    <span class="comment">// 但答案上限是不同元素的个数，这里用 n-1 作为搜索空间的基数</span></span><br><span class="line">ans := <span class="number">1</span> + sort.Search(n<span class="number">-1</span>, <span class="function"><span class="keyword">func</span><span class="params">(upper <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">upper++ <span class="comment">// sort.Search 的参数是从 0 开始的，实际含义需要 +1</span></span><br><span class="line">cnt := <span class="number">0</span></span><br><span class="line">l := <span class="number">0</span></span><br><span class="line">freq := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125; <span class="comment">// 哈希表记录窗口内元素频率</span></span><br><span class="line"><span class="keyword">for</span> r, in := <span class="keyword">range</span> nums &#123;</span><br><span class="line">freq[in]++ <span class="comment">// 移入右端点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果窗口内不同元素数量超过 upper，则收缩左端点</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(freq) &gt; upper &#123; <span class="comment">// 窗口内元素过多</span></span><br><span class="line">out := nums[l]</span><br><span class="line">freq[out]-- <span class="comment">// 移出左端点</span></span><br><span class="line"><span class="keyword">if</span> freq[out] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(freq, out) <span class="comment">// 彻底移除元素，确保 len(freq) 正确</span></span><br><span class="line">&#125;</span><br><span class="line">l++</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 累加当前右端点 r 对应的合法子数组数量</span></span><br><span class="line">cnt += r - l + <span class="number">1</span> <span class="comment">// 右端点固定为 r 时，有 r-l+1 个合法左端点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果计数满足要求，返回 true，二分查找会尝试更小的值</span></span><br><span class="line"><span class="keyword">if</span> cnt &gt;= k &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: O(N * log(M))</p><ul><li>其中 N 是数组 <code>nums</code> 的长度，M 是数组中不同元素的个数（最坏情况下 M &#x3D; N）。</li><li>二分查找进行 O(log M) 次迭代。</li><li>每次 <code>check</code> 函数中使用滑动窗口遍历整个数组，时间复杂度为 O(N)。</li><li>总复杂度为 O(N log M)。</li></ul></li><li><p><strong>空间复杂度</strong>: O(M)</p><ul><li>主要消耗在于滑动窗口中的哈希表 <code>freq</code>，其大小最多存储 M 个不同的元素。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 3134 题：&lt;a href=&quot;https://leetcode.cn/problems/find-the-median-of-the-uniqueness-array/&quot;&gt;找出唯一性数组的中位数&lt;/a&gt;。&lt;br&gt;我们需要在 O(N²) 的子数组空间中，高效地找到第 K 小的唯一性计数。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分答案" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
    <category term="第K小/大" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/%E7%AC%ACK%E5%B0%8F-%E5%A4%A7/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="哈希表" scheme="http://github.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="滑动窗口" scheme="http://github.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="第395场周赛" scheme="http://github.com/tags/%E7%AC%AC395%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 3116 | 单面值组合的第 K 小金额</title>
    <link href="http://github.com/posts/leetcode-3116/"/>
    <id>http://github.com/posts/leetcode-3116/</id>
    <published>2025-11-29T09:22:00.000Z</published>
    <updated>2025-11-29T09:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 3116 题：<a href="https://leetcode.cn/problems/kth-smallest-amount-with-single-denomination-combination/">单面值组合的第 K 小金额</a>。<br>一道结合了“二分答案”与“容斥原理”的经典数论题目。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给你一个整数 <code>k</code>。<br>你有无限量的每种面额的硬币。但是，你 <strong>不能</strong> 组合使用不同面额的硬币。<br>也就是说，如果你选择面额为 <code>c</code> 的硬币，你只能制造 <code>c, 2c, 3c, ...</code> 这些金额。<br>返回使用这些硬币能制造的 <strong>第 k 小</strong> 的金额。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [3,6,9], k = 3</span><br><span class="line">输出：9</span><br><span class="line">解释：</span><br><span class="line">3元硬币产生：3, 6, 9, 12...</span><br><span class="line">6元硬币产生：6, 12, 18...</span><br><span class="line">9元硬币产生：9, 18, 27...</span><br><span class="line">去重合并后：3, 6, 9, 12...</span><br><span class="line">第3小的是9。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; coins.length &lt;&#x3D; 15</li><li>1 &lt;&#x3D; coins[i] &lt;&#x3D; 25</li><li>1 &lt;&#x3D; k &lt;&#x3D; 2 * 10^9</li><li>coins 包含两两不同的整数。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-预处理：去重与排序"><a href="#1-预处理：去重与排序" class="headerlink" title="1. 预处理：去重与排序"></a>1. 预处理：去重与排序</h4><p>首先观察示例 1：<code>coins = [3, 6, 9]</code>。</p><ul><li><code>6</code> 是 <code>3</code> 的倍数，所有能由 <code>6</code> 产生的金额（6, 12…）一定都能由 <code>3</code> 产生。</li><li>同理，<code>9</code> 也是 <code>3</code> 的倍数。</li><li>因此，集合 <code>[3, 6, 9]</code> 等价于 <code>[3]</code>。</li></ul><p>为了减少容斥原理计算时的集合数量（指数级复杂度），我们首先应该对 <code>coins</code> 进行排序，并移除那些“本身是其他较小面额倍数”的硬币。</p><h4 id="2-二分答案"><a href="#2-二分答案" class="headerlink" title="2. 二分答案"></a>2. 二分答案</h4><p>类似于求“第 K 小”的题目，通常具有单调性：</p><ul><li>如果金额 <code>m</code> 能够覆盖至少 <code>k</code> 个生成数，那么比 <code>m</code> 大的金额也能覆盖至少 <code>k</code> 个。</li><li>我们需要找到满足 <code>count(m) &gt;= k</code> 的最小 <code>m</code>。</li></ul><p><strong>搜索范围：</strong></p><ul><li>下界：<code>k</code>（假设最小面额是1）。</li><li>上界：<code>min(coins) * k</code>（最坏情况只使用最小面额）。</li></ul><h4 id="3-容斥原理"><a href="#3-容斥原理" class="headerlink" title="3. 容斥原理"></a>3. 容斥原理</h4><p>核心难点在于 <code>check(m)</code> 函数：计算小于等于 <code>m</code> 的金额中有多少个是给定硬币的倍数。<br>假设去重后的硬币集合为 <code>A</code>，我们需要计算 $|A_0 \cup A_1 \cup \dots \cup A_{n-1}|$。</p><p>根据容斥原理：<br><code>Count = Σ(奇数个集合的交集大小) - Σ(偶数个集合的交集大小)</code></p><ul><li>集合 <code>coin_i</code> 在范围 <code>m</code> 内的元素个数为 <code>m // coin_i</code>。</li><li>多个集合的交集，即这些硬币的 <strong>最小公倍数 (LCM)</strong> 的倍数个数：<code>m // lcm(c1, c2, ...)</code>。</li></ul><p>由于 <code>coins</code> 长度最多为 15，我们可以预处理所有子集的 LCM。<br>使用位掩码（Bitmask）<code>1</code> 到 <code>(1 &lt;&lt; n) - 1</code> 来表示所有子集。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthSmallest</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        coins.sort()</span><br><span class="line">        a = []</span><br><span class="line">        <span class="comment"># 预处理：去除倍数关系的冗余硬币</span></span><br><span class="line">        <span class="comment"># 例如 [2, 4] -&gt; [2]，因为 4 的倍数一定是 2 的倍数</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">all</span>(x % y <span class="keyword">for</span> y <span class="keyword">in</span> a):</span><br><span class="line">                a.append(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 预处理所有子集的 LCM</span></span><br><span class="line">        <span class="comment"># subset_lcm[mask] 存储掩码为 mask 的子集的最小公倍数</span></span><br><span class="line">        n = <span class="built_in">len</span>(a)</span><br><span class="line">        subset_lcm = [<span class="number">1</span>] * (<span class="number">1</span> &lt;&lt; n)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 动态规划计算子集 LCM</span></span><br><span class="line">        <span class="comment"># 外层遍历每一个硬币，内层遍历已有的掩码</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):</span><br><span class="line">            bit = <span class="number">1</span> &lt;&lt; i</span><br><span class="line">            <span class="keyword">for</span> mask <span class="keyword">in</span> <span class="built_in">range</span>(bit):</span><br><span class="line">                <span class="comment"># 新的 LCM = lcm(旧子集 LCM, 新加入的硬币)</span></span><br><span class="line">                subset_lcm[bit | mask] = math.lcm(subset_lcm[mask], x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找的 check 函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 遍历所有非空子集</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(subset_lcm)):  </span><br><span class="line">                <span class="comment"># 容斥原理：</span></span><br><span class="line">                <span class="comment"># 奇数个元素的集合（bit_count 为奇数）：加</span></span><br><span class="line">                <span class="comment"># 偶数个元素的集合（bit_count 为偶数）：减</span></span><br><span class="line">                <span class="keyword">if</span> i.bit_count() % <span class="number">2</span>:</span><br><span class="line">                    cnt += m // subset_lcm[i]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cnt -= m // subset_lcm[i]</span><br><span class="line">            <span class="keyword">return</span> cnt &gt;= k</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 二分查找左边界</span></span><br><span class="line">        <span class="comment"># 搜索范围从 0 到 a[0] * k</span></span><br><span class="line">        <span class="comment"># key=check 会寻找第一个使 check(m) 为 True 的位置</span></span><br><span class="line">        <span class="keyword">return</span> bisect_left(<span class="built_in">range</span>(a[<span class="number">0</span>] * k), <span class="literal">True</span>, k, key=check)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;math/bits&quot;</span></span><br><span class="line"><span class="string">&quot;slices&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthSmallest</span><span class="params">(coins []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">slices.Sort(coins)</span><br><span class="line"><span class="comment">// 预处理：去除冗余硬币</span></span><br><span class="line"><span class="comment">// 使用切片过滤技巧，a 存储过滤后的硬币</span></span><br><span class="line">a := coins[:<span class="number">0</span>]</span><br><span class="line">next:</span><br><span class="line"><span class="keyword">for</span> _, x := <span class="keyword">range</span> coins &#123;</span><br><span class="line"><span class="keyword">for</span> _, y := <span class="keyword">range</span> a &#123;</span><br><span class="line"><span class="keyword">if</span> x%y == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a = <span class="built_in">append</span>(a, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理所有子集的 LCM</span></span><br><span class="line">subsetLcm := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1</span>&lt;&lt;<span class="built_in">len</span>(a))</span><br><span class="line">subsetLcm[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">bit := <span class="number">1</span> &lt;&lt; i</span><br><span class="line"><span class="comment">// 遍历当前已生成的子集掩码</span></span><br><span class="line"><span class="keyword">for</span> mask, l := <span class="keyword">range</span> subsetLcm[:bit] &#123;</span><br><span class="line">subsetLcm[bit|mask] = lcm(l, x)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化：预处理符号</span></span><br><span class="line"><span class="comment">// 根据容斥原理，偶数个元素的子集需要减去，奇数个需要加上</span></span><br><span class="line"><span class="comment">// 这里直接将偶数个元素的 LCM 设为负数，方便后续只做加法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> subsetLcm &#123;</span><br><span class="line"><span class="keyword">if</span> bits.OnesCount(<span class="type">uint</span>(i))%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">subsetLcm[i] *= <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="comment">// sort.Search 查找 [0, n) 范围内第一个使函数返回 true 的值</span></span><br><span class="line">ans := sort.Search(a[<span class="number">0</span>]*k, <span class="function"><span class="keyword">func</span><span class="params">(m <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">cnt := <span class="number">0</span></span><br><span class="line"><span class="comment">// 遍历除空集外的所有子集 LCM</span></span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> subsetLcm[<span class="number">1</span>:] &#123;</span><br><span class="line"><span class="comment">// 如果 l 是正数（奇数个元素），加</span></span><br><span class="line"><span class="comment">// 如果 l 是负数（偶数个元素），相当于减去绝对值</span></span><br><span class="line">cnt += m / l</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= k</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> <span class="type">int64</span>(ans)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">for</span> a != <span class="number">0</span> &#123;</span><br><span class="line">a, b = b%a, a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lcm</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a == <span class="number">0</span> || b == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a / gcd(a, b) * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设 <code>coins</code> 去重后的长度为 <code>M</code> (M &lt;&#x3D; 15)。</p><ul><li><p><strong>时间复杂度</strong>: </p><ul><li><strong>预处理 LCM</strong>: <code>O(2^M)</code>。我们需要遍历所有可能的子集来计算 LCM。</li><li><strong>二分查找</strong>: 搜索范围上限约为 <code>min(coins) * k</code>，二分次数为 <code>O(log(min(coins) * k))</code>。</li><li><strong>Check 函数</strong>: 每次 check 需要遍历 <code>2^M</code> 个子集。</li><li>总时间复杂度：<code>O(2^M · log(C·K))</code>。对于 <code>M=15</code>，<code>2^15 ≈ 3.2万</code>，二分约 60 次，总计算量在 200万次左右，完全可以通过。</li></ul></li><li><p><strong>空间复杂度</strong>: <code>O(2^M)</code><br>需要一个数组来存储所有子集的 LCM 值。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 3116 题：&lt;a href=&quot;https://leetcode.cn/problems/kth-smallest-amount-with-single-denomination-combination/&quot;&gt;单面值组合的第 K 小金额&lt;/a&gt;。&lt;br&gt;一道结合了“二分答案”与“容斥原理”的经典数论题目。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分答案" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
    <category term="第K小/大" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/%E7%AC%ACK%E5%B0%8F-%E5%A4%A7/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="位运算" scheme="http://github.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="数学" scheme="http://github.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="组合数学" scheme="http://github.com/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数论" scheme="http://github.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="第393场周赛" scheme="http://github.com/tags/%E7%AC%AC393%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 786 | 第 K 个最小的质数分数</title>
    <link href="http://github.com/posts/leetcode-786/"/>
    <id>http://github.com/posts/leetcode-786/</id>
    <published>2025-11-28T10:12:00.000Z</published>
    <updated>2025-11-28T10:12:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 786 题：<a href="https://leetcode.cn/problems/k-th-smallest-prime-fraction/">第 K 个最小的质数分数</a>。<br>解法的核心在于<strong>对分数的值进行二分</strong>，结合双指针统计数量，并在统计过程中记录满足条件的最大分数。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个按递增顺序排序的数组 <code>arr</code> 和一个整数 <code>k</code> 。数组 <code>arr</code> 由 <code>1</code> 和若干 <strong>质数</strong> 组成，且其中所有整数互不相同。</p><p>对于每对满足 <code>0 &lt;= i &lt; j &lt; arr.length</code> 的 <code>i</code> 和 <code>j</code> ，可以得到分数 <code>arr[i] / arr[j]</code> 。</p><p>那么第 <code>k</code> 个最小的分数是多少呢?  以长度为 2 的整数数组返回你的答案, 这里 <code>answer[0] == arr[i]</code> 且 <code>answer[1] == arr[j]</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [1,2,3,5], k = 3</span><br><span class="line">输出：[2,5]</span><br><span class="line">解释：已构造好的分数,排序后如下所示: </span><br><span class="line">1/5, 1/3, 2/5, 1/2, 3/5, 2/3</span><br><span class="line">很明显第三个最小的分数是 2/5</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [1,7], k = 1</span><br><span class="line">输出：[1,7]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt;= 3 * 10^4</code></li><li><code>arr[0] == 1</code></li><li><code>arr[i]</code> 是一个 <strong>质数</strong> ，<code>i &gt; 0</code></li><li><code>arr</code> 中的所有数字 <strong>互不相同</strong> ，且按 <strong>严格递增</strong> 排序</li><li><code>1 &lt;= k &lt;= arr.length * (arr.length - 1) / 2</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-思路分析"><a href="#1-思路分析" class="headerlink" title="1. 思路分析"></a>1. 思路分析</h4><p>这道题要求找出第 <code>k</code> 小的分数。如果我们将所有可能的分数 <code>arr[i] / arr[j]</code> 列出来并排序，时间复杂度会非常高，因为分数的总对数是 <code>O(N^2)</code> 级别的。</p><p>我们可以换一个角度：<br>分数的范围一定在 <code>(0, 1)</code> 之间。我们可以对<strong>数值</strong>进行二分查找。<br>假设我们选定一个值 <code>mid</code>，我们可以很容易地统计出有多少个分数严格小于 <code>mid</code>。</p><ul><li>如果小于 <code>mid</code> 的分数个数等于 <code>k</code>，那么 <code>mid</code> 附近的某个分数可能就是答案吗？不一定，因为 <code>mid</code> 是一个浮点数，它可能不等于任何一个 <code>arr[i] / arr[j]</code>。</li><li>但是，如果我们能在统计“小于 <code>mid</code> 的分数”的过程中，同时记录下<strong>小于 <code>mid</code> 的最大分数</strong>，那么当计数恰好为 <code>k</code> 时，这个记录下来的最大分数就是我们要找的第 <code>k</code> 小的分数。</li></ul><h4 id="2-二分查找流程"><a href="#2-二分查找流程" class="headerlink" title="2. 二分查找流程"></a>2. 二分查找流程</h4><ol><li><strong>初始化范围</strong>：<code>l = 0.0</code>, <code>r = 1.0</code>。</li><li><strong>二分过程</strong>：<ul><li>取 <code>mid = (l + r) / 2</code>。</li><li><strong>统计与记录</strong>：遍历分母 <code>arr[j]</code>（从索引 1 到 n-1），使用双指针（或滑动窗口）找到对应的分子 <code>arr[i]</code>，使得 <code>arr[i] / arr[j] &lt; mid</code>。</li><li>在遍历过程中，计算所有满足条件的分数总数 <code>cnt</code>。</li><li><strong>关键点</strong>：在统计过程中，维护一个变量 <code>x/y</code>，用来记录当前小于 <code>mid</code> 的所有分数中<strong>最大</strong>的那个分数。</li></ul></li><li><strong>调整边界</strong>：<ul><li>如果 <code>cnt &lt; k</code>：说明 <code>mid</code> 选小了，甚至还没凑够 <code>k</code> 个数，需要扩大范围，<code>l = mid</code>。</li><li>如果 <code>cnt &gt; k</code>：说明 <code>mid</code> 选大了，<code>r = mid</code>。</li><li>如果 <code>cnt == k</code>：说明我们要找的第 <code>k</code> 小的分数包含在小于 <code>mid</code> 的集合中，并且由于我们记录了集合中最大的那个分数 <code>x/y</code>，它一定就是第 <code>k</code> 小的分数（因为比它小的有 <code>k-1</code> 个）。直接返回 <code>[x, y]</code>。</li></ul></li></ol><h4 id="3-双指针的运用"><a href="#3-双指针的运用" class="headerlink" title="3. 双指针的运用"></a>3. 双指针的运用</h4><p>由于数组 <code>arr</code> 是严格递增的：<br>对于固定的分母 <code>arr[j]</code>，随着分子索引 <code>i</code> 的增加，<code>arr[i] / arr[j]</code> 是单调递增的。<br>因此，对于每个 <code>j</code>，我们不需要每次都从头扫描 <code>i</code>。<br>随着 <code>j</code> 的增加（分母变大），为了保持 <code>arr[i] / arr[j] &lt; mid</code>，<code>i</code> 只会向右移动（分子变大）或保持不变。这使得内部统计的时间复杂度为 <code>O(N)</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallestPrimeFraction</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="comment"># 二分查找的范围初始化为 (0.0, 1.0)</span></span><br><span class="line">        l, r = <span class="number">0.0</span>, <span class="number">1.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            mid = (l + r) / <span class="number">2</span></span><br><span class="line">            <span class="comment"># i 是分子的索引，cnt 统计小于 mid 的分数个数</span></span><br><span class="line">            i, cnt = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">            <span class="comment"># x, y 用于记录小于 mid 的最大分数，初始设为 0/1</span></span><br><span class="line">            x, y = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 遍历每一个可能的分母 arr[j]</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># 寻找当前分母下，满足分数 &lt; mid 的最大分子索引 i</span></span><br><span class="line">                <span class="comment"># arr 是递增的，所以 i 是单调不减的（双指针逻辑）</span></span><br><span class="line">                <span class="keyword">while</span> arr[i+<span class="number">1</span>] / arr[j] &lt; mid:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 更新当前小于 mid 的最大分数</span></span><br><span class="line">                    <span class="comment"># 比较 arr[i]/arr[j] 与 x/y 的大小</span></span><br><span class="line">                    <span class="comment"># 使用交叉相乘 arr[i]*y &gt; arr[j]*x 避免浮点精度问题</span></span><br><span class="line">                    <span class="keyword">if</span> arr[i] * y &gt; arr[j] * x:</span><br><span class="line">                        x, y = arr[i], arr[j]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># arr[0] 到 arr[i] 都是满足条件的分子，共 i+1 个</span></span><br><span class="line">                cnt += i + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果小于 mid 的分数个数恰好为 k</span></span><br><span class="line">            <span class="comment"># 那么我们在统计过程中记录的最大分数 x/y 即为第 k 小的分数</span></span><br><span class="line">            <span class="keyword">if</span> cnt == k:</span><br><span class="line">                <span class="keyword">return</span> [x, y]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果个数不足 k，说明 mid 偏小，需要向右区间搜索</span></span><br><span class="line">            <span class="keyword">if</span> cnt &lt; k:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="comment"># 如果个数超过 k，说明 mid 偏大，需要向左区间搜索</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthSmallestPrimeFraction</span><span class="params">(arr []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="comment">// 二分查找的范围初始化为 (0.0, 1.0)</span></span><br><span class="line">    l, r := <span class="number">0.0</span>, <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        mid := (l + r) / <span class="number">2</span></span><br><span class="line">        <span class="comment">// i 是分子的索引</span></span><br><span class="line">        <span class="comment">// cnt 统计小于 mid 的分数个数</span></span><br><span class="line">        i, cnt := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment">// x, y 用于记录小于 mid 的最大分数，初始设为 0/1</span></span><br><span class="line">        <span class="comment">// x 为分子，y 为分母</span></span><br><span class="line">        x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每一个可能的分母 arr[j]</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="comment">// 寻找当前分母下，满足分数 &lt; mid 的最大分子索引 i</span></span><br><span class="line">            <span class="comment">// 需要将整数转换为 float64 进行除法比较</span></span><br><span class="line">            <span class="comment">// 注意边界检查：i+1 &lt; n 且 arr[i+1]/arr[j] &lt; mid</span></span><br><span class="line">            <span class="keyword">for</span> i+<span class="number">1</span> &lt; j &amp;&amp; <span class="type">float64</span>(arr[i+<span class="number">1</span>])/<span class="type">float64</span>(arr[j]) &lt; mid &#123;</span><br><span class="line">                i++</span><br><span class="line">                <span class="comment">// 更新当前小于 mid 的最大分数</span></span><br><span class="line">                <span class="comment">// 比较 arr[i]/arr[j] 与 x/y 的大小</span></span><br><span class="line">                <span class="comment">// 使用交叉相乘 arr[i]*y &gt; arr[j]*x，利用整数运算避免精度丢失</span></span><br><span class="line">                <span class="keyword">if</span> arr[i]*y &gt; arr[j]*x &#123;</span><br><span class="line">                    x, y = arr[i], arr[j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// arr[0] 到 arr[i] 都是满足条件的分子，共 i+1 个</span></span><br><span class="line">            cnt += i + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果小于 mid 的分数个数恰好为 k</span></span><br><span class="line">        <span class="comment">// 那么我们在统计过程中记录的最大分数 x/y 即为第 k 小的分数</span></span><br><span class="line">        <span class="keyword">if</span> cnt == k &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;x, y&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果个数不足 k，说明 mid 偏小，需要向右区间搜索</span></span><br><span class="line">        <span class="keyword">if</span> cnt &lt; k &#123;</span><br><span class="line">            l = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果个数超过 k，说明 mid 偏大，需要向左区间搜索</span></span><br><span class="line">            r = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(N * log(C))</code><br>其中 <code>N</code> 是数组的长度，<code>C</code> 取决于二分的精度要求或者数据的数值范围。由于每次 check 操作需要遍历数组一次（双指针复杂度为 <code>O(N)</code>），而二分查找在实数域上进行，直到找到确切的整数解，通常迭代次数是有限的（与浮点数精度或最大可能的整数值有关）。</p></li><li><p><strong>空间复杂度</strong>: <code>O(1)</code><br>我们只使用了常数个变量 <code>l</code>, <code>r</code>, <code>mid</code>, <code>x</code>, <code>y</code>, <code>i</code>, <code>j</code> 等，不需要额外的数组空间。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 786 题：&lt;a href=&quot;https://leetcode.cn/problems/k-th-smallest-prime-fraction/&quot;&gt;第 K 个最小的质数分数&lt;/a&gt;。&lt;br&gt;解法的核心在于&lt;strong&gt;对分数的值进行二分&lt;/strong&gt;，结合双指针统计数量，并在统计过程中记录满足条件的最大分数。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分答案" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
    <category term="第K小/大" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/%E7%AC%ACK%E5%B0%8F-%E5%A4%A7/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="排序" scheme="http://github.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="堆（优先队列）" scheme="http://github.com/tags/%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89/"/>
    
    <category term="双指针" scheme="http://github.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1439 | 有序矩阵中的第 k 个最小数组和</title>
    <link href="http://github.com/posts/leetcode-1439/"/>
    <id>http://github.com/posts/leetcode-1439/</id>
    <published>2025-11-27T02:00:00.000Z</published>
    <updated>2025-11-27T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 1439 题：<a href="https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/">有序矩阵中的第 k 个最小数组和</a>。<br>由于矩阵行有序，我们可以利用 <strong>BS</strong> 来确定答案，结合 <strong>DFS</strong> 进行验证。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个 <code>m * n</code> 的矩阵 <code>mat</code>，以及一个整数 <code>k</code>，矩阵中的每一行都以非递减的顺序排列。</p><p>你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 <code>k</code> 个 <strong>最小</strong> 数组和。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[1,3,11],[2,4,6]], k = 5</span><br><span class="line">输出：7</span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == mat.length</code></li><li><code>n == mat.length[i]</code></li><li><code>1 &lt;= m, n &lt;= 40</code></li><li><code>1 &lt;= k &lt;= min(200, n ^ m)</code></li><li><code>1 &lt;= mat[i][j] &lt;= 5000</code></li><li><code>mat[i]</code> 是一个非递减数组</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-为什么选择二分答案？"><a href="#1-为什么选择二分答案？" class="headerlink" title="1. 为什么选择二分答案？"></a>1. 为什么选择二分答案？</h4><p>我们需要找到所有可能的数组和中第 <code>k</code> 小的那个和。<br>如果我们把所有可能的数组和从小到大排列，设第 <code>k</code> 小的和为 <code>target</code>，那么我们可以发现一个规律：</p><ul><li>对于任意小于 <code>target</code> 的数值 <code>x</code>，能组成的数组和小于等于 <code>x</code> 的数量一定小于 <code>k</code>。</li><li>对于任意大于等于 <code>target</code> 的数值 <code>x</code>，能组成的数组和小于等于 <code>x</code> 的数量一定大于等于 <code>k</code>。</li></ul><p>这满足<strong>单调性</strong>，因此我们可以对“数组和”这个值进行二分查找。</p><h4 id="2-确定二分范围"><a href="#2-确定二分范围" class="headerlink" title="2. 确定二分范围"></a>2. 确定二分范围</h4><ul><li><strong>下界 (Left)</strong>：每行取最小的元素（即第一列），求和。这是所有组合中最小的和 <code>sl</code>。</li><li><strong>上界 (Right)</strong>：每行取最大的元素（即最后一列），求和。这是所有组合中最大的和 <code>sr</code>。</li></ul><p>答案一定在 <code>[sl, sr]</code> 之间。</p><h4 id="3-Check-函数的设计-DFS"><a href="#3-Check-函数的设计-DFS" class="headerlink" title="3. Check 函数的设计 (DFS)"></a>3. Check 函数的设计 (DFS)</h4><p>二分的核心在于 <code>check(s)</code> 函数：判断是否存在至少 <code>k</code> 个数组组合，其和小于等于 <code>s</code>。</p><p>如果我们要枚举所有组合，复杂度是指数级的，无法接受。但我们只需要知道 <strong>数量是否达到 k</strong>。<br>我们可以使用 DFS 回溯来统计：</p><ol><li>从最后一行开始往前递归（或从第一行开始，效果一样）。</li><li>为了加速，我们不传递当前的累加和，而是传递 <strong>剩余的额度</strong>。<ul><li>初始额度 &#x3D; <code>s</code> - <code>sl</code> (当前二分值减去最小基础和)。</li><li>这相当于我们在计算除了每行选第一个数（基准）之外，额外增加的增量能否控制在限制内。</li></ul></li><li><strong>剪枝策略</strong>：<ul><li>如果在某一行，选择某个元素后，增量已经超过了剩余额度，由于行是有序的，后面的元素更大，肯定也不满足，直接 <code>break</code>。</li><li><strong>数量限制</strong>：维护一个全局计数器（或引用变量）<code>lk</code>，初始为 <code>k</code>。每找到一个合法组合，<code>lk</code> 减 1。当 <code>lk</code> 降为 0 时，说明我们已经找到了 <code>k</code> 个满足条件的组合，直接返回 <code>True</code>。</li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># check 函数：判断小于等于 s 的数组和的数量是否 &gt;= k</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">s: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># lk 用于计数，还需要找到多少个满足条件的组合</span></span><br><span class="line">            lk = k</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># DFS 搜索</span></span><br><span class="line">            <span class="comment"># i: 当前处理的行索引</span></span><br><span class="line">            <span class="comment"># s: 当前剩余的可支配和（相对于每行最小值的增量）</span></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, s: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">                <span class="comment"># Base case: 成功遍历完所有行（i &lt; 0），说明找到一个合法组合</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">nonlocal</span> lk</span><br><span class="line">                    lk -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> lk == <span class="number">0</span> <span class="comment"># 如果找到了 k 个，返回 True</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 遍历当前行的元素</span></span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> mat[i]:</span><br><span class="line">                    <span class="comment"># 剪枝：如果当前元素带来的增量 (x - mat[i][0]) 超过了剩余预算 s</span></span><br><span class="line">                    <span class="comment"># 由于 mat[i] 是有序的，后面的元素肯定也超，直接 break</span></span><br><span class="line">                    <span class="keyword">if</span> x - mat[i][<span class="number">0</span>] &gt; s:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 递归处理上一行</span></span><br><span class="line">                    <span class="comment"># 这里的 s - (x - mat[i][0]) 是减去当前元素相对于该行最小值的增量</span></span><br><span class="line">                    <span class="keyword">if</span> dfs(i - <span class="number">1</span>, s - (x - mat[i][<span class="number">0</span>])):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 如果子递归已经找到了足够的数量，向上返回 True</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从最后一行开始 DFS，初始预算是 s - sl</span></span><br><span class="line">            <span class="comment"># s 是二分的猜测值，sl 是所有行最小值的和</span></span><br><span class="line">            <span class="keyword">return</span> dfs(<span class="built_in">len</span>(mat) - <span class="number">1</span>, s - sl)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算可能的最小和 sl 和最大和 sr</span></span><br><span class="line">        sl = <span class="built_in">sum</span>(row[<span class="number">0</span>] <span class="keyword">for</span> row <span class="keyword">in</span> mat)</span><br><span class="line">        sr = <span class="built_in">sum</span>(row[-<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> mat)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 二分查找</span></span><br><span class="line">        <span class="comment"># range(sl, sr) 生成从 sl 到 sr-1 的序列</span></span><br><span class="line">        <span class="comment"># bisect_left 会寻找第一个使得 check(val) 为 True 的位置</span></span><br><span class="line">        <span class="comment"># 结果需要加上 sl 偏移量</span></span><br><span class="line">        <span class="comment"># 注意：如果 range 中所有值都 check 失败，bisect_left 返回数组长度，即 sr - sl</span></span><br><span class="line">        <span class="comment"># 此时结果为 sl + (sr - sl) = sr，逻辑是自洽的</span></span><br><span class="line">        <span class="keyword">return</span> sl + bisect_left(<span class="built_in">range</span>(sl, sr), <span class="literal">True</span>, key=check)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthSmallest</span><span class="params">(mat [][]<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sl, sr := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment">// 计算理论最小和 sl 和最大和 sr</span></span><br><span class="line">    <span class="keyword">for</span> _, row := <span class="keyword">range</span> mat &#123;</span><br><span class="line">        sl += row[<span class="number">0</span>]</span><br><span class="line">        sr += row[<span class="built_in">len</span>(row)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="comment">// sort.Search(n, f) 在 [0, n) 范围内查找使得 f(i) 为 true 的最小 i</span></span><br><span class="line">    <span class="comment">// 这里的范围长度是 sr - sl，代表从最小和开始的增量范围</span></span><br><span class="line">    <span class="keyword">return</span> sl + sort.Search(sr-sl, <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="comment">// s 代表当前二分尝试的“额外增量”值</span></span><br><span class="line">        <span class="comment">// 实际尝试的数组和 target = sl + s</span></span><br><span class="line">        </span><br><span class="line">        lk := k <span class="comment">// 剩余需要寻找的组合数量</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">bool</span></span><br><span class="line">        dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, s <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="comment">// Base case: 所有行都选择完毕</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> &#123;</span><br><span class="line">                lk--</span><br><span class="line">                <span class="keyword">return</span> lk == <span class="number">0</span> <span class="comment">// 如果找到了 k 个，返回 true</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历第 i 行的元素</span></span><br><span class="line">            <span class="keyword">for</span> _, x := <span class="keyword">range</span> mat[i] &#123;</span><br><span class="line">                <span class="comment">// 剪枝：如果当前元素相对于该行最小值的增量大于剩余预算 s</span></span><br><span class="line">                <span class="comment">// 则该行后续元素也一定不满足，直接 break</span></span><br><span class="line">                <span class="keyword">if</span> x-mat[i][<span class="number">0</span>] &gt; s &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 递归进入上一行 (i-1)</span></span><br><span class="line">                <span class="comment">// 预算减去当前选择带来的增量</span></span><br><span class="line">                <span class="keyword">if</span> dfs(i<span class="number">-1</span>, s-(x-mat[i][<span class="number">0</span>])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从最后一行开始，初始预算就是二分传入的 s</span></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="built_in">len</span>(mat)<span class="number">-1</span>, s)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: <code>O(m * k * log(Range))</code><ul><li>二分查找的范围是 <code>Range = sr - sl</code>，大约为 <code>m * 5000</code>，二分次数为 <code>log(Range)</code>。</li><li>在每次 <code>check</code> 中，我们使用 DFS 寻找不超过 <code>k</code> 个合法组合。虽然最坏情况下 DFS 复杂度较高，但由于我们限制了找到 <code>k</code> 个就停止，且利用了排序进行剪枝，实际运行效率很高。这里的有效搜索节点数与 <code>k</code> 和 <code>m</code> 相关。</li></ul></li><li><strong>空间复杂度</strong>: <code>O(m)</code><ul><li>主要消耗在于 DFS 的递归调用栈，深度为 <code>m</code>。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 1439 题：&lt;a href=&quot;https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/&quot;&gt;有序矩阵中的第 k 个最小数组和&lt;/a&gt;。&lt;br&gt;由于矩阵行有序，我们可以利用 &lt;strong&gt;BS&lt;/strong&gt; 来确定答案，结合 &lt;strong&gt;DFS&lt;/strong&gt; 进行验证。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分答案" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
    <category term="第K小/大" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/%E7%AC%ACK%E5%B0%8F-%E5%A4%A7/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="矩阵" scheme="http://github.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="堆（优先队列）" scheme="http://github.com/tags/%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89/"/>
    
    <category term="第187场周赛" scheme="http://github.com/tags/%E7%AC%AC187%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 373 | 查找和最小的 K 对数字</title>
    <link href="http://github.com/posts/leetcode-373/"/>
    <id>http://github.com/posts/leetcode-373/</id>
    <published>2025-11-26T01:40:00.000Z</published>
    <updated>2025-11-26T01:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 373 题：<a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/">查找和最小的 K 对数字</a>。<br>这是一道经典的“多路归并”问题，本质上是在一个隐式的二维矩阵中寻找第 K 小的元素。利用 <strong>最小堆（优先队列）</strong> 可以高效解决。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定两个以 <strong>非递减顺序排列</strong> 的整数数组 <code>nums1</code> 和 <code>nums2</code> , 以及一个整数 <code>k</code> 。</p><p>定义一对值 <code>(u,v)</code>，其中第一个元素来自 <code>nums1</code>，第二个元素来自 <code>nums2</code> 。</p><p>请找到和最小的 <code>k</code> 个数对 <code>(u1,v1), (u2,v2) ... (uk,vk)</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3</span><br><span class="line">输出: [1,2],[1,4],[1,6]</span><br><span class="line">解释: 返回序列中的前 3 对数：</span><br><span class="line">     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2</span><br><span class="line">输出: [1,1],[1,1]</span><br><span class="line">解释: 返回序列中的前 2 对数：</span><br><span class="line">     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 10^5</li><li>-10^9 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 10^9</li><li>nums1 和 nums2 均为 升序排列</li><li>1 &lt;&#x3D; k &lt;&#x3D; 10^4</li><li>k &lt;&#x3D; nums1.length * nums2.length</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-为什么暴力法不可行？"><a href="#1-为什么暴力法不可行？" class="headerlink" title="1. 为什么暴力法不可行？"></a>1. 为什么暴力法不可行？</h4><p>如果直接生成所有可能的数对 <code>(nums1[i], nums2[j])</code>，总共有 <code>m * n</code> 对（其中 <code>m</code> 和 <code>n</code> 分别是数组的长度）。题目中数组长度可达 10^5，乘积可能达到 10^10，内存和时间都无法承受。<br>然而，我们需要找的只是 <strong>前 k 个</strong> 最小的对，且 <code>k</code> 的范围相对较小（最大 10^4），这提示我们应该使用与 <code>k</code> 相关的复杂度算法。</p><h4 id="2-利用有序性与堆"><a href="#2-利用有序性与堆" class="headerlink" title="2. 利用有序性与堆"></a>2. 利用有序性与堆</h4><p>由于 <code>nums1</code> 和 <code>nums2</code> 都是升序排列的，我们可以将所有可能的数对想象成一个矩阵，其中第 <code>i</code> 行第 <code>j</code> 列的元素是 <code>nums1[i] + nums2[j]</code>。<br>在这个矩阵中：</p><ul><li>每一行从左到右是递增的。</li><li>每一列从上到下是递增的。</li></ul><p>最小的元素一定是 <code>(nums1[0], nums2[0])</code>。<br>当我们选择了 <code>(nums1[i], nums2[j])</code> 后，下一个可能的最小元素只能是它的右边邻居 <code>(nums1[i], nums2[j+1])</code> 或者下边邻居 <code>(nums1[i+1], nums2[j])</code>。</p><h4 id="3-优化入堆策略"><a href="#3-优化入堆策略" class="headerlink" title="3. 优化入堆策略"></a>3. 优化入堆策略</h4><p>为了避免重复访问和控制堆的大小，我们可以采取一种特定的扩展策略：</p><ol><li>初始时，只将 <code>(nums1[0] + nums2[0], 0, 0)</code> 放入最小堆。元组中记录的是 <code>(数值和, nums1下标, nums2下标)</code>。</li><li>每次从堆中取出最小元素 <code>(sum, i, j)</code>，将其加入答案。</li><li>接下来需要将该元素的潜在“后继”加入堆中。为了保证不重不漏：<ul><li><strong>向右扩展</strong>：总是将 <code>(i, j+1)</code> 加入堆（如果 <code>j+1</code> 未越界）。</li><li><strong>向下扩展</strong>：只有当 <code>j == 0</code> 时，才将 <code>(i+1, 0)</code> 加入堆（如果 <code>i+1</code> 未越界）。</li></ul></li></ol><p>这种策略相当于把 <code>nums1</code> 看作行的起始，我们可以在行内自由向右走；但换行操作只允许在每一行的开头进行。这样可以保证每一对组合只被加入堆一次。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kSmallestPairs</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 初始只放入 (0,0) 位置的元素</span></span><br><span class="line">        h = [(nums1[<span class="number">0</span>]+nums2[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="comment"># 取出当前堆中最小的元素</span></span><br><span class="line">            _,i,j = heappop(h)</span><br><span class="line">            ans.append([nums1[i],nums2[j]])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 策略：如果当前是该行的第一个元素 (j==0)，则可以将下一行的第一个元素入堆</span></span><br><span class="line">            <span class="comment"># 这样保证了第一列的元素会被依次加入</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span> <span class="keyword">and</span> i+<span class="number">1</span>&lt;<span class="built_in">len</span>(nums1):</span><br><span class="line">                heappush(h,(nums1[i+<span class="number">1</span>]+nums2[<span class="number">0</span>],i+<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 策略：总是将当前元素的右侧元素入堆</span></span><br><span class="line">            <span class="keyword">if</span> j+<span class="number">1</span>&lt;<span class="built_in">len</span>(nums2):</span><br><span class="line">                heappush(h,(nums1[i]+nums2[j+<span class="number">1</span>],i,j+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kSmallestPairs</span><span class="params">(nums1, nums2 []<span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n, m := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="comment">// 初始化最小堆，放入 (0,0)</span></span><br><span class="line">    h := hp&#123;&#123;nums1[<span class="number">0</span>] + nums2[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>, k) <span class="comment">// 预分配空间</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> k &#123;</span><br><span class="line">        <span class="comment">// 弹出堆顶最小元素</span></span><br><span class="line">        p := heap.Pop(&amp;h).(tuple)</span><br><span class="line">        i, j := p.i, p.j</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, []<span class="type">int</span>&#123;nums1[i], nums2[j]&#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只有当我们在当前行的第一个位置时，才去添加下一行的起始元素</span></span><br><span class="line">        <span class="comment">// 这相当于负责了 &quot;向下&quot; 的搜索方向</span></span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">0</span> &amp;&amp; i+<span class="number">1</span> &lt; n &#123;</span><br><span class="line">            heap.Push(&amp;h, tuple&#123;nums1[i+<span class="number">1</span>] + nums2[<span class="number">0</span>], i + <span class="number">1</span>, <span class="number">0</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 总是尝试添加当前位置右边的元素</span></span><br><span class="line">        <span class="comment">// 这相当于负责了 &quot;向右&quot; 的搜索方向</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span> &lt; m &#123;</span><br><span class="line">            heap.Push(&amp;h, tuple&#123;nums1[i] + nums2[j+<span class="number">1</span>], i, j + <span class="number">1</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义堆所需的结构体和接口方法</span></span><br><span class="line"><span class="keyword">type</span> tuple <span class="keyword">struct</span>&#123; s, i, j <span class="type">int</span> &#125;</span><br><span class="line"><span class="keyword">type</span> hp []tuple</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h hp)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h hp)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i].s &lt; h[j].s &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h hp)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hp)</span></span> Push(v any)        &#123; *h = <span class="built_in">append</span>(*h, v.(tuple)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hp)</span></span> Pop() any          &#123; a := *h; v := a[<span class="built_in">len</span>(a)<span class="number">-1</span>]; *h = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]; <span class="keyword">return</span> v &#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(k log k)</code><br>我们需要循环 <code>k</code> 次来找到前 <code>k</code> 个最小对。在每次迭代中，我们执行一次 <code>heappop</code> 和最多两次 <code>heappush</code>。堆中的元素数量最多不会超过 <code>k</code>（实际上更接近于 <code>k</code> 或 <code>nums1</code> 的长度，取决于扩展策略，但在最坏情况下与 <code>k</code> 同阶）。因此，每次堆操作的时间复杂度为 <code>O(log k)</code>。总时间复杂度为 <code>O(k log k)</code>。</p></li><li><p><strong>空间复杂度</strong>: <code>O(k)</code><br>堆中最多存储 <code>k</code> 个元素（或者更准确地说是生成的候选对数量，这与 <code>k</code> 成正比）。用于存储答案的数组也需要 <code>O(k)</code> 的空间。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 373 题：&lt;a href=&quot;https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/&quot;&gt;查找和最小的 K 对数字&lt;/a&gt;。&lt;br&gt;这是一道经典的“多路归并”问题，本质上是在一个隐式的二维矩阵中寻找第 K 小的元素。利用 &lt;strong&gt;最小堆（优先队列）&lt;/strong&gt; 可以高效解决。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分答案" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
    <category term="第K小/大" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/%E7%AC%ACK%E5%B0%8F-%E5%A4%A7/"/>
    
    
    <category term="数组" scheme="http://github.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="堆（优先队列）" scheme="http://github.com/tags/%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 793 | 阶乘函数后 K 个零</title>
    <link href="http://github.com/posts/leetcode-793/"/>
    <id>http://github.com/posts/leetcode-793/</id>
    <published>2025-11-25T03:05:00.000Z</published>
    <updated>2025-11-25T03:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeetCode 第 793 题：<a href="https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/">阶乘函数后 K 个零</a>。<br>这道题是 <a href="https://leetcode.cn/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a> 的逆向问题。核心在于理解阶乘末尾零的单调性，并利用二分查找来确定范围。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>f(x) 是 x! 末尾是 0 的数量。回想一下 x! &#x3D; 1 * 2 * 3 * … * x，且 0! &#x3D; 1 。</p><p>例如， f(3) &#x3D; 0 ，因为 3! &#x3D; 6 的末尾没有 0 ；而 f(11) &#x3D; 2 ，因为 11!&#x3D; 39916800 末端有 2 个 0 。<br>给定 k，找出返回能满足 f(x) &#x3D; k 的非负整数 x 的数量。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 0</span><br><span class="line">输出：5</span><br><span class="line">解释：0!, 1!, 2!, 3!, 和 4! 均符合 k = 0 的条件。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 5</span><br><span class="line">输出：0</span><br><span class="line">解释：没有匹配到这样的 x!，符合 k = 5 的条件。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 &lt;&#x3D; k &lt;&#x3D; 10^9</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-数学原理分析"><a href="#1-数学原理分析" class="headerlink" title="1. 数学原理分析"></a>1. 数学原理分析</h4><p>首先，我们需要知道如何计算 x! 末尾 0 的个数。<br>末尾的 0 是由因子 2 * 5 产生的。在 1 到 x 的所有数中，因子 2 的数量远多于因子 5 的数量。因此，x! 末尾 0 的数量取决于因子 5 的数量。</p><p>根据勒让德定理（Legendre’s Formula），f(x) 的计算公式如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x) = floor(x / 5) + floor(x / 25) + floor(x / 125) + ...</span><br></pre></td></tr></table></figure><p>简单来说，就是计算 x 中包含多少个 5，多少个 25，多少个 125……以此类推并求和。</p><h4 id="2-函数的单调性与结果特性"><a href="#2-函数的单调性与结果特性" class="headerlink" title="2. 函数的单调性与结果特性"></a>2. 函数的单调性与结果特性</h4><p>观察函数 f(x)：</p><ul><li><strong>单调性</strong>：随着 x 增大，f(x) 的值是非递减的。</li><li><strong>阶梯状</strong>：因为只有当 x 是 5 的倍数时，f(x) 的值才会增加。对于 x, x+1, x+2, x+3, x+4，它们的阶乘末尾 0 的个数是一样的。</li><li><strong>答案的取值</strong>：基于上述特性，满足 f(x) &#x3D; k 的 x 的数量，<strong>要么是 5，要么是 0</strong>。<ul><li>如果是 5：说明存在某个区间 [5m, 5m+4] 使得其阶乘末尾恰好有 k 个 0。</li><li>如果是 0：说明 f(x) 的值直接从 k-1 跳到了 k+1（或更大），跳过了 k。这通常发生在 x 是 25, 125 等 5 的高次幂的倍数时（此时因子 5 的数量会一次性增加多个）。</li></ul></li></ul><h4 id="3-二分查找解法"><a href="#3-二分查找解法" class="headerlink" title="3. 二分查找解法"></a>3. 二分查找解法</h4><p>由于 f(x) 具有单调性，我们可以使用 <strong>二分查找</strong>。<br>题目要求满足 f(x) &#x3D; k 的数量，这可以转化为求两个边界：</p><ol><li>满足 f(x) &gt;&#x3D; k 的最小 x（左边界）。</li><li>满足 f(x) &gt;&#x3D; k + 1 的最小 x（右边界）。</li></ol><p>最终答案即为：<code>search(k + 1) - search(k)</code>。<br>如果 k 存在解，差值为 5；如果不存在，差值为 0。</p><p><strong>搜索范围：</strong></p><ul><li>因为 f(x) 大约等于 x&#x2F;5 加上一些更小的项，所以 x 大约是 5*k。</li><li>考虑到 k 最大为 10^9，我们可以将二分的上界设为 5 * 10^9 左右，使用 64 位整数（long long 或 Python int）不会溢出。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preimageSizeFZF</span>(<span class="params">self, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 计算 x! 末尾有多少个 0</span></span><br><span class="line">        <span class="comment"># 逻辑：f(x) = x//5 + x//25 + x//125 ...</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">zeta</span>(<span class="params">x</span>):</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> x:</span><br><span class="line">                x //= <span class="number">5</span></span><br><span class="line">                res += x</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 二分查找：寻找满足 zeta(x) &gt;= target 的最小 x</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">search_min_x</span>(<span class="params">target</span>):</span><br><span class="line">            <span class="comment"># 搜索范围 [0, 5*target] 足够覆盖</span></span><br><span class="line">            <span class="comment"># 当 target 很大时，上界稍微放宽一点保证覆盖</span></span><br><span class="line">            l, r = <span class="number">0</span>, <span class="number">5</span> * target + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                mid = (l + r) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> zeta(mid) &lt; target:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 逻辑：(满足 f(x) &gt;= k+1 的最小 x) - (满足 f(x) &gt;= k 的最小 x)</span></span><br><span class="line">        <span class="comment"># 如果 k 存在解，差值为 5；否则为 0</span></span><br><span class="line">        <span class="keyword">return</span> search_min_x(k + <span class="number">1</span>) - search_min_x(k)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preimageSizeFZF</span><span class="params">(k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 辅助函数：计算 x! 末尾 0 的个数</span></span><br><span class="line">    <span class="comment">// 逻辑：count = x/5 + x/25 + x/125 ...</span></span><br><span class="line">    zeta := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        res := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">            x /= <span class="number">5</span></span><br><span class="line">            res += x</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找：寻找满足 zeta(x) &gt;= t 的最小 x</span></span><br><span class="line">    search := <span class="function"><span class="keyword">func</span><span class="params">(t <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="comment">// 搜索范围：下界 0，上界 5*t + 1</span></span><br><span class="line">        <span class="comment">// 当 t=10^9 时，5*t 约为 50亿，在 64位 int 范围内</span></span><br><span class="line">        l, r := <span class="number">0</span>, <span class="number">5</span>*t+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">            mid := l + (r-l)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> zeta(mid) &lt; t &#123;</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用差分思想：</span></span><br><span class="line">    <span class="comment">// 寻找 f(x)=k 的数量等价于：</span></span><br><span class="line">    <span class="comment">// (f(x) &gt;= k+1 的起点) - (f(x) &gt;= k 的起点)</span></span><br><span class="line">    <span class="keyword">return</span> search(k+<span class="number">1</span>) - search(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>: O(log^2 k)</p><ul><li>二分查找的范围大约是 5k，迭代次数为 O(log k)。</li><li>每次迭代中计算 <code>zeta(mid)</code> 需要 O(log_5 mid) 的时间，也就是 O(log k)。</li><li>总复杂度为 O(log k * log k)。对于 k &#x3D; 10^9，计算量非常小，执行速度很快。</li></ul></li><li><p><strong>空间复杂度</strong>: O(1)</p><ul><li>只使用了常数个变量。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeetCode 第 793 题：&lt;a href=&quot;https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/&quot;&gt;阶乘函数后 K 个零&lt;/a&gt;。&lt;br&gt;这道题是 &lt;a href=&quot;https://leetcode.cn/problems/factorial-trailing-zeroes/&quot;&gt;172. 阶乘后的零&lt;/a&gt; 的逆向问题。核心在于理解阶乘末尾零的单调性，并利用二分查找来确定范围。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分答案" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
    <category term="第 K小/大" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/%E7%AC%AC-K%E5%B0%8F-%E5%A4%A7/"/>
    
    
    <category term="二分查找" scheme="http://github.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="数学" scheme="http://github.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
