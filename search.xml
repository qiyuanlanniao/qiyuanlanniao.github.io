<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode 1011 | 在 D 天内送达包裹的能力</title>
    <url>//posts/leetcode-1011/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1011 题：<a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/description/">在 D 天内送达包裹的能力</a>。<br>本题的核心在于识别出答案的单调性，并将一个求解最优值的问题，巧妙地转化为一个判定性的问题，从而利用二分查找在对数时间内高效求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要找到一艘船的最低运载能力，这艘船需要把传送带上的一系列包裹，在指定的天数 <code>days</code> 内，从一个港口运送到另一个港口。</p>
<p>这里的核心约束条件是：</p>
<ol>
<li>包裹必须按照 <code>weights</code> 数组给出的顺序装运，不能打乱。</li>
<li>每天装载的包裹总重量不能超过船的运载能力。</li>
<li>必须在 <code>days</code> 天（含）之内完成所有包裹的运输。</li>
</ol>
<p>我们的目标是找出满足这些条件的<strong>最低</strong>运载能力。</p>
<p>举个例子，<code>weights = [1,2,3,4,5,6,7,8,9,10]</code>, <code>days = 5</code>。<br>如果船的运载能力是 10，我们需要的天数会超过 5 天。而如果运载能力是 55（所有包裹总和），我们只需要 1 天就能运完。这暗示了运载能力和所需天数之间存在一种反比关系：运载能力越大，所需天数越少。</p>
<p>我们的任务就是在所有可行的运载能力中，找到那个最小的值。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最低运载能力”似乎很困难。一个更直接的想法是：如果我们<strong>假定</strong>一个运载能力 <code>c</code>，我们能否判断出这个能力是否足够在 <code>days</code> 天内运完所有货物？</p>
<p>这个判定问题就简单多了。我们可以写一个辅助函数 <code>canShip(capacity)</code>，贪心地模拟装载过程：</p>
<ul>
<li>初始化天数 <code>d = 1</code>，当前船上已装载重量 <code>current_weight = 0</code>。</li>
<li>按顺序遍历 <code>weights</code> 数组中的每个包裹：<ul>
<li>如果 <code>current_weight</code> 加上当前包裹的重量 <code>w</code> 不超过 <code>capacity</code>，则继续装载，<code>current_weight += w</code>。</li>
<li>否则，说明今天装不下了，需要新的一天。我们让天数 <code>d</code> 增加 1，然后将当前包裹装上新船，<code>current_weight = w</code>。</li>
</ul>
</li>
<li>遍历结束后，得到的 <code>d</code> 就是在运载能力为 <code>capacity</code> 时，运完所有货物所需的最少天数。</li>
<li>最后，我们比较这个 <code>d</code> 和题目给定的 <code>days</code>。如果 <code>d &lt;= days</code>，说明 <code>capacity</code> 是一个可行的运载能力。</li>
</ul>
<p>现在，我们有了一个判定的方法。观察可以发现，这个判定结果具有<strong>单调性</strong>：</p>
<ul>
<li>如果一个运载能力 <code>c</code> 可以在 <code>days</code> 天内完成任务，那么任何大于 <code>c</code> 的运载能力 <code>c&#39;</code> 也一定可以完成。</li>
<li>反之，如果 <code>c</code> 无法完成，任何小于 <code>c</code> 的能力也必然无法完成。</li>
</ul>
<p>这种单调性是应用二分查找的完美信号。 我们可以对“运载能力”这个值进行二分查找，来快速定位到那个“最低可行”的临界点。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：船的运载能力至少要能装下最重的那一个包裹，所以下界是 <code>max(weights)</code>。</li>
<li><strong>上界 (right)</strong>：在最极端的情况下，我们可以用一天把所有包裹都运走，此时需要的运载能力是所有包裹的重量之和，即 <code>sum(weights)</code>。</li>
</ul>
<p>因此，我们就在 <code>[max(weights), sum(weights)]</code> 这个区间内，对运载能力进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = max(weights)</code>：这是可能的最低运载能力。</li>
<li><code>right = sum(weights)</code>：这是可能的最高运载能力。</li>
<li><code>ans</code> 初始化为 <code>right</code>，用来记录我们找到的可行解。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>left &lt;= right</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = left + (right - left) // 2</code> 作为当前的“猜测运载能力”。</li>
<li>调用辅助函数 <code>canShip(mid)</code> 来判定这个猜测值是否可行。<ul>
<li><strong>如果 <code>canShip(mid)</code> 返回 <code>True</code></strong> (即 <code>mid</code> 这个运载能力可以在 <code>days</code> 天内运完)：<ul>
<li>说明 <code>mid</code> 是一个潜在的答案，我们记录下来 <code>ans = mid</code>。</li>
<li>但是我们想找的是“最低”运载能力，所以我们尝试一个更小的值，将搜索范围缩小到左半边：<code>right = mid - 1</code>。</li>
</ul>
</li>
<li><strong>如果 <code>canShip(mid)</code> 返回 <code>False</code></strong> (即 <code>mid</code> 这个运载能力不够)：<ul>
<li>说明我们需要更大的运载能力，将搜索范围缩小到右半边：<code>left = mid + 1</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>ans</code> 中存储的就是满足条件的最低运载能力。在我们的实现中，最后返回 <code>left</code> 也是等价的。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shipWithinDays</span>(<span class="params">self, weights: <span class="type">List</span>[<span class="built_in">int</span>], days: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 确定二分查找的左右边界</span></span><br><span class="line">        <span class="comment"># 运载能力的下限是单个包裹的最大重量</span></span><br><span class="line">        left = <span class="built_in">max</span>(weights)</span><br><span class="line">        <span class="comment"># 运载能力的上限是所有包裹的总重量</span></span><br><span class="line">        right = <span class="built_in">sum</span>(weights)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 辅助函数：检查在给定的运载能力 capacity 下，能否在 days 天内运完</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">can_ship</span>(<span class="params">capacity: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            days_needed = <span class="number">1</span></span><br><span class="line">            current_weight = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> weights:</span><br><span class="line">                <span class="keyword">if</span> current_weight + w &gt; capacity:</span><br><span class="line">                    <span class="comment"># 当前船装不下了，需要新的一天</span></span><br><span class="line">                    days_needed += <span class="number">1</span></span><br><span class="line">                    current_weight = w</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 继续装货</span></span><br><span class="line">                    current_weight += w</span><br><span class="line">            <span class="keyword">return</span> days_needed &lt;= days</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> can_ship(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 可行，说明它可能就是答案，</span></span><br><span class="line">                <span class="comment"># 或者还有更小的可行值，所以我们尝试在左半部分继续寻找</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 不可行，说明运载能力太小，</span></span><br><span class="line">                <span class="comment"># 必须增大，所以去右半部分寻找</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时，left 就是满足条件的最低运载能力</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N * log(S))。<ul>
<li><code>N</code> 是包裹数组 <code>weights</code> 的长度。</li>
<li><code>S</code> 是 <code>sum(weights) - max(weights)</code>，即二分查找的搜索空间大小。</li>
<li>二分查找本身需要 <code>log(S)</code> 次迭代。</li>
<li>在每次迭代中，我们都需要调用 <code>can_ship</code> 函数，该函数需要遍历一次 <code>weights</code> 数组，时间复杂度为 O(N)。</li>
<li>因此，总时间复杂度是这两者的乘积。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)。<ul>
<li>除了输入数组外，我们只使用了几个变量来存储左右边界、中间值和模拟过程中的状态，所以空间复杂度是常数级的。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是二分查找思想应用的经典范例。它教会我们当遇到求解“最小值中的最大值”或者“最大值中的最小值”这类问题时，可以尝试将其转化为一个更简单的“判定性”问题。如果这个判定问题具有单调性，那么就可以利用二分查找，将搜索范围不断折半，从而在对数级别的时间复杂度内找到最优解，这比线性扫描所有可能的答案要高效得多。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最小</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>第128场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1016 | 滑动窗口巧解二进制子串问题</title>
    <url>//posts/leetcode-1016/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1016 题：<a href="https://leetcode.cn/problems/binary-string-with-substrings-representing-1-to-n/description/">子串能表示从 1 到 N 数字的二进制串</a>。<br>这道题巧妙地将字符串子串搜索与数字的二进制表示结合起来，考验我们能否从不同的角度思考问题。虽然存在更直接的解法，但我们同样可以用“滑动窗口”的思想来解决它，从而更深刻地理解其应用范式。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们来仔细分析一下题目：给定一个二进制字符串 <code>s</code> 和一个正整数 <code>n</code>，我们需要判断<strong>从 1 到 n 的每一个整数</strong>，其对应的二进制表示形式是否都是 <code>s</code> 的一个<strong>子字符串</strong>。</p>
<ul>
<li><strong>二进制表示</strong>：这里指的是标准的二进制转换，例如整数 <code>3</code> 对应字符串 <code>&quot;11&quot;</code>。</li>
<li><strong>子字符串</strong>：必须是原字符串中<strong>连续</strong>的字符序列。</li>
</ul>
<p>例如，<code>s = &quot;0110&quot;</code>, <code>n = 3</code>。我们需要检查 <code>1</code>, <code>2</code>, <code>3</code>：</p>
<ul>
<li>整数 <code>1</code> 的二进制是 <code>&quot;1&quot;</code>，它是 <code>s</code> 的子串。</li>
<li>整数 <code>2</code> 的二进制是 <code>&quot;10&quot;</code>，它是 <code>s</code> 的子串。</li>
<li>整数 <code>3</code> 的二进制是 <code>&quot;11&quot;</code>，它是 <code>s</code> 的子串。<br>因为 <code>1</code> 到 <code>3</code> 都满足条件，所以最终返回 <code>true</code>。</li>
</ul>
<p>如果 <code>n = 4</code>，由于 <code>4</code> 的二进制是 <code>&quot;100&quot;</code>，在 <code>s</code> 中找不到，因此应返回 <code>false</code>。</p>
<h3 id="核心思路：转化问题"><a href="#核心思路：转化问题" class="headerlink" title="核心思路：转化问题"></a>核心思路：转化问题</h3><h4 id="常规思路-vs-滑动窗口思路"><a href="#常规思路-vs-滑动窗口思路" class="headerlink" title="常规思路 vs 滑动窗口思路"></a>常规思路 vs 滑动窗口思路</h4><p>一个非常直接的想法是：从 <code>n</code> 开始倒序遍历到 <code>1</code>，对每个数字 <code>i</code>，将其转换为二进制字符串，然后检查这个二进制串是否存在于 <code>s</code> 中。只要有一个数字不满足，就立刻返回 <code>false</code>。这种方法通常是最高效的。</p>
<p>然而，为了探索“滑动窗口”的应用，我们可以<strong>逆向思考</strong>这个问题：我们不去检查 <code>1</code> 到 <code>n</code> 是否在 <code>s</code> 里，而是<strong>从 <code>s</code> 中提取出所有可能的二进制子串，将它们转换为数字，看看这些数字是否完整地覆盖了 <code>1</code> 到 <code>n</code> 的集合</strong>。</p>
<p>这个“生成并检查”的策略，就是滑动窗口思想的一种体现。这里的“窗口”不再是固定的长度，而是所有可能的长度。</p>
<h4 id="滑动窗口登场"><a href="#滑动窗口登场" class="headerlink" title="滑动窗口登场"></a>滑动窗口登场</h4><p>这个思路的实现步骤如下：</p>
<ol>
<li>创建一个<strong>哈希集合（Set）</strong>，用来存放我们在 <code>s</code> 中找到的、且在 <code>[1, n]</code> 范围内的所有数字。集合可以自动处理重复值。</li>
<li>遍历所有可能的子串长度，作为我们滑动窗口的<strong>大小</strong>。</li>
<li>对于每一个确定的窗口大小，我们在 <code>s</code> 上从左到右滑动这个窗口。</li>
<li>在每次滑动中，提取窗口内的子串，将其从二进制转换为十进制数。</li>
<li>如果这个数字在 <code>[1, n]</code> 的范围内，就将其加入哈希集合。</li>
<li>当所有长度、所有位置的窗口都检查完毕后，我们最后判断集合的大小是否等于 <code>n</code>。如果等于，说明 <code>1</code> 到 <code>n</code> 都被找到了。</li>
</ol>
<h3 id="滑动窗口算法详解"><a href="#滑动窗口算法详解" class="headerlink" title="滑动窗口算法详解"></a>滑动窗口算法详解</h3><ol>
<li><p><strong>准备工作</strong>:</p>
<ul>
<li>创建一个空的哈希集合 <code>found_numbers</code>，用于存储找到的有效数字。</li>
</ul>
</li>
<li><p><strong>确定窗口范围</strong>:</p>
<ul>
<li>我们的窗口大小（即子串长度 <code>length</code>）可以从 <code>1</code> 变化到 <code>s</code> 的总长度 <code>len(s)</code>。</li>
<li><strong>优化</strong>：我们可以加入一些剪枝逻辑。例如，如果一个长度为 <code>length</code> 的二进制数（其最小值是 <code>2^(length-1)</code>）已经大于 <code>n</code>，那么更长的子串代表的数字必然也大于 <code>n</code>，后续的长度遍历就可以提前终止。</li>
</ul>
</li>
<li><p><strong>滑动与生成</strong>:</p>
<ul>
<li>外层循环遍历窗口大小 <code>length</code>，从 <code>1</code> 到 <code>len(s)</code>。</li>
<li>内层循环是真正的滑动窗口，遍历窗口的起始位置 <code>i</code>，从 <code>0</code> 到 <code>len(s) - length</code>。</li>
<li><strong>提取与转换</strong>：获取子串 <code>s[i : i+length]</code>。</li>
<li><strong>有效性判断</strong>：将子串转换为数字 <code>num</code>。注意，<code>int(&quot;011&quot;, 2)</code> 会正确得到 <code>3</code>，所以我们不需要手动处理前导零，但可以做一个小优化：如果子串以 <code>&#39;0&#39;</code> 开头，可以跳过，因为它不会是任何正整数的标准二进制表示。</li>
<li><strong>记录结果</strong>：如果 <code>1 &lt;= num &lt;= n</code>，则将 <code>num</code> 添加到 <code>found_numbers</code> 集合中。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>:</p>
<ul>
<li>所有循环结束后，检查 <code>len(found_numbers)</code> 是否等于 <code>n</code>。如果相等，返回 <code>True</code>；否则返回 <code>False</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">queryString</span>(<span class="params">self, s: <span class="built_in">str</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1：准备工作</span></span><br><span class="line">        found_numbers = <span class="built_in">set</span>()</span><br><span class="line">        s_len = <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2 &amp; 3：遍历不同大小的窗口并滑动</span></span><br><span class="line">        <span class="comment"># 外层循环：确定窗口大小 length</span></span><br><span class="line">        <span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, s_len + <span class="number">1</span>):</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 优化：如果当前长度的最小可能值都大于n，则无需继续</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (length - <span class="number">1</span>)) &gt; n:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 内层循环：滑动窗口</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s_len - length + <span class="number">1</span>):</span><br><span class="line">                substring = s[i : i + length]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 优化：非&quot;0&quot;的数字，其标准二进制表示不以&#x27;0&#x27;开头</span></span><br><span class="line">                <span class="keyword">if</span> substring[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 转换并检查数字</span></span><br><span class="line">                num = <span class="built_in">int</span>(substring, <span class="number">2</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> num &gt; n:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 记录在[1, n]范围内的数字</span></span><br><span class="line">                <span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                    found_numbers.add(num)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 4：返回最终结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(found_numbers) == n</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(L²)。其中 L 是字符串 <code>s</code> 的长度。我们有两层循环来生成所有子串，子串数量级为 O(L²)。将一个长度为 <code>k</code> 的二进制串转换为整数的时间大致为 O(k)。由于 <code>k</code> 最大为 <code>L</code>，总时间复杂度近似为 O(L³)。不过，因为 <code>k</code> 的平均长度远小于 <code>L</code>，且有剪枝，实际运行速度会更快。</li>
<li><strong>空间复杂度</strong>: O(N)。在最坏的情况下，哈希集合 <code>found_numbers</code> 需要存储从 <code>1</code> 到 <code>n</code> 的所有 <code>n</code> 个数字。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题提供了一个独特的视角，让我们看到滑动窗口不仅可以用于寻找满足特定<strong>性质</strong>的子串（如字符频率），还可以用于<strong>生成</strong>所有子串来进行检查。</p>
<p>尽管从 <code>n</code> 向 <code>1</code> 遍历的直接解法在性能上通常更优，但通过本题的“滑动窗口”解法，我们锻炼了逆向思维和问题转化的能力。在算法学习中，能够从多个角度分析和解决同一个问题，是提升能力的关键一步。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>位运算</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>第 129 场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1040 | SW脑筋急转弯求解“移动石子直到连续 II”</title>
    <url>//posts/leetcode-1040/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1040 题：<a href="https://leetcode.cn/problems/moving-stones-until-consecutive-ii/description/">移动石子直到连续 II</a>。<br>该题要求我们计算将一组分散的石子移动成连续序列所需的最小和最大步数。最大步数是一个有趣的数学问题，而最小步数则巧妙地伪装成了一个滑动窗口问题，并带有一个需要细心处理的“陷阱”。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们 X 轴上一些不同位置的石子，要求我们通过一系列移动，将它们变成连续的。移动规则如下：</p>
<ol>
<li>只能移动位于<strong>最小</strong>或<strong>最大</strong>位置的<strong>端点石子</strong>。</li>
<li>必须将它移动到一个<strong>未被占用</strong>的位置。</li>
<li>移动后，该石子<strong>不能</strong>成为新的端点石子。这意味着它必须被放置在其他两个石子之间。</li>
</ol>
<p>游戏在所有石子位置连续时结束。我们需要返回一个数组 <code>[最小移动次数, 最大移动次数]</code>。</p>
<p>例如，对于 <code>stones = [7,4,9]</code>，排序后是 <code>[4, 7, 9]</code>。</p>
<ul>
<li><strong>最大移动</strong>：可以先将 <code>4</code> 移动到 <code>6</code>，得到 <code>[6, 7, 9]</code>；再将 <code>9</code> 移动到 <code>8</code>，得到 <code>[6, 7, 8]</code>。共 2 步。</li>
<li><strong>最小移动</strong>：可以将 <code>4</code> 移动到 <code>8</code>，直接得到 <code>[7, 8, 9]</code>。只需 1 步。<br>所以答案是 <code>[1, 2]</code>。</li>
</ul>
<h3 id="核心思路：最大和最小分开击破"><a href="#核心思路：最大和最小分开击破" class="headerlink" title="核心思路：最大和最小分开击破"></a>核心思路：最大和最小分开击破</h3><p>这类要求两个极值的题目，通常可以将最大值和最小值的求解策略分开考虑。</p>
<h4 id="最大移动次数：贪心思想"><a href="#最大移动次数：贪心思想" class="headerlink" title="最大移动次数：贪心思想"></a>最大移动次数：贪心思想</h4><p>要让移动次数最多，我们应该“小步慢走”，每次只填补一个最小的空位，从而为后续移动保留最大的空间。</p>
<ol>
<li><strong>排序</strong>：首先将石子位置 <code>stones</code> 排序。</li>
<li><strong>总空位数</strong>：石子占据的总区间长度是 <code>stones[n-1] - stones[0] + 1</code>。其中有 <code>n</code> 个石子，所以总的空位数是 <code>(stones[n-1] - stones[0] + 1) - n</code>。</li>
<li><strong>贪心策略</strong>：每次移动，我们都会放弃一端的空间。为了保留最大的可操作空间，我们应该总是从<strong>间隙更小</strong>的那一端移动端点石子。例如，如果 <code>stones[1] - stones[0]</code> 比 <code>stones[n-1] - stones[n-2]</code> 小，我们就应该先移动 <code>stones[0]</code>，把 <code>stones[1]</code> 作为新的左端点。</li>
<li><strong>简化公式</strong>：这个过程最终可以简化成一个优美的数学公式。最大移动次数等于<strong>总空位数</strong>减去<strong>两端中较小的那个空隙</strong>。<ul>
<li><code>max_moves = (总空位数) - min(左端空隙, 右端空隙)</code></li>
<li>左端空隙 &#x3D; <code>stones[1] - stones[0] - 1</code></li>
<li>右端空隙 &#x3D; <code>stones[n-1] - stones[n-2] - 1</code></li>
<li>代入化简后可得：<code>max_moves = max(stones[n-1] - stones[1] - n + 2, stones[n-2] - stones[0] - n + 2)</code></li>
</ul>
</li>
</ol>
<h4 id="最小移动次数：滑动窗口"><a href="#最小移动次数：滑动窗口" class="headerlink" title="最小移动次数：滑动窗口"></a>最小移动次数：滑动窗口</h4><p>要让移动次数最少，我们应该尽可能多地保留原地不动的石子。最终，所有石子会占据一个长度为 <code>n</code> 的连续区间。我们的目标就是找到这样一个目标区间，它能容纳最多的原始石子。</p>
<p>这个问题可以转化为：<strong>用一个长度为 <code>n</code> 的尺子（窗口），在数轴上滑动，找到它能覆盖的最多石子数</strong>。</p>
<p>假设我们找到了这个最大可覆盖数 <code>max_coverage</code>。那么，需要移动的石子数就是 <code>n - max_coverage</code>。这就是最小移动次数的基本思路。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><strong>排序</strong>：对 <code>stones</code> 数组进行升序排序。</li>
<li><strong>计算 <code>max_moves</code></strong>：直接套用上面推导出的公式。</li>
<li><strong>计算 <code>min_moves</code></strong>：<ul>
<li>使用一个滑动窗口 <code>[j, i]</code> 遍历排序后的 <code>stones</code> 数组。</li>
<li>对于每个右端点 <code>i</code>，我们向右移动左端点 <code>j</code>，直到窗口代表的区间长度 <code>stones[i] - stones[j] + 1</code> 不超过 <code>n</code>。</li>
<li>此时，窗口 <code>[j, i]</code> 内的石子数是 <code>i - j + 1</code>，这些是可以被一个长度为 <code>n</code> 的最终序列容纳的。我们记录这个数量的最大值 <code>max_coverage</code>。</li>
<li>基本的 <code>min_moves</code> 就是 <code>n - max_coverage</code>。</li>
</ul>
</li>
<li><strong>处理 <code>min_moves</code> 的特殊情况</strong>：<ul>
<li>考虑一种情况：<code>stones = [2,3,4,5,10]</code> (<code>n=5</code>)。我们的滑动窗口会找到 <code>[2,3,4,5]</code> 这 4 个石子，<code>max_coverage = 4</code>，得出 <code>min_moves = 1</code>。</li>
<li>但问题是，我们能一步完成吗？目标是 <code>[2,3,4,5,6]</code>。我们需要移动 <code>10</code> 到 <code>6</code>。移动后，石子 <code>10</code> 位于 <code>6</code>，成为新的最大端点，这违反了规则 “移动后不能是端点石子”。</li>
<li>因此，我们不能直接移动 <code>10</code>。我们必须移动 <code>2</code> 或 <code>5</code>，比如把 <code>5</code> 移动到 <code>6</code>，得到 <code>[2,3,4,6,10]</code>。这之后还需要移动 <code>10</code>，总共需要 2 步。</li>
<li>这个<strong>特殊情况</strong>发生在：当 <code>max_coverage = n-1</code> 且这 <code>n-1</code> 个石子本身是<strong>紧密连续</strong>的，同时那个唯一的“局外石”与这个连续块的距离<strong>大于1</strong>时，最小移动次数是 <strong>2</strong>。</li>
<li>我们可以通过检查排序后数组的两端是否存在这种情况来判断。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numMovesStonesII</span>(<span class="params">self, stones: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stones.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(stones)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算最大移动次数</span></span><br><span class="line">        max_moves = <span class="built_in">max</span>(stones[n-<span class="number">1</span>] - stones[<span class="number">1</span>] - n + <span class="number">2</span>, stones[n-<span class="number">2</span>] - stones[<span class="number">0</span>] - n + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用滑动窗口计算最小移动次数</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        max_coverage = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 保证窗口 `[j, i]` 内的石子可以被一个长度为 n 的尺子覆盖</span></span><br><span class="line">            <span class="keyword">while</span> stones[i] - stones[j] + <span class="number">1</span> &gt; n:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            max_coverage = <span class="built_in">max</span>(max_coverage, i - j + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        min_moves = n - max_coverage</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理特殊情况：n-1个石子连续，且 outlier 距离 &gt; 1</span></span><br><span class="line">        <span class="comment"># 例如 [2,3,4,5,10] (n=5), stones[3]-stones[0]=3 (n-2), stones[4]-stones[3]=5 (&gt;2)</span></span><br><span class="line">        is_consecutive_at_start = (stones[n-<span class="number">2</span>] - stones[<span class="number">0</span>] == n - <span class="number">2</span>)</span><br><span class="line">        is_consecutive_at_end = (stones[n-<span class="number">1</span>] - stones[<span class="number">1</span>] == n - <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (is_consecutive_at_start <span class="keyword">and</span> stones[n-<span class="number">1</span>] - stones[n-<span class="number">2</span>] &gt; <span class="number">2</span>) <span class="keyword">or</span> \</span><br><span class="line">           (is_consecutive_at_end <span class="keyword">and</span> stones[<span class="number">1</span>] - stones[<span class="number">0</span>] &gt; <span class="number">2</span>):</span><br><span class="line">            min_moves = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [min_moves, max_moves]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N log N)。主要开销来自于初始的排序。后续的滑动窗口和计算都是 O(N)。</li>
<li><strong>空间复杂度</strong>: O(1) 或 O(N)，取决于排序算法使用的空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是数学思维和经典算法模型的结合。最大移动次数可以通过分析移动过程中的“状态保持”推导出贪心策略和数学公式。最小移动次数则是一个典型的“最大化保留&#x2F;覆盖”问题，可以优雅地用滑动窗口解决。解题的关键在于不仅要想到滑动窗口模型，还要根据题目独特的移动限制，识别并正确处理那个导致答案从 1 变为 2 的特殊情况。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
        <tag>数学</tag>
        <tag>排序</tag>
        <tag>第135场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1146 | 二分查找实现“快照数组”</title>
    <url>//posts/leetcode-1146/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1146 题：<a href="https://leetcode.cn/problems/snapshot-array/">快照数组</a>。<br>通过为每个数组索引维护一个历史记录列表，并利用二分查找，我们可以在 O(log K) 的时间内高效地获取任意历史快照中的值。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>这道题要求我们设计一个名为 <code>SnapshotArray</code> 的类，它模拟一个数组，但增加了“快照”功能。具体来说，需要实现以下几个接口：</p>
<ul>
<li><code>SnapshotArray(int length)</code>：构造函数，初始化一个长度为 <code>length</code> 的数组，所有元素的初始值都为 0。</li>
<li><code>void set(index, val)</code>：将当前数组在 <code>index</code> 位置的元素值修改为 <code>val</code>。</li>
<li><code>int snap()</code>：对当前数组的状态进行一次“快照”，并返回这次快照的唯一标识 <code>snap_id</code>。这个 ID 是从 0 开始递增的。</li>
<li><code>int get(index, snap_id)</code>：获取在 <code>snap_id</code> 这次快照时，<code>index</code> 位置上元素的值。</li>
</ul>
<p>举个例子来理解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SnapshotArray snapshotArr = new SnapshotArray(3); // 数组为 [0, 0, 0]</span><br><span class="line">snapshotArr.set(0, 5);  // 当前数组为 [5, 0, 0]</span><br><span class="line">snapshotArr.snap();     // 拍了一张快照，snap_id = 0。这张快照记录了 [5, 0, 0] 的状态</span><br><span class="line">snapshotArr.set(0, 6);  // 当前数组为 [6, 0, 0]</span><br><span class="line">snapshotArr.get(0, 0);  // 获取 snap_id=0 的快照中，索引0的值。当时的值是 5，所以返回 5。</span><br></pre></td></tr></table></figure>

<h3 id="核心思路：空间换时间-二分查找"><a href="#核心思路：空间换时间-二分查找" class="headerlink" title="核心思路：空间换时间 + 二分查找"></a>核心思路：空间换时间 + 二分查找</h3><p>一个最直观但效率低下的想法是，每次调用 <code>snap()</code> 时，都完整地复制一份当前数组的全部内容并存储起来。如果数组长度为 <code>L</code>，调用 <code>snap()</code> 的次数为 <code>S</code>，这种方法的空间复杂度将高达 O(L * S)，在 <code>L</code> 和 <code>S</code> 都很大时会消耗巨量内存。同时，<code>snap()</code> 操作本身的时间复杂度也是 O(L)，效率堪忧。</p>
<p>我们可以进行优化。实际上，每次调用 <code>set</code> 时，只有单个元素的值发生了改变。我们没有必要为整个数组创建副本，而只需要记录<strong>哪个元素，在哪个时刻（snap_id），变成了什么值</strong>。</p>
<p>基于这个想法，我们可以为数组的<strong>每一个索引</strong>都维护一个独立的修改历史列表。这个列表里存储的是一个个的 <code>(snap_id, value)</code> 对。</p>
<p>例如，<code>history[0] = [(0, 5), (2, 8)]</code> 就表示：</p>
<ul>
<li>在 <code>snap_id = 0</code> 时，索引 <code>0</code> 的值被设置为了 <code>5</code>。</li>
<li>在 <code>snap_id = 2</code> 时，索引 <code>0</code> 的值被更新为了 <code>8</code>。</li>
</ul>
<p>当我们要调用 <code>get(index, snap_id)</code> 时，问题就转变成了：<strong>在 <code>index</code> 的历史记录中，找到在小于等于 <code>snap_id</code> 的所有记录里，离 <code>snap_id</code> 最近的那一条记录的值。</strong></p>
<p>由于我们是按时间顺序调用 <code>set</code> 和 <code>snap</code> 的，所以每个索引的历史记录中，<code>snap_id</code> 自然是单调递增的。这就为我们使用<strong>二分查找</strong>创造了完美的条件，从而可以快速地定位到目标记录。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>数据结构设计</strong></p>
<ul>
<li>我们需要一个变量 <code>csi</code> (current snap id) 来记录当前的快照编号，初始为 0。</li>
<li>我们需要一个核心数据结构来存储每个索引的历史变更。这里使用一个哈希表（在 Python 中是 <code>defaultdict</code>），键是数组的 <code>index</code>，值是一个列表，列表里存放 <code>(snap_id, val)</code> 的元组。例如：<code>self.history = &#123;0: [(0, 5), (2, 8)], 1: [(0, 4)]&#125;</code>。</li>
</ul>
</li>
<li><p><strong><code>__init__(self, length)</code></strong></p>
<ul>
<li>初始化 <code>csi = 0</code>。</li>
<li>初始化 <code>self.history = defaultdict(list)</code>。</li>
</ul>
</li>
<li><p><strong><code>set(self, index, val)</code></strong></p>
<ul>
<li>向 <code>index</code> 对应的历史记录列表中追加一个新的元组 <code>(self.csi, val)</code>。这表示在当前的快照时间点，<code>index</code> 的值被设置为了 <code>val</code>。</li>
<li><em>优化提示</em>: 如果 <code>index</code> 对应的历史列表不为空，且最后一条记录的 <code>snap_id</code> 与当前的 <code>csi</code> 相同，说明在同一次快照内对同一位置进行了多次 <code>set</code>。此时可以直接覆盖最后一条记录的值，而不是追加，可以节省一点空间。但直接追加在逻辑上也是完全正确的。</li>
</ul>
</li>
<li><p><strong><code>snap(self)</code></strong></p>
<ul>
<li>这个操作非常简单，只需将 <code>csi</code> 加一，并返回加一之前的旧值即可，即 <code>self.csi - 1</code>。</li>
</ul>
</li>
<li><p><strong><code>get(self, index, snap_id)</code></strong></p>
<ul>
<li>这是算法的核心。首先获取 <code>index</code> 对应的历史记录列表 <code>history[index]</code>。</li>
<li>我们需要在这个列表中找到满足 <code>记录的snap_id &lt;= 给定的snap_id</code> 的最右侧（即 <code>snap_id</code> 最大）的那条记录。</li>
<li>我们可以使用二分查找来高效地完成这个任务。具体来说，我们查找第一个 <code>snap_id &gt; 给定的snap_id</code> 的位置。这个位置的前一个元素，就是我们想要的答案。</li>
<li>Python 的 <code>bisect_left</code> 或 <code>bisect_right</code> 模块非常适合这个场景。<code>bisect_left(history[index], (snap_id + 1, ))</code> 会找到 <code>(snap_id + 1, )</code> 这个元组应该插入的位置，这个位置索引 <code>j</code> 正是第一条 <code>snap_id</code> 大于 <code>snap_id</code> 的记录。</li>
<li>因此，<code>j - 1</code> 就是我们目标记录的索引。</li>
<li>需要处理边界情况：<ul>
<li>如果 <code>j - 1</code> 为负数，说明 <code>history[index]</code> 中所有的记录 <code>snap_id</code> 都大于给定的 <code>snap_id</code>，或者这个索引从未被 <code>set</code> 过。根据题意，此时应返回初始值 0。</li>
<li>否则，返回 <code>history[index][j-1]</code> 中存储的值即可。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SnapshotArray</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, length: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># csi: current snap id, 当前快照编号</span></span><br><span class="line">        <span class="variable language_">self</span>.csi = <span class="number">0</span></span><br><span class="line">        <span class="comment"># history: 使用哈希表存储每个索引的历史记录</span></span><br><span class="line">        <span class="comment"># key: 数组索引, value: [(snap_id, val), ...] 列表</span></span><br><span class="line">        <span class="variable language_">self</span>.history = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 在当前快照时间点，记录 index 处的值</span></span><br><span class="line">        <span class="comment"># 如果历史记录的最后一次快照ID和当前ID相同，可以优化为覆盖，但追加更简单且正确</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.history[index] <span class="keyword">and</span> <span class="variable language_">self</span>.history[index][-<span class="number">1</span>][<span class="number">0</span>] == <span class="variable language_">self</span>.csi:</span><br><span class="line">            <span class="variable language_">self</span>.history[index][-<span class="number">1</span>] = (<span class="variable language_">self</span>.csi, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.history[index].append((<span class="variable language_">self</span>.csi, val))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">snap</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 快照数加一，并返回旧的 snap_id</span></span><br><span class="line">        <span class="variable language_">self</span>.csi += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.csi - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index: <span class="built_in">int</span>, snap_id: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 在 index 的历史记录中，二分查找 snap_id</span></span><br><span class="line">        <span class="comment"># 目标是找到 &lt;= snap_id 的最大快照记录</span></span><br><span class="line">        records = <span class="variable language_">self</span>.history[index]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># bisect_left 寻找插入 (snap_id + 1, ) 的位置</span></span><br><span class="line">        <span class="comment"># 这个位置的左边所有元素的 snap_id 都 &lt;= snap_id</span></span><br><span class="line">        <span class="comment"># 因为元组比较时会先比较第一个元素</span></span><br><span class="line">        j = bisect_left(records, (snap_id + <span class="number">1</span>,)) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果 j &gt;= 0，说明找到了一个有效的历史记录</span></span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> records[j][<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 否则，说明在该快照或之前，该索引从未被 set 过，返回初始值 0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><code>N</code> 是数组的长度, <code>C</code> 是 <code>set</code> 操作的总调用次数。</li>
<li><strong>时间复杂度</strong>:<ul>
<li><code>__init__</code>: O(1)。<code>defaultdict</code> 的初始化是常数时间。</li>
<li><code>set</code>: O(1)。向列表末尾追加元素是摊还 O(1) 的时间复杂度。</li>
<li><code>snap</code>: O(1)。仅涉及一次整数自增操作。</li>
<li><code>get</code>: O(log K)。其中 <code>K</code> 是对 <code>index</code> 调用 <code>set</code> 的次数。在最坏的情况下，所有的 <code>set</code> 操作都作用于同一个 <code>index</code>，此时 <code>K</code> 等于 <code>C</code>，所以最坏时间复杂度为 O(log C)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(C)。我们存储了每一次 <code>set</code> 操作的数据。每次 <code>set</code> 都会创建一个 <code>(snap_id, val)</code> 元组，所以总的空间消耗与 <code>set</code> 的调用次数成正比。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预处理 + 二分查找”模式的一个经典应用，同时也考察了数据结构设计的能力。面对可能导致巨大时空开销的朴素解法，我们应该思考<strong>变化的是什么，不变的是什么</strong>。在这里，数组的大部分内容在快照之间是不变的，只有被 <code>set</code> 的部分才变化。抓住这一关键点，通过只记录增量变化（即历史记录）的方式，成功地用可控的空间换取了极高的查询效率。而二分查找，正是利用历史记录中 <code>snap_id</code> 的有序性来实现高效查询的利器。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>哈希表</tag>
        <tag>设计</tag>
        <tag>第148场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1156 | 滑动窗口求解“单字符重复子串的最大长度”</title>
    <url>//posts/leetcode-1156/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1156 题：<a href="https://leetcode.cn/problems/swap-for-longest-repeated-character-substring/">单字符重复子串的最大长度</a>。<br>这道题的有趣之处在于“一次交换”这个操作。它给了我们一次修正错误的机会，让原本不连续的相同字符子串，有了连接起来的可能。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个字符串 <code>text</code>，我们有一次机会可以交换字符串中的任意两个字符（也可以选择不交换）。我们的目标是，在这次操作后，找到一个最长的、只包含同一种字符的子串，并返回其长度。</p>
<p>我们来分析一下“一次交换”能带来什么：</p>
<ol>
<li><strong>修复一个“缺口”</strong>：在一个几乎全是 <code>a</code> 的子串中，如果有一个字符不是 <code>a</code>，例如 <code>&quot;aaabaaa&quot;</code>，我们可以从字符串的其他地方找一个 <code>a</code> 换掉那个 <code>b</code>。</li>
<li><strong>连接两个“断崖”</strong>：如果一个子串像 <code>&quot;aaaa&quot;</code> 这样已经很完美，我们可以尝试从别处找一个 <code>a</code>，换到这个子串的旁边，让它变得更长，例如变成 <code>&quot;aaaaa&quot;</code>。</li>
</ol>
<p>举个例子，对于 <code>text = &quot;aaabaaa&quot;</code>：</p>
<ul>
<li>我们关注字符 <code>a</code>。字符串里总共有 6 个 <code>a</code>。</li>
<li>有一个子串 <code>&quot;aaabaaa&quot;</code>，它的长度是 7，其中包含一个 <code>b</code>。</li>
<li>我们可以用一次交换机会把 <code>b</code> 换成 <code>a</code>。但是，我们需要从字符串的其他位置找到一个 <code>a</code> 来交换。在这个例子里，除了这 6 个 <code>a</code> 之外，没有多余的 <code>a</code> 可以换过来。</li>
<li>因此，即使我们换掉了 <code>b</code>，最多也只能形成一个长度为 6 的 <code>a</code> 串（因为总共就 6 个 <code>a</code>）。所以最大长度是 6。</li>
</ul>
<p>对于 <code>text = &quot;ababa&quot;</code>:</p>
<ul>
<li>我们关注字符 <code>a</code>。总共有 3 个 <code>a</code>。</li>
<li>子串 <code>&quot;ababa&quot;</code> 中，<code>a</code> 被 <code>b</code> 隔开。</li>
<li>我们可以把中间的 <code>b</code> 和末尾的 <code>a</code> 交换，字符串变为 <code>&quot;aaabb&quot;</code>。这样我们就得到了一个长度为 3 的 <code>a</code> 串 <code>&quot;aaa&quot;</code>。</li>
<li>因为总共只有 3 个 <code>a</code>，所以长度 3 就是 <code>a</code> 能达到的极限。</li>
</ul>
<h3 id="核心思路：枚举字符-滑动窗口"><a href="#核心思路：枚举字符-滑动窗口" class="headerlink" title="核心思路：枚举字符 + 滑动窗口"></a>核心思路：枚举字符 + 滑动窗口</h3><p>问题的关键是找到“最长的”单字符重复子串。一个直接的想法是，我们可以对每一种可能出现的字符（<code>a</code> 到 <code>z</code>）都计算一次它能形成的最长子串长度，然后取其中的最大值。</p>
<p>当我们聚焦于某一个特定字符 <code>ch</code> 时，问题就转化为：<strong>只考虑字符 <code>ch</code>，通过一次交换能得到的最长 <code>ch</code> 子串是多长？</strong></p>
<p>这个问题非常适合用<strong>滑动窗口</strong>来解决。我们可以用一个窗口 <code>[l, r]</code> 在字符串上滑动，这个窗口代表我们希望最终全是 <code>ch</code> 的目标子串。因为我们只有一次交换机会，所以这个窗口内最多只能容忍一个“杂质”（即不是 <code>ch</code> 的字符）。</p>
<p>于是，我们的策略是：</p>
<ol>
<li><strong>预处理</strong>：先用哈希表（<code>Counter</code>）统计出整个字符串中每个字符的总数。这个信息至关重要，因为它决定了我们能用来“填补”窗口的原材料上限。</li>
<li><strong>主循环</strong>：遍历从 <code>a</code> 到 <code>z</code> 的每一个字符 <code>ch</code>，将其作为目标字符。</li>
<li><strong>滑动窗口</strong>：<ul>
<li>维护一个窗口 <code>[l, r]</code> 和一个杂质计数器 <code>occ</code>。</li>
<li>当右指针 <code>r</code> 扩张时，如果 <code>text[r]</code> 不是 <code>ch</code>，就增加 <code>occ</code>。</li>
<li>如果 <code>occ</code> 超过 1，说明窗口内的杂质太多，一次交换已经无法修复，必须从左侧 <code>l</code> 收缩窗口，直到 <code>occ</code> 恢复到 1 或 0。</li>
</ul>
</li>
<li><strong>更新答案</strong>：在每一步窗口扩张后，我们都计算当前窗口能形成的最长 <code>ch</code> 子串长度，并更新全局最大值 <code>ans</code>。这里有两种情况：<ul>
<li><strong>情况一：窗口内没有杂质（<code>occ == 0</code>）</strong><ul>
<li>窗口内的子串已经是完美的 <code>ch</code> 串，如 <code>&quot;aaaa&quot;</code>。长度为 <code>w = r-l+1</code>。</li>
<li>我们能否让它更长？可以！如果字符串中还有其他的 <code>ch</code>（即 <code>ch</code> 的总数 <code>tc</code> &gt; <code>w</code>），我们就可以把其中一个 <code>ch</code> 换到窗口旁边，使其长度加一。</li>
<li>所以，这种情况下能达到的最大长度是 <code>w + 1</code>（前提是 <code>tc &gt; w</code>），否则就是 <code>w</code>。</li>
</ul>
</li>
<li><strong>情况二：窗口内有一个杂质（<code>occ == 1</code>）</strong><ul>
<li>窗口内的子串有一个缺口，如 <code>&quot;aaabaa&quot;</code>。长度为 <code>w</code>。</li>
<li>我们可以用一次交换把杂质换成 <code>ch</code>。但这需要我们有足够的 <code>ch</code> 来填充。</li>
<li>我们最多能形成多长的 <code>ch</code> 串，取决于我们拥有的 <code>ch</code> 的总数 <code>tc</code>。我们不可能创造出比 <code>tc</code> 更长的 <code>ch</code> 串。</li>
<li>所以，这种情况下能达到的最大长度是 <code>min(w, tc)</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>对所有 26 个字母执行上述过程，记录下的最大值就是最终答案。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>第一步：预计算字符总数</strong></p>
<ul>
<li>使用 <code>collections.Counter</code> 对 <code>text</code> 进行计数，得到每个字符的总出现次数 <code>cnt</code>。</li>
</ul>
</li>
<li><p><strong>第二步：遍历所有可能的字符</strong></p>
<ul>
<li>循环遍历从 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 的所有字符 <code>ch</code>。如果某个字符在 <code>text</code> 中不存在，直接跳过。</li>
</ul>
</li>
<li><p><strong>第三步：针对每个字符ch，使用滑动窗口计算最大长度</strong></p>
<ul>
<li>初始化左指针 <code>l = 0</code> 和杂质计数器 <code>occ = 0</code>。</li>
<li>用右指针 <code>r</code> 遍历字符串 <code>text</code> (从 <code>0</code> 到 <code>n-1</code>)。</li>
<li>在循环中，如果 <code>text[r]</code> 不是我们当前关注的字符 <code>ch</code>，则 <code>occ += 1</code>。</li>
<li>检查 <code>occ</code> 是否大于 1。如果是，则不断地收缩左边界：如果 <code>text[l]</code> 是一个杂质，则 <code>occ -= 1</code>，然后 <code>l += 1</code>。</li>
<li>计算当前窗口 <code>[l, r]</code> 的大小 <code>w = r - l + 1</code>。</li>
<li>根据杂质数量 <code>occ</code> 更新答案：<ul>
<li>如果 <code>occ == 0</code>，我们有一个纯 <code>ch</code> 窗口。如果 <code>ch</code> 的总数 <code>tc</code> 大于当前窗口大小 <code>w</code>，我们就可以从别处“借”一个 <code>ch</code> 来加长它。所以，候选长度为 <code>w + (1 if tc &gt; w else 0)</code>。</li>
<li>如果 <code>occ == 1</code>，我们有一个带杂质的窗口。我们可以用一个 <code>ch</code> 来替换这个杂质。我们最多能得到的长度受限于 <code>ch</code> 的总数 <code>tc</code>。所以，候选长度为 <code>min(w, tc)</code>。</li>
</ul>
</li>
<li>用计算出的候选长度更新全局最大值 <code>ans</code>。</li>
</ul>
</li>
<li><p><strong>第四步：返回结果</strong></p>
<ul>
<li>遍历完所有字符后，<code>ans</code> 中存储的就是最终答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxRepOpt1</span>(<span class="params">self, text: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1: 预计算每个字符的总数</span></span><br><span class="line">        cnt = Counter(text)</span><br><span class="line">        n = <span class="built_in">len</span>(text)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2: 遍历 &#x27;a&#x27; 到 &#x27;z&#x27;，对每个字符ch进行分析</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>), <span class="built_in">ord</span>(<span class="string">&#x27;z&#x27;</span>) + <span class="number">1</span>):</span><br><span class="line">            ch = <span class="built_in">chr</span>(c)</span><br><span class="line">            tc = cnt[ch] <span class="comment"># 当前关注字符的总数</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果该字符不存在，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> tc == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 步骤 3: 滑动窗口</span></span><br><span class="line">            l = occ = <span class="number">0</span> <span class="comment"># l是左指针，occ是窗口内“杂质”的数量</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> text[r] != ch:</span><br><span class="line">                    occ += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 当杂质多于1个时，收缩左边界</span></span><br><span class="line">                <span class="keyword">while</span> occ &gt; <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> text[l] != ch:</span><br><span class="line">                        occ -= <span class="number">1</span></span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 步骤 4: 更新答案</span></span><br><span class="line">                w = r - l + <span class="number">1</span> <span class="comment"># 当前窗口大小</span></span><br><span class="line">                <span class="keyword">if</span> occ == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 情况一：窗口内没有杂质</span></span><br><span class="line">                    <span class="comment"># 如果字符串中还有多余的ch，可以换过来一个，长度+1</span></span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, w + (<span class="number">1</span> <span class="keyword">if</span> tc &gt; w <span class="keyword">else</span> <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># occ == 1</span></span><br><span class="line">                    <span class="comment"># 情况二：窗口内有一个杂质</span></span><br><span class="line">                    <span class="comment"># 用一个ch替换杂质，最大长度不能超过ch的总数</span></span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(w, tc))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。虽然代码有两层循环，但外层循环是常数 26 次。对于内层的滑动窗口，每个字符作为目标时，<code>l</code> 和 <code>r</code> 指针都只会从头到尾遍历字符串一次。因此总的时间复杂度是 O(26 * N) &#x3D; O(N)。</li>
<li><strong>空间复杂度</strong>: O(Σ)。其中 Σ 是字符集的大小，这里是 26。我们用了一个 <code>Counter</code> 来存储字符频率，空间是常数级别的，所以是 O(1)。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想的一个巧妙应用。通过将问题分解为“为每个字符寻找最优解”，我们将一个复杂问题转化为了 26 个独立的、更简单的子问题。在解决子问题时，滑动窗口是处理连续子数组&#x2F;子串问题的利器。本题的难点在于，更新答案时需要细致地分情况讨论：窗口是“完美的”还是“有缺陷的”，并结合字符总数这一全局信息，来判断一次交换到底能带来多大的收益。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>第149场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1170 | 二分查找解决“比较字符串最小字母出现频次”</title>
    <url>//posts/leetcode-1170/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1170 题：<a href="https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/">比较字符串最小字母出现频次</a>。<br>通过对词汇表进行预处理和排序，我们可以利用二分查找将查询效率从线性级别优化到对数级别。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目首先定义了一个函数 <code>f(s)</code>，它的功能是计算一个非空字符串 <code>s</code> 中，按字典序最小的那个字母出现的次数。例如，对于 <code>s = &quot;dcce&quot;</code>，最小的字母是 ‘c’，它出现了 2 次，所以 <code>f(&quot;dcce&quot;) = 2</code>。</p>
<p>接着，题目给了我们两个字符串数组：一个查询数组 <code>queries</code> 和一个词汇表数组 <code>words</code>。我们的任务是，对于 <code>queries</code> 中的每一个查询字符串 <code>queries[i]</code>，都要计算出在 <code>words</code> 数组中有多少个单词 <code>W</code> 满足 <code>f(queries[i]) &lt; f(W)</code>。最后，返回一个整数数组 <code>answer</code>，其中 <code>answer[i]</code> 就是第 <code>i</code> 次查询的结果。</p>
<p>举个例子，<code>queries = [&quot;bbb&quot;,&quot;cc&quot;]</code>, <code>words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]</code>：</p>
<ul>
<li>对于第一个查询 “bbb”：<ul>
<li>最小字母是 ‘b’，出现 3 次，所以 <code>f(&quot;bbb&quot;) = 3</code>。</li>
<li>我们需要在 <code>words</code> 中找到 <code>f(W) &gt; 3</code> 的单词。</li>
<li><code>f(&quot;a&quot;)=1</code>, <code>f(&quot;aa&quot;)=2</code>, <code>f(&quot;aaa&quot;)=3</code>, <code>f(&quot;aaaa&quot;)=4</code>。只有一个 “aaaa” 满足条件。所以结果是 1。</li>
</ul>
</li>
<li>对于第二个查询 “cc”：<ul>
<li>最小字母是 ‘c’，出现 2 次，所以 <code>f(&quot;cc&quot;) = 2</code>。</li>
<li>我们需要在 <code>words</code> 中找到 <code>f(W) &gt; 2</code> 的单词。</li>
<li>“aaa” 和 “aaaa” 满足条件。所以结果是 2。</li>
</ul>
</li>
<li>因此，最终答案是 <code>[1, 2]</code>。</li>
</ul>
<h3 id="核心思路：预计算-二分查找"><a href="#核心思路：预计算-二分查找" class="headerlink" title="核心思路：预计算 + 二分查找"></a>核心思路：预计算 + 二分查找</h3><p>一个直观的想法是，对每个 <code>query</code>，我们都遍历一遍 <code>words</code> 数组，计算每个 <code>word</code> 的 <code>f</code> 值并进行比较。如果 <code>queries</code> 的长度是 N，<code>words</code> 的长度是 M，那么这种暴力解法的时间复杂度大约是 O(N * M)，在 N 和 M 都达到 2000 的情况下，可能会超时。</p>
<p>注意到，<code>words</code> 数组是固定不变的。我们可以对其进行<strong>预处理</strong>，来加速后续的查询过程。</p>
<p>整个优化的思路分为两步：</p>
<ol>
<li><p><strong>预计算与排序</strong>：我们先遍历一次 <code>words</code> 数组，计算出其中每个单词 <code>W</code> 的 <code>f(W)</code> 值，并将这些频率值存入一个新数组 <code>word_freqs</code> 中。为了能够快速查找，我们对 <code>word_freqs</code> 进行升序排序。</p>
</li>
<li><p><strong>高效查询</strong>：完成预处理后，对于每个 <code>query</code>，我们先计算出它的频率 <code>q_freq</code>。然后，问题就转化成了：<strong>在一个排好序的数组 <code>word_freqs</code> 中，有多少个元素大于 <code>q_freq</code>？</strong> 这是一个典型的二分查找应用场景。我们可以通过二分查找，快速定位到第一个大于 <code>q_freq</code> 的元素的位置。一旦找到了这个位置，那么它后面的所有元素都满足条件，我们就能立刻得到答案。</p>
</li>
</ol>
<p>通过这种方式，每次查询的时间复杂度从 O(M) 降到了 O(log M)，从而显著提高了算法的整体效率。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>定义辅助函数 <code>f(s)</code></strong></p>
<ul>
<li>这个函数接收一个字符串 <code>s</code>。</li>
<li>找到 <code>s</code> 中的最小字符 <code>min_char</code>。</li>
<li>返回 <code>min_char</code> 在 <code>s</code> 中出现的次数。</li>
</ul>
</li>
<li><p><strong>预处理 <code>words</code> 数组</strong></p>
<ul>
<li>创建一个整数数组 <code>word_freqs</code>。</li>
<li>遍历 <code>words</code> 中的每一个 <code>word</code>，调用 <code>f(word)</code> 计算其频率，并将结果添加到 <code>word_freqs</code> 中。</li>
<li>对 <code>word_freqs</code> 数组进行升序排序。</li>
</ul>
</li>
<li><p><strong>处理 <code>queries</code> 数组</strong></p>
<ul>
<li>创建一个空的答案数组 <code>ans</code>。</li>
<li>遍历 <code>queries</code> 中的每一个 <code>query</code>：<ul>
<li>计算其频率 <code>q_freq = f(query)</code>。</li>
<li>在排好序的 <code>word_freqs</code> 数组上执行二分查找，目标是找到第一个<strong>严格大于</strong> <code>q_freq</code> 的元素的索引。</li>
<li>在 Python 中，<code>bisect.bisect_right(array, value)</code> 函数可以完美地实现这个功能。它会返回 <code>value</code> 在 <code>array</code> 中的插入点索引，这个索引恰好是数组中大于 <code>value</code> 的第一个元素的位置。</li>
<li>假设 <code>word_freqs</code> 的长度为 <code>n</code>，找到的索引为 <code>index</code>，那么 <code>word_freqs</code> 中大于 <code>q_freq</code> 的元素个数就是 <code>n - index</code>。</li>
<li>将这个计数结果添加到 <code>ans</code> 数组中。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>遍历结束后，返回 <code>ans</code> 数组。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSmallerByFrequency</span>(<span class="params">self, queries: <span class="type">List</span>[<span class="built_in">str</span>], words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1: 定义辅助函数 f(s)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            min_char = <span class="built_in">min</span>(s)</span><br><span class="line">            <span class="keyword">return</span> s.count(min_char)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2: 预处理 words 数组</span></span><br><span class="line">        <span class="comment"># 计算 words 中每个单词的频率并排序</span></span><br><span class="line">        word_freqs = <span class="built_in">sorted</span>([f(word) <span class="keyword">for</span> word <span class="keyword">in</span> words])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 处理 queries 数组</span></span><br><span class="line">        ans = []</span><br><span class="line">        n = <span class="built_in">len</span>(word_freqs)</span><br><span class="line">        <span class="keyword">for</span> query <span class="keyword">in</span> queries:</span><br><span class="line">            q_freq = f(query)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 使用二分查找找到第一个 &gt; q_freq 的元素的位置</span></span><br><span class="line">            <span class="comment"># n - (该位置的索引) 即为满足条件的单词数量</span></span><br><span class="line">            index = bisect.bisect_right(word_freqs, q_freq)</span><br><span class="line">            count = n - index</span><br><span class="line">            ans.append(count)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 4: 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(M * Lw + M log M + N * (Lq + log M))。<ul>
<li><code>N</code> 是 <code>queries</code> 的长度, <code>M</code> 是 <code>words</code> 的长度。</li>
<li><code>Lq</code> 和 <code>Lw</code> 分别是 <code>queries</code> 和 <code>words</code> 中字符串的最大长度。</li>
<li>计算 <code>word_freqs</code> 需要 O(M * Lw)。</li>
<li>排序 <code>word_freqs</code> 需要 O(M log M)。</li>
<li>对于每个查询，计算 <code>f(query)</code> 需要 O(Lq)，二分查找需要 O(log M)。总共是 O(N * (Lq + log M))。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(M)。我们需要一个额外的数组 <code>word_freqs</code> 来存储 <code>words</code> 数组中每个单词的频率。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预处理 + 二分查找”模式的一个经典应用。当题目要求对一个固定的数据集进行多次查询时，我们应该优先考虑是否能通过对数据集进行一次性的预处理（例如计算、排序等），来为后续的查询操作提供便利，从而将整体复杂度降低一个量级。二分查找正是利用了数据的有序性来实现高效查询的强大工具。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>排序</tag>
        <tag>第151场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1201 | 丑数 III</title>
    <url>//posts/leetcode-1201/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1201 题：<a href="https://leetcode.cn/problems/ugly-number-iii/description/">丑数 III</a>。<br>核心思路依然是 <strong>二分答案</strong> 结合 <strong>容斥原理</strong>，区别在于变量从两个增加到了三个。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你四个整数：<code>n</code> 、<code>a</code> 、<code>b</code> 、<code>c</code> ，请你设计一个算法来找出第 <code>n</code> 个丑数。<br>丑数是可以被 <code>a</code> 或 <code>b</code> 或 <code>c</code> 整除的 <strong>正整数</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：n = 3, a = 2, b = 3, c = 5</span><br><span class="line">输出：4</span><br><span class="line">解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：n = 4, a = 2, b = 3, c = 4</span><br><span class="line">输出：6</span><br><span class="line">解释：丑数序列为 2, 3, 4, 6, 8, 9, 10, 12... 其中第 4 个是 6。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n, a, b, c &lt;= 10^9</code></li>
<li><code>1 &lt;= a * b * c &lt;= 10^18</code></li>
<li>本题结果在 <code>[1, 2 * 10^9]</code> 的范围内</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-二分答案"><a href="#1-二分答案" class="headerlink" title="1. 二分答案"></a>1. 二分答案</h4><p>与“第 N 个神奇数字”一样，丑数的分布具有单调性：</p>
<ul>
<li>如果一个数字 <code>x</code> 是第 <code>k</code> 个丑数，那么小于 <code>x</code> 的丑数肯定少于 <code>k</code> 个，大于 <code>x</code> 的丑数肯定多于 <code>k</code> 个。</li>
<li>我们可以二分枚举答案 <code>x</code>，判断 <code>[1, x]</code> 范围内有多少个丑数。如果个数 <code>&gt;= n</code>，说明答案在左半区间（尝试更小的 <code>x</code>）；否则在右半区间。</li>
</ul>
<p><strong>搜索范围：</strong></p>
<ul>
<li>下界：<code>1</code>（或者 <code>min(a, b, c)</code>）。</li>
<li>上界：题目提示结果在 <code>2 * 10^9</code> 范围内，可以直接设为 <code>2 * 10^9</code>。</li>
</ul>
<h4 id="2-集合的三维容斥原理"><a href="#2-集合的三维容斥原理" class="headerlink" title="2. 集合的三维容斥原理"></a>2. 集合的三维容斥原理</h4><p>我们需要计算 <code>[1, mid]</code> 范围内，能被 <code>a</code> 或 <code>b</code> 或 <code>c</code> 整除的数的个数。<br>设：</p>
<ul>
<li>集合 A：能被 <code>a</code> 整除的数。</li>
<li>集合 B：能被 <code>b</code> 整除的数。</li>
<li>集合 C：能被 <code>c</code> 整除的数。</li>
</ul>
<p>我们需要求的是集合的并集大小 <code>|A ∪ B ∪ C|</code>。<br>根据 <strong>容斥原理</strong>：<br><code>|A ∪ B ∪ C| = |A| + |B| + |C| - |A ∩ B| - |A ∩ C| - |B ∩ C| + |A ∩ B ∩ C|</code></p>
<p>转换成具体的计算公式：</p>
<ol>
<li><code>mid // a</code>：能被 <code>a</code> 整除的个数。</li>
<li><code>mid // lcm(a, b)</code>：既能被 <code>a</code> 又能被 <code>b</code> 整除的个数（即 <code>a</code> 和 <code>b</code> 的最小公倍数的倍数）。</li>
<li><code>mid // lcm(a, b, c)</code>：同时能被 <code>a, b, c</code> 整除的个数。</li>
</ol>
<p>最终公式为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">count = mid/a + mid/b + mid/c </span><br><span class="line">      - mid/lcm(a,b) - mid/lcm(a,c) - mid/lcm(b,c) </span><br><span class="line">      + mid/lcm(a,b,c)</span><br></pre></td></tr></table></figure>

<h4 id="3-最小公倍数-LCM-计算"><a href="#3-最小公倍数-LCM-计算" class="headerlink" title="3. 最小公倍数 (LCM) 计算"></a>3. 最小公倍数 (LCM) 计算</h4><ul>
<li>两个数的 LCM：<code>lcm(a, b) = (a * b) / gcd(a, b)</code></li>
<li>三个数的 LCM：<code>lcm(a, b, c) = lcm(lcm(a, b), c)</code></li>
</ul>
<p>注意：题目提示 <code>a * b * c</code> 可能达到 <code>10^18</code>，在计算 LCM 时要注意由乘法引起的溢出风险。Python 自动处理大整数，Go 语言需要使用 <code>int64</code>（不过本题结果范围在 <code>int</code> 内，中间计算 LCM 建议使用 64 位整数）。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nthUglyNumber</span>(<span class="params">self, n: <span class="built_in">int</span>, a: <span class="built_in">int</span>, b: <span class="built_in">int</span>, c: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 预先计算两两的 LCM 和三者的 LCM</span></span><br><span class="line">        <span class="comment"># 避免在二分查找中重复计算</span></span><br><span class="line">        ab = math.lcm(a,b)</span><br><span class="line">        ac = math.lcm(a,c)</span><br><span class="line">        bc = math.lcm(b,c)</span><br><span class="line">        abc = math.lcm(ab,c)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义 check 函数：判定丑数个数是否 &gt;=n </span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">x:<span class="built_in">int</span></span>)-&gt;<span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># 容斥原理公式</span></span><br><span class="line">            <span class="comment"># + 单个</span></span><br><span class="line">            count = x // a + x // b + x // c</span><br><span class="line">            <span class="comment"># - 两两交集</span></span><br><span class="line">            count -= (x // lcm_ab + x // lcm_ac + x // lcm_bc)</span><br><span class="line">            <span class="comment"># + 三者交集</span></span><br><span class="line">            count += x // lcm_abc</span><br><span class="line">            <span class="keyword">return</span> cnt&gt;=n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找</span></span><br><span class="line">        l,r = <span class="number">0</span>,<span class="number">2</span>*<span class="number">10</span>**<span class="number">9</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l+<span class="number">1</span>&lt;r:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nthUglyNumber</span><span class="params">(n <span class="type">int</span>, a <span class="type">int</span>, b <span class="type">int</span>, c <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 转换为 int64 防止 LCM 计算过程中溢出</span></span><br><span class="line">    <span class="comment">// 虽然题目结果在 int 范围，但 a*b*c 可能达到 10^18</span></span><br><span class="line">    nA, nB, nC := <span class="type">int64</span>(a), <span class="type">int64</span>(b), <span class="type">int64</span>(c)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预计算最小公倍数</span></span><br><span class="line">    lcmAB := lcm(nA, nB)</span><br><span class="line">    lcmAC := lcm(nA, nC)</span><br><span class="line">    lcmBC := lcm(nB, nC)</span><br><span class="line">    lcmABC := lcm(lcmAB, nC)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二分查找范围 [1, 2*10^9]</span></span><br><span class="line">    <span class="comment">// 使用 int64 进行二分</span></span><br><span class="line">    <span class="keyword">var</span> l, r <span class="type">int64</span> = <span class="number">1</span>, <span class="number">2000000000</span></span><br><span class="line">    target := <span class="type">int64</span>(n)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := l + (r-l)/<span class="number">2</span></span><br><span class="line">        <span class="comment">// 容斥原理计算数量</span></span><br><span class="line">        count := mid/nA + mid/nB + mid/nC - mid/lcmAB - mid/lcmAC - mid/lcmBC + mid/lcmABC</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> count &gt;= target &#123;</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>(l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> a != <span class="number">0</span> &#123;</span><br><span class="line">        a, b = b%a, a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：最小公倍数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lcm</span><span class="params">(a, b <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a / gcd(a, b)) * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: <code>O(log(Range))</code><br>这里 <code>Range</code> 取决于题目给出的结果上限 <code>2 * 10^9</code>。每次 <code>check</code> 操作仅涉及常数次加减乘除运算。由于预先计算了 LCM，二分过程非常快。</p>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(1)</code><br>只使用了常数个变量来存储 LCM 值和二分边界。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>第K小/大</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>数论</tag>
        <tag>第155场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1208 | 滑动窗口巧解“尽可能使字符串相等”</title>
    <url>//posts/leetcode-1208/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1208 题：<a href="https://leetcode.cn/problems/get-equal-substrings-within-budget/">尽可能使字符串相等</a>。<br>当题目要求我们寻找一个满足特定条件的<strong>最长连续子数组或子字符串</strong>时，滑动窗口往往是最高效的解法。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们来仔细分析一下题目的要求：</p>
<ol>
<li><strong>转换开销 (Cost)</strong>：将字符串 <code>s</code> 中的一个字符 <code>s[i]</code> 变为 <code>t</code> 中对应的字符 <code>t[i]</code>，需要 <code>|ord(s[i]) - ord(t[i])|</code> 的开销。这其实就是两个字符 ASCII 码值的差的绝对值。</li>
<li><strong>预算限制 (Budget)</strong>：我们有一个总预算 <code>maxCost</code>。我们可以在 <code>s</code> 中选择一个子字符串，将其转换为 <code>t</code> 中对应的子字符串，但总开销不能超过 <code>maxCost</code>。</li>
<li><strong>目标</strong>：找到在预算范围内，可以转换的<strong>最长</strong>子字符串的长度。</li>
</ol>
<p>例如，<code>s = &quot;abcd&quot;</code>, <code>t = &quot;bcdf&quot;</code>, <code>maxCost = 3</code>。<br>我们可以计算每个位置的转换开销：</p>
<ul>
<li><code>&#39;a&#39; -&gt; &#39;b&#39;</code>: |97 - 98| &#x3D; 1</li>
<li><code>&#39;b&#39; -&gt; &#39;c&#39;</code>: |98 - 99| &#x3D; 1</li>
<li><code>&#39;c&#39; -&gt; &#39;d&#39;</code>: |99 - 100| &#x3D; 1</li>
<li><code>&#39;d&#39; -&gt; &#39;f&#39;</code>: |100 - 102| &#x3D; 2</li>
</ul>
<p>如果我们尝试转换子字符串 <code>&quot;abc&quot;</code>，总开销为 <code>1 + 1 + 1 = 3</code>。这个开销没有超过 <code>maxCost</code>，所以这是一个合法的转换，其长度为 3。如果我们尝试转换 <code>&quot;abcd&quot;</code>，总开销为 <code>3 + 2 = 5</code>，超出了预算。因此，能转换的最长子字符串就是 <code>&quot;abc&quot;</code>，答案是 3。</p>
<h3 id="核心思路：滑动窗口"><a href="#核心思路：滑动窗口" class="headerlink" title="核心思路：滑动窗口"></a>核心思路：滑动窗口</h3><p>这个问题要求我们找到一个<strong>连续</strong>的子字符串，其总转换开销不超过一个给定值，并使这个子字符串的<strong>长度最大化</strong>。这正是滑动窗口算法的典型应用场景。</p>
<p>我们可以把 <code>s</code> 的一个子字符串想象成一个“窗口”。这个窗口在字符串上从左到右滑动。</p>
<ol>
<li><strong>窗口的定义</strong>：窗口 <code>[left, right]</code> 表示我们当前正在考虑的 <code>s</code> 的子字符串 <code>s[left...right]</code>。</li>
<li><strong>窗口的状态</strong>：我们需要一个变量 <code>current_cost</code> 来实时记录当前窗口内所有字符的总转换开销。</li>
<li><strong>窗口的移动逻辑</strong>：<ul>
<li><strong>扩大窗口</strong>：我们不断地将窗口的右边界 <code>right</code>向右移动，把新的字符 <code>s[right]</code> 纳入窗口，并将其转换开销累加到 <code>current_cost</code> 中。</li>
<li><strong>收缩窗口</strong>：当 <code>current_cost</code> 超过了预算 <code>maxCost</code> 时，说明当前窗口太“贵”了，不满足条件。此时，我们必须从窗口的左边开始丢弃元素，即将左边界 <code>left</code> 向右移动，并从 <code>current_cost</code> 中减去被丢弃字符 <code>s[left]</code> 的转换开销。我们重复这个过程，直到 <code>current_cost</code> 再次回到预算范围内。</li>
<li><strong>更新结果</strong>：在每一步中，只要窗口是有效的（即 <code>current_cost &lt;= maxCost</code>），它就是一个潜在的答案。我们记录下当前窗口的长度 <code>right - left + 1</code>，并与我们已知的最大长度 <code>max_len</code> 进行比较，随时保留最大值。</li>
</ul>
</li>
</ol>
<p>通过这种方式，窗口在字符串上滑动一次，我们就能找到最长的有效子字符串。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>left = 0</code>：窗口的左边界。</li>
<li><code>current_cost = 0</code>：当前窗口的总开销。</li>
<li><code>max_len = 0</code>：记录满足条件的最大长度。</li>
</ul>
</li>
<li><p><strong>遍历与扩大窗口</strong>：</p>
<ul>
<li>用一个 <code>right</code> 指针从 0 开始遍历整个字符串，它代表窗口的右边界。</li>
<li>在循环的每一步，计算 <code>s[right]</code> 到 <code>t[right]</code> 的开销，并加入到 <code>current_cost</code>。</li>
</ul>
</li>
<li><p><strong>检查与收缩窗口</strong>：</p>
<ul>
<li>在扩大窗口后，立即检查 <code>current_cost</code> 是否大于 <code>maxCost</code>。</li>
<li>如果大于，则进入一个 <code>while</code> 循环：从 <code>current_cost</code> 中减去 <code>s[left]</code> 对应的开销，然后将 <code>left</code> 指针右移一位。重复此操作直到 <code>current_cost &lt;= maxCost</code>。</li>
</ul>
</li>
<li><p><strong>更新最大长度</strong>：</p>
<ul>
<li>当窗口的总开销满足预算时，当前窗口 <code>[left, right]</code> 就是一个有效的子字符串。</li>
<li>计算其长度 <code>right - left + 1</code>，并更新 <code>max_len = max(max_len, right - left + 1)</code>。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>遍历结束后，<code>max_len</code> 就是最终的答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">equalSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span>, maxCost: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用滑动窗口解决问题。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        我们维护一个窗口 [left, right]，表示我们试图转换的子字符串。</span></span><br><span class="line"><span class="string">        current_cost 记录了当前窗口内所有字符的转换总成本。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        current_cost = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># right 指针作为窗口的右边界，用于扩大窗口</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># 步骤 1: 扩大窗口</span></span><br><span class="line">            <span class="comment"># 累加新进入窗口的右侧字符的转换开销</span></span><br><span class="line">            current_cost += <span class="built_in">abs</span>(<span class="built_in">ord</span>(s[right]) - <span class="built_in">ord</span>(t[right]))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 2: 判断是否需要收缩窗口</span></span><br><span class="line">            <span class="comment"># 如果当前窗口的总开销超过了预算</span></span><br><span class="line">            <span class="keyword">while</span> current_cost &gt; maxCost:</span><br><span class="line">                <span class="comment"># 从总开销中减去即将移出窗口的左侧字符的开销</span></span><br><span class="line">                current_cost -= <span class="built_in">abs</span>(<span class="built_in">ord</span>(s[left]) - <span class="built_in">ord</span>(t[left]))</span><br><span class="line">                <span class="comment"># 左指针向右移动，完成收缩</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 3: 更新结果</span></span><br><span class="line">            <span class="comment"># 此时的窗口 [left, right] 是一个有效的窗口</span></span><br><span class="line">            <span class="comment"># 计算其长度并更新最大长度记录</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)，其中 N 是字符串的长度。虽然代码中有一个 <code>while</code> 循环嵌套在 <code>for</code> 循环内部，但 <code>left</code> 和 <code>right</code> 指针都只会从头到尾遍历字符串一次，每个字符最多被访问两次（一次被 <code>right</code> 指针加入，一次被 <code>left</code> 指针移出）。因此，总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了几个额外的变量 (<code>left</code>, <code>current_cost</code>, <code>max_len</code>) 来存储状态，其空间占用与输入字符串的长度无关。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口算法的绝佳练习题。通过这道题，我们可以加深对滑动窗口思想的理解：</p>
<ol>
<li><strong>识别应用场景</strong>：当问题涉及在序列（数组、字符串）上寻找满足条件的<strong>最长&#x2F;最短连续子序列</strong>时，滑动窗口是一个强有力的工具。</li>
<li><strong>双指针与状态维护</strong>：滑动窗口的核心是使用 <code>left</code> 和 <code>right</code> 两个指针来定义一个动态变化的窗口，并高效地维护窗口内的状态（例如本题中的 <code>current_cost</code>）。</li>
<li><strong>“收缩”的智慧</strong>：滑动窗口的精髓在于，当窗口不满足条件时，我们不是暴力地重新开始，而是通过“收缩”窗口的左边界来尝试使其重新满足条件，这大大提高了算法的效率。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
        <tag>前缀和</tag>
        <tag>第 156 场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1234 | 滑动窗口求解“替换子串得到平衡字符串”</title>
    <url>//posts/leetcode-1234/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1234 题：<a href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/">替换子串得到平衡字符串</a>。<br>该题要求我们通过替换一个连续子串，使得 ‘Q’, ‘W’, ‘E’, ‘R’ 四个字符数量相等。问题的关键在于逆向思考：我们不是要决定用什么字符来替换，而是要决定保留哪些字符。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给定一个长度为 <code>n</code> 的字符串 <code>s</code>，它只包含 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符。一个“平衡字符串”是指这四种字符都恰好出现 <code>n/4</code> 次。</p>
<p>我们的任务是找到一个<strong>最短的连续子串</strong>，将它替换成任意等长的字符串后，能使整个 <code>s</code> 变成一个平衡字符串。我们需要返回这个最短子串的长度。如果 <code>s</code> 本身就是平衡的，则返回 0。</p>
<p>举个例子，对于 <code>s = &quot;QQQW&quot;</code>, <code>n = 4</code>：</p>
<ul>
<li>一个平衡字符串需要 ‘Q’, ‘W’, ‘E’, ‘R’ 各出现 1 次 (<code>4/4=1</code>)。</li>
<li>当前 <code>s</code> 中有 3 个 ‘Q’ 和 1 个 ‘W’。’Q’ 超了 2 个，而 ‘E’ 和 ‘R’ 各缺 1 个。</li>
<li>我们可以替换掉开头的 “QQ”，用 “ER” 来替换，得到 “ERQW”。这是一个平衡字符串。</li>
<li>被替换的子串 “QQ” 长度为 2，这是我们能找到的最小长度，所以答案是 2。</li>
</ul>
<p>直接枚举所有子串并判断替换后的结果是否平衡，效率太低。我们需要找到更巧妙的切入点。</p>
<h3 id="核心思路：逆向思考与滑动窗口"><a href="#核心思路：逆向思考与滑动窗口" class="headerlink" title="核心思路：逆向思考与滑动窗口"></a>核心思路：逆向思考与滑动窗口</h3><p>这道题的突破口在于对“替换”操作的理解。当我们选择一个子串 <code>s[l...r]</code> 进行替换时，这个子串内的所有字符都会被“抹去”，我们可以换成任何我们需要的字符。这意味着，最终字符串的平衡性，完全取决于<strong>原字符串中位于子串之外的字符</strong>。</p>
<p>假设目标是每个字符最终都有 <code>k = n/4</code> 个。我们先统计整个字符串 <code>s</code> 中每个字符的出现次数。</p>
<ul>
<li>对于那些出现次数 <code>count(c) &lt;= k</code> 的字符 <code>c</code>，它们不是问题，因为我们可以在替换时补充它们。</li>
<li>对于那些出现次数 <code>count(c) &gt; k</code> 的字符 <code>c</code>，它们是“多余”的。我们必须通过替换操作，将 <code>count(c) - k</code> 个多余的 <code>c</code> 包含在被替换的子串中。</li>
</ul>
<p>这样，问题就从“找到最短的子串去替换”，巧妙地转换成了：<br><strong>找到一个最短的子串，这个子串恰好包含了所有“多余”的字符。</strong></p>
<p>例如 <code>s = &quot;QQQW&quot;</code>，<code>k=1</code>。’Q’ 的数量为 3，多余了 <code>3-1=2</code> 个。我们只需要找到一个最短的子串，它里面至少包含 2 个 ‘Q’。最短的子串就是 “QQ”，长度为 2。</p>
<p>这是一个典型的不定长滑动窗口问题：寻找满足特定条件的最短连续子数组&#x2F;子串。</p>
<ul>
<li><strong>窗口扩张</strong>：移动右指针 <code>r</code>，将新字符纳入窗口。</li>
<li><strong>条件判断</strong>：检查窗口内的字符是否已经满足了“包含所有多余字符”的条件。</li>
<li><strong>窗口收缩</strong>：如果条件满足，记录当前窗口的长度并尝试移动左指针 <code>l</code>，缩小窗口，寻找更短的满足条件的窗口。</li>
</ul>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>预处理</strong>：</p>
<ul>
<li>计算平衡状态下每个字符的目标数量 <code>tc = n / 4</code>。</li>
<li>使用哈希表（或数组）统计整个字符串 <code>s</code> 中 ‘Q’, ‘W’, ‘E’, ‘R’ 的原始数量 <code>fc</code>。</li>
<li>创建一个“多余字符”哈希表 <code>ex</code>。遍历 <code>fc</code>，如果某个字符 <code>c</code> 的数量 <code>cnt &gt; tc</code>，则将 <code>ex[c] = cnt - tc</code> 加入表中。这表示我们需要在滑动窗口中找到 <code>cnt - tc</code> 个 <code>c</code>。</li>
<li>如果 <code>ex</code> 为空，说明字符串已经平衡，直接返回 0。</li>
</ul>
</li>
<li><p><strong>滑动窗口</strong>：</p>
<ul>
<li>初始化左指针 <code>l = 0</code>，最小长度 <code>ans = n</code>。</li>
<li>用右指针 <code>r</code> 从 0 开始遍历字符串 <code>s</code>。</li>
<li>当字符 <code>s[r]</code> 进入窗口时，如果 <code>s[r]</code> 是一个多余字符（即 <code>s[r]</code> 在 <code>ex</code> 中），则将 <code>ex[s[r]]</code> 的计数值减 1。</li>
<li>进入 <code>while</code> 循环，判断窗口是否满足条件：<code>ex</code> 中所有字符的计数值是否都 <code> &lt;= 0</code>。<ul>
<li>如果满足，说明当前窗口 <code>s[l...r]</code> 已经包含了所有多余的字符。我们用当前窗口长度 <code>r - l + 1</code> 更新 <code>ans</code>。</li>
<li>然后，尝试收缩窗口。考察左边界字符 <code>s[l]</code>，如果它是一个多余字符，那么当它离开窗口时，需要将 <code>ex[s[l]]</code> 的计数值加 1（因为它不再被窗口覆盖了）。</li>
<li>将左指针 <code>l</code> 右移一位。</li>
</ul>
</li>
<li>重复此过程，直到右指针 <code>r</code> 遍历完整个字符串。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>遍历结束后，<code>ans</code> 即为所求的最小子串长度。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">balancedString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 目标计数</span></span><br><span class="line">        tc = n//<span class="number">4</span></span><br><span class="line">        <span class="comment"># 频率统计</span></span><br><span class="line">        fc = Counter(s)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 统计需要被替换掉的“多余”的字符</span></span><br><span class="line">        ex = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c ,cnt  <span class="keyword">in</span> fc.items():</span><br><span class="line">            <span class="keyword">if</span> cnt &gt; tc:</span><br><span class="line">                ex[c] = cnt - tc</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果 ex 为空，说明字符串已经平衡</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ex:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        ans = n</span><br><span class="line">        <span class="comment"># 右指针 r 遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> r, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="comment"># 如果当前字符是多余字符，则需求量减一</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> ex:</span><br><span class="line">                ex[c] -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当窗口满足包含所有多余字符的条件时</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">all</span>(v &lt;= <span class="number">0</span> <span class="keyword">for</span> v <span class="keyword">in</span> ex.values()):</span><br><span class="line">                <span class="comment"># 更新最小长度</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans, r - l + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 尝试收缩窗口</span></span><br><span class="line">                lc = s[l]</span><br><span class="line">                <span class="keyword">if</span> lc <span class="keyword">in</span> ex:</span><br><span class="line">                    <span class="comment"># 左边界的字符移出窗口，如果它是多余字符，则需求量加一</span></span><br><span class="line">                    ex[lc] += <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是字符串 <code>s</code> 的长度。左右指针 <code>l</code> 和 <code>r</code> 都只会从头到尾遍历字符串一次，因此总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(Σ)。其中 Σ 是字符集的数量。在这里，字符集为 {‘Q’, ‘W’, ‘E’, ‘R’}，数量是常数 4。因此空间复杂度为 O(1)。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题通过将问题“替换子串使外部平衡”转化为“寻找包含所有超额字符的最短子串”，我们将一个看似复杂的问题简化为了一个经典的算法模型。这种“逆向思考”或“问题转化”的能力，在解决算法题时至关重要。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
        <tag>第159场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1283 | 二分查找解决“使结果不超过阈值的最小除数”</title>
    <url>//posts/leetcode-1283/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1283 题：<a href="https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/description/">使结果不超过阈值的最小除数</a>。<br>本题的核心在于识别出“除数”与“结果和”之间的单调性，从而将问题转化为一个经典的“在答案空间上进行二分查找”的场景。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目要求我们寻找一个<strong>最小的正整数除数</strong>，用这个除数去除数组 <code>nums</code> 中的每个元素，并将所有结果<strong>向上取整</strong>后求和。最终，这个和必须小于或等于给定的 <code>threshold</code>。</p>
<p>关键点在于“向上取整”。例如，<code>7 / 3 = 2.33...</code>，向上取整后是 <code>3</code>；<code>10 / 2 = 5</code>，向上取整后还是 <code>5</code>。</p>
<p>我们来看一个例子：<code>nums = [1,2,5,9], threshold = 6</code>。</p>
<ul>
<li>如果选择除数为 1，和为 <code>ceil(1/1) + ceil(2/1) + ceil(5/1) + ceil(9/1) = 1 + 2 + 5 + 9 = 17</code>。<code>17 &gt; 6</code>，不满足条件。</li>
<li>如果选择除数为 4，和为 <code>ceil(1/4) + ceil(2/4) + ceil(5/4) + ceil(9/4) = 1 + 1 + 2 + 3 = 7</code>。<code>7 &gt; 6</code>，不满足条件。</li>
<li>如果选择除数为 5，和为 <code>ceil(1/5) + ceil(2/5) + ceil(5/5) + ceil(9/5) = 1 + 1 + 1 + 2 = 5</code>。<code>5 &lt;= 6</code>，满足条件。</li>
</ul>
<p>我们找到了一个满足条件的除数 <code>5</code>。但题目要求的是<strong>最小</strong>的那个。我们可以继续验证，发现除数 <code>4</code> 不满足条件，因此 <code>5</code> 就是我们要找的最小除数。</p>
<h3 id="核心思路：在答案上进行二分查找"><a href="#核心思路：在答案上进行二分查找" class="headerlink" title="核心思路：在答案上进行二分查找"></a>核心思路：在答案上进行二分查找</h3><p>一个朴素的想法是，从除数 <code>d = 1</code> 开始，逐个向上尝试，计算每次的和，直到找到第一个满足 <code>sum &lt;= threshold</code> 的除数。然而，<code>nums</code> 中的元素最大可达 <code>10^6</code>，这意味着除数的取值范围也可能很大，线性遍历非常耗时，可能会超时。</p>
<p>这时，我们需要观察问题是否存在某种<strong>单调性</strong>。</p>
<ul>
<li>当<strong>除数增大</strong>时，数组中每个元素 <code>num / divisor</code> 的结果会减小或不变。</li>
<li>因此，所有结果向上取整后的<strong>总和也会减小或不变</strong>。</li>
</ul>
<p>这种“除数”与“总和”之间的单调递减关系，是使用<strong>二分查找</strong>的绝佳信号。我们可以对<strong>答案（也就是除数）本身</strong>进行二分查找。</p>
<ol>
<li><p><strong>确定搜索范围</strong>：</p>
<ul>
<li>除数最小也得是 <code>1</code>，这是我们的左边界。</li>
<li>除数最大是多少呢？如果除数等于 <code>max(nums)</code>，那么每个数相除的结果向上取整后不是 <code>1</code> 就是 <code>0</code>（正整数没有0），所以和最大是 <code>len(nums)</code>。如果除数比 <code>max(nums)</code> 还大，和依然是 <code>len(nums)</code>。因此，将搜索范围的右边界设为 <code>max(nums)</code> 是一个合理的上界。</li>
</ul>
</li>
<li><p><strong>二分过程</strong>：</p>
<ul>
<li>取搜索范围 <code>[left, right]</code> 的中间值 <code>mid</code> 作为候选的除数。</li>
<li>计算当除数为 <code>mid</code> 时的总和。</li>
<li>如果 <code>sum &lt;= threshold</code>，说明 <code>mid</code> 是一个<strong>可能</strong>的解，但我们想找更小的，所以我们尝试在 <code>[left, mid]</code> 这个更小的区间里继续寻找。</li>
<li>如果 <code>sum &gt; threshold</code>，说明 <code>mid</code> 这个除数太小了，导致和超标了。我们需要一个更大的除数，所以在 <code>[mid + 1, right]</code> 区间里继续寻找。</li>
</ul>
</li>
</ol>
<p>通过不断缩小搜索范围，我们最终可以锁定满足条件的最小除数。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分边界</strong></p>
<ul>
<li>左边界 <code>l</code>：最小可能的除数是 <code>1</code>。</li>
<li>右边界 <code>r</code>：最大可能的除数是 <code>max(nums)</code>。</li>
<li><em>注意</em>：代码实现中 <code>l</code> 从 <code>0</code> 开始，但因为 <code>mid</code> 的计算和 <code>l</code> 的更新方式，<code>mid</code> 永远不会是 <code>0</code>，不影响结果。</li>
</ul>
</li>
<li><p><strong>编写 <code>check</code> 函数（求和逻辑）</strong></p>
<ul>
<li>这是二分查找的核心判断条件。给定一个除数 <code>d</code>，我们需要计算 <code>sum(ceil(x/d) for x in nums)</code>。</li>
<li>在整数运算中，<code>ceil(x/d)</code> 有一个巧妙的等价转换：<code>(x + d - 1) // d</code>。</li>
<li>代码中使用了另一个更精妙的转换：<code>ceil(x/d) = (x - 1) // d + 1</code>。</li>
<li>因此，<code>sum(ceil(x/d))</code> 等于 <code>sum((x - 1) // d + 1)</code>，进一步等于 <code>sum((x - 1) // d) + len(nums)</code>。</li>
<li>所以，判断条件 <code>sum(ceil(x/d)) &lt;= threshold</code> 就等价于 <code>sum((x - 1) // d) + len(nums) &lt;= threshold</code>，即 <code>sum((x - 1) // d) &lt;= threshold - len(nums)</code>。这正是代码中所使用的判断逻辑，它通过预先减掉 <code>len(nums)</code> 使得循环内的计算更简洁。</li>
</ul>
</li>
<li><p><strong>循环二分</strong></p>
<ul>
<li>采用 <code>while l + 1 &lt; r</code> 的二分模板。这个模板的循环终止条件是 <code>l</code> 和 <code>r</code> 相邻。</li>
<li>在循环中，计算 <code>mid = (l + r) // 2</code>。</li>
<li>如果 <code>mid</code> 满足条件（和小于等于阈值），说明 <code>mid</code> 是一个潜在的答案，或者还有更小的答案。我们将上界收缩到 <code>mid</code>，即 <code>r = mid</code>，去左半边寻找更优解。</li>
<li>如果 <code>mid</code> 不满足条件，说明 <code>mid</code> 太小了，必须选择一个更大的除数。我们将下界提升到 <code>mid</code>，即 <code>l = mid</code>，去右半边寻找解。</li>
<li>循环结束后，<code>r</code> 就指向了满足条件的最小除数。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestDivisor</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], threshold: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1: 确定二分查找的边界</span></span><br><span class="line">        <span class="comment"># 左边界 l 可以从 0 或 1 开始，因为除数最小为 1。</span></span><br><span class="line">        <span class="comment"># 右边界 r 是数组中的最大值，更大的除数不会产生更小的和。</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">max</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 循环二分</span></span><br><span class="line">        <span class="comment"># 采用 l + 1 &lt; r 的模板，循环直到 l 和 r 相邻</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 防止除以 0 的情况</span></span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span>:</span><br><span class="line">                l = mid</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 2: check 函数逻辑</span></span><br><span class="line">            <span class="comment"># 计算以 mid 为除数时的总和</span></span><br><span class="line">            <span class="comment"># ceil(x/mid) 等价于 (x-1)//mid + 1</span></span><br><span class="line">            <span class="comment"># sum((x-1)//mid + 1) &lt;= threshold 变形为:</span></span><br><span class="line">            <span class="comment"># sum((x-1)//mid) &lt;= threshold - len(nums)</span></span><br><span class="line">            current_sum = <span class="built_in">sum</span>((x - <span class="number">1</span>) // mid <span class="keyword">for</span> x <span class="keyword">in</span> nums)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> current_sum &lt;= threshold - <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="comment"># 如果和满足条件，说明 mid 是一个可能的解</span></span><br><span class="line">                <span class="comment"># 我们尝试寻找更小的解，所以收缩上界</span></span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果和不满足条件，说明 mid 太小了</span></span><br><span class="line">                <span class="comment"># 我们需要更大的除数，所以收缩下界</span></span><br><span class="line">                l = mid</span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 循环结束时, r 是满足条件的最小除数</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: O(N * log K)</p>
<ul>
<li>其中 <code>N</code> 是数组 <code>nums</code> 的长度，<code>K</code> 是 <code>nums</code> 数组中的最大值。</li>
<li>二分查找的搜索空间大小为 <code>K</code>，因此二分过程需要进行 O(log K) 次迭代。</li>
<li>在每一次迭代中，我们都需要遍历整个 <code>nums</code> 数组来计算总和，这个操作的复杂度是 O(N)。</li>
<li>因此，总的时间复杂度是 O(N * log K)。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>: O(1)</p>
<ul>
<li>算法在执行过程中只使用了有限的几个变量（如 <code>l</code>, <code>r</code>, <code>mid</code>, <code>current_sum</code>），没有使用额外的、与输入规模相关的存储空间。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是二分查找思想的一个典型应用，但它并非直接在输入数组上进行查找，而是在**可能解的范围（答案空间）**上进行查找。解决这类问题的关键在于：</p>
<ol>
<li>分析问题，发现输入与输出之间的单调关系。</li>
<li>确定这个单调关系的定义域，即二分查找的上下边界。</li>
<li>将原问题转化为一个“判定问题”（Check 函数）：给定一个候选解 <code>mid</code>，能否在 O(N) 时间内判断它是否满足条件？</li>
</ol>
<p>一旦这三步完成，就可以套用二分查找模板来高效地解决问题，将时间复杂度从可能的 O(N<em>K) 优化到 O(N</em>log K)。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最小</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>第166场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1439 | 有序矩阵中的第 k 个最小数组和</title>
    <url>//posts/leetcode-1439/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1439 题：<a href="https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/">有序矩阵中的第 k 个最小数组和</a>。<br>由于矩阵行有序，我们可以利用 <strong>BS</strong> 来确定答案，结合 <strong>DFS</strong> 进行验证。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个 <code>m * n</code> 的矩阵 <code>mat</code>，以及一个整数 <code>k</code>，矩阵中的每一行都以非递减的顺序排列。</p>
<p>你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 <code>k</code> 个 <strong>最小</strong> 数组和。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：mat = [[1,3,11],[2,4,6]], k = 5</span><br><span class="line">输出：7</span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat.length[i]</code></li>
<li><code>1 &lt;= m, n &lt;= 40</code></li>
<li><code>1 &lt;= k &lt;= min(200, n ^ m)</code></li>
<li><code>1 &lt;= mat[i][j] &lt;= 5000</code></li>
<li><code>mat[i]</code> 是一个非递减数组</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-为什么选择二分答案？"><a href="#1-为什么选择二分答案？" class="headerlink" title="1. 为什么选择二分答案？"></a>1. 为什么选择二分答案？</h4><p>我们需要找到所有可能的数组和中第 <code>k</code> 小的那个和。<br>如果我们把所有可能的数组和从小到大排列，设第 <code>k</code> 小的和为 <code>target</code>，那么我们可以发现一个规律：</p>
<ul>
<li>对于任意小于 <code>target</code> 的数值 <code>x</code>，能组成的数组和小于等于 <code>x</code> 的数量一定小于 <code>k</code>。</li>
<li>对于任意大于等于 <code>target</code> 的数值 <code>x</code>，能组成的数组和小于等于 <code>x</code> 的数量一定大于等于 <code>k</code>。</li>
</ul>
<p>这满足<strong>单调性</strong>，因此我们可以对“数组和”这个值进行二分查找。</p>
<h4 id="2-确定二分范围"><a href="#2-确定二分范围" class="headerlink" title="2. 确定二分范围"></a>2. 确定二分范围</h4><ul>
<li><strong>下界 (Left)</strong>：每行取最小的元素（即第一列），求和。这是所有组合中最小的和 <code>sl</code>。</li>
<li><strong>上界 (Right)</strong>：每行取最大的元素（即最后一列），求和。这是所有组合中最大的和 <code>sr</code>。</li>
</ul>
<p>答案一定在 <code>[sl, sr]</code> 之间。</p>
<h4 id="3-Check-函数的设计-DFS"><a href="#3-Check-函数的设计-DFS" class="headerlink" title="3. Check 函数的设计 (DFS)"></a>3. Check 函数的设计 (DFS)</h4><p>二分的核心在于 <code>check(s)</code> 函数：判断是否存在至少 <code>k</code> 个数组组合，其和小于等于 <code>s</code>。</p>
<p>如果我们要枚举所有组合，复杂度是指数级的，无法接受。但我们只需要知道 <strong>数量是否达到 k</strong>。<br>我们可以使用 DFS 回溯来统计：</p>
<ol>
<li>从最后一行开始往前递归（或从第一行开始，效果一样）。</li>
<li>为了加速，我们不传递当前的累加和，而是传递 <strong>剩余的额度</strong>。<ul>
<li>初始额度 &#x3D; <code>s</code> - <code>sl</code> (当前二分值减去最小基础和)。</li>
<li>这相当于我们在计算除了每行选第一个数（基准）之外，额外增加的增量能否控制在限制内。</li>
</ul>
</li>
<li><strong>剪枝策略</strong>：<ul>
<li>如果在某一行，选择某个元素后，增量已经超过了剩余额度，由于行是有序的，后面的元素更大，肯定也不满足，直接 <code>break</code>。</li>
<li><strong>数量限制</strong>：维护一个全局计数器（或引用变量）<code>lk</code>，初始为 <code>k</code>。每找到一个合法组合，<code>lk</code> 减 1。当 <code>lk</code> 降为 0 时，说明我们已经找到了 <code>k</code> 个满足条件的组合，直接返回 <code>True</code>。</li>
</ul>
</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># check 函数：判断小于等于 s 的数组和的数量是否 &gt;= k</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">s: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># lk 用于计数，还需要找到多少个满足条件的组合</span></span><br><span class="line">            lk = k</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># DFS 搜索</span></span><br><span class="line">            <span class="comment"># i: 当前处理的行索引</span></span><br><span class="line">            <span class="comment"># s: 当前剩余的可支配和（相对于每行最小值的增量）</span></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, s: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">                <span class="comment"># Base case: 成功遍历完所有行（i &lt; 0），说明找到一个合法组合</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">nonlocal</span> lk</span><br><span class="line">                    lk -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> lk == <span class="number">0</span> <span class="comment"># 如果找到了 k 个，返回 True</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 遍历当前行的元素</span></span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> mat[i]:</span><br><span class="line">                    <span class="comment"># 剪枝：如果当前元素带来的增量 (x - mat[i][0]) 超过了剩余预算 s</span></span><br><span class="line">                    <span class="comment"># 由于 mat[i] 是有序的，后面的元素肯定也超，直接 break</span></span><br><span class="line">                    <span class="keyword">if</span> x - mat[i][<span class="number">0</span>] &gt; s:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 递归处理上一行</span></span><br><span class="line">                    <span class="comment"># 这里的 s - (x - mat[i][0]) 是减去当前元素相对于该行最小值的增量</span></span><br><span class="line">                    <span class="keyword">if</span> dfs(i - <span class="number">1</span>, s - (x - mat[i][<span class="number">0</span>])):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 如果子递归已经找到了足够的数量，向上返回 True</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从最后一行开始 DFS，初始预算是 s - sl</span></span><br><span class="line">            <span class="comment"># s 是二分的猜测值，sl 是所有行最小值的和</span></span><br><span class="line">            <span class="keyword">return</span> dfs(<span class="built_in">len</span>(mat) - <span class="number">1</span>, s - sl)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算可能的最小和 sl 和最大和 sr</span></span><br><span class="line">        sl = <span class="built_in">sum</span>(row[<span class="number">0</span>] <span class="keyword">for</span> row <span class="keyword">in</span> mat)</span><br><span class="line">        sr = <span class="built_in">sum</span>(row[-<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> mat)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 二分查找</span></span><br><span class="line">        <span class="comment"># range(sl, sr) 生成从 sl 到 sr-1 的序列</span></span><br><span class="line">        <span class="comment"># bisect_left 会寻找第一个使得 check(val) 为 True 的位置</span></span><br><span class="line">        <span class="comment"># 结果需要加上 sl 偏移量</span></span><br><span class="line">        <span class="comment"># 注意：如果 range 中所有值都 check 失败，bisect_left 返回数组长度，即 sr - sl</span></span><br><span class="line">        <span class="comment"># 此时结果为 sl + (sr - sl) = sr，逻辑是自洽的</span></span><br><span class="line">        <span class="keyword">return</span> sl + bisect_left(<span class="built_in">range</span>(sl, sr), <span class="literal">True</span>, key=check)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthSmallest</span><span class="params">(mat [][]<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sl, sr := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment">// 计算理论最小和 sl 和最大和 sr</span></span><br><span class="line">    <span class="keyword">for</span> _, row := <span class="keyword">range</span> mat &#123;</span><br><span class="line">        sl += row[<span class="number">0</span>]</span><br><span class="line">        sr += row[<span class="built_in">len</span>(row)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="comment">// sort.Search(n, f) 在 [0, n) 范围内查找使得 f(i) 为 true 的最小 i</span></span><br><span class="line">    <span class="comment">// 这里的范围长度是 sr - sl，代表从最小和开始的增量范围</span></span><br><span class="line">    <span class="keyword">return</span> sl + sort.Search(sr-sl, <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="comment">// s 代表当前二分尝试的“额外增量”值</span></span><br><span class="line">        <span class="comment">// 实际尝试的数组和 target = sl + s</span></span><br><span class="line">        </span><br><span class="line">        lk := k <span class="comment">// 剩余需要寻找的组合数量</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">bool</span></span><br><span class="line">        dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, s <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="comment">// Base case: 所有行都选择完毕</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> &#123;</span><br><span class="line">                lk--</span><br><span class="line">                <span class="keyword">return</span> lk == <span class="number">0</span> <span class="comment">// 如果找到了 k 个，返回 true</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历第 i 行的元素</span></span><br><span class="line">            <span class="keyword">for</span> _, x := <span class="keyword">range</span> mat[i] &#123;</span><br><span class="line">                <span class="comment">// 剪枝：如果当前元素相对于该行最小值的增量大于剩余预算 s</span></span><br><span class="line">                <span class="comment">// 则该行后续元素也一定不满足，直接 break</span></span><br><span class="line">                <span class="keyword">if</span> x-mat[i][<span class="number">0</span>] &gt; s &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 递归进入上一行 (i-1)</span></span><br><span class="line">                <span class="comment">// 预算减去当前选择带来的增量</span></span><br><span class="line">                <span class="keyword">if</span> dfs(i<span class="number">-1</span>, s-(x-mat[i][<span class="number">0</span>])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从最后一行开始，初始预算就是二分传入的 s</span></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="built_in">len</span>(mat)<span class="number">-1</span>, s)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: <code>O(m * k * log(Range))</code><ul>
<li>二分查找的范围是 <code>Range = sr - sl</code>，大约为 <code>m * 5000</code>，二分次数为 <code>log(Range)</code>。</li>
<li>在每次 <code>check</code> 中，我们使用 DFS 寻找不超过 <code>k</code> 个合法组合。虽然最坏情况下 DFS 复杂度较高，但由于我们限制了找到 <code>k</code> 个就停止，且利用了排序进行剪枝，实际运行效率很高。这里的有效搜索节点数与 <code>k</code> 和 <code>m</code> 相关。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: <code>O(m)</code><ul>
<li>主要消耗在于 DFS 的递归调用栈，深度为 <code>m</code>。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>第K小/大</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>矩阵</tag>
        <tag>堆（优先队列）</tag>
        <tag>第187场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1515 | 服务中心的最佳位置</title>
    <url>//posts/leetcode-1515/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1515 题：<a href="https://leetcode.cn/problems/best-position-for-a-service-centre/">服务中心的最佳位置</a>。<br>我们需要找到一个点，使其到所有给定点的欧几里得距离之和最小。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>一家快递公司希望在新城市建立新的服务中心。公司统计了该城市所有客户在二维地图上的坐标 <code>positions</code>，其中 <code>positions[i] = [xi, yi]</code>。</p>
<p>请你为服务中心选址 <code>[xcentre, ycentre]</code>，使服务中心到所有客户的 <strong>欧几里得距离的总和最小</strong>。</p>
<p>返回该最小距离总和。答案与真实值误差在 <code>10^-5</code> 之内的将被视作正确答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：positions = [[0,1],[1,0],[1,2],[2,1]]</span><br><span class="line">输出：4.00000</span><br><span class="line">解释：选 [1, 1] 作为新中心的位置，到每个客户的距离都是 1，总和为 4。</span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-几何重心-vs-几何中位数"><a href="#1-几何重心-vs-几何中位数" class="headerlink" title="1. 几何重心 vs 几何中位数"></a>1. 几何重心 vs 几何中位数</h4><ul>
<li><strong>几何重心（Centroid）</strong>：是所有点坐标的平均值 <code>(sum(x)/n, sum(y)/n)</code>。它最小化的是到所有点的<strong>距离平方和</strong>。</li>
<li><strong>几何中位数（Geometric Median）</strong>：最小化的是到所有点的<strong>欧几里得距离之和</strong>。</li>
</ul>
<p>本题要求的是后者。不幸的是，当点的数量 <code>n &gt; 4</code> 时，不存在通用的封闭公式（即无法直接用公式算出来）。我们需要使用<strong>迭代近似</strong>的方法。</p>
<h4 id="2-凸函数的性质"><a href="#2-凸函数的性质" class="headerlink" title="2. 凸函数的性质"></a>2. 凸函数的性质</h4><p>目标函数 <code>f(x, y) = Σ sqrt((xi-x)^2 + (yi-y)^2)</code> 是一个<strong>凸函数</strong>。<br>这意味着：</p>
<ol>
<li>它形状像一个碗，只有一个最低点（局部最小值即全局最小值）。</li>
<li>我们可以使用**梯度下降（Gradient Descent）<strong>或</strong>爬山法（Hill Climbing）**等迭代算法，从任意初始点出发，一步步逼近最低点。</li>
</ol>
<h4 id="3-求解方法"><a href="#3-求解方法" class="headerlink" title="3. 求解方法"></a>3. 求解方法</h4><ul>
<li><strong>Python (SciPy)</strong>: 题目允许使用数值优化库，Python 的 <code>scipy.optimize</code> 模块提供了现成的最小化函数求解器，非常适合处理这类非线性优化问题。</li>
<li><strong>Go (手动迭代)</strong>: 由于标准库通常不包含此类高级数学优化器，我们可以手写一个简单的<strong>步长衰减法</strong>（类似梯度下降或三分法的变种）：<ol>
<li><strong>初始化</strong>：将中心点设为所有点的重心（平均值），这是一个很好的起始猜测。</li>
<li><strong>迭代</strong>：尝试向 上、下、左、右 四个方向移动。</li>
<li><strong>贪心策略</strong>：如果移动后的新位置能使总距离变小，就更新中心点到新位置。</li>
<li><strong>衰减步长</strong>：如果四个方向都不能使距离变小，说明当前步长太大，需要减小步长（例如除以 2）以进行微调。</li>
<li><strong>终止</strong>：当步长非常小（如小于 <code>1e-7</code>）时停止。</li>
</ol>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> dist</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMinDistSum</span>(<span class="params">self, positions: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="comment"># 使用 SciPy 的 minimize 函数进行数值优化</span></span><br><span class="line">        <span class="comment"># minimize 寻找目标函数的最小值</span></span><br><span class="line">        <span class="comment"># 参数 1: lambda t ... : 目标函数。输入是点 t (x, y)，输出是 t 到所有 positions 的欧几里得距离之和</span></span><br><span class="line">        <span class="comment"># 参数 2: (0, 0) : 初始猜测值 (x0, y0)。虽然重心是更好的猜测，但 (0,0) 对于凸函数也能收敛</span></span><br><span class="line">        <span class="comment"># 返回值: minimize 返回一个对象，[&#x27;fun&#x27;] 属性包含了目标函数的最小值</span></span><br><span class="line">        <span class="keyword">return</span> minimize(<span class="keyword">lambda</span> t: <span class="built_in">sum</span>([dist(p, t) <span class="keyword">for</span> p <span class="keyword">in</span> positions]), (<span class="number">0</span>, <span class="number">0</span>))[<span class="string">&#x27;fun&#x27;</span>]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMinDistSum</span><span class="params">(positions [][]<span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="comment">// 辅助函数：计算点 (xc, yc) 到所有点的欧几里得距离之和</span></span><br><span class="line">    getSum := <span class="function"><span class="keyword">func</span><span class="params">(xc, yc <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">        sum := <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> _, pos := <span class="keyword">range</span> positions &#123;</span><br><span class="line">            <span class="comment">// dist = sqrt((x1-x2)^2 + (y1-y2)^2)</span></span><br><span class="line">            sum += math.Sqrt(math.Pow(<span class="type">float64</span>(pos[<span class="number">0</span>])-xc, <span class="number">2</span>) + math.Pow(<span class="type">float64</span>(pos[<span class="number">1</span>])-yc, <span class="number">2</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 初始化中心点 (x, y) 为几何重心（平均值）</span></span><br><span class="line">    <span class="comment">// 这是一个很好的起始位置，比 (0,0) 更接近答案</span></span><br><span class="line">    x, y := <span class="number">0.0</span>, <span class="number">0.0</span></span><br><span class="line">    n := <span class="type">float64</span>(<span class="built_in">len</span>(positions))</span><br><span class="line">    <span class="keyword">for</span> _, pos := <span class="keyword">range</span> positions &#123;</span><br><span class="line">        x += <span class="type">float64</span>(pos[<span class="number">0</span>])</span><br><span class="line">        y += <span class="type">float64</span>(pos[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    x /= n</span><br><span class="line">    y /= n</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 迭代参数设置</span></span><br><span class="line">    <span class="comment">// 初始步长，由于坐标范围是 0-100，步长设为 1 比较合理</span></span><br><span class="line">    step := <span class="number">1.0</span> </span><br><span class="line">    <span class="comment">// 精度控制，题目要求 10^-5，我们设置得更小一点以保证准确度</span></span><br><span class="line">    epsilon := <span class="number">1e-7</span> </span><br><span class="line">    <span class="comment">// 衰减率，每次无法移动时步长缩小的比例</span></span><br><span class="line">    decay := <span class="number">0.5</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义四个移动方向：左、右、下、上</span></span><br><span class="line">    dirs := [<span class="number">4</span>][<span class="number">2</span>]<span class="type">float64</span>&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前的最小距离和</span></span><br><span class="line">    minDist := getSum(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 开始迭代，直到步长小于阈值</span></span><br><span class="line">    <span class="keyword">for</span> step &gt; epsilon &#123;</span><br><span class="line">        foundBetter := <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试往四个方向走一步</span></span><br><span class="line">        <span class="keyword">for</span> _, d := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">            nx := x + d[<span class="number">0</span>]*step</span><br><span class="line">            ny := y + d[<span class="number">1</span>]*step</span><br><span class="line">            </span><br><span class="line">            newDist := getSum(nx, ny)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果新位置的距离和更小，则移动中心点</span></span><br><span class="line">            <span class="keyword">if</span> newDist &lt; minDist &#123;</span><br><span class="line">                minDist = newDist</span><br><span class="line">                x = nx</span><br><span class="line">                y = ny</span><br><span class="line">                foundBetter = <span class="literal">true</span></span><br><span class="line">                <span class="comment">// 这里可以选择 break 也可以不 break</span></span><br><span class="line">                <span class="comment">// 不 break 意味着一轮可能移动多次，通常不 break 收敛更快</span></span><br><span class="line">                <span class="keyword">break</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果四个方向都不能优化结果，说明当前步长太大，需要缩小步长</span></span><br><span class="line">        <span class="keyword">if</span> !foundBetter &#123;</span><br><span class="line">            step *= decay</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minDist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>:<ul>
<li><strong>Python</strong>: 取决于 SciPy 内部优化算法（通常是 BFGS 或类似算法），一般迭代次数不多。</li>
<li><strong>Go</strong>: <code>O(N * K)</code>，其中 <code>N</code> 是点的数量，<code>K</code> 是迭代次数。迭代次数与 <code>step</code> 从 1 衰减到 <code>1e-7</code> 的过程有关，约为 <code>log(1/epsilon)</code>。由于目标函数是凸的，收敛速度非常快。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: <code>O(1)</code>，只需要常数级别的变量存储坐标和距离。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><strong>Python 环境</strong>: <code>scipy</code> 是第三方科学计算库，在标准的 LeetCode 在线环境中<strong>通常不可用</strong>（除非是特定的支持全库的比赛环境）。Python 解法在本地环境或支持 <code>scipy</code> 的 OJ 上非常方便，但在标准 LeetCode 环境下，建议使用类似 Go 语言解法中的模拟退火或梯度下降逻辑来实现 Python 版本。</li>
<li><strong>局部最优即全局最优</strong>: 因为距离和函数是<strong>凸函数</strong>，所以我们不需要担心算法陷入局部最优解，简单的贪心移动策略配合步长衰减一定能找到全局最优解。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>三分法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>数学</tag>
        <tag>几何</tag>
        <tag>随机化</tag>
        <tag>第197场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1287 | 有序数组中出现次数超过四分之一的元素</title>
    <url>//posts/leetcode-1287/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1287 题：<a href="https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/description/">有序数组中出现次数超过四分之一的元素</a>。<br>这道题的优雅解法，完美诠释了如何利用问题的内在约束（“超过25%”）和数据特性（“有序”），将一个看似需要线性扫描的问题，转化为仅需常数次检查的对数级别算法。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="算法优化特性：从-O-n-到-O-log-n-的飞跃"><a href="#算法优化特性：从-O-n-到-O-log-n-的飞跃" class="headerlink" title="算法优化特性：从 O(n) 到 O(log n) 的飞跃"></a>算法优化特性：从 O(n) 到 O(log n) 的飞跃</h3><p>面对这个问题，最直观的想法是遍历整个数组，使用哈希表或计数器来统计每个数字的出现次数，时间复杂度为 O(n)。但题目给出了一个至关重要的线索：<strong>数组是有序的</strong>。这个特性让我们有机会使用二分查找来进行优化。</p>
<p>然而，对谁进行二分查找呢？我们不可能对每个元素都去计算其出现次数，这样效率会更低。</p>
<p>关键的优化点来自对 <strong>“超过 25%”</strong> 这个条件的深度挖掘。如果一个元素在长度为 <code>n</code> 的数组中出现次数超过 <code>n/4</code> 次，那么这个元素的分佈必然具有一个非常特殊的性质，这使得我们<strong>不需要检查所有元素</strong>，而只需要检查<strong>几个固定的“候选”位置</strong>即可。</p>
<p>这个思想将遍历所有元素的 O(n) 思路，降维成了检查常数个候选元素，每次检查使用二分查找，最终实现了 O(log n) 的时间复杂度。</p>
<h3 id="正确性证明：为何只需检查几个点？"><a href="#正确性证明：为何只需检查几个点？" class="headerlink" title="正确性证明：为何只需检查几个点？"></a>正确性证明：为何只需检查几个点？</h3><p>算法的核心是基于一个类似<strong>鸽巢原理</strong>的简单证明：一个长度超过 <code>n/4</code> 的连续区块，不可能完全“躲藏”在数组的四个“角落”里，它必然会跨越我们设定的几个关键“检查点”。</p>
<p>下面我们来严谨地证明这一点。</p>
<ol>
<li><p><strong>定义问题</strong></p>
<ul>
<li>设数组 <code>arr</code> 的长度为 <code>n</code>。</li>
<li>我们要找的特殊整数为 <code>x</code>，其出现次数为 <code>k</code>。</li>
<li>根据题意，<code>k &gt; n / 4</code>。由于 <code>k</code> 是整数，这等价于 <code>k &gt;= floor(n / 4) + 1</code>。</li>
</ul>
</li>
<li><p><strong>利用有序性</strong></p>
<ul>
<li>因为数组是<strong>非递减</strong>的，所有 <code>k</code> 个 <code>x</code> 必定是<strong>连续排列</strong>的。它们会形成一个长度为 <code>k</code> 的连续区块。</li>
</ul>
</li>
<li><p><strong>设置检查点</strong></p>
<ul>
<li>我们可以将数组从概念上分为四段。最直观的分割点（即我们的“检查点”）是位于 <code>n/4</code>, <code>n/2</code>, 和 <code>3n/4</code> 位置上的元素。</li>
<li>为了方便，我们考虑下取整的索引：<code>idx_1 = n // 4</code>, <code>idx_2 = n // 2</code>, <code>idx_3 = 3 * n // 4</code>。</li>
<li>我们的论点是：特殊整数 <code>x</code> <strong>必然</strong>是 <code>arr[idx_1]</code>, <code>arr[idx_2]</code>, <code>arr[idx_3]</code> 中的一个。</li>
</ul>
</li>
<li><p><strong>反证法证明</strong></p>
<ul>
<li>假设特殊整数 <code>x</code> <strong>不是</strong>这三个检查点中的任何一个。</li>
<li>那么，<code>x</code> 所形成的长度为 <code>k</code> 的连续区块，必须完整地存在于由这些检查点分割出的四个“间隙”之一中：<ol>
<li><code>[0, idx_1 - 1]</code></li>
<li><code>[idx_1 + 1, idx_2 - 1]</code></li>
<li><code>[idx_2 + 1, idx_3 - 1]</code></li>
<li><code>[idx_3 + 1, n - 1]</code></li>
</ol>
</li>
<li>现在我们来计算这些“间隙”的最大长度。最长的间隙是第一个，其长度为 <code>(idx_1 - 1) - 0 + 1 = idx_1 = n // 4</code>。其他间隙的长度都不会超过 <code>n // 4</code>。</li>
<li>我们得到一个结论：任何不包含检查点的连续区间，其长度<strong>最大为 <code>n // 4</code></strong>。</li>
<li>这与我们已知的事实——<code>x</code> 的连续区块长度 <code>k</code> <strong>严格大于 <code>n / 4</code></strong>——产生了矛盾！</li>
<li>因此，最初的假设（<code>x</code> 不是任何一个检查点元素）是错误的。</li>
</ul>
</li>
</ol>
<p><strong>结论：</strong> 特殊整数 <code>x</code> 必然是 <code>arr[n//4]</code>, <code>arr[n//2]</code>, 或 <code>arr[3*n//4]</code> 中的一个（或多个）。我们只需要将这三个位置的元素作为候选者，验证它们中哪一个的出现次数超过 <code>n/4</code> 即可。</p>
<h3 id="巧妙的实现"><a href="#巧妙的实现" class="headerlink" title="巧妙的实现"></a>巧妙的实现</h3><p>验证一个候选者 <code>cand</code> 的次数，最直接的方法是找到它的左右边界：<code>count = bisect_right(arr, cand) - bisect_left(arr, cand)</code>。</p>
<p>而下列代码则采用了一种更精炼的“前向检查”技巧，避免了第二次二分查找：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSpecialInteger</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="comment"># 任何出现次数 &gt; n/4 的元素，其个数至少为 m + 1</span></span><br><span class="line">        m = n // <span class="number">4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 候选检查点的索引。其原理是：长度 &gt; m 的连续块必然会跨过这些点之一。</span></span><br><span class="line">        <span class="comment"># 这里选择的点集 (m, 2m+1, ...) 也能起到分割作用，确保间隙长度不大于 m</span></span><br><span class="line">        candidates_indices = (m, m * <span class="number">2</span> + <span class="number">1</span>, m * <span class="number">3</span> + <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> candidates_indices:</span><br><span class="line">            <span class="comment"># 数组边界保护</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= n:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            candidate = arr[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 1. 找到该候选者第一次出现的位置</span></span><br><span class="line">            first_occurrence_idx = bisect.bisect_left(arr, candidate)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 2. 精髓：从第一次出现的位置向后数 m 个位置</span></span><br><span class="line">            <span class="comment"># 如果目标索引仍在数组界内，并且其值仍然是 candidate</span></span><br><span class="line">            <span class="comment"># 则证明从 first_occurrence_idx 到 first_occurrence_idx + m</span></span><br><span class="line">            <span class="comment"># 这 m + 1 个元素都是 candidate，计数达标。</span></span><br><span class="line">            target_idx = first_occurrence_idx + m</span><br><span class="line">            <span class="keyword">if</span> target_idx &lt; n <span class="keyword">and</span> arr[target_idx] == candidate:</span><br><span class="line">                <span class="keyword">return</span> candidate</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 基于题目“恰好有一个”答案的保证，在大多数情况下循环会提前返回。</span></span><br><span class="line">        <span class="comment"># 为覆盖所有边界情况（例如数组长度很短），返回 arr[0] 作为保底。</span></span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码的巧妙之处在于：</p>
<ol>
<li><strong>高效验证</strong>：通过 <code>bisect_left</code> 找到起始点 <code>j</code>，然后直接检查 <code>arr[j + m]</code> 的值。如果它仍然是我们的候选者，就意味着从 <code>j</code> 到 <code>j+m</code>（共 <code>m+1</code> 个）都是同一个数，直接满足了 <code>&gt; n/4</code> 的条件。这比“找左边界再找右边界”的方式更高效。</li>
<li><strong>候选者选择</strong>：选择 <code>m</code>, <code>2m+1</code>, <code>3m+2</code> 等作为检查点索引，同样可以保证覆盖所有可能性，因为它们之间的间隔小于等于 <code>m+1</code>，而目标元素的区块长度大于 <code>m</code>。</li>
<li><strong>确定性</strong>：由于题目保证了答案“恰好有一个”，所以我们测试的几个候选者中必然会有一个满足条件并被返回。</li>
</ol>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(logn)，其中 n 是 arr 的长度。</li>
<li><strong>空间复杂度</strong>: O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>鸽巢原理</tag>
        <tag>第15场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 154 | 寻找旋转排序数组中的最小值 II</title>
    <url>//posts/leetcode-154/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 154 题：<a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">寻找旋转排序数组中的最小值 II</a>。<br>该题难点在于数组中可能存在 <strong>重复元素</strong>。这破坏了二分查找原本严格的单调性，使得我们需要特殊处理相等的情况。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 1 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。<br>例如，原数组 <code>nums = [0,1,4,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 4 次，则可以得到 <code>[4,5,6,7,0,1,4]</code></li>
<li>若旋转 7 次，则可以得到 <code>[0,1,4,4,5,6,7]</code></li>
</ul>
<p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>nums</code>，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong>。</p>
<p>你必须尽可能减少整个过程的操作步骤。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,5]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>
<li><code>nums</code>原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-旋转数组的性质"><a href="#1-旋转数组的性质" class="headerlink" title="1. 旋转数组的性质"></a>1. 旋转数组的性质</h4><p>旋转排序数组（Rotated Sorted Array）通常可以看作是被分割成了两个有序的子数组。例如 <code>[4,5,6,7,0,1,2]</code>，左半部分 <code>[4,5,6,7]</code> 和右半部分 <code>[0,1,2]</code> 都是有序的，且右半部分的元素通常小于等于左半部分的元素（除非未旋转）。最小值就是右半部分的第一个元素。</p>
<h4 id="2-二分查找策略"><a href="#2-二分查找策略" class="headerlink" title="2. 二分查找策略"></a>2. 二分查找策略</h4><p>我们的目标是找到旋转点（最小值）。在标准的二分查找中（没有重复元素），我们通常比较 <code>nums[mid]</code> 和 <code>nums[right]</code>：</p>
<ul>
<li>如果 <code>nums[mid] &lt; nums[right]</code>：说明 <code>mid</code> 到 <code>right</code> 这部分是有序的，最小值肯定在 <code>mid</code> 左边或者就是 <code>mid</code> 自己。因此区间缩小为 <code>[left, mid]</code>。</li>
<li>如果 <code>nums[mid] &gt; nums[right]</code>：说明 <code>mid</code> 处于左半段较大的有序部分，最小值一定在 <code>mid</code> 的右边。因此区间缩小为 <code>[mid + 1, right]</code>。</li>
</ul>
<h4 id="3-处理重复元素"><a href="#3-处理重复元素" class="headerlink" title="3. 处理重复元素"></a>3. 处理重复元素</h4><p>本题的难点在于 <strong>重复元素</strong>，即 <code>nums[mid] == nums[right]</code> 的情况。<br>例如：</p>
<ul>
<li>情况 A: <code>[1, 0, 1, 1, 1]</code>，<code>mid</code> 为 2，<code>nums[mid] = 1</code>，<code>nums[right] = 1</code>。最小值 0 在左边。</li>
<li>情况 B: <code>[1, 1, 1, 0, 1]</code>，<code>mid</code> 为 2，<code>nums[mid] = 1</code>，<code>nums[right] = 1</code>。最小值 0 在右边。</li>
</ul>
<p>当 <code>nums[mid] == nums[right]</code> 时，我们无法判断最小值是在 <code>mid</code> 的左边还是右边。<br>但是，由于 <code>nums[mid]</code> 和 <code>nums[right]</code> 相等，我们可以确定的是：<strong>哪怕我们忽略掉 <code>nums[right]</code> 这个位置，最小值的候选人 <code>nums[mid]</code> 依然保留在搜索范围内</strong>。<br>所以，安全的做法是将右边界 <code>right</code> 向左移动一位（<code>right--</code>），逐步缩小范围，直到打破相等的状态。</p>
<h4 id="4-开区间二分法"><a href="#4-开区间二分法" class="headerlink" title="4. 开区间二分法"></a>4. 开区间二分法</h4><p>在提供的代码中，使用的是 <code>(l, r)</code> 开区间（或者说 <code>l</code> 是非解集边界，<code>r</code> 是解集边界）的写法：</p>
<ul>
<li><code>l</code> 初始化为 <code>-1</code>。</li>
<li><code>r</code> 初始化为 <code>len(nums) - 1</code>。</li>
<li>循环条件 <code>l + 1 &lt; r</code>。</li>
<li>最终返回 <code>nums[r]</code>。</li>
</ul>
<p>这种写法下，<code>r</code> 始终指向“可能是最小值”的位置，而 <code>l</code> 指向“必定不是最小值”或“旋转点左侧的大值部分”的位置。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化左右指针</span></span><br><span class="line">        <span class="comment"># 采用开区间写法，l 初始为 -1，r 初始为最后一个元素下标</span></span><br><span class="line">        l, r = -<span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当 l 和 r 相邻时停止循环，此时 r 指向最小值</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = (r + l) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情况 1: 中间值等于右边界值</span></span><br><span class="line">            <span class="comment"># 无法确定最小值在左还是右，但由于 nums[mid] == nums[r]，</span></span><br><span class="line">            <span class="comment"># 我们可以安全地排除 nums[r]，因为即使它是最小值，nums[mid] 还在范围内</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == nums[r]:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情况 2: 中间值小于右边界值</span></span><br><span class="line">            <span class="comment"># 说明 mid 到 r 区间是有序的（未旋转或旋转点在 mid 左侧）</span></span><br><span class="line">            <span class="comment"># 最小值可能是 mid 自己，或者是 mid 左边的元素</span></span><br><span class="line">            <span class="comment"># 收缩右边界到 mid</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; nums[r]:</span><br><span class="line">                r = mid</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情况 3: 中间值大于右边界值</span></span><br><span class="line">            <span class="comment"># 说明 mid 在左半段较大的有序区间内</span></span><br><span class="line">            <span class="comment"># 最小值一定在 mid 的右侧</span></span><br><span class="line">            <span class="comment"># 收缩左边界到 mid</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid</span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 循环结束时，r 指向最小值的位置</span></span><br><span class="line">        <span class="keyword">return</span> nums[r]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化左右指针</span></span><br><span class="line">    <span class="comment">// l 表示左边界（不包含），r 表示右边界（包含）</span></span><br><span class="line">    l, r := <span class="number">-1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保持 l 和 r 之间至少有一个元素</span></span><br><span class="line">    <span class="keyword">for</span> l+<span class="number">1</span> &lt; r &#123;</span><br><span class="line">        mid := l + (r-l)/<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 情况 1: 遇到重复元素</span></span><br><span class="line">        <span class="comment">// 无法判断最小值方位，只能线性缩减右边界</span></span><br><span class="line">        <span class="comment">// 这是一个安全操作，因为 nums[mid] 和 nums[r] 值相同</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == nums[r] &#123;</span><br><span class="line">            r--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; nums[r] &#123;</span><br><span class="line">            <span class="comment">// 情况 2: 右半部分有序</span></span><br><span class="line">            <span class="comment">// 最小值在 [l+1, mid] 范围内（包括 mid）</span></span><br><span class="line">            r = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 情况 3: nums[mid] &gt; nums[r]</span></span><br><span class="line">            <span class="comment">// 左半部分有序且值较大，最小值肯定在右边</span></span><br><span class="line">            <span class="comment">// 最小值在 [mid+1, r] 范围内</span></span><br><span class="line">            l = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// r 最终停留在最小值的索引上</span></span><br><span class="line">    <span class="keyword">return</span> nums[r]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>:<ul>
<li><strong>平均情况</strong>: <code>O(log n)</code>。当数组中重复元素较少时，主要逻辑类似于二分查找。</li>
<li><strong>最坏情况</strong>: <code>O(n)</code>。当数组中包含大量重复元素（例如 <code>[1, 1, 1, 1]</code>）时，每次循环只能将 <code>r</code> 减少 1，退化为线性查找。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: <code>O(1)</code>。只使用了常数个变量。</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1610 | 几何与滑动窗口：求解可见点的最大数目</title>
    <url>//posts/leetcode-1610/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1610 题：<a href="https://leetcode.cn/problems/maximum-number-of-visible-points/">可见点的最大数目</a>。<br>这道题将一个几何问题巧妙地包装起来，表面上看是在一个二维平面内旋转视野，但其核心可以转化为一个在一维数组上处理循环问题的经典滑动窗口场景。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一组二维点 <code>points</code>，一个观察者的位置 <code>location</code>，以及一个视野角度 <code>angle</code>。我们可以站在 <code>location</code> 原地旋转，视野范围是一个宽度为 <code>angle</code> 的扇形区域。我们需要找到一个最佳的朝向，使得能看到的点的数量最多。</p>
<p>有几个关键点需要注意：</p>
<ol>
<li>与观察者位置重合的点，永远都是可见的。</li>
<li>点不会遮挡其他点。</li>
<li>我们需要求解的是<strong>最多</strong>能同时看到多少个点。</li>
</ol>
<p>直接去模拟旋转并计算每个角度下可见点的数量，无疑是低效且复杂的。我们需要一种更数学化、更高效的方法来解决这个问题。</p>
<h3 id="核心思路：坐标转换与滑动窗口"><a href="#核心思路：坐标转换与滑动窗口" class="headerlink" title="核心思路：坐标转换与滑动窗口"></a>核心思路：坐标转换与滑动窗口</h3><p>这个问题的核心在于，将二维的坐标问题，转化为一维的角度问题。</p>
<ol>
<li><p><strong>坐标系中心化</strong>：首先，我们将观察者的位置 <code>location</code> 视为坐标原点 <code>(0,0)</code>。所有 <code>points</code> 都需要进行相应的平移，即 <code>(px, py)</code> 变为 <code>(px - loc_x, py - loc_y)</code>。</p>
</li>
<li><p><strong>计算极角</strong>：对于每一个平移后的点，我们可以计算它相对于新原点（即观察者位置）和正东方向（x轴正方向）的夹角。在编程中，<code>math.atan2(y, x)</code> 函数是完成这项工作的完美工具，它可以精确地计算出 <code>(-π, π]</code> 范围内的弧度。我们再将弧度转换为 <code>(-180, 180]</code> 范围内的角度。</p>
</li>
<li><p><strong>处理循环问题</strong>：现在，所有的点都被映射到了一系列角度上。我们的视野是一个宽度为 <code>angle</code> 的“窗口”，可以在 <code>[-180, 180]</code> 这个角度圈上滑动。这里最大的挑战是<strong>循环性</strong>。例如，如果 <code>angle</code> 是 90 度，一个从 350 度开始的视野会覆盖到 <code>[350, 360]</code> 和 <code>[0, 80]</code> 这个范围。直接在数组上处理这种跨越边界的情况非常麻烦。</p>
<p><strong>关键技巧</strong>：为了打破这个循环，我们可以将角度数组“线性化”。首先对所有角度进行排序。然后，我们将每个角度值加上 360 度，并将这些新值追加到原数组的末尾。例如，一个排序后的角度数组 <code>[10, 150, 350]</code> 会被扩展为 <code>[10, 150, 350, 370, 510, 710]</code>。</p>
<p>这样做之后，一个从 350 度到 10 度的视野，就等价于在扩展数组中一个从 350 度到 370 度 (<code>10 + 360</code>) 的连续区间。问题就转化成了一个标准的滑动窗口问题。</p>
</li>
<li><p><strong>应用滑动窗口</strong>：在新生成的、线性且有序的角度数组上，我们寻找一个窗口，其宽度（即 <code>angles[right] - angles[left]</code>）不超过 <code>angle</code>，并使其包含的元素数量最多。</p>
</li>
</ol>
<p>最终，滑动窗口找到的最大点数，加上一开始就统计好的、与观察者位置重合的点数，就是我们的答案。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>预处理</strong>：</p>
<ul>
<li>创建一个空列表 <code>angles</code> 用于存放所有点的角度。</li>
<li>初始化一个计数器 <code>same_location_points = 0</code>。</li>
<li>遍历所有 <code>points</code>，如果一个点与 <code>location</code> 重合，则 <code>same_location_points</code> 加一。</li>
</ul>
</li>
<li><p><strong>计算并转换角度</strong>：</p>
<ul>
<li>对于不与 <code>location</code> 重合的点，将其坐标相对于 <code>location</code> 平移。</li>
<li>使用 <code>math.atan2(y, x)</code> 计算角度（弧度制），然后用 <code>math.degrees()</code> 转换为角度制。将结果存入 <code>angles</code> 列表。</li>
</ul>
</li>
<li><p><strong>排序与数组扩展</strong>：</p>
<ul>
<li>对 <code>angles</code> 列表进行升序排序。</li>
<li>为了处理视野跨越 0&#x2F;360 度的情况，遍历排序后的 <code>angles</code> 列表，将每个角度 <code>a</code> 加上 360 后，作为一个新元素追加到 <code>angles</code> 列表的末尾。</li>
</ul>
</li>
<li><p><strong>滑动窗口</strong>：</p>
<ul>
<li>初始化左指针 <code>left = 0</code> 和最大可见点数 <code>max_visible = 0</code>。</li>
<li>用右指针 <code>right</code> 从 <code>0</code> 开始遍历扩展后的 <code>angles</code> 数组。</li>
<li>在循环中，检查当前窗口 <code>angles[left]</code> 到 <code>angles[right]</code> 的角度差是否大于 <code>angle</code>。</li>
<li>如果 <code>angles[right] - angles[left] &gt; angle</code>，说明窗口过大，需要收缩。我们将 <code>left</code> 指针向右移动，直到窗口重新满足条件。</li>
<li>在每次移动 <code>right</code> 之后（并可能收缩 <code>left</code> 之后），当前窗口 <code>s[left:right+1]</code> 是一个有效的视野范围。我们用它的长度 <code>right - left + 1</code> 来更新 <code>max_visible</code>。</li>
</ul>
</li>
<li><p><strong>计算最终答案</strong>：</p>
<ul>
<li>遍历结束后，<code>max_visible</code> 就是在非重合点中能看到的最大数量。</li>
<li>最终结果是 <code>max_visible + same_location_points</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">visiblePoints</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], angle: <span class="built_in">int</span>, location: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        angles = []</span><br><span class="line">        same_location_points = <span class="number">0</span></span><br><span class="line">        loc_x, loc_y = location[<span class="number">0</span>], location[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 1 &amp; 2: 处理重合点并计算所有其他点的角度</span></span><br><span class="line">        <span class="keyword">for</span> p_x, p_y <span class="keyword">in</span> points:</span><br><span class="line">            <span class="keyword">if</span> p_x == loc_x <span class="keyword">and</span> p_y == loc_y:</span><br><span class="line">                same_location_points += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 使用 atan2 计算弧度，再转换为角度</span></span><br><span class="line">                rad = math.atan2(p_y - loc_y, p_x - loc_x)</span><br><span class="line">                angles.append(math.degrees(rad))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 排序并扩展数组以处理循环</span></span><br><span class="line">        angles.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(angles)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            angles.append(angles[i] + <span class="number">360.0</span>)</span><br><span class="line">            </span><br><span class="line">        max_visible = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果除了重合点外没有其他点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> angles:</span><br><span class="line">            <span class="keyword">return</span> same_location_points</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 4: 滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(angles)):</span><br><span class="line">            <span class="comment"># 如果窗口角度范围超过 angle，收缩左边界</span></span><br><span class="line">            <span class="keyword">while</span> angles[right] - angles[left] &gt; angle:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新最大可见点数</span></span><br><span class="line">            max_visible = <span class="built_in">max</span>(max_visible, right - left + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 步骤 5: 最终结果是窗口内的最大点数加上重合点数</span></span><br><span class="line">        <span class="keyword">return</span> max_visible + same_location_points</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N log N)。其中 N 是点的数量。算法的瓶颈在于对所有点的角度进行排序。计算角度和滑动窗口部分都是 O(N) 的。</li>
<li><strong>空间复杂度</strong>: O(N)。我们需要一个列表来存储 N 个点的角度，并且为了处理循环问题，这个列表的长度会翻倍。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是一个很好的例子，展示了如何将一个几何问题抽象和转化为我们熟悉的算法模型。核心的转化步骤有两步：</p>
<ol>
<li><strong>降维</strong>：通过计算极角，将二维坐标问题转化为一维的角度数组问题。</li>
<li><strong>线性化</strong>：通过排序和扩展数组，将一个循环数组上的问题转化为一个普通线性数组上的问题。</li>
</ol>
<p>完成这两步转化后，问题就变成了一个可以用滑动窗口模板轻松解决的经典问题。这个“扩展数组以处理循环”的技巧在很多涉及环形数组的问题中都非常有用。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
        <tag>数学</tag>
        <tag>排序</tag>
        <tag>几何</tag>
        <tag>第209场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1631 | 最小体力消耗路径</title>
    <url>//posts/leetcode-1631/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1631 题：<a href="https://leetcode.cn/problems/path-with-minimum-effort/description/">最小体力消耗路径</a>。<br>本题是“二分答案”思想的经典应用。它要求我们寻找一个“最小值”，而这个“值”本身又是由路径上的“最大值”决定的。这种“最小化最大值”的结构，强烈地暗示了我们可以将求解问题转化为判定问题，并利用二分查找来高效解决。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们得到一个 <code>rows x columns</code> 的二维地图，每个格子 <code>(row, col)</code> 都有一个高度值。我们需要从左上角 <code>(0, 0)</code> 出发，到达右下角 <code>(rows-1, columns-1)</code>。</p>
<p>与常规的寻路问题不同，这里的“成本”或“体力消耗”定义得比较特殊：</p>
<ol>
<li>我们可以在上、下、左、右四个方向移动。</li>
<li>一条路径的<strong>体力消耗</strong>，被定义为这条路径上<strong>所有相邻格子之间高度差绝对值的最大值</strong>。</li>
<li>我们的目标是找到一条路径，使得这个“体力消耗”值<strong>最小</strong>。</li>
</ol>
<p>举个例子，<code>heights = [[1,2,2],[3,8,2],[5,3,5]]</code>。</p>
<ul>
<li>路径 <code>[1,3,5,3,5]</code>：相邻高度差为 <code>|1-3|=2</code>, <code>|3-5|=2</code>, <code>|5-3|=2</code>, <code>|3-5|=2</code>。这些差值中的最大值是 2，所以这条路径的体力消耗是 2。</li>
<li>路径 <code>[1,2,2,2,5]</code>：相邻高度差为 <code>|1-2|=1</code>, <code>|2-2|=0</code>, <code>|2-2|=0</code>, <code>|2-5|=3</code>。这些差值中的最大值是 3，所以这条路径的体力消耗是 3。</li>
</ul>
<p>比较这两条路径，第一条更优。我们的任务就是找出所有可能的路径中，体力消耗值最小的那一个。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接去寻找那条最优路径似乎很复杂，因为路径的成本不是累加的，我们无法直接使用像 Dijkstra 这样的标准最短路算法（虽然稍作修改后也可以）。</p>
<p>一个更巧妙的思路是转换问题角度。我们不去直接问“最小体力消耗是多少？”，而是去问一个更容易回答的判定性问题：<strong>“是否存在一条路径，其体力消耗不超过 <code>k</code>？”</strong></p>
<p>这个问题就简单多了。如果一条路径的体力消耗不超过 <code>k</code>，那就意味着这条路径上任意两个相邻格子的高度差都不能大于 <code>k</code>。这实际上是在问：在图中，如果我们只保留那些边权（高度差）小于等于 <code>k</code> 的边，起点和终点是否还是连通的？</p>
<p>这个问题可以用一次 <strong>广度优先搜索（BFS）</strong> 或 <strong>深度优先搜索（DFS）</strong> 来解决。我们可以写一个辅助函数 <code>canReach(k)</code>：</p>
<ul>
<li>将网格看作一个图，每个格子是一个节点。</li>
<li>从起点 <code>(0, 0)</code> 开始进行图遍历（BFS 或 DFS）。</li>
<li>在遍历过程中，只有当一个邻居格子与当前格子的高度差绝对值 <code>abs(h1 - h2)</code> 不超过 <code>k</code> 时，我们才认为可以移动到那个邻居。</li>
<li>如果遍历过程中能够到达终点 <code>(rows-1, columns-1)</code>，那么 <code>canReach(k)</code> 就返回 <code>True</code>，否则返回 <code>False</code>。</li>
</ul>
<p>现在我们有了一个判定方法，并且这个判定结果具有非常重要的<strong>单调性</strong>：</p>
<ul>
<li>如果一个最大体力消耗 <code>k</code> 是可行的（即存在这样的路径），那么任何大于 <code>k</code> 的体力消耗 <code>k&#39;</code> 也一定是可行的。因为允许的差值变大了，原来能走的路径现在依然能走。</li>
<li>反之，如果 <code>k</code> 是不可行的，那么任何小于 <code>k</code> 的值也必然不可行。</li>
</ul>
<p>这种单调性正是应用<strong>二分查找</strong>的完美场景。我们可以对“体力消耗值”这个答案本身进行二分查找，来快速定位到那个“最小可行”的临界点。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：最小可能的体力消耗是 0（如果存在一条路径所有格子高度都相同）。</li>
<li><strong>上界 (right)</strong>：最大可能的体力消耗是地图中的最大高度和最小高度之差，一个宽松的上界是 <code>10^6 - 1</code>。</li>
</ul>
<p>因此，我们就在 <code>[0, 10^6 - 1]</code> 这个区间内，对体力消耗值进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = 0</code>：可能的最小体力消耗。</li>
<li><code>right = 10**6</code>：可能的最高体力消耗（或更精确的 <code>max_height - min_height</code>）。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>left &lt; right</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = left + (right - left) // 2</code> 作为当前的“猜测体力消耗”。</li>
<li>调用辅助函数 <code>canReach(mid)</code> 来判定这个猜测值是否可行。<ul>
<li><strong>如果 <code>canReach(mid)</code> 返回 <code>True</code></strong>：<ul>
<li>说明体力消耗 <code>mid</code> 是可行的。但这不一定是最小的，可能还有更小的可行值。</li>
<li>因此，我们记录 <code>mid</code> 作为一个潜在的答案，并尝试在更小的范围里搜索，将搜索范围缩小到左半边：<code>right = mid</code>。</li>
</ul>
</li>
<li><strong>如果 <code>canReach(mid)</code> 返回 <code>False</code></strong>：<ul>
<li>说明体力消耗 <code>mid</code> 太小了，无法从起点走到终点。</li>
<li>我们必须允许更大的体力消耗，因此需要将搜索范围缩小到右半边：<code>left = mid + 1</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>left</code> 和 <code>right</code> 将会相遇在那个最小的可行体力消耗值上，这个值就是我们的答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumEffortPath</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        rows, cols = <span class="built_in">len</span>(heights), <span class="built_in">len</span>(heights[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判定函数：检查在 effort_limit 的限制下，是否存在一条从起点到终点的路径</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">can_reach_destination</span>(<span class="params">effort_limit: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            q = collections.deque([(<span class="number">0</span>, <span class="number">0</span>)])</span><br><span class="line">            visited = &#123;(<span class="number">0</span>, <span class="number">0</span>)&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                r, c = q.popleft()</span><br><span class="line">                <span class="keyword">if</span> r == rows - <span class="number">1</span> <span class="keyword">and</span> c == cols - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 遍历四个方向</span></span><br><span class="line">                <span class="keyword">for</span> dr, dc <span class="keyword">in</span> [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]:</span><br><span class="line">                    nr, nc = r + dr, c + dc</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= nr &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= nc &lt; cols <span class="keyword">and</span> (nr, nc) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        <span class="comment"># 只有当高度差不超过限制时，才可通行</span></span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">abs</span>(heights[nr][nc] - heights[r][c]) &lt;= effort_limit:</span><br><span class="line">                            visited.add((nr, nc))</span><br><span class="line">                            q.append((nr, nc))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对“体力消耗值”进行二分查找</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">10</span>**<span class="number">6</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> can_reach_destination(mid):</span><br><span class="line">                <span class="comment"># mid 可行，尝试更小的值</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># mid 不可行，必须增大消耗值</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(M * N * log(C))。<ul>
<li><code>M</code> 和 <code>N</code> 分别是地图的行数和列数。</li>
<li><code>C</code> 是高度差的可能范围（即 <code>10^6</code>），所以 <code>log(C)</code> 是二分查找的迭代次数。</li>
<li>在每次迭代中，我们都需要调用 <code>can_reach_destination</code> 函数，该函数执行一次 BFS，最坏情况下会访问所有 <code>M * N</code> 个格子，时间复杂度为 O(M * N)。</li>
<li>因此，总时间复杂度是这几部分的乘积。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(M * N)。<ul>
<li>空间主要消耗在 BFS 的 <code>visited</code> 集合和队列 <code>q</code> 上。在最坏情况下，它们可能需要存储地图上所有的格子。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是二分查找思想应用的绝佳范例。它完美地诠释了如何将一个求解“最优值”（最小的最大值）的复杂问题，转化为一个简单的、具有单调性的“可行性判定”问题。一旦识别出这种模式，就可以套用二分查找的框架，将一个巨大的搜索空间通过对数次判定，快速收敛到最终答案，这是一种非常强大且高效的算法思想。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>最小化最大值</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>矩阵</tag>
        <tag>堆（优先队列）</tag>
        <tag>并查集</tag>
        <tag>广度优先搜索</tag>
        <tag>深度优先搜索</tag>
        <tag>第212场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1642 | 可以到达的最远建筑</title>
    <url>//posts/leetcode-1642/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1642 题：<a href="https://leetcode.cn/problems/furthest-building-you-can-reach/description/">可以到达的最远建筑</a>。<br>本题的核心在于识别出“能否到达某个建筑”这一判定的单调性，从而将一个求解最大值的问题，巧妙地转化为一个判定性的问题，并利用二分查找高效求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要在一系列高度不同的建筑物之间移动，从第 0 个建筑出发，尽可能到达最远的建筑。我们拥有一定数量的砖块 <code>bricks</code> 和梯子 <code>ladders</code> 作为辅助工具。</p>
<p>核心的移动规则是：</p>
<ol>
<li>从建筑 <code>i</code> 到 <code>i+1</code>，如果 <code>heights[i] &gt;= heights[i+1]</code>（即向下或平着走），不需要任何工具。</li>
<li>如果 <code>heights[i] &lt; heights[i+1]</code>（即向上爬），则需要克服 <code>h[i+1] - h[i]</code> 的高度差。此时，我们可以选择使用相应数量的砖块，或者使用一架梯子。梯子可以克服任意高度差。</li>
</ol>
<p>我们的目标是在砖块和梯子的约束下，找到能到达的<strong>最远</strong>的建筑下标。</p>
<p>举个例子，<code>heights = [4,2,7,6,9,14,12]</code>, <code>bricks = 5</code>, <code>ladders = 1</code>。</p>
<ul>
<li>到达建筑 1 (高度2): 向下走，无消耗。</li>
<li>到达建筑 2 (高度7): 向上爬，高度差为 5。可以使用 5 个砖块。剩余 <code>bricks=0</code>, <code>ladders=1</code>。</li>
<li>到达建筑 3 (高度6): 向下走，无消耗。</li>
<li>到达建筑 4 (高度9): 向上爬，高度差为 3。此时砖块用完，只能使用梯子。剩余 <code>bricks=0</code>, <code>ladders=0</code>。</li>
<li>尝试到达建筑 5 (高度14): 向上爬，高度差为 5。此时砖块和梯子都已耗尽，无法继续前进。<br>因此，能到达的最远建筑是下标 4。</li>
</ul>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接计算能到达的最远距离似乎很复杂，因为在每个需要向上爬的地方，我们都要做出“用砖块还是用梯子”的决策。</p>
<p>一个更巧妙的思路是转变问题：与其直接问“最远能到哪”，不如问一个更容易判断的问题：“我们<strong>能否到达</strong>第 <code>k</code> 个建筑？”</p>
<p>这个问题相对简单。我们可以写一个辅助函数 <code>can_reach(k)</code> 来进行判断。为了判断能否到达建筑 <code>k</code>，我们需要考虑从建筑 0 到 <code>k</code> 的所有需要向上爬的路径，并以最节省的方式使用资源。显然，梯子比砖块更宝贵，因为它能应对无限高的高度差。因此，最优策略是<strong>将有限的梯子用在最高的几次攀爬上</strong>，而用砖块来应对相对较小的高度差。</p>
<p>这个判定策略具有非常重要的<strong>单调性</strong>：</p>
<ul>
<li>如果我们可以到达建筑 <code>k</code>，那么对于任何小于 <code>k</code> 的建筑 <code>j</code>，我们必然也能到达。</li>
<li>反之，如果我们无法到达建筑 <code>k</code>，那么我们也绝不可能到达任何比 <code>k</code> 更远的建筑。</li>
</ul>
<p>这种单调性是应用二分查找的完美信号。 我们可以对“建筑的下标”进行二分查找，来快速定位到那个“最远可到达”的临界点。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：<code>0</code>，即起点。</li>
<li><strong>上界 (right)</strong>：<code>len(heights) - 1</code>，即最后一个建筑。</li>
</ul>
<p>因此，我们就在 <code>[0, len(heights) - 1]</code> 这个区间内，对建筑下标进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = 0</code>：可能的最小答案。</li>
<li><code>right = len(heights) - 1</code>：可能的最大答案。</li>
<li><code>ans</code> 初始化为 <code>0</code>，用来记录我们找到的可行解。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>left &lt;= right</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = left + (right - left) // 2</code> 作为当前的“猜测能到达的建筑下标”。</li>
<li>调用辅助函数 <code>check(mid)</code> 来判定这个猜测值是否可行。<ul>
<li><strong><code>check(mid)</code> 的内部逻辑</strong>：<ol>
<li>收集从建筑 0 到 <code>mid</code> 之间所有需要向上爬的高度差，存入列表 <code>climbs</code>。</li>
<li>如果 <code>climbs</code> 的数量小于等于 <code>ladders</code>，说明所有攀爬都可以用梯子解决，返回 <code>True</code>。</li>
<li>否则，对 <code>climbs</code> 进行排序。我们将梯子用于 <code>ladders</code> 个最大的高度差。</li>
<li>计算剩下较小的高度差之和，即为需要的砖块数。</li>
<li>如果所需砖块数不大于我们拥有的 <code>bricks</code>，返回 <code>True</code>；否则返回 <code>False</code>。</li>
</ol>
</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>True</code></strong>：<ul>
<li>说明 <code>mid</code> 是一个可以到达的位置，我们记录下来 <code>ans = mid</code>。</li>
<li>既然 <code>mid</code> 可以到达，我们应该尝试走得更远，将搜索范围缩小到右半边：<code>left = mid + 1</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>False</code></strong>：<ul>
<li>说明 <code>mid</code> 到不了，那更远的地方也肯定到不了。我们将搜索范围缩小到左半边：<code>right = mid - 1</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>ans</code> 中存储的就是能到达的最远建筑物的下标。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">furthestBuilding</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>], bricks: <span class="built_in">int</span>, ladders: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(heights)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 辅助函数：检查是否能到达第 k 个建筑</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 收集从 0 到 k 需要攀爬的高度差</span></span><br><span class="line">            climbs = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                diff = heights[i+<span class="number">1</span>] - heights[i]</span><br><span class="line">                <span class="keyword">if</span> diff &gt; <span class="number">0</span>:</span><br><span class="line">                    climbs.append(diff)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果攀爬次数不多于梯子数，肯定可以到达</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(climbs) &lt;= ladders:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 对高度差进行排序，优先用梯子处理最大的几次攀爬</span></span><br><span class="line">            climbs.sort()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 剩下的攀爬需要用砖块</span></span><br><span class="line">            <span class="comment"># 我们需要为最小的 len(climbs) - ladders 次攀爬提供砖块</span></span><br><span class="line">            bricks_needed = <span class="built_in">sum</span>(climbs[:<span class="built_in">len</span>(climbs) - ladders])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> bricks_needed &lt;= bricks</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找最远的 k</span></span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 可以到达，它就是一个潜在的答案</span></span><br><span class="line">                <span class="comment"># 我们继续向右搜索，看能否走得更远</span></span><br><span class="line">                ans = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 无法到达，说明目标太远了，需要向左搜索</span></span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N * log(N) * log(N))。<ul>
<li><code>N</code> 是建筑物数组 <code>heights</code> 的长度。</li>
<li>二分查找本身需要 <code>log(N)</code> 次迭代。</li>
<li>在每次迭代中，我们调用 <code>check(mid)</code> 函数。该函数内部：<ul>
<li>遍历 <code>mid</code> 次来收集高度差，时间为 O(mid)。</li>
<li>对最多 <code>mid</code> 个高度差进行排序，时间为 O(mid * log(mid))。</li>
</ul>
</li>
<li>因此，<code>check(mid)</code> 的时间复杂度由排序主导，为 O(mid * log(mid))。</li>
<li>总时间复杂度近似为 <code>log(N)</code> 乘以 <code>check</code> 函数在 <code>mid</code> 接近 <code>N</code> 时的复杂度，即 O(log(N) * N * log(N))。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(N)。<ul>
<li>在 <code>check</code> 函数中，我们需要一个列表来存储所有的高度差，其大小最多为 <code>N-1</code>。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“二分答案”这一经典算法模式的绝佳体现。 当遇到求解“最大值”或“最小值”这类优化问题时，如果可以直接判断某个潜在答案是否可行，并且这个可行性判断具有单调性，那么就可以考虑使用二分查找。 这种方法将复杂的求解问题转化为一系列简单的判定问题，从而大幅优化算法效率，是一种非常强大和常用的解题技巧。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最大</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>贪心</tag>
        <tag>堆（优先队列）</tag>
        <tag>第213场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1648 | 销售价值减少的颜色球</title>
    <url>//posts/leetcode-1648/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1648 题：<a href="https://leetcode.cn/problems/sell-diminishing-valued-colored-balls/description/">销售价值减少的颜色球</a>。<br>本题的核心在于如何高效处理大规模订单下的贪心策略。通过观察答案的单调性，我们可以将一个求解最大利润的问题，转化为一个判定性的问题（某个价值阈值是否可行），从而利用二分查找在对数时间内锁定最优解的范围。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们有一批库存，包含多种颜色的球。顾客要购买 <code>orders</code> 个球。这道题的特别之处在于球的价值计算方式：一个球的价值等于<strong>卖出它之前</strong>，库存中同色球的数量。这意味着，如果我们有 10 个红球，卖掉第一个红球价值 10，第二个价值 9，以此类推。</p>
<p>我们的目标是制定一个销售策略，来最大化卖出 <code>orders</code> 个球的总价值。</p>
<p>这个问题的贪心思路非常直观：<strong>在任何时候，我们都应该选择当前价值最高的球来卖</strong>。价值最高的球，就是来自当前库存数量最多的那种颜色的球。</p>
<p>例如，库存是 <code>[2, 5]</code>，要卖 4 个。</p>
<ol>
<li>当前库存最多的是 5 个球的那种，价值为 5。卖一个，库存变为 <code>[2, 4]</code>，总价值 5。</li>
<li>现在库存最多的是 4 个球的那种，价值为 4。卖一个，库存变为 <code>[2, 3]</code>，总价值 5 + 4 &#x3D; 9。</li>
<li>现在库存最多的是 3 个球的那种，价值为 3。卖一个，库存变为 <code>[2, 2]</code>，总价值 9 + 3 &#x3D; 12。</li>
<li>现在两种球都剩 2 个，价值都是 2。随便卖一个，库存变为 <code>[1, 2]</code>，总价值 12 + 2 &#x3D; 14。</li>
</ol>
<p>这个过程如果用一个最大堆（Priority Queue）来模拟，每次取出最大值，减一后再放回去，重复 <code>orders</code> 次。但题目的数据范围 <code>orders</code> 可以达到 10^9，O(orders * logN) 的复杂度显然会超时。我们需要更高效的方法。</p>
<h3 id="核心思路：将“贪心求解”转化为“二分答案”"><a href="#核心思路：将“贪心求解”转化为“二分答案”" class="headerlink" title="核心思路：将“贪心求解”转化为“二分答案”"></a>核心思路：将“贪心求解”转化为“二分答案”</h3><p>既然逐个销售太慢，我们可以考虑“成批”销售。观察贪心过程，我们总是在卖光所有价值为 <code>v</code> 的球之后，才开始卖价值为 <code>v-1</code> 的球。这启发我们，一定存在一个“价值阈值” <code>k</code>，我们的销售策略是：</p>
<ol>
<li>把所有价值 <strong>大于</strong> <code>k</code> 的球全部卖掉。</li>
<li>再卖掉一部分价值 <strong>等于</strong> <code>k</code> 的球，直到满足 <code>orders</code> 的数量要求。</li>
</ol>
<p>这个价值阈值 <code>k</code> 是解题的关键。如果我们能快速找到它，问题就迎刃而解。</p>
<p>这个阈值 <code>k</code> 具有单调性：</p>
<ul>
<li>我们设定的阈值 <code>k</code> 越高，意味着我们只卖价值非常高的球，卖出的球的总数就越少。</li>
<li>反之，阈值 <code>k</code> 越低，卖出的球的总数就越多。</li>
</ul>
<p>卖出球的数量是关于阈值 <code>k</code> 的单调递减函数。这种单调性正是二分查找的绝佳应用场景。我们可以对这个“价值阈值 <code>k</code>”进行二分查找。</p>
<p>我们的目标是找到一个临界值 <code>k</code>，使得所有价值 &gt; <code>k</code> 的球加起来的数量，刚好小于 <code>orders</code>，而所有价值 &gt; <code>k-1</code> 的球加起来的数量，则会大于等于 <code>orders</code>。</p>
<p>这个 <code>k</code> 就是我们最后卖出的那批球的价值。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = 0</code>：价值阈值的下限。</li>
<li><code>right = max(inventory)</code>：价值阈值的上限，不可能超过初始最多的球数。</li>
</ul>
</li>
<li><p><strong>定义判定函数 <code>count_balls(k)</code></strong></p>
<ul>
<li>这个函数用于计算：如果我们将阈值设为 <code>k</code>，即所有价值严格大于 <code>k</code> 的球都卖掉，总共能卖出多少个球。</li>
<li>实现很简单，遍历 <code>inventory</code>，对于每个库存 <code>inv</code>，如果 <code>inv &gt; k</code>，则可以卖出 <code>inv - k</code> 个球。将这些数量求和即可。</li>
<li><code>count_balls(k) = sum(max(0, inv - k) for inv in inventory)</code></li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>left &lt;= right</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = left + (right - left) // 2</code> 作为当前的“猜测阈值”。</li>
<li>调用 <code>count_balls(mid)</code> 来判定：<ul>
<li><strong>如果 <code>count_balls(mid) &gt;= orders</code></strong>：说明把所有价值 &gt; <code>mid</code> 的球都卖掉，数量已经足够或超额了。这意味着我们最终的阈值 <code>k</code> 应该<strong>不低于</strong> <code>mid</code>。所以，我们尝试一个更高的阈值，<code>left = mid + 1</code>。</li>
<li><strong>如果 <code>count_balls(mid) &lt; orders</code></strong>：说明即使把所有价值 &gt; <code>mid</code> 的球都卖掉，数量仍然不够 <code>orders</code>。这意味着我们的阈值设得太高了，必须降低才能卖出更多的球。所以，<code>right = mid - 1</code>。</li>
</ul>
</li>
<li>循环结束后，<code>right</code> (或者 <code>left-1</code>) 就是我们苦苦寻找的那个临界阈值 <code>k</code>。</li>
</ul>
</li>
<li><p><strong>计算总价值</strong></p>
<ul>
<li>找到阈值 <code>k</code> 后，总利润的计算分为两部分：</li>
<li><strong>第一部分：价值 &gt; k 的球</strong><ul>
<li>遍历 <code>inventory</code>，对于每个 <code>inv &gt; k</code> 的库存，我们卖掉了从 <code>inv</code> 到 <code>k+1</code> 的所有球。这是一个等差数列求和。</li>
<li>卖出的数量是 <code>count = inv - k</code>。</li>
<li>价值总和是 <code>(inv + k + 1) * count / 2</code>。</li>
<li>我们将这部分的利润和卖出的球数累加起来。</li>
</ul>
</li>
<li><strong>第二部分：价值 &#x3D; k 的球</strong><ul>
<li>用总订单数 <code>orders</code> 减去第一部分卖出的球数，得到还需要卖多少个球，我们称之为 <code>remaining_orders</code>。</li>
<li>这 <code>remaining_orders</code> 个球的价值都是 <code>k</code>。</li>
<li>所以这部分的利润是 <code>remaining_orders * k</code>。</li>
</ul>
</li>
<li>将两部分利润相加，就是最终答案。注意，在计算过程中要时刻对 <code>10^9 + 7</code> 取余，防止整数溢出。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, inventory: <span class="type">List</span>[<span class="built_in">int</span>], orders: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 辅助函数：计算如果所有价值 &gt; k 的球都卖掉，能卖出多少个</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">count_balls</span>(<span class="params">k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> inv <span class="keyword">in</span> inventory:</span><br><span class="line">                <span class="keyword">if</span> inv &gt; k:</span><br><span class="line">                    count += (inv - k)</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找寻找价值阈值 k</span></span><br><span class="line">        <span class="comment"># k 是我们最终售出的球中，价值最低的那个球的价值</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">max</span>(inventory)</span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span>: <span class="comment"># 避免 mid-1 出现负数</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果把价值 &gt; mid-1 的球都卖了，数量还不够 orders</span></span><br><span class="line">            <span class="comment"># 说明阈值太高了，需要降低</span></span><br><span class="line">            <span class="keyword">if</span> count_balls(mid - <span class="number">1</span>) &lt; orders:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 否则，mid 可能就是我们的阈值 k，或者 k 更大</span></span><br><span class="line">                <span class="comment"># 我们希望 k 尽可能大，以获得更高利润</span></span><br><span class="line">                k = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算总利润</span></span><br><span class="line">        total_profit = <span class="number">0</span></span><br><span class="line">        orders_sold = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一部分：计算所有价值 &gt; k 的球带来的利润</span></span><br><span class="line">        <span class="keyword">for</span> inv <span class="keyword">in</span> inventory:</span><br><span class="line">            <span class="keyword">if</span> inv &gt; k:</span><br><span class="line">                <span class="comment"># 卖出从 inv 到 k+1 的所有球</span></span><br><span class="line">                num_balls = inv - k</span><br><span class="line">                orders_sold += num_balls</span><br><span class="line">                <span class="comment"># 等差数列求和公式: (首项 + 末项) * 项数 / 2</span></span><br><span class="line">                profit = (inv + k + <span class="number">1</span>) * num_balls // <span class="number">2</span></span><br><span class="line">                total_profit = (total_profit + profit) % MOD</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第二部分：卖出剩余的球，它们的价值都是 k</span></span><br><span class="line">        remaining_orders = orders - orders_sold</span><br><span class="line">        total_profit = (total_profit + remaining_orders * k) % MOD</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> total_profit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N * log(M))。<ul>
<li><code>N</code> 是库存数组 <code>inventory</code> 的长度。</li>
<li><code>M</code> 是 <code>inventory</code> 中的最大值，即二分查找的搜索空间大小。</li>
<li>二分查找本身需要 <code>log(M)</code> 次迭代。</li>
<li>在每次迭代中，我们都需要调用 <code>count_balls</code> 函数，该函数需要遍历一次 <code>inventory</code> 数组，时间复杂度为 O(N)。</li>
<li>因此，总时间复杂度是这两者的乘积。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)。<ul>
<li>除了输入数组外，我们只使用了几个变量来存储左右边界、中间值和计算过程中的状态，所以空间复杂度是常数级的。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“二分答案”思想的经典应用。当直接求解一个最优值（如本题的最大利润）很困难，但验证一个给定的答案（“如果最终卖出的最低价值是k，能否满足条件？”）相对容易时，就可以考虑使用二分查找。如果验证函数具有单调性，我们就能将求解问题转化为判定问题，通过不断缩小答案的搜索范围，在对数级别的时间复杂度内找到最优解，这对于处理大规模数据至关重要。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>二分间接值</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>数学</tag>
        <tag>堆（优先队列）</tag>
        <tag>第214场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1658 | 逆向思维+滑动窗口求解“将 x 减到 0 的最小操作数”</title>
    <url>//posts/leetcode-1658/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1658 题：<a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/">将 x 减到 0 的最小操作数</a>。<br>这道题看似复杂，因为它允许从数组的两端进行操作。但只要我们转换一下思路，它就会变成一个非常经典的滑动窗口问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目要求我们从一个整数数组 <code>nums</code> 的最左边或最右边移除元素，每次移除一个元素，它的值就从 <code>x</code> 中减去。目标是用<strong>最少的操作次数</strong>将 <code>x</code> 恰好减到 0。</p>
<p>我们来分析一下这个操作：</p>
<ul>
<li>可以只从左边移除</li>
<li>可以只从右边移除</li>
<li>可以两边都移除</li>
</ul>
<p>例如，对于 <code>nums = [1,1,4,2,3], x = 5</code>：</p>
<ul>
<li>我们可以从左边移除 <code>1</code> 和 <code>1</code>，再从右边移除 <code>3</code>，总和为 <code>1+1+3=5</code>，操作 3 次。</li>
<li>我们也可以直接从右边移除 <code>3</code> 和 <code>2</code>，总和为 <code>3+2=5</code>，操作 2 次。</li>
</ul>
<p>因为 <code>2 &lt; 3</code>，所以最小操作数是 2。</p>
<p>直接模拟所有“左边取 i 个，右边取 j 个”的组合会非常低效。我们需要找到一个更优雅的切入点。</p>
<h3 id="核心思路：逆向思维与问题转化"><a href="#核心思路：逆向思维与问题转化" class="headerlink" title="核心思路：逆向思维与问题转化"></a>核心思路：逆向思维与问题转化</h3><p>直接求解“两端移除的最小元素数量”比较困难，那我们不妨换个角度思考：<strong>当我们从两端移除一部分元素后，剩下的是什么？</strong></p>
<p>答案是：<strong>一个连续的、位于数组中间的子数组。</strong></p>
<p>我们的目标是让移除的元素之和恰好为 <code>x</code>，并且移除的元素数量最少。这等价于什么呢？</p>
<p><strong>让保留在中间的子数组最长！</strong></p>
<p>如果数组的总和是 <code>total_sum</code>，要移除的元素之和是 <code>x</code>，那么保留在中间的那个连续子数组，其元素之和就必须是 <code>target = total_sum - x</code>。</p>
<p>这样一来，原问题就被我们巧妙地转化成了另一个问题：<br><strong>在数组 <code>nums</code> 中，找到一个和为 <code>total_sum - x</code> 的最长的连续子数组。</strong></p>
<p>只要我们找到了这个最长的子数组，用数组的总长度 <code>n</code> 减去这个子数组的长度，就是我们要求的“最小操作数”。</p>
<p>而“寻找和为定值的最长连续子数组”正是一个可以用滑动窗口高效解决的经典问题！</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>问题转化</strong>:</p>
<ul>
<li>首先计算整个数组的总和 <code>total_sum</code>。</li>
<li>计算出我们要在中间寻找的目标子数组的和 <code>target = total_sum - x</code>。</li>
<li>处理一些边界情况：<ul>
<li>如果 <code>target &lt; 0</code>，说明 <code>x</code> 本身就比数组所有元素之和还大，不可能凑成，返回 <code>-1</code>。</li>
<li>如果 <code>target == 0</code>，说明需要移除所有元素才能使 <code>x</code> 减到 0，此时最长的中间子数组为空，但我们需要移除所有元素，答案是数组长度 <code>n</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>滑动窗口求解</strong>:</p>
<ul>
<li>现在，我们在数组 <code>nums</code> 上寻找和为 <code>target</code> 的最长连续子数组。</li>
<li>初始化左指针 <code>left = 0</code>，当前窗口内元素的和 <code>current_sum = 0</code>，以及记录最长长度的 <code>max_len = -1</code>（-1 表示尚未找到）。</li>
<li>使用右指针 <code>right</code> 遍历数组，<code>right</code> 每向右移动一步，就将 <code>nums[right]</code> 加入 <code>current_sum</code>，这代表窗口在向右扩张。</li>
<li>当 <code>current_sum &gt; target</code> 时，说明当前窗口的和太大了，需要缩小。我们让 <code>left</code> 指针向右移动，并从 <code>current_sum</code> 中减去 <code>nums[left]</code>，直到 <code>current_sum &lt;= target</code>。</li>
<li>在每一步扩张或收缩后，如果 <code>current_sum == target</code>，我们就找到了一个符合条件的子数组。计算其长度 <code>right - left + 1</code>，并更新 <code>max_len</code>。</li>
</ul>
</li>
<li><p><strong>计算最终结果</strong>:</p>
<ul>
<li>遍历结束后，如果 <code>max_len</code> 仍然是 <code>-1</code>，说明数组中不存在和为 <code>target</code> 的子数组，即无法通过移除操作使 <code>x</code> 减到 0，返回 <code>-1</code>。</li>
<li>否则，最小操作数就是 <code>n - max_len</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        total_sum = <span class="built_in">sum</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1: 问题转化，计算目标和</span></span><br><span class="line">        target = total_sum - x</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 边界情况：x 大于数组总和，无解</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 边界情况：需要移除所有元素</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2: 滑动窗口寻找和为 target 的最长子数组</span></span><br><span class="line">        max_len = -<span class="number">1</span>  <span class="comment"># 记录最长子数组的长度</span></span><br><span class="line">        current_sum = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span>  <span class="comment"># 窗口左边界</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 窗口右边界扩张</span></span><br><span class="line">            current_sum += nums[right]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当窗口和大于 target 时，收缩左边界</span></span><br><span class="line">            <span class="keyword">while</span> current_sum &gt; target <span class="keyword">and</span> left &lt;= right:</span><br><span class="line">                current_sum -= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果窗口和等于 target，更新最大长度</span></span><br><span class="line">            <span class="keyword">if</span> current_sum == target:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 3: 计算最终结果</span></span><br><span class="line">        <span class="comment"># 如果 max_len 未被更新，说明找不到满足条件的子数组</span></span><br><span class="line">        <span class="keyword">if</span> max_len == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> n - max_len</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是数组 <code>nums</code> 的长度。滑动窗口的左、右指针 <code>left</code> 和 <code>right</code> 都只会从头到尾遍历数组一次，因此总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个额外变量（如 <code>left</code>, <code>right</code>, <code>current_sum</code> 等），没有使用额外的数据结构。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题的核心在于<strong>逆向思维</strong>。当我们面对一个从两端操作、看似复杂的问题时，不妨思考一下操作的“补集”是什么。通过将“求两端最小移除数”转化为“求中间最长保留数”，问题瞬间豁然开朗，变成了一个我们非常熟悉的滑动窗口模板题。这个思路在很多算法题中都非常有效，是工具箱中必备的思维技巧。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>前缀和</tag>
        <tag>第215场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1763 | 滑动窗口求解“最长的美好子字符串”</title>
    <url>//posts/leetcode-1763/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1763 题：<a href="https://leetcode.cn/problems/longest-nice-substring/description/">最长的美好子字符串</a>。<br>该题要求在字符串中寻找一个最长的子串且其中每个字母大小写必须同时存在。直接枚举所有子串的复杂度较高，我们可以通过枚举子串的“属性”，将问题转化为滑动窗口来高效求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目定义了一个“美好字符串”：对于字符串中出现的任意一种字母，它的大写和小写形式必须同时存在。例如 <code>&quot;aAa&quot;</code> 是美好的，因为 <code>&#39;a&#39;</code> 和 <code>&#39;A&#39;</code> 都出现了。而 <code>&quot;abA&quot;</code> 不是美好的，因为 <code>&#39;b&#39;</code> 出现了但 <code>&#39;B&#39;</code> 没有。</p>
<p>我们的任务是，给定一个字符串 <code>s</code>，找到它最长的一个“美好子字符串”。如果长度相同，返回最先出现的那一个。</p>
<p>直接用暴力法（枚举所有子串 <code>s[i:j]</code> 并逐一检查）的时间复杂度会达到 O(N³)，对于 <code>N=100</code> 的限制虽然可行，但不够优雅。我们可以构思一个更高效的算法。</p>
<h3 id="核心思路：枚举字符类型的滑动窗口"><a href="#核心思路：枚举字符类型的滑动窗口" class="headerlink" title="核心思路：枚举字符类型的滑动窗口"></a>核心思路：枚举字符类型的滑动窗口</h3><p>一个常规的滑动窗口通常依赖于一个单调的性质（比如窗口内不同字符数不超过 <code>k</code>）。但“美好”这个性质并非单调的：给一个美好的子串 <code>&quot;aA&quot;</code> 添加一个字符 <code>&#39;b&#39;</code> 会使其变得不美好；给一个不美好的子串 <code>&quot;aAb&quot;</code> 添加 <code>&#39;B&#39;</code> 又可能使其变得美好。</p>
<p>这种性质的复杂性让我们很难用一个简单的规则来收缩窗口。此时，一个高级的技巧是**“枚举窗口属性”<strong>。与其让窗口自己寻找满足复杂条件的子串，不如我们</strong>指定窗口应该满足的某个简单属性**，然后用滑动窗口来寻找符合这个简单属性的最优解。</p>
<p>在这里，我们可以枚举美好子串中<strong>包含的唯一字母类型的数量</strong>，设为 <code>k</code>（例如，<code>&quot;aAZ&quot;</code> 包含 <code>&#39;a&#39;/&#39;A&#39;</code> 和 <code>&#39;z&#39;/&#39;Z&#39;</code> 两种类型，所以 <code>k=2</code>）。<code>k</code> 的取值范围是 1 到 26。</p>
<p>对于每一个固定的 <code>k</code>，问题就转化为：<strong>寻找一个最长的子字符串，它恰好包含 <code>k</code> 种字母类型，并且这 <code>k</code> 种类型都是“美好”的（即大小写齐全）。</strong></p>
<p>这个问题就非常适合用滑动窗口来解决了。窗口需要维护两个核心信息：</p>
<ol>
<li>当前窗口内有多少种唯一字母类型。</li>
<li>这其中，有多少种是“美好”的。</li>
</ol>
<p>当两个计数器都等于我们正在枚举的 <code>k</code> 时，就意味着我们找到了一个候选的子字符串。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>外层循环</strong>：我们用一个循环来枚举唯一字母类型的数量 <code>k</code>，从 1 遍历到 26。</p>
</li>
<li><p><strong>内层滑动窗口</strong>：对于每个 <code>k</code>，我们执行一次完整的滑动窗口遍历。</p>
<ul>
<li><strong>状态维护</strong>：我们需要 <code>lower_count</code> 和 <code>upper_count</code> 两个数组来记录窗口内26个字母大小写的频率。此外，还需要两个计数器：<code>unique_types</code> 记录窗口内唯一字母类型的总数，<code>nice_types</code> 记录大小写都存在的字母类型数。</li>
<li><strong>扩张窗口</strong>：<code>right</code> 指针向右移动，将新字符 <code>s[right]</code> 纳入窗口。相应地更新 <code>lower/upper_count</code> 数组，并根据新字符的加入，判断 <code>unique_types</code> 和 <code>nice_types</code> 是否需要增加。</li>
<li><strong>收缩窗口</strong>：扩张后，如果 <code>unique_types &gt; k</code>，说明当前窗口包含的字母类型太多了，不符合我们对 <code>k</code> 的设定。此时需要移动 <code>left</code> 指针向右，从窗口中移除 <code>s[left]</code>，并同步更新 <code>lower/upper_count</code> 和两个计数器。这个过程一直持续到 <code>unique_types &lt;= k</code> 为止。</li>
<li><strong>更新答案</strong>：当窗口收缩完毕后（也可能无需收缩），我们检查是否满足 <code>unique_types == k</code> 并且 <code>nice_types == k</code>。如果满足，说明当前窗口 <code>s[left:right+1]</code> 就是一个恰好包含 <code>k</code> 种美好字母类型的子串。我们用它的长度来更新全局的最大长度和起始位置。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：外层循环结束后，记录下的最长长度和起始位置对应的子串即为最终答案。</p>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestNiceSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        result_start = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># k: 枚举窗口中唯一字母类型的数量</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">27</span>):</span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            lower_count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            upper_count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            unique_types = <span class="number">0</span></span><br><span class="line">            nice_types = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># --- 1. 右指针扩张窗口 ---</span></span><br><span class="line">                char_r = s[right]</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> &lt;= char_r &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">                    idx = <span class="built_in">ord</span>(char_r) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                    <span class="keyword">if</span> lower_count[idx] == <span class="number">0</span> <span class="keyword">and</span> upper_count[idx] == <span class="number">0</span>:</span><br><span class="line">                        unique_types += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> lower_count[idx] == <span class="number">0</span> <span class="keyword">and</span> upper_count[idx] &gt; <span class="number">0</span>:</span><br><span class="line">                        nice_types += <span class="number">1</span></span><br><span class="line">                    lower_count[idx] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 大写字母</span></span><br><span class="line">                    idx = <span class="built_in">ord</span>(char_r) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                    <span class="keyword">if</span> lower_count[idx] == <span class="number">0</span> <span class="keyword">and</span> upper_count[idx] == <span class="number">0</span>:</span><br><span class="line">                        unique_types += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> upper_count[idx] == <span class="number">0</span> <span class="keyword">and</span> lower_count[idx] &gt; <span class="number">0</span>:</span><br><span class="line">                        nice_types += <span class="number">1</span></span><br><span class="line">                    upper_count[idx] += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># --- 2. 左指针收缩窗口 ---</span></span><br><span class="line">                <span class="keyword">while</span> unique_types &gt; k:</span><br><span class="line">                    char_l = s[left]</span><br><span class="line">                    <span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> &lt;= char_l &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">                        idx = <span class="built_in">ord</span>(char_l) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                        lower_count[idx] -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> lower_count[idx] == <span class="number">0</span> <span class="keyword">and</span> upper_count[idx] &gt; <span class="number">0</span>:</span><br><span class="line">                            nice_types -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> lower_count[idx] == <span class="number">0</span> <span class="keyword">and</span> upper_count[idx] == <span class="number">0</span>:</span><br><span class="line">                            unique_types -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>: <span class="comment"># 大写字母</span></span><br><span class="line">                        idx = <span class="built_in">ord</span>(char_l) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                        upper_count[idx] -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> upper_count[idx] == <span class="number">0</span> <span class="keyword">and</span> lower_count[idx] &gt; <span class="number">0</span>:</span><br><span class="line">                            nice_types -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> lower_count[idx] == <span class="number">0</span> <span class="keyword">and</span> upper_count[idx] == <span class="number">0</span>:</span><br><span class="line">                            unique_types -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># --- 3. 更新结果 ---</span></span><br><span class="line">                <span class="keyword">if</span> unique_types == k <span class="keyword">and</span> nice_types == k:</span><br><span class="line">                    current_len = right - left + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> current_len &gt; max_len:</span><br><span class="line">                        max_len = current_len</span><br><span class="line">                        result_start = left</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> max_len == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> s[result_start : result_start + max_len]</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(C * N)，其中 C 是字符集的大小（这里是 26），N 是字符串 <code>s</code> 的长度。外层循环固定为 26 次，内部的滑动窗口逻辑中，<code>left</code> 和 <code>right</code> 指针都只遍历一次字符串。因此，总时间复杂度为 O(N)。</li>
<li><strong>空间复杂度</strong>: O(C)。我们使用了几个固定大小的数组（<code>lower_count</code>, <code>upper_count</code>）来存储状态，空间是常数级别的。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口技巧的一个精彩应用。当窗口需要满足的条件比较复杂、不单调时，可以尝试**“升维”**的思路：通过枚举窗口的某个关键属性（本题中是唯一字母类型的数量），将一个复杂问题分解为一系列具有更清晰约束的简单子问题，然后逐一用滑动窗口求解。这种“分类讨论 + 滑动窗口”的模式是解决困难字符串问题的一个有力武器。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>位运算</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>分治</tag>
        <tag>第46场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1802 | 有界数组中指定下标处的最大值</title>
    <url>//posts/leetcode-1802/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1802 题：<a href="https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/">有界数组中指定下标处的最大值</a>。<br>本题的核心在于识别出答案的单调性，将一个求解“最大值”的问题，巧妙地转化为一个“可行性判定”的问题，从而利用二分查找在对数时间内高效求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要根据给定的三个正整数 <code>n</code>、<code>index</code> 和 <code>maxSum</code>，构造一个数组 <code>nums</code>，并找到 <code>nums[index]</code> 可能的最大值。</p>
<p>这个构造过程需要满足以下几个核心约束条件：</p>
<ol>
<li>数组长度为 <code>n</code>。</li>
<li>数组中的每个元素 <code>nums[i]</code> 都必须是正整数（即 <code>nums[i] &gt;= 1</code>）。</li>
<li>相邻元素之差的绝对值不能超过 1，即 <code>abs(nums[i] - nums[i+1]) &lt;= 1</code>。</li>
<li>数组所有元素的总和不能超过 <code>maxSum</code>。</li>
<li>在满足以上所有条件的前提下，让 <code>nums[index]</code> 的值尽可能大。</li>
</ol>
<p>我们的目标就是找出这个被最大化的 <code>nums[index]</code>。</p>
<p>这个问题的有趣之处在于第三个条件 <code>abs(nums[i] - nums[i+1]) &lt;= 1</code>。为了在总和 <code>maxSum</code> 的限制下尽可能地增大 <code>nums[index]</code> 的值，我们直觉上应该让其他位置的元素尽可能小。这个约束意味着，数组的值会以 <code>index</code> 为中心，向两侧逐渐递减，每次最多减 1，直到减至 1 为止，形成一个“山峰”形状。例如，如果 <code>nums[index] = 3</code>，它旁边的元素最大只能是 2 或 3，为了总和最小，我们选择 2，再旁边就是 1，之后的元素都会保持为 1。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接计算出 <code>nums[index]</code> 的最大值非常困难。但是，我们可以换一个角度思考：如果我们<strong>假设</strong> <code>nums[index]</code> 的值是一个具体的数 <code>v</code>，我们能否判断出是否存在一个满足所有条件的数组？</p>
<p>这个问题就相对简单了。我们可以编写一个辅助函数 <code>check(v)</code>，来判断当 <code>nums[index] = v</code> 时，构造出的数组其<em>最小可能总和</em>是否会超过 <code>maxSum</code>。</p>
<ul>
<li>为了使总和最小，以 <code>nums[index] = v</code> 为峰值，数组其他元素向两侧依次递减 1，直到达到 1 为止。</li>
<li>剩下的所有位置都用 1 填充。</li>
<li>我们计算出这个“山峰”数组的总和。如果这个最小总和不大于 <code>maxSum</code>，那就说明 <code>v</code> 是一个<strong>可行</strong>的值。</li>
</ul>
<p>现在，我们有了一个判定的方法。我们可以观察到这个判定结果具有<strong>单调性</strong>：</p>
<ul>
<li>如果 <code>nums[index]</code> 取值为 <code>v</code> 时是可行的（即最小总和 <code>≤ maxSum</code>），那么任何小于 <code>v</code> 的值 <code>v&#39;</code> 也一定是可行的，因为 <code>v&#39;</code> 对应的最小总和只会更小。</li>
<li>反之，如果 <code>v</code> 是不可行的（最小总和 <code>&gt; maxSum</code>），那么任何大于 <code>v</code> 的值也必然不可行。</li>
</ul>
<p>这种单调性是应用二分查找的绝佳信号。我们可以对 <code>nums[index]</code> 的可能取值进行二分查找，来快速定位到那个“最大可行”的临界点。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：数组中每个元素至少为 1，所以 <code>nums[index]</code> 的最小值是 <code>1</code>。</li>
<li><strong>上界 (right)</strong>：在最极端的情况下，<code>nums[index]</code> 的值也不会超过 <code>maxSum</code>，所以上界可以设为 <code>maxSum</code>。</li>
</ul>
<p>因此，我们就在 <code>[1, maxSum]</code> 这个区间内，对 <code>nums[index]</code> 的值进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = 1</code>：<code>nums[index]</code> 可能的最小值。</li>
<li><code>right = maxSum</code>：<code>nums[index]</code> 可能的最大值。</li>
<li><code>ans</code> 用来记录我们找到的可行解。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>left &lt;= right</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = left + (right - left) // 2</code> 作为当前的“猜测值”。</li>
<li>调用辅助函数 <code>check(mid)</code> 来判定这个猜测值是否可行。该函数计算当 <code>nums[index] = mid</code> 时，数组的最小总和。<ul>
<li><strong>如果 <code>check(mid)</code> 返回 <code>True</code></strong> (即最小总和 <code>≤ maxSum</code>)：<ul>
<li>说明 <code>mid</code> 是一个潜在的答案，我们记录下来 <code>ans = mid</code>。</li>
<li>但是我们想找的是“最大”的值，所以我们尝试一个更大的值，将搜索范围缩小到右半边：<code>left = mid + 1</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>False</code></strong> (即最小总和 <code>&gt; maxSum</code>)：<ul>
<li>说明 <code>mid</code> 这个值太大了，我们需要更小的值，将搜索范围缩小到左半边：<code>right = mid - 1</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>ans</code> 中存储的就是满足条件的最大值。</li>
</ul>
</li>
</ol>
<h4 id="check-v-函数的实现细节"><a href="#check-v-函数的实现细节" class="headerlink" title="check(v) 函数的实现细节"></a><code>check(v)</code> 函数的实现细节</h4><p>为了计算当 <code>nums[index] = v</code> 时的最小和，我们可以分别计算 <code>index</code> 左侧和右侧的和，最后再加上 <code>v</code> 本身（注意避免重复计算）。</p>
<ul>
<li><strong>左侧部分</strong>（从 <code>0</code> 到 <code>index</code>，共 <code>index + 1</code> 个元素）：<ul>
<li>如果峰值 <code>v</code> 大于左侧长度 <code>index + 1</code>，则数组形态为 <code>[v-index, ..., v-1, v]</code>，这是一个等差数列。</li>
<li>如果峰值 <code>v</code> 小于等于左侧长度，则数组形态为 <code>[1, ..., 1, 2, ..., v]</code>，它由 <code>(index + 1) - v</code> 个 1 和一个从 1 到 <code>v</code> 的等差数列组成。</li>
</ul>
</li>
<li><strong>右侧部分</strong>（从 <code>index</code> 到 <code>n-1</code>，共 <code>n - index</code> 个元素）：<ul>
<li>逻辑与左侧类似，根据 <code>v</code> 和右侧长度 <code>n - index</code> 的大小关系来计算。</li>
</ul>
</li>
</ul>
<p>最后将左侧和与右侧和相加，并减去被重复计算的峰值 <code>v</code>，即可得到整个数组的最小总和。</p>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxValue</span>(<span class="params">self, n: <span class="built_in">int</span>, index: <span class="built_in">int</span>, maxSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用二分查找来寻找 nums[index] 的最大可能值。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">v: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            辅助函数，用于检查当 nums[index] = v 时，</span></span><br><span class="line"><span class="string">            构造出的数组其最小和是否小于等于 maxSum。</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># 左侧部分（从 0 到 index）的长度和最小和</span></span><br><span class="line">            left_len = index + <span class="number">1</span></span><br><span class="line">            left_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> v &gt; left_len:</span><br><span class="line">                <span class="comment"># 数组形态为 [v-index, ..., v-1, v]</span></span><br><span class="line">                <span class="comment"># 等差数列求和：(首项 + 末项) * 项数 / 2</span></span><br><span class="line">                left_sum = (v + v - index) * left_len // <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 数组形态为 [1, ..., 1, 2, ..., v]</span></span><br><span class="line">                <span class="comment"># 1到v的和 + 剩余的1</span></span><br><span class="line">                left_sum = v * (v + <span class="number">1</span>) // <span class="number">2</span> + (left_len - v)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 右侧部分（从 index 到 n-1）的长度和最小和</span></span><br><span class="line">            right_len = n - index</span><br><span class="line">            right_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> v &gt; right_len:</span><br><span class="line">                <span class="comment"># 数组形态为 [v, v-1, ..., v-(right_len-1)]</span></span><br><span class="line">                right_sum = (v + v - (right_len - <span class="number">1</span>)) * right_len // <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 数组形态为 [v, v-1, ..., 1, ..., 1]</span></span><br><span class="line">                right_sum = v * (v + <span class="number">1</span>) // <span class="number">2</span> + (right_len - v)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 总和为左侧和 + 右侧和 - 重复计算的峰值 v</span></span><br><span class="line">            total_sum = left_sum + right_sum - v</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> total_sum &lt;= maxSum</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对 nums[index] 的可能值进行二分查找</span></span><br><span class="line">        left, right = <span class="number">1</span>, maxSum</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># mid 是一个可行解，尝试寻找更大的解</span></span><br><span class="line">                ans = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># mid 太大，需要缩小范围</span></span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(log(maxSum))。<ul>
<li>二分查找的搜索空间大小为 <code>maxSum</code>。</li>
<li>在每次二分迭代中，我们调用的 <code>check</code> 函数内部只进行常数次算术运算，其时间复杂度为 O(1)。</li>
<li>因此，总时间复杂度由二分查找的次数决定。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)。<ul>
<li>除了输入参数外，我们只使用了几个变量来存储左右边界和中间值，所以空间复杂度是常数级的。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“二分答案”思想的又一个经典应用。当直接求解一个“最大值”或“最小值”问题比较困难时，可以思考能否将其转化为一个更简单的“判定性”问题。如果这个判定问题对于答案具有单调性，那么就可以利用二分查找，将搜索范围不断折半，从而在对数级别的时间复杂度内找到最优解，这比线性扫描所有可能的答案要高效得多。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最大</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>第233场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1818 | 二分查找优化绝对差值和</title>
    <url>//posts/leetcode-1818/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1818 题：<a href="https://leetcode.cn/problems/minimum-absolute-sum-difference/">绝对差值和</a>。<br>本题的关键在于，将问题转化为寻找最大“收益”的单次替换。通过对<code>nums1</code>排序并利用二分查找，我们可以高效地为<code>nums2</code>中的每个元素找到最佳匹配，从而将寻找最优解的复杂度从 O(n²) 优化到 O(n log n)。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们两个长度相等的正整数数组 <code>nums1</code> 和 <code>nums2</code>。首先，我们需要理解“绝对差值和”的定义，即 <code>sum(|nums1[i] - nums2[i]|)</code>。</p>
<p>核心任务是：我们可以对 <code>nums1</code> 进行<strong>至多一次</strong>修改，即用 <code>nums1</code> 中的<strong>任意</strong>一个元素替换 <code>nums1</code> 中的某个元素，目标是让这个“绝对差值和”变得尽可能小。最后返回这个最小的和，并对 <code>10^9 + 7</code> 取余。</p>
<p>举个例子，<code>nums1 = [1,7,5]</code>, <code>nums2 = [2,3,5]</code>：</p>
<ul>
<li><strong>不替换</strong>：初始的绝对差值和是 <code>|1-2| + |7-3| + |5-5| = 1 + 4 + 0 = 5</code>。</li>
<li><strong>尝试替换</strong>：我们希望通过一次替换来最大化地减小这个和。<ul>
<li>观察到 <code>|7-3|=4</code> 是最大的差值项。如果我们能将 <code>nums1[1]</code>（值为7）换成一个更接近 <code>nums2[1]</code>（值为3）的数，收益可能最大。</li>
<li><code>nums1</code> 中有哪些元素可选？有 <code>1</code> 和 <code>5</code>。</li>
<li>如果用 <code>1</code> 替换 <code>7</code>，新 <code>nums1</code> 为 <code>[1,1,5]</code>。差值和变为 <code>|1-2| + |1-3| + |5-5| = 1 + 2 + 0 = 3</code>。</li>
<li>如果用 <code>5</code> 替换 <code>7</code>，新 <code>nums1</code> 为 <code>[1,5,5]</code>。差值和变为 <code>|1-2| + |5-3| + |5-5| = 1 + 2 + 0 = 3</code>。</li>
</ul>
</li>
<li><strong>结论</strong>：最小的绝对差值和是 3。</li>
</ul>
<h3 id="核心思路：贪心-二分查找"><a href="#核心思路：贪心-二分查找" class="headerlink" title="核心思路：贪心 + 二分查找"></a>核心思路：贪心 + 二分查找</h3><p>问题的本质是找到一个最优的替换方案。对于 <code>n</code> 个位置中的每一个 <code>i</code>，我们都有机会将其 <code>nums1[i]</code> 替换掉，从而改变 <code>|nums1[i] - nums2[i]|</code> 这一项。我们的目标是让这次替换带来的<strong>收益</strong>（即差值和的减少量）最大化。</p>
<p>对于任意一个位置 <code>i</code>，其原始差值为 <code>diff_i = |nums1[i] - nums2[i]|</code>。如果我们用 <code>nums1</code> 中的某个值 <code>val</code> 来替换 <code>nums1[i]</code>，那么新的差值变为 <code>new_diff_i = |val - nums2[i]|</code>。这次替换带来的收益就是 <code>reduction = diff_i - new_diff_i</code>。</p>
<p>要想让 <code>reduction</code> 最大，我们就必须让 <code>new_diff_i</code> 最小。这意味着，对于当前的 <code>nums2[i]</code>，我们需要在整个 <code>nums1</code> 数组中，找到一个与它最接近的数。</p>
<p><strong>如何高效地找到这个“最接近的数”？</strong><br>如果我们对每一个 <code>nums2[i]</code> 都遍历一遍 <code>nums1</code> 来寻找最接近的值，那么单次查找的时间复杂度是 O(n)，总时间复杂度将是 O(n²)，对于 n 高达 10^5 的情况，这显然会超时。</p>
<p>注意到 <code>nums1</code> 数组是固定的。我们可以先对其进行<strong>排序</strong>。在一个有序数组中查找一个数，或者查找与它最接近的数，正是<strong>二分查找</strong>的经典应用场景。</p>
<p>因此，我们的整体策略是：</p>
<ol>
<li><strong>预处理</strong>：先对 <code>nums1</code> 进行排序，得到一个有序版本 <code>sorted_nums1</code>。</li>
<li><strong>计算初始值</strong>：计算不做任何替换时的原始绝对差值和 <code>total_diff</code>。</li>
<li><strong>寻找最大收益</strong>：遍历 <code>i</code> 从 <code>0</code> 到 <code>n-1</code>，对于每一个 <code>nums2[i]</code>，利用二分查找在 <code>sorted_nums1</code> 中找到与它最接近的数。从而计算出替换 <code>nums1[i]</code> 能带来的最大收益 <code>max_reduction</code>。</li>
<li><strong>计算最终结果</strong>：最终的最小绝对差值和就是 <code>total_diff - max_reduction</code>。</li>
</ol>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>计算初始总和</strong></p>
<ul>
<li>定义模 <code>MOD = 10^9 + 7</code>。</li>
<li>遍历 <code>nums1</code> 和 <code>nums2</code>，累加 <code>|nums1[i] - nums2[i]|</code> 得到初始总和 <code>total_diff</code>。</li>
</ul>
</li>
<li><p><strong>排序 <code>nums1</code></strong></p>
<ul>
<li>创建一个 <code>nums1</code> 的副本并对其进行升序排序，得到 <code>sorted_nums1</code>。</li>
</ul>
</li>
<li><p><strong>寻找最大可减少量 (max_reduction)</strong></p>
<ul>
<li>初始化 <code>max_reduction = 0</code>。</li>
<li>再次遍历两个数组，对于每个索引 <code>i</code>：<ul>
<li>获取原始差值 <code>original_diff = |nums1[i] - nums2[i]|</code>。</li>
<li>以 <code>target = nums2[i]</code> 为目标，在 <code>sorted_nums1</code> 中执行二分查找。</li>
<li>二分查找会返回一个插入点 <code>j</code>。<code>target</code> 最接近的两个候选值就是 <code>sorted_nums1[j]</code> (如果 <code>j</code> 没越界) 和 <code>sorted_nums1[j-1]</code> (如果 <code>j &gt; 0</code>)。</li>
<li>计算 <code>target</code> 与这两个候选值的差的绝对值，取其中较小的一个作为 <code>min_new_diff</code>。</li>
<li>当前位置 <code>i</code> 能产生的最大收益为 <code>reduction = original_diff - min_new_diff</code>。</li>
<li>更新全局最大收益：<code>max_reduction = max(max_reduction, reduction)</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>最终的答案是 <code>(total_diff - max_reduction) % MOD</code>。为了防止结果为负（在某些语言的取模运算中），可以使用 <code>(total_diff - max_reduction + MOD) % MOD</code> 来保证结果非负。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minAbsoluteSumDiff</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums1)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 1: 创建 nums1 的排序副本</span></span><br><span class="line">        sorted_nums1 = <span class="built_in">sorted</span>(nums1)</span><br><span class="line"></span><br><span class="line">        total_diff = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 步骤 2: 计算原始的绝对差值和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            total_diff += <span class="built_in">abs</span>(nums1[i] - nums2[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> total_diff == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        max_reduction = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 步骤 3: 遍历查找最大的可减少量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            original_diff = <span class="built_in">abs</span>(nums1[i] - nums2[i])</span><br><span class="line">            target = nums2[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 4: 使用二分查找在 sorted_nums1 中寻找最接近 target 的值</span></span><br><span class="line">            j = bisect.bisect_left(sorted_nums1, target)</span><br><span class="line">            </span><br><span class="line">            min_new_diff = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 候选1: 插入点右侧（或本身）的元素</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; n:</span><br><span class="line">                min_new_diff = <span class="built_in">min</span>(min_new_diff, <span class="built_in">abs</span>(sorted_nums1[j] - target))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 候选2: 插入点左侧的元素</span></span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                min_new_diff = <span class="built_in">min</span>(min_new_diff, <span class="built_in">abs</span>(sorted_nums1[j-<span class="number">1</span>] - target))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算当前替换能带来的收益</span></span><br><span class="line">            reduction = original_diff - min_new_diff</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新全局最大收益</span></span><br><span class="line">            max_reduction = <span class="built_in">max</span>(max_reduction, reduction)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 5: 从原始总和中减去最大收益并取模</span></span><br><span class="line">        result = (total_diff - max_reduction + MOD) % MOD</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(n log n)。<ul>
<li><code>n</code> 是数组的长度。</li>
<li>对 <code>nums1</code> 排序需要 O(n log n)。</li>
<li>计算初始的 <code>total_diff</code> 需要 O(n)。</li>
<li>主循环执行 <code>n</code> 次，每次循环内部执行一次二分查找，需要 O(log n)。这部分总共是 O(n log n)。</li>
<li>因此，总的时间复杂度由排序和主循环决定，为 O(n log n)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(n)。<ul>
<li>我们需要一个额外的数组 <code>sorted_nums1</code> 来存储 <code>nums1</code> 的排序副本，占用了 O(n) 的空间。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是一个很好的例子，展示了如何通过<strong>预处理</strong>和<strong>数据结构&#x2F;算法</strong>的选择来优化暴力解法。通过贪心地锁定“最大化收益”这一目标，我们将一个复杂的替换问题简化为了一系列查找问题。而排序和二分查找这对经典组合，则为我们提供了高效完成查找任务的强大工具，使得算法的性能满足了题目的要求。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>排序</tag>
        <tag>有序集合</tag>
        <tag>第235场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1838 | 滑动窗口求解“最高频元素的频数”</title>
    <url>//posts/leetcode-1838/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1838 题：<a href="https://leetcode.cn/problems/frequency-of-the-most-frequent-element/">最高频元素的频数</a>。<br>这道题巧妙地将“操作次数”的限制与“最大频数”的目标结合起来，通过“排序”加“滑动窗口”的组合拳，可以高效地找到答案。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个整数数组 <code>nums</code> 和一个操作预算 <code>k</code>。我们被允许执行一种操作：将数组中的任意一个元素的值增加 1。我们的目标是，在执行不超过 <code>k</code> 次操作的前提下，让数组中某一个元素的出现次数（即频数）变得尽可能大，并返回这个最大的可能频数。</p>
<p>我们来分析一下这个目标：</p>
<ul>
<li>我们想让某个数 <code>x</code> 出现的次数最多。</li>
<li>为了实现这个目标，我们需要挑选数组中的一些元素，通过增加它们的值，让它们都等于 <code>x</code>。</li>
<li>由于我们只能执行“增加”操作，一个非常重要的贪心思路是：如果我们想让一组数都变成 <code>x</code>，那么 <code>x</code> 必须是这组数中最大的那个数。否则，如果 <code>x</code> 不是最大的，我们就需要把那个比 <code>x</code> 还大的数也变成 <code>x</code>，但这是“增加”操作无法做到的。</li>
</ul>
<p>举个例子，对于 <code>nums = [1,2,4], k = 5</code>：</p>
<ul>
<li>我们的目标是找到一个子集，能用最多 5 次操作让它们全部相等。</li>
<li>如果我们选择 <code>[1, 2, 4]</code> 这个子集，为了让它们相等，最划算的方式是把它们都变成其中最大的 <code>4</code>。</li>
<li>需要的操作次数为：<code>(4 - 1) + (4 - 2) = 3 + 2 = 5</code>。</li>
<li>这个操作次数正好等于 <code>k</code>，是允许的。此时，我们得到了 <code>[4, 4, 4]</code>，元素 <code>4</code> 的频数是 3。这就是本例的最优解。</li>
</ul>
<h3 id="核心思路：排序-滑动窗口"><a href="#核心思路：排序-滑动窗口" class="headerlink" title="核心思路：排序 + 滑动窗口"></a>核心思路：排序 + 滑动窗口</h3><p>这类求解“满足特定条件的最长连续子数组”的问题，通常是滑动窗口算法的用武之地。而本题的“特定条件”与元素的值有关，因此，<strong>先排序</strong>是至关重要的一步。</p>
<p><strong>为什么需要排序？</strong><br>排序后，对于任意一个连续的子数组（即我们的“窗口”），其中最大的元素就是最右侧的那个元素。这就完美契合了我们之前的贪心思路：将窗口内的所有元素都变成窗口内的最大值，这样操作成本最低。</p>
<p>算法的动态过程如下：</p>
<ol>
<li><strong>排序</strong>：首先对 <code>nums</code> 数组进行升序排序。</li>
<li><strong>窗口设定</strong>：我们使用 <code>left</code> 和 <code>right</code> 两个指针来维护一个窗口 <code>nums[left...right]</code>。</li>
<li><strong>窗口扩张</strong>：<code>right</code> 指针不断向右移动，将新元素 <code>nums[right]</code> 纳入窗口。</li>
<li><strong>成本计算与窗口收缩</strong>：<ul>
<li>我们的目标是将窗口内所有元素都变成 <code>nums[right]</code>。</li>
<li>要实现这个目标，需要的总操作次数（成本）为：<code>(nums[right] * 窗口长度) - (窗口内元素的当前总和)</code>。</li>
<li>如果计算出的<strong>成本大于 <code>k</code></strong>，说明当前窗口过长，无法在预算内完成目标。此时，我们必须收缩窗口的左边界，即把 <code>left</code> 指针向右移动，并将 <code>nums[left]</code> 从窗口中移除，直到成本重新回到 <code>k</code> 的预算之内。</li>
</ul>
</li>
<li><strong>结果更新</strong>：<code>right</code> 指针每移动一步，在确保窗口有效（成本 <code>&lt;= k</code>）之后，当前窗口的长度 <code>right - left + 1</code> 就是一个可能的频数。我们用它来更新全局的最大频数 <code>max_freq</code>。</li>
</ol>
<p>通过这个“扩张-收缩”的循环，我们就能在一次遍历中找到满足条件的最长窗口，其长度就是答案。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>排序</strong>：</p>
<ul>
<li>对输入数组 <code>nums</code> 进行升序排序。</li>
</ul>
</li>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>左指针 <code>left = 0</code>。</li>
<li>记录最大频数 <code>max_freq = 0</code>。</li>
<li>记录窗口内元素的总和 <code>current_sum = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历与扩张</strong>：</p>
<ul>
<li>用右指针 <code>right</code> 从 <code>0</code> 到 <code>n-1</code> 遍历整个数组。</li>
<li>在循环的每一步，首先将新元素 <code>nums[right]</code> 加入窗口，更新 <code>current_sum += nums[right]</code>。</li>
</ul>
</li>
<li><p><strong>收缩</strong>：</p>
<ul>
<li>紧接着，使用一个 <code>while</code> 循环检查窗口的有效性。条件是：<code>nums[right] * (right - left + 1) &gt; current_sum + k</code>。</li>
<li>只要条件成立，就说明成本超支，窗口需要收缩。</li>
<li>收缩操作：从 <code>current_sum</code> 中减去 <code>nums[left]</code>，然后将左指针 <code>left</code> 右移一位。</li>
<li><code>while</code> 循环会一直执行，直到窗口恢复到成本不超支的状态。</li>
</ul>
</li>
<li><p><strong>更新结果</strong>：</p>
<ul>
<li>在 <code>while</code> 循环结束后，当前窗口 <code>nums[left:right+1]</code> 一定是有效的。</li>
<li>计算当前窗口长度 <code>right - left + 1</code>，并更新 <code>max_freq = max(max_freq, right - left + 1)</code>。</li>
</ul>
</li>
<li><p><strong>返回</strong>：</p>
<ul>
<li><code>right</code> 指针遍历完整个数组后，<code>max_freq</code> 中存储的就是最终答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxFrequency</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1: 排序是关键前提</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2: 初始化指针和状态变量</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        max_freq = <span class="number">0</span></span><br><span class="line">        current_sum = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 遍历数组，right 指针用于扩张窗口</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            current_sum += nums[right]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 4: 当窗口不满足条件时 (成本 &gt; k)，进行收缩</span></span><br><span class="line">            <span class="comment"># 成本 = 目标总和 - 当前总和</span></span><br><span class="line">            <span class="comment"># 目标总和 = nums[right] * 窗口长度</span></span><br><span class="line">            <span class="keyword">while</span> (nums[right] * (right - left + <span class="number">1</span>)) &gt; current_sum + k:</span><br><span class="line">                <span class="comment"># 从左侧移出元素</span></span><br><span class="line">                current_sum -= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 5: 更新最大频数，此时的窗口一定是有效的</span></span><br><span class="line">            max_freq = <span class="built_in">max</span>(max_freq, right - left + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> max_freq</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N log N)。其中 N 是数组 <code>nums</code> 的长度。算法的瓶颈在于初始的排序步骤，其时间复杂度为 O(N log N)。后续的滑动窗口遍历中，<code>left</code> 和 <code>right</code> 指针都只移动 N 次，所以是 O(N) 的。因此，总的时间复杂度为 O(N log N)。</li>
<li><strong>空间复杂度</strong>: O(log N) 或 O(N)。这取决于编程语言中排序算法的实现。例如，Python 的 Timsort 在最坏情况下需要 O(N) 的空间，而一些快速排序的实现会使用 O(log N) 的递归栈空间。如果我们不考虑排序所用的空间，则算法本身只使用了常数个额外变量，空间复杂度为 O(1)。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是一个“排序 + 滑动窗口”的经典范例。解决这类问题的关键在于：</p>
<ol>
<li><strong>发现贪心性质</strong>：通过分析题目，找到一个贪心策略（如本题的“将所有数变为窗口最大值”），这个策略往往需要先对数据进行排序。</li>
<li><strong>定义窗口有效性</strong>：明确一个窗口需要满足的“条件”。在本题中，这个条件就是 <code>(窗口目标和 - 窗口当前和) &lt;= k</code>。</li>
<li><strong>实现窗口的动规过程</strong>：清晰地定义窗口在扩张和收缩时，需要更新哪些状态变量（本题中是 <code>current_sum</code>），以确保能够高效地判断窗口的有效性。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>滑动窗口</tag>
        <tag>排序</tag>
        <tag>前缀和</tag>
        <tag>第 238 场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1888 | 利用滑动窗口巧解循环字符串反转问题</title>
    <url>//posts/leetcode-1888/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1888 题：<a href="https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/description/">使二进制字符串交替的最少反转次数</a>。<br>这是一道非常有趣的中等难度题目，它巧妙地将字符串循环操作和经典算法模型“滑动窗口”结合了起来。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>首先，我们来分析一下题目的要求。给定一个二进制字符串 <code>s</code>，我们有两种操作：</p>
<ul>
<li><strong>类型 1（循环移位）</strong>: 将字符串的第一个字符移动到末尾。这个操作可以执行任意次，意味着字符串的<strong>起点可以是任意位置</strong>。例如，<code>&quot;111000&quot;</code> 可以变成 <code>&quot;110001&quot;</code>、<code>&quot;100011&quot;</code> 等。</li>
<li><strong>类型 2（字符反转）</strong>: 将任意一个 <code>&#39;0&#39;</code> 变成 <code>&#39;1&#39;</code>，或者 <code>&#39;1&#39;</code> 变成 <code>&#39;0&#39;</code>。</li>
</ul>
<p>我们的目标是，通过这两种操作，将原字符串变成一个“交替字符串”（如 <code>&quot;01010...&quot;</code> 或 <code>&quot;10101...&quot;</code>），并求出<strong>最少的类型 2（反转）操作次数</strong>。</p>
<h3 id="核心思路：转化问题"><a href="#核心思路：转化问题" class="headerlink" title="核心思路：转化问题"></a>核心思路：转化问题</h3><h4 id="如何处理“循环移位”？"><a href="#如何处理“循环移位”？" class="headerlink" title="如何处理“循环移位”？"></a>如何处理“循环移位”？</h4><p>“任意次循环移位”是一个非常关键的信息。它暗示我们，最终的字符串可能是原字符串通过旋转得到的任何一种形态。直接枚举所有旋转结果再计算会非常低效。</p>
<p>处理这类环形或循环问题的经典技巧是：<strong>将字符串复制一份拼接在原字符串后面</strong>。</p>
<p>例如，如果 <code>s = &quot;1110&quot;</code>，我们构造一个新的字符串 <code>s&#39; = s + s = &quot;11101110&quot;</code>。<br>现在，在 <code>s&#39;</code> 上任意一个长度为 <code>n</code>（原字符串长度）的子串，都对应了原字符串 <code>s</code> 的一种循环移位结果。</p>
<ul>
<li><code>s&#39;</code> 从索引 0 开始的子串: <code>&quot;1110&quot;</code> (原字符串)</li>
<li><code>s&#39;</code> 从索引 1 开始的子串: <code>&quot;1101&quot;</code> (相当于原字符串循环移位 1 次)</li>
<li><code>s&#39;</code> 从索引 2 开始的子串: <code>&quot;1011&quot;</code> (相当于原字符串循环移位 2 次)</li>
<li><code>s&#39;</code> 从索引 3 开始的子串: <code>&quot;0111&quot;</code> (相当于原字符串循环移位 3 次)</li>
</ul>
<p>通过这个转换，我们就把一个复杂的“循环问题”转化成了一个更熟悉的“<strong>在固定长度的字符串上寻找最优子串</strong>”的问题。这自然而然地引出了我们的主角——<strong>滑动窗口</strong>。</p>
<h4 id="确定我们的“目标”"><a href="#确定我们的“目标”" class="headerlink" title="确定我们的“目标”"></a>确定我们的“目标”</h4><p>我们的目标是把字符串变成一个交替字符串。对于一个固定长度 <code>n</code> 的字符串，交替的形式只有两种：</p>
<ol>
<li>以 <code>&#39;0&#39;</code> 开头：我们称之为 <code>target1</code>，例如 <code>n=6</code> 时为 <code>&quot;010101&quot;</code>。</li>
<li>以 <code>&#39;1&#39;</code> 开头：我们称之为 <code>target2</code>，例如 <code>n=6</code> 时为 <code>&quot;101010&quot;</code>。</li>
</ol>
<p>我们的任务就是在 <code>s&#39;</code> 上滑动一个长度为 <code>n</code> 的窗口，对于每一个窗口，计算它变成 <code>target1</code> 或 <code>target2</code> 所需的最小反转次数，然后取所有这些结果中的最小值。</p>
<h3 id="滑动窗口算法详解"><a href="#滑动窗口算法详解" class="headerlink" title="滑动窗口算法详解"></a>滑动窗口算法详解</h3><ol>
<li><p><strong>准备工作</strong>:</p>
<ul>
<li>令 <code>n</code> 为原字符串 <code>s</code> 的长度。</li>
<li>构造新字符串 <code>s&#39; = s + s</code>，其长度为 <code>2n</code>。</li>
<li>构造两个长度为 <code>2n</code> 的目标字符串 <code>target1</code> 和 <code>target2</code>。</li>
</ul>
</li>
<li><p><strong>初始化窗口</strong>:</p>
<ul>
<li>计算 <code>s&#39;</code> 的前 <code>n</code> 个字符（即第一个窗口）与 <code>target1</code> 的前 <code>n</code> 个字符有多少位不同，记为 <code>diff1</code>。</li>
<li>同理，计算与 <code>target2</code> 的前 <code>n</code> 个字符的不同位数，记为 <code>diff2</code>。</li>
<li>此时，我们得到的最小反转次数 <code>ans = min(diff1, diff2)</code>。</li>
</ul>
</li>
<li><p><strong>滑动窗口</strong>:</p>
<ul>
<li>窗口从索引 <code>1</code> 开始向右滑动，直到窗口的起始点到达 <code>n</code>。</li>
<li>每次窗口向右滑动一格，我们不需要重新计算整个窗口的 <code>diff</code>。我们只需要更新变化的部分：<ul>
<li><strong>移出字符</strong>：检查即将离开窗口的那个字符（例如 <code>s&#39;[i-1]</code>）是否与目标字符串的对应位置不同。如果不同，说明我们之前为这个不同点计了 1 次反转，现在它离开窗口了，所以 <code>diff</code> 应该减 1。</li>
<li><strong>移入字符</strong>：检查新进入窗口的那个字符（例如 <code>s&#39;[i+n-1]</code>）是否与目标字符串的对应位置不同。如果不同，<code>diff</code> 应该加 1。</li>
</ul>
</li>
<li>每次滑动后，我们都更新 <code>diff1</code> 和 <code>diff2</code>，并用 <code>min(diff1, diff2)</code> 来更新全局的 <code>ans</code>。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>:</p>
<ul>
<li>遍历完所有窗口后，<code>ans</code> 就是最终答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minFlips</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        s = s + s <span class="comment"># 步骤 1：处理循环问题</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 1：构建两种目标交替字符串</span></span><br><span class="line">        target1 = <span class="string">&quot;&quot;</span> <span class="comment"># 形式如 &quot;010101...&quot;</span></span><br><span class="line">        target2 = <span class="string">&quot;&quot;</span> <span class="comment"># 形式如 &quot;101010...&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * n):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                target1 += <span class="string">&quot;0&quot;</span></span><br><span class="line">                target2 += <span class="string">&quot;1&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                target1 += <span class="string">&quot;1&quot;</span></span><br><span class="line">                target2 += <span class="string">&quot;0&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2：初始化第一个窗口的差异（需要反转的次数）</span></span><br><span class="line">        diff1 = <span class="number">0</span> <span class="comment"># 与 target1 的差异</span></span><br><span class="line">        diff2 = <span class="number">0</span> <span class="comment"># 与 target2 的差异</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> s[i] != target1[i]:</span><br><span class="line">                diff1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] != target2[i]:</span><br><span class="line">                diff2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化最小反转次数</span></span><br><span class="line">        ans = <span class="built_in">min</span>(diff1, diff2)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 3：开始滑动窗口</span></span><br><span class="line">        <span class="comment"># left 是移出窗口的字符索引，i 是移入窗口的字符索引</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, <span class="number">2</span> * n):</span><br><span class="line">            left = i - n</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新与 target1 的差异</span></span><br><span class="line">            <span class="keyword">if</span> s[left] != target1[left]:        </span><br><span class="line">                diff1 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] != target1[i]:</span><br><span class="line">                diff1 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新与 target2 的差异</span></span><br><span class="line">            <span class="keyword">if</span> s[left] != target2[left]:        </span><br><span class="line">                diff2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] != target2[i]:</span><br><span class="line">                diff2 += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 更新全局最小反转次数</span></span><br><span class="line">            ans = <span class="built_in">min</span>(ans, diff1, diff2)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(n)。我们只遍历了长度为 <code>2n</code> 的新字符串一次。</li>
<li><strong>空间复杂度</strong>: O(n)。我们需要额外的空间来存储拼接后的字符串 <code>s&#39;</code> 以及两个目标字符串。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题的核心在于将“循环移位”操作通过拼接字符串的方式，转化为一个可以在线性结构上求解的滑动窗口问题，这是一种非常值得学习和掌握的技巧。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
        <tag>动态规划</tag>
        <tag>第244场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1898 | 可移除字符的最大数目</title>
    <url>//posts/leetcode-1898/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1898 题：<a href="https://leetcode.cn/problems/maximum-number-of-removable-characters/description/">可移除字符的最大数目</a>。<br>本题旨在求解一个“最大值”，其核心性质具有单调性。通过巧妙地将这个“求解最优值”的问题转化为一个“判定可行性”的问题，我们可以利用二分查找在对数时间内高效地锁定最终答案。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们得到两个字符串 <code>s</code> 和 <code>p</code>（<code>p</code> 是 <code>s</code> 的一个子序列），以及一个包含 <code>s</code> 中字符下标的数组 <code>removable</code>。题目要求我们从 <code>removable</code> 数组中按顺序取出前 <code>k</code> 个下标，并将 <code>s</code> 中对应位置的字符移除。我们的目标是找到一个最大的 <code>k</code>，使得在移除了这 <code>k</code> 个字符之后，<code>p</code> 仍然是 <code>s</code> 的子序列。</p>
<p>这里的核心约束条件是：</p>
<ol>
<li>移除操作必须严格按照 <code>removable</code> 数组给出的顺序进行，即只能选择 <code>removable</code> 的一个前缀 <code>[0, ..., k-1]</code>。</li>
<li>移除字符后，<code>s</code> 中剩余字符的相对顺序保持不变。</li>
<li>我们需要找到使 <code>p</code> 依然是 <code>s</code> 的子序列的那个<strong>最大</strong>的 <code>k</code>。</li>
</ol>
<p>举个例子，<code>s = &quot;abcacb&quot;</code>, <code>p = &quot;ab&quot;</code>, <code>removable = [3,1,0]</code>。</p>
<ul>
<li>如果我们尝试 <code>k=1</code>，移除 <code>removable[0]</code> 即 <code>s[3]</code>，<code>s</code> 变为 <code>&quot;abccb&quot;</code>。<code>&quot;ab&quot;</code> 是其子序列。可行。</li>
<li>如果我们尝试 <code>k=2</code>，移除 <code>removable[0]</code> 和 <code>removable[1]</code> 即 <code>s[3]</code> 和 <code>s[1]</code>，<code>s</code> 变为 <code>&quot;accb&quot;</code>。<code>&quot;ab&quot;</code> 仍然是其子序列。可行。</li>
<li>如果我们尝试 <code>k=3</code>，移除 <code>removable[0]</code>, <code>removable[1]</code>, <code>removable[2]</code> 即 <code>s[3]</code>, <code>s[1]</code>, <code>s[0]</code>，<code>s</code> 变为 <code>&quot;ccb&quot;</code>。<code>&quot;ab&quot;</code> 不再是其子序列。不可行。</li>
</ul>
<p>因此，满足条件的最大 <code>k</code> 就是 2。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接去寻找这个最大的 <code>k</code> 可能比较棘手。但是，我们可以换一个角度思考：如果我们<strong>假定</strong>一个 <code>k</code> 值，我们能否判断出这个 <code>k</code> 是否满足条件？</p>
<p>这个判定问题相对简单。我们可以写一个辅助函数 <code>is_subsequence(k)</code>，它的功能是：检查当移除 <code>removable</code> 数组前 <code>k</code> 个下标对应的字符后，<code>p</code> 是否还是 <code>s</code> 的子序列。<br>这个函数可以这样实现：</p>
<ol>
<li>将 <code>removable</code> 数组的前 <code>k</code> 个下标存入一个哈希集合（Set），以便后续能以 O(1) 的时间复杂度快速判断某个下标是否需要被移除。</li>
<li>使用双指针法来检查子序列关系。一个指针 <code>p_ptr</code> 指向 <code>p</code> 的开头，另一个指针 <code>s_ptr</code> 指向 <code>s</code> 的开头。</li>
<li>遍历字符串 <code>s</code>（用 <code>s_ptr</code>）。如果 <code>s_ptr</code> 指向的下标不在移除集合中，并且 <code>s[s_ptr]</code> 等于 <code>p[p_ptr]</code>，那么我们就成功匹配了一个字符，将 <code>p_ptr</code> 向后移动一位。</li>
<li>遍历结束后，如果 <code>p_ptr</code> 已经走完了整个 <code>p</code> 字符串（即 <code>p_ptr == len(p)</code>），那就说明 <code>p</code> 是修改后 <code>s</code> 的一个子序列，<code>k</code> 是可行的。</li>
</ol>
<p>现在，我们有了这个判定的方法。我们可以观察到这个判定结果具有非常重要的<strong>单调性</strong>：</p>
<ul>
<li>如果移除 <code>k</code> 个字符后 <code>p</code> <strong>是</strong> <code>s</code> 的子序列，那么移除更少的字符（例如 <code>k-1</code> 个），<code>s</code> 中留下的字符会更多，<code>p</code> 自然也<strong>是</strong> <code>s</code> 的子序列。</li>
<li>反之，如果移除 <code>k</code> 个字符后 <code>p</code> <strong>不是</strong> <code>s</code> 的子序列，那么移除更多的字符（例如 <code>k+1</code> 个），<code>s</code> 中留下的字符会更少，<code>p</code> 就更不可能成为 <code>s</code> 的子序列了。</li>
</ul>
<p>这种 <code>[是, 是, ..., 是, 否, 否, ...]</code> 的性质，正是应用二分查找的完美场景。我们可以对 <code>k</code> 的取值范围进行二分查找，来快速定位那个从“是”到“否”的临界点，也就是我们想要的最大的可行 <code>k</code>。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：可以一个都不移除，所以 <code>k</code> 的最小值是 0。</li>
<li><strong>上界 (right)</strong>：最多可以把 <code>removable</code> 数组里所有的下标都移除，所以 <code>k</code> 的最大值是 <code>len(removable)</code>。</li>
</ul>
<p>因此，我们就在 <code>[0, len(removable)]</code> 这个区间内，对 <code>k</code> 进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = 0</code>：可能的最小 <code>k</code> 值。</li>
<li><code>right = len(removable)</code>：可能的最大 <code>k</code> 值。</li>
<li><code>ans = 0</code> 初始化结果，用来记录我们找到的最大的可行 <code>k</code>。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>left &lt;= right</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = left + (right - left) // 2</code> 作为当前的“猜测 <code>k</code> 值”。</li>
<li>调用辅助函数 <code>is_subsequence(mid)</code> 来判定这个猜测值是否可行。<ul>
<li><strong>如果 <code>is_subsequence(mid)</code> 返回 <code>True</code></strong> (即移除 <code>mid</code> 个字符是可行的)：<ul>
<li>说明 <code>mid</code> 是一个潜在的答案。但我们想找的是“最大”的 <code>k</code>，所以我们尝试一个更大的值。我们先将当前的可行解记录下来 <code>ans = mid</code>，然后将搜索范围缩小到右半边：<code>left = mid + 1</code>。</li>
</ul>
</li>
<li><strong>如果 <code>is_subsequence(mid)</code> 返回 <code>False</code></strong> (即移除 <code>mid</code> 个字符后 <code>p</code> 不再是子序列)：<ul>
<li>说明 <code>mid</code> 这个 <code>k</code> 值太大了，我们需要减少移除的字符数量。将搜索范围缩小到左半边：<code>right = mid - 1</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>ans</code> 中存储的就是满足条件的最大 <code>k</code> 值。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumRemovals</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span>, removable: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 辅助函数，检查移除 k 个字符后 p 是否仍然是 s 的子序列</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">is_subsequence</span>(<span class="params">k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># 创建一个要移除的字符索引的集合，方便 O(1) 快速查找</span></span><br><span class="line">            removed_indices = <span class="built_in">set</span>(removable[:k])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 使用双指针判断子序列</span></span><br><span class="line">            p_ptr = <span class="number">0</span>  <span class="comment"># p 的指针</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 遍历 s，但只考虑未被移除的字符</span></span><br><span class="line">            <span class="keyword">for</span> s_idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="comment"># 如果 p 已经被完全匹配，则提前结束</span></span><br><span class="line">                <span class="keyword">if</span> p_ptr == <span class="built_in">len</span>(p):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 如果当前 s 中的字符没有被移除，并且与 p 中的字符匹配</span></span><br><span class="line">                <span class="keyword">if</span> s_idx <span class="keyword">not</span> <span class="keyword">in</span> removed_indices <span class="keyword">and</span> s[s_idx] == p[p_ptr]:</span><br><span class="line">                    p_ptr += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果 p_ptr 走完了整个 p 字符串，说明 p 是子序列</span></span><br><span class="line">            <span class="keyword">return</span> p_ptr == <span class="built_in">len</span>(p)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对 k (可移除的字符数) 进行二分查找</span></span><br><span class="line">        <span class="comment"># 搜索区间为 [0, len(removable)]</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(removable)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># mid 代表我们尝试移除的字符数量</span></span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> is_subsequence(mid):</span><br><span class="line">                <span class="comment"># 如果移除 mid 个字符后 p 仍然是子序列，</span></span><br><span class="line">                <span class="comment"># 说明 mid 是一个可能的解。我们尝试移除更多字符以找到最大值。</span></span><br><span class="line">                ans = mid  <span class="comment"># 记录这个可行的解</span></span><br><span class="line">                left = mid + <span class="number">1</span> <span class="comment"># 往右边搜索，寻找更大的 k</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 p 不再是子序列，说明移除的字符太多了。</span></span><br><span class="line">                <span class="comment"># 必须减少移除的数量。</span></span><br><span class="line">                right = mid - <span class="number">1</span> <span class="comment"># 往左边搜索</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(log(R) * (M + R))。<ul>
<li><code>M</code> 是字符串 <code>s</code> 的长度，<code>R</code> 是 <code>removable</code> 数组的长度。</li>
<li>二分查找的搜索空间大小是 <code>R+1</code>，因此二分本身需要 <code>log(R)</code> 次迭代。</li>
<li>在每次迭代中，我们都需要调用 <code>is_subsequence</code> 函数。在该函数内部：<ul>
<li>构建哈希集合需要 O(k) 的时间，<code>k</code> 是当前的 <code>mid</code>，最大为 <code>R</code>。</li>
<li>双指针检查子序列需要遍历一次 <code>s</code>，时间复杂度为 O(M)。</li>
</ul>
</li>
<li>因此，<code>is_subsequence</code> 函数的复杂度为 O(M + k)。</li>
<li>总时间复杂度是 <code>log(R) * O(M + R)</code>。鉴于题目限制 <code>R &lt; M</code>，也可记为 O(M * log(R))。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(R)。<ul>
<li>在 <code>is_subsequence</code> 函数中，我们创建了一个哈希集合 <code>removed_indices</code> 来存储要移除的下标。在最坏的情况下，其大小可以达到 <code>R</code>。因此，空间复杂度为 O(R)。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“二分答案”思想的典型应用。当我们面对求解满足特定条件的“最大值”或“最小值”问题时，如果该条件具有单调性，就可以优先考虑是否能将其转化为一个判定问题。通过将复杂的求解问题简化为重复的、更简单的判定问题，并结合二分查找，我们能将时间复杂度从线性级别（或更高）优化到对数级别，从而高效地解决问题。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最大</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>字符串</tag>
        <tag>双指针</tag>
        <tag>第245场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1901 | 寻找峰值 II</title>
    <url>//posts/leetcode-1901/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1901 题：<a href="https://leetcode.cn/problems/find-a-peak-element-ii/">寻找峰值 II</a>。<br>题目要求时间复杂度为 O(m log n) 或 O(n log m)，这提示我们需要在一个维度上进行二分查找，在另一个维度上进行线性扫描。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>一个 2D 网格中的 <strong>峰值</strong> 是指那些 <strong>严格大于</strong> 其相邻格子(上、下、左、右)的元素。</p>
<p>给你一个 从 0 开始编号 的 <code>m x n</code> 矩阵 <code>mat</code> ，其中任意两个相邻格子的值都 <strong>不相同</strong> 。找出 <strong>任意一个</strong> 峰值 <code>mat[i][j]</code> 并 返回其位置 <code>[i,j]</code> 。</p>
<p>你可以假设整个矩阵周边环绕着一圈值为 -1 的格子。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入: mat = [[1,4],[3,2]]</span><br><span class="line">输出: [0,1]</span><br><span class="line">解释: 3 和 4 都是峰值，所以[1,0]和[0,1]都是可接受的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入: mat = [[10,20,15],[21,30,14],[7,16,32]]</span><br><span class="line">输出: [1,1]</span><br><span class="line">解释: 30 和 32 都是峰值，所以[1,1]和[2,2]都是可接受的答案。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>m &#x3D;&#x3D; mat.length</li>
<li>n &#x3D;&#x3D; mat[i].length</li>
<li>1 &lt;&#x3D; m, n &lt;&#x3D; 500</li>
<li>1 &lt;&#x3D; mat[i][j] &lt;&#x3D; 10^5</li>
<li>任意两个相邻元素均不相等</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-为什么不能暴力遍历？"><a href="#1-为什么不能暴力遍历？" class="headerlink" title="1. 为什么不能暴力遍历？"></a>1. 为什么不能暴力遍历？</h4><p>如果直接遍历整个矩阵寻找峰值，时间复杂度是 O(m * n)。虽然对于 500x500 的数据规模来说可以通过，但题目明确要求 O(m log n) 或 O(n log m) 的复杂度，这意味着我们必须利用二分查找的思想。</p>
<h4 id="2-行二分查找策略"><a href="#2-行二分查找策略" class="headerlink" title="2. 行二分查找策略"></a>2. 行二分查找策略</h4><p>我们可以对 <strong>行</strong> 进行二分查找，具体步骤如下：</p>
<ol>
<li><strong>二分行号</strong>：在行索引 <code>0</code> 到 <code>m-1</code> 之间进行二分，设当前中间行为 <code>i</code>。</li>
<li><strong>寻找行最大值</strong>：在第 <code>i</code> 行中找到最大值 <code>mat[i][j]</code>。<ul>
<li>为什么找行最大值？因为如果一个位置是该行的最大值，那么它一定严格大于它的左边和右边（如果存在）。此时要判断它是不是峰值，只需要看它的 <strong>上</strong> 和 <strong>下</strong> 两个邻居。</li>
</ul>
</li>
<li><strong>比较相邻行</strong>：将 <code>mat[i][j]</code> 与它下方的元素 <code>mat[i+1][j]</code> 进行比较：<ul>
<li><strong>情况 A</strong>：<code>mat[i][j] &gt; mat[i+1][j]</code>。<br>说明从第 <code>i</code> 行往下走是“下坡”。根据爬坡理论，如果我们往数值大的方向走一定能找到峰值。既然下方变小了，说明峰值不可能在下方（或者说上方一定存在一个峰值，可能是 <code>mat[i][j]</code> 自己，也可能是更上面的某处）。因此，我们可以舍弃 <code>i</code> 下面的所有行，将搜索范围缩小到上这半部分（包含第 <code>i</code> 行）。</li>
<li><strong>情况 B</strong>：<code>mat[i][j] &lt; mat[i+1][j]</code>。<br>说明从第 <code>i</code> 行往下走是“上坡”。这意味着第 <code>i</code> 行肯定不是峰值所在行（因为有个邻居比它大），且下方一定存在一个峰值。因此，我们将搜索范围缩小到 <code>i</code> 的下方。</li>
</ul>
</li>
</ol>
<h4 id="3-算法复杂度"><a href="#3-算法复杂度" class="headerlink" title="3. 算法复杂度"></a>3. 算法复杂度</h4><ul>
<li><strong>二分过程</strong>：我们对行号 <code>0</code> 到 <code>m-1</code> 进行二分，次数为 O(log m)。</li>
<li><strong>查找最大值</strong>：每次二分内部，我们需要遍历当前行的 <code>n</code> 个元素找到最大值，耗时 O(n)。</li>
<li><strong>总复杂度</strong>：O(n log m)。这完全符合题目要求。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findPeakGrid</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 二分查找的上下界</span></span><br><span class="line">        <span class="comment"># 采用开区间写法 (l, r)，l 和 r 分别是这一轮不可能的边界和可能的边界</span></span><br><span class="line">        <span class="comment"># 初始 l = -1 (假想的上边界), r = len(mat) - 1 (最后一行索引)</span></span><br><span class="line">        l, r = -<span class="number">1</span>, <span class="built_in">len</span>(mat) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当 l + 1 &lt; r 时，说明区间内至少还有一个待检查的元素</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            <span class="comment"># 取中间行</span></span><br><span class="line">            i = (l + r) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 找到第 i 行的最大值</span></span><br><span class="line">            <span class="comment"># 时间复杂度 O(n)</span></span><br><span class="line">            mx = <span class="built_in">max</span>(mat[i])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 找到最大值所在的列索引</span></span><br><span class="line">            j = mat[i].index(mx)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 比较当前行最大值与下一行对应位置的值</span></span><br><span class="line">            <span class="comment"># 如果当前行最大值 &gt; 下一行对应值，说明峰值在当前行或上方</span></span><br><span class="line">            <span class="comment"># 注意：i 是二分的中点，由于 l+1 &lt; r，i 至少比 r 小 1，</span></span><br><span class="line">            <span class="comment"># 只有当 len(mat) &gt; 1 时才会进入循环，此时 i+1 不会越界</span></span><br><span class="line">            <span class="comment"># 实际上若只有一行，循环不执行，直接返回第0行结果</span></span><br><span class="line">            <span class="keyword">if</span> mx &gt; mat[i+<span class="number">1</span>][j]:</span><br><span class="line">                r = i  <span class="comment"># 峰值行号 &lt;= i，缩小右边界</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = i  <span class="comment"># 峰值行号 &gt; i，缩小左边界（mat[i][j] &lt; mat[i+1][j]）</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 循环结束后，r 指向满足条件的行</span></span><br><span class="line">        <span class="comment"># 重新找到该行的最大值位置并返回</span></span><br><span class="line">        <span class="keyword">return</span> [r, mat[r].index(<span class="built_in">max</span>(mat[r]))]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findPeakGrid</span><span class="params">(mat [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化二分查找的上下边界</span></span><br><span class="line">    <span class="comment">// left 为开区间左边界（不包含），right 为闭区间右边界（包含）</span></span><br><span class="line">    left, right := <span class="number">-1</span>, <span class="built_in">len</span>(mat)<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开区间二分查找模板</span></span><br><span class="line">    <span class="keyword">for</span> left+<span class="number">1</span> &lt; right &#123;</span><br><span class="line">        <span class="comment">// 计算中间行索引</span></span><br><span class="line">        i := left + (right-left)/<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到第 i 行最大值的列索引 j</span></span><br><span class="line">        j := indexOfMax(mat[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 比较当前值与它下方邻居的值</span></span><br><span class="line">        <span class="comment">// 注意：由于是向下取整且 left+1 &lt; right，i+1 不会越界</span></span><br><span class="line">        <span class="keyword">if</span> mat[i][j] &gt; mat[i+<span class="number">1</span>][j] &#123;</span><br><span class="line">            right = i <span class="comment">// 当前值更大，说明峰值可能在第 i 行或其上方</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = i <span class="comment">// 下方值更大，说明第 i 行不是峰值行，峰值在下方</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// right 最终指向峰值所在的行</span></span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;right, indexOfMax(mat[right])&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：返回切片中最大值的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexOfMax</span><span class="params">(a []<span class="type">int</span>)</span></span> (idx <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">        <span class="keyword">if</span> x &gt; a[idx] &#123;</span><br><span class="line">            idx = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: <code>O(n log m)</code><br>我们需要对 <code>m</code> 行进行二分查找，这需要 <code>log m</code> 次迭代。在每一次迭代中，我们需要遍历一行 <code>n</code> 个元素来找到最大值。因此总的时间复杂度是 <code>n * log m</code>。</p>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(1)</code><br>我们只使用了常数个变量（如 <code>left</code>, <code>right</code>, <code>i</code>, <code>mx</code> 等）来存储状态，不需要额外的存储空间（除了输入矩阵本身）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2024 | 滑动窗口求解“考试的最大困扰度”</title>
    <url>//posts/leetcode-2024/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2024 题：<a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/description/">考试的最大困扰度</a>。<br>该题核心在于，如何维护一个“窗口”，使得窗口内的子字符串可以通过不超过 k 次修改，变成一个全 ‘T’ 或全 ‘F’ 的字符串。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们来仔细分析一下题目的目标：<strong>最大化连续相同结果的题数</strong>。</p>
<p>这意味着我们要找到一个最长的子字符串，这个子字符串要么是 <code>TT...T</code>，要么是 <code>FF...F</code>。我们拥有一个强大的能力：最多可以将 <code>k</code> 个字符进行修改。</p>
<p>这个问题可以分解为两个子问题：</p>
<ol>
<li>找到一个最长的子字符串，它最多包含 <code>k</code> 个 <code>&#39;F&#39;</code>。这样我们就可以把这些 <code>&#39;F&#39;</code> 都改成 <code>&#39;T&#39;</code>，从而得到一串连续的 <code>&#39;T&#39;</code>。</li>
<li>找到一个最长的子字符串，它最多包含 <code>k</code> 个 <code>&#39;T&#39;</code>。这样我们就可以把这些 <code>&#39;T&#39;</code> 都改成 <code>&#39;F&#39;</code>，从而得到一串连续的 <code>&#39;F&#39;</code>。</li>
</ol>
<p>最终的答案就是这两个子问题结果中的最大值。这两个子问题都可以用滑动窗口完美解决。更巧妙的是，我们可以将这两个问题合二为一进行求解。</p>
<h3 id="核心思路：滑动窗口"><a href="#核心思路：滑动窗口" class="headerlink" title="核心思路：滑动窗口"></a>核心思路：滑动窗口</h3><p>当我们看到“最长连续子串”这类问题时，通常可以考虑使用滑动窗口。滑动窗口就像一个在字符串上移动的框，我们关心的是这个框内的内容是否满足特定条件。</p>
<p>在这个问题中，窗口需要满足的条件是：<strong>窗口内需要修改的字符数不能超过 <code>k</code></strong>。</p>
<p>如何计算“需要修改的字符数”呢？假设当前窗口大小为 <code>len</code>，窗口内 ‘T’ 的数量为 <code>countT</code>，’F’ 的数量为 <code>countF</code>。</p>
<ul>
<li>要将窗口内所有字符变为 ‘T’，需要修改 <code>countF</code> 次。</li>
<li>要将窗口内所有字符变为 ‘F’，需要修改 <code>countT</code> 次。</li>
</ul>
<p>我们希望用最少的操作次数，所以我们会选择将数量较少的字符修改成数量较多的字符。因此，需要修改的次数就是 <code>min(countT, countF)</code>。不过，换一种思路会更简单：<br><strong>需要修改的字符数 &#x3D; 窗口长度 - 窗口内出现次数最多的字符的数量</strong></p>
<p>所以，窗口的“有效”条件就变成了：<br><code>(窗口长度) - max(countT, countF) &lt;= k</code></p>
<h4 id="滑动窗口的运作流程"><a href="#滑动窗口的运作流程" class="headerlink" title="滑动窗口的运作流程"></a>滑动窗口的运作流程</h4><ol>
<li><strong>窗口扩张</strong>：我们使用右指针 <code>right</code> 不断向右移动，扩大窗口，并将新字符纳入统计。</li>
<li><strong>条件判断</strong>：每扩大一步，我们都检查上述“有效”条件是否还成立。</li>
<li><strong>窗口收缩</strong>：如果条件不成立，说明当前窗口“太长了”，包含了太多需要修改的字符。此时，我们必须从左边收缩窗口，即移动左指针 <code>left</code>，并将被移出窗口的字符从统计中移除，直到窗口重新变得“有效”。</li>
<li><strong>更新结果</strong>：在整个过程中，窗口的最大尺寸就是我们所求的答案。因为窗口收缩时，<code>left</code> 和 <code>right</code> 同步右移，长度不变；只有在不收缩时，<code>right</code> 右移，长度才会增加。所以，<code>right - left + 1</code> 始终记录着当前有效的最大窗口长度。</li>
</ol>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化</strong>:</p>
<ul>
<li>定义左右指针 <code>left = 0</code>, <code>right = 0</code>。</li>
<li>定义一个计数器（<code>dict</code> 或 <code>Counter</code>）来统计窗口内 <code>&#39;T&#39;</code> 和 <code>&#39;F&#39;</code> 的数量。</li>
<li>初始化最大长度 <code>max_len = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历扩张</strong>:</p>
<ul>
<li>用 <code>right</code> 指针遍历整个字符串 <code>answerKey</code>。</li>
<li>在循环中，将 <code>answerKey[right]</code> 对应的字符计数加一。</li>
</ul>
</li>
<li><p><strong>判断与收缩</strong>:</p>
<ul>
<li>计算当前窗口内出现次数最多的字符的数量 <code>max_freq</code>。</li>
<li>检查 <code>(right - left + 1) - max_freq</code> 是否大于 <code>k</code>。</li>
<li>如果大于 <code>k</code>，说明需要修改的字符超过了限制，必须收缩窗口：<ul>
<li>将 <code>answerKey[left]</code> 对应的字符计数减一。</li>
<li>将左指针 <code>left</code> 右移一位。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>记录结果</strong>:</p>
<ul>
<li>经过收缩（或不收缩）后，当前窗口 <code>[left, right]</code> 必然是有效的。我们用它的长度 <code>right - left + 1</code> 来更新 <code>max_len</code>。</li>
</ul>
</li>
<li><p><strong>返回</strong>:</p>
<ul>
<li>遍历结束后，<code>max_len</code> 即为最终答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxConsecutiveAnswers</span>(<span class="params">self, answerKey: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(answerKey)</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        counts = Counter()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># right 指针负责扩大窗口</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 将新字符计入窗口</span></span><br><span class="line">            counts[answerKey[right]] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 窗口内出现次数最多的字符的数量</span></span><br><span class="line">            <span class="comment"># A more robust way is `max_freq = max(counts.get(&#x27;T&#x27;, 0), counts.get(&#x27;F&#x27;, 0))`</span></span><br><span class="line">            <span class="comment"># but since counts will not be empty, max(counts.values()) is fine.</span></span><br><span class="line">            max_freq = <span class="built_in">max</span>(counts.values())</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 判断窗口是否需要收缩</span></span><br><span class="line">            <span class="comment"># 窗口长度: right - left + 1</span></span><br><span class="line">            <span class="comment"># 需要改变的字符数: (right - left + 1) - max_freq</span></span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span>) - max_freq &gt; k:</span><br><span class="line">                <span class="comment"># 从窗口左边移出一个字符</span></span><br><span class="line">                counts[answerKey[left]] -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 左指针右移，收缩窗口</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 经过上面的调整，当前窗口 [left, right] 肯定是有效的</span></span><br><span class="line">            <span class="comment"># 我们用它的长度更新最大长度</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> max_len</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)，其中 N 是字符串 <code>answerKey</code> 的长度。因为 <code>left</code> 和 <code>right</code> 指针都只会从头到尾遍历字符串一次。</li>
<li><strong>空间复杂度</strong>: O(1)。我们使用的计数器 <code>counts</code> 最多只会存储两个键（’T’ 和 ‘F’），所以其空间占用是常数级别的。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想的直接应用，考察的是对滑动窗口“维护一个满足特定条件的区间”这一核心思想的理解。<br>关键的收获是：</p>
<ol>
<li><strong>问题转化</strong>：将原问题“在 k 次修改下，最长的连续 T&#x2F;F 串”转化为“找到一个最长的子串，其中数量较少的字符不超过 k 个”。</li>
<li><strong>窗口条件</strong>：巧妙地利用 <code>(窗口长度) - (主要元素数量) &lt;= k</code> 来作为窗口的有效性判断条件，这个公式同时兼顾了求最长连续 ‘T’ 和最长连续 ‘F’ 两种情况。</li>
<li><strong>动态维护</strong>：通过扩张和收缩窗口，动态地维护一个始终满足条件的、尽可能长的区间，从而得到最终答案。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
        <tag>前缀和</tag>
        <tag>双指针</tag>
        <tag>第 62 场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2064 | 分配给商店的最多商品的最小值</title>
    <url>//posts/leetcode-2064/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2064 题：<a href="https://leetcode.cn/problems/minimized-maximum-of-products-distributed-to-any-store/description/">分配给商店的最多商品的最小值</a>。<br>本题是一道典型的“最小化最大值”问题。其核心在于识别出答案的单调性，并将一个求解最优值的问题，巧妙地转化为一个判定性的问题，从而利用二分查找在对数时间内高效求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要将 <code>m</code> 种商品分配给 <code>n</code> 家商店。每种商品的数量在 <code>quantities</code> 数组中给出。分配时必须遵守以下规则：</p>
<ol>
<li>一间商店最多只能分配到<strong>一种</strong>商品。</li>
<li>商店可以接收任意数量的同种商品（可以为0）。</li>
<li>我们的目标是找到一种分配方案，使得所有商店中，商品数量最多的那一家，其商品数量（我们称之为 <code>x</code>）尽可能小。返回这个最小的 <code>x</code>。</li>
</ol>
<p>这个问题本质上是要求我们找到一个最优的 <code>x</code>，即“最小化的最大值”。</p>
<p>举个例子，<code>n = 6</code>, <code>quantities = [11, 6]</code>。</p>
<ul>
<li>如果我们尝试让 <code>x=2</code>（即每家商店最多拿2件商品），会发生什么？<ul>
<li>11 件商品需要 <code>ceil(11/2) = 6</code> 间商店。</li>
<li>6 件商品需要 <code>ceil(6/2) = 3</code> 间商店。</li>
<li>总共需要 <code>6 + 3 = 9</code> 间商店，但这超出了我们拥有的 <code>n=6</code> 间商店，所以 <code>x=2</code> 是不可行的。</li>
</ul>
</li>
<li>如果我们尝试让 <code>x=3</code> 呢？<ul>
<li>11 件商品需要 <code>ceil(11/3) = 4</code> 间商店。</li>
<li>6 件商品需要 <code>ceil(6/3) = 2</code> 间商店。</li>
<li>总共需要 <code>4 + 2 = 6</code> 间商店，这恰好等于 <code>n=6</code>。所以 <code>x=3</code> 是一个可行的分配方案。</li>
</ul>
</li>
</ul>
<p>通过这个例子，我们可以感觉到 <code>x</code> 和所需商店数量之间的一种反比关系：<code>x</code> 越大，分配同一种商品所需的商店就越少，总商店数也可能越少。我们的任务就是在所有可行的 <code>x</code> 中，找到那个最小的值。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最小的可能 <code>x</code>”似乎比较复杂。但我们可以换一个角度思考：如果我们<strong>假设</strong>一个 <code>x</code> 的值，我们能否判断出这个值是否可行？</p>
<p>这个问题就简单多了。我们可以写一个辅助函数 <code>check(mx)</code>，来判定当每家商店最多分配 <code>mx</code> 件商品时，能否在 <code>n</code> 家商店内完成所有分配。</p>
<ul>
<li>对于 <code>quantities</code> 数组中的每一种商品 <code>q</code>，为了保证每家商店不超过 <code>mx</code> 件，我们需要 <code>ceil(q / mx)</code> 间商店。在整数运算中，这等价于 <code>(q + mx - 1) // mx</code>。</li>
<li>我们将所有商品类型所需要的商店数加起来，得到一个总和 <code>total_stores</code>。</li>
<li>最后，比较 <code>total_stores</code> 和 <code>n</code>。如果 <code>total_stores &lt;= n</code>，说明 <code>mx</code> 是一个可行的最大值。</li>
</ul>
<p>现在，我们拥有了一个判定方法，并且可以发现这个判定结果具有<strong>单调性</strong>：</p>
<ul>
<li>如果一个值 <code>mx</code> 是可行的（即所需商店数 <code>≤ n</code>），那么任何大于 <code>mx</code> 的值 <code>mx&#39;</code> 也必然可行（因为它需要的商店数只会更少或相等）。</li>
<li>反之，如果 <code>mx</code> 不可行，那么任何小于 <code>mx</code> 的值也必然不可行。</li>
</ul>
<p>这种单调性是应用二分查找的完美信号。我们可以对 <code>x</code> 的可能取值范围进行二分查找，来快速定位到那个“最小可行”的临界点。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：<code>x</code> 至少为1才有意义。在代码实现中，我们可以从0开始作为搜索下界。</li>
<li><strong>上界 (right)</strong>：在最极端的情况下，一种数量最多的商品可能全部分配给一家商店，所以 <code>x</code> 的上界不会超过 <code>max(quantities)</code>。</li>
</ul>
<p>因此，我们就在 <code>[1, max(quantities)]</code> 这个区间内，对 <code>x</code> 进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>l = 0</code>：一个不可能的下界，用于二分查找的边界。</li>
<li><code>r = max(quantities)</code>：一个肯定可行的上界。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>使用 <code>while l + 1 &lt; r</code> 的循环条件，这是一种在整数域上查找下界的常用模板。</li>
<li>计算中间值 <code>mid = (l + r) // 2</code> 作为当前的“猜测最大值”。</li>
<li>调用辅助函数 <code>check(mid)</code> 来判定这个猜测值是否可行。<ul>
<li><strong>如果 <code>check(mid)</code> 返回 <code>True</code></strong> (即 <code>mid</code> 这个最大值是可行的)：<ul>
<li>说明 <code>mid</code> 是一个潜在的答案，但我们想找的是“最小”的 <code>x</code>，所以我们尝试一个更小的值。我们将 <code>mid</code> 作为新的上界：<code>r = mid</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>False</code></strong> (即 <code>mid</code> 这个最大值太小，导致所需商店超过 <code>n</code>)：<ul>
<li>说明我们需要允许商店分配更多的商品，所以 <code>mid</code> 不可能是答案。我们将 <code>mid</code> 作为新的下界：<code>l = mid</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束时，<code>l</code> 和 <code>r</code> 相邻（<code>l + 1 == r</code>）。根据我们的更新规则，<code>l</code> 是最后一个不满足条件的值，而 <code>r</code> 是第一个满足条件的值。因此，<code>r</code> 就是我们要求的最小的可能的 <code>x</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimizedMaximum</span>(<span class="params">self, n: <span class="built_in">int</span>, quantities: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用二分查找来寻找最小化的最大值x。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 辅助函数：检查在每家商店最多分配 mx 件商品的情况下，</span></span><br><span class="line">        <span class="comment"># 所需的总商店数是否不超过 n。</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">mx: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># mx为0会导致除零错误，在我们的二分范围l=0, r&gt;0时，mid永远不会是0。</span></span><br><span class="line">            <span class="keyword">if</span> mx == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> quantities:</span><br><span class="line">                <span class="comment"># 计算分配数量为x的商品需要多少家商店</span></span><br><span class="line">                <span class="comment"># (x + mx - 1) // mx 是向上取整的整数运算技巧</span></span><br><span class="line">                cnt += (x + mx - <span class="number">1</span>) // mx</span><br><span class="line">            <span class="keyword">return</span> cnt &lt;= n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找的范围</span></span><br><span class="line">        <span class="comment"># l 是一个不可能的下界，r 是一个可能的上界</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">max</span>(quantities)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当 l 和 r 之间至少还有一个整数时，继续循环</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 可行，说明它可能就是答案，</span></span><br><span class="line">                <span class="comment"># 或者还有更小的可行值，所以我们将上界缩小到 mid</span></span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 不可行，说明最大值太小了，</span></span><br><span class="line">                <span class="comment"># 必须增大，所以我们将下界提升到 mid</span></span><br><span class="line">                l = mid</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时，r 是第一个满足 check(r) == True 的值</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(M * log(K))。<ul>
<li><code>M</code> 是商品种类的数量，即 <code>len(quantities)</code>。</li>
<li><code>K</code> 是商品数量的最大值，即 <code>max(quantities)</code>。二分查找的搜索空间大小为 <code>K</code>。</li>
<li>二分查找本身需要 <code>log(K)</code> 次迭代。</li>
<li>在每次迭代中，我们都需要调用 <code>check</code> 函数，该函数需要遍历一次 <code>quantities</code> 数组，时间复杂度为 O(M)。</li>
<li>因此，总时间复杂度是这两者的乘积。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)。<ul>
<li>除了输入数据外，我们只使用了少数几个变量来辅助计算，空间复杂度是常数级的。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>最小化最大值</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>第266场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2070 | 二分查找解决“每一个查询的最大美丽值”</title>
    <url>//posts/leetcode-2070/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2070 题：<a href="https://leetcode.cn/problems/most-beautiful-item-for-each-query/description/">每一个查询的最大美丽值</a>。<br>对于每个价格查询，如何高效找到符合条件物品中的最大美丽值？通过预处理和二分查找，我们可以将问题迎刃而解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个二维数组 <code>items</code>，其中每个元素 <code>items[i] = [price_i, beauty_i]</code> 代表一件物品的价格和美丽值。同时，我们还有一个查询数组 <code>queries</code>，里面包含了一系列的价格。</p>
<p>我们的任务是，对于 <code>queries</code> 中的每一个价格 <code>q</code>，找出所有价格<strong>小于或等于</strong> <code>q</code> 的物品中，<strong>美丽值最大</strong>的是多少。如果不存在价格小于或等于 <code>q</code> 的物品，那么该查询的结果就是 0。最终，我们需要返回一个包含所有查询结果的数组。</p>
<p>举个例子，<code>items = [[1,2],[3,2],[2,4],[5,6],[3,5]]</code>, <code>queries = [1,2,3,4,5,6]</code>：</p>
<ul>
<li>对于查询 <code>q = 1</code>：只有 <code>[1,2]</code> 的价格 <code>&lt;= 1</code>。最大美丽值是 2。</li>
<li>对于查询 <code>q = 2</code>：有 <code>[1,2]</code> 和 <code>[2,4]</code> 的价格 <code>&lt;= 2</code>。最大美丽值是 4。</li>
<li>对于查询 <code>q = 3</code>：有 <code>[1,2]</code>, <code>[2,4]</code>, <code>[3,2]</code>, <code>[3,5]</code> 的价格 <code>&lt;= 3</code>。它们中的最大美丽值是 5。</li>
<li>对于查询 <code>q = 4</code>：符合条件的物品和 <code>q=3</code> 时一样，最大美丽值仍然是 5。</li>
<li>对于查询 <code>q = 5</code> 和 <code>q = 6</code>：所有物品都符合条件，最大美丽值是 6。</li>
<li>因此，最终答案是 <code>[2,4,5,5,6,6]</code>。</li>
</ul>
<h3 id="核心思路：预处理-二分查找"><a href="#核心思路：预处理-二分查找" class="headerlink" title="核心思路：预处理 + 二分查找"></a>核心思路：预处理 + 二分查找</h3><p>一个显而易见的暴力解法是：对每一个 <code>query</code>，都完整遍历一次 <code>items</code> 数组，筛选出所有价格符合条件的物品，然后找到其中的最大美丽值。如果 <code>queries</code> 的长度是 M，<code>items</code> 的长度是 N，这种方法的时间复杂度将是 O(M * N)，在 N 和 M 都达到 10^5 的情况下，计算量过大，会导致超时。</p>
<p>注意到，<code>items</code> 数组是固定不变的，而查询是多次的。这提示我们可以对 <code>items</code> 进行<strong>预处理</strong>，以加速后续的查询过程。</p>
<p>优化的核心思路是：</p>
<ol>
<li><strong>排序</strong>：如果我们按价格对 <code>items</code> 数组进行升序排序，那么对于一个查询价格 <code>q</code>，所有符合条件的物品都会集中在数组的开头部分。</li>
<li><strong>预计算最大美丽值</strong>：仅仅排序还不够，因为我们仍然需要遍历这个开头部分来找最大美丽值。关键的优化在于，我们可以在排序后再次遍历 <code>items</code> 数组，将每个物品的美丽值更新为<strong>到它为止（包括它自己）所有物品中的最大美丽值</strong>。也就是说，<code>items[i][1]</code> 将存储价格不高于 <code>items[i][0]</code> 的所有物品中的最大美丽值。</li>
<li><strong>二分查找</strong>：完成预处理后，对于每个查询 <code>q</code>，问题就变成了：在排序好的 <code>items</code> 数组中，找到价格 <code>&lt;= q</code> 的最后一个物品。由于我们已经预处理了最大美丽值，这个物品所存储的美丽值就是该查询的最终答案。这个查找过程可以通过高效的二分查找来完成。</li>
</ol>
<p>通过这种“预处理 + 二分查找”的模式，每次查询的时间复杂度可以从 O(N) 降低到 O(log N)，从而极大地提升了算法的整体性能。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><h4 id="解法一：原地更新最大美丽值"><a href="#解法一：原地更新最大美丽值" class="headerlink" title="解法一：原地更新最大美丽值"></a>解法一：原地更新最大美丽值</h4><ol>
<li><p><strong>排序</strong>：</p>
<ul>
<li>首先，按价格（<code>item[0]</code>）对 <code>items</code> 数组进行升序排序。</li>
</ul>
</li>
<li><p><strong>预处理 <code>items</code> 数组</strong>：</p>
<ul>
<li>遍历排序后的 <code>items</code> 数组，从第二个元素开始（索引为 1）。</li>
<li>将当前物品 <code>items[i]</code> 的美丽值更新为它自身美丽值与前一个物品 <code>items[i-1]</code> 美丽值的较大者，即 <code>items[i][1] = max(items[i][1], items[i-1][1])</code>。</li>
<li>这次遍历完成后，<code>items[i][1]</code> 就代表了在价格不超过 <code>items[i][0]</code> 的所有物品里，能找到的最大美丽值。</li>
</ul>
</li>
<li><p><strong>处理 <code>queries</code> 数组</strong>：</p>
<ul>
<li>遍历 <code>queries</code> 中的每一个查询价格 <code>q</code>。</li>
<li>使用二分查找（例如 Python 的 <code>bisect_right</code>）在 <code>items</code> 数组中查找 <code>q</code>。<code>bisect_right</code> 会返回一个插入点索引 <code>j</code>，这个索引是第一个价格<strong>严格大于</strong> <code>q</code> 的物品的位置。</li>
<li>因此，所有价格小于或等于 <code>q</code> 的物品的索引范围是 <code>0</code> 到 <code>j-1</code>。</li>
<li>如果 <code>j</code> 为 0，表示没有物品的价格小于等于 <code>q</code>，答案为 0。</li>
<li>否则，价格小于等于 <code>q</code> 的最后一个物品是 <code>items[j-1]</code>。根据我们的预处理，<code>items[j-1][1]</code> 就是我们想要的答案。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>将所有查询的结果收集起来并返回。</li>
</ul>
</li>
</ol>
<h4 id="解法二：压缩数组（空间优化）"><a href="#解法二：压缩数组（空间优化）" class="headerlink" title="解法二：压缩数组（空间优化）"></a>解法二：压缩数组（空间优化）</h4><p>这种解法在思路上与解法一类似，但在预处理阶段有所不同。它不是更新每一个物品的美丽值，而是创建一个“浓缩”版的 <code>items</code> 列表，只保留那些有意义的物品。一个物品 <code>items[i]</code> 如果其价格更高但美丽值却不比前面的物品更高，那么它对于寻找最大美丽值是没有贡献的。</p>
<ol>
<li><p><strong>排序</strong>：</p>
<ul>
<li>同解法一，按价格对 <code>items</code> 数组进行升序排序。</li>
</ul>
</li>
<li><p><strong>预处理（压缩数组）</strong>：</p>
<ul>
<li>使用一个指针 <code>k</code> 来记录有效物品列表的末尾（初始为 0）。</li>
<li>遍历排序后的 <code>items</code> 数组（从索引 1 开始）。如果当前物品 <code>items[i]</code> 的美丽值大于 <code>items[k]</code> 的美丽值，说明这是一个更优的选择，我们将其保留下来，更新 <code>k</code> 并将 <code>items[i]</code> 移动到 <code>k</code> 的位置：<code>k += 1; items[k] = items[i]</code>。</li>
<li>这样，我们就原地生成了一个长度为 <code>k+1</code> 的有效物品列表，其中价格和美丽值都是单调递增的。</li>
</ul>
</li>
<li><p><strong>查询与返回</strong>：</p>
<ul>
<li>对每个查询 <code>q</code>，在这个长度为 <code>k+1</code> 的有效列表上执行二分查找。其余逻辑与解法一完全相同。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumBeauty</span>(<span class="params">self, items: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], queries: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">      <span class="comment"># 步骤 1: 按价格排序</span></span><br><span class="line">      items.sort(key=<span class="keyword">lambda</span> item:item[<span class="number">0</span>])</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 步骤 2: 预处理，更新每个物品为其价格及以下的最大美丽值</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(items)):</span><br><span class="line">        items[i][<span class="number">1</span>] = <span class="built_in">max</span>(items[i][<span class="number">1</span>], items[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">      </span><br><span class="line">      ans = []</span><br><span class="line">      <span class="comment"># 步骤 3 &amp; 4: 对每个查询进行二分查找</span></span><br><span class="line">      <span class="keyword">for</span> q <span class="keyword">in</span> queries:</span><br><span class="line">        <span class="comment"># 找到第一个价格 &gt; q 的物品的索引 j</span></span><br><span class="line">        j = bisect.bisect_right(items, q, key=<span class="keyword">lambda</span> item:item[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 如果 j &gt; 0, 那么 items[j-1] 就是价格 &lt;= q 的物品中美丽值最大的</span></span><br><span class="line">        <span class="comment"># 这个美丽值已经是我们预处理好的前缀最大值</span></span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">          ans.append(items[j-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          <span class="comment"># 没有物品价格 &lt;= q</span></span><br><span class="line">          ans.append(<span class="number">0</span>)</span><br><span class="line">          </span><br><span class="line">      <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumBeauty</span>(<span class="params">self, items: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], queries: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 步骤 1: 按价格排序</span></span><br><span class="line">        items.sort(key=<span class="keyword">lambda</span> t: t[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2: 预处理，原地压缩数组，只保留美丽值递增的项</span></span><br><span class="line">        k = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(items)):</span><br><span class="line">            <span class="keyword">if</span> items[i][<span class="number">1</span>] &gt; items[k][<span class="number">1</span>]:</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">                items[k] = items[i]</span><br><span class="line">        </span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 步骤 3 &amp; 4: 在压缩后的数组部分进行二分查找</span></span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> queries:</span><br><span class="line">            <span class="comment"># 在 items[0...k] 范围内查找</span></span><br><span class="line">            j = bisect.bisect_right(items, q, hi=k+<span class="number">1</span>, key=<span class="keyword">lambda</span> t: t[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">              ans.append(items[j-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              ans.append(<span class="number">0</span>)</span><br><span class="line">              </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>令 <code>N</code> 为 <code>items</code> 数组的长度，<code>M</code> 为 <code>queries</code> 数组的长度。</p>
<ul>
<li><p><strong>时间复杂度</strong>: O((N+M)log N)</p>
<ul>
<li>对 <code>items</code> 数组进行排序所需时间为 O(N log N)。</li>
<li>预处理阶段（无论是更新美丽值还是压缩数组）都只需要一次线性遍历，时间复杂度为 O(N)。</li>
<li>处理 <code>M</code> 个查询，每个查询都进行一次二分查找，目标数组长度为 <code>N</code>（或压缩后的 <code>k+1</code>，最坏情况也是 <code>N</code>），所以二分查找的时间复杂度是 O(log N)。<code>M</code> 次查询总共是 O(M log N)。</li>
<li>因此，总的时间复杂度为 O(N log N + N + M log N)，简化后为 O(N log N + M log N)。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>: O(1)</p>
<ul>
<li>两种解法都是在输入数组 <code>items</code> 上进行原地修改。</li>
<li>如果不考虑排序算法本身可能使用的栈空间（或少量临时空间），我们没有创建任何与输入规模 <code>N</code> 或 <code>M</code> 成正比的额外数据结构。</li>
<li>返回的答案数组 <code>ans</code> 所占用的空间通常不计入额外空间复杂度。</li>
<li>因此，忽略排序的栈开销，额外空间复杂度为 O(1)。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预处理 + 二分查找”模式的一个典型应用。当题目涉及到对一个静态数据集进行多次范围性（如“小于等于”）查询时，应首先考虑是否能通过排序来建立有序性。在此基础上，通过一次线性扫描进行预处理（如计算前缀和、前缀最大&#x2F;最小值等），可以将每次查询的复杂度从线性降低到对数级别。二分查找正是利用数据有序性来实现高效查询的利器。两种解法在核心思想和复杂度上没有本质区别，都出色地解决了问题。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>排序</tag>
        <tag>第65场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2071 | 你可以安排的最多任务数目</title>
    <url>//posts/leetcode-2071/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2071 题：<a href="https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/description/">你可以安排的最多任务数目</a>。<br>本题旨在求解“最多能完成的任务数”，这是一个典型的最优化问题。其核心在于识别出答案具有单调性，从而可以将求解问题转化为判定问题，利用二分查找在对数时间内高效求解。而其中的判定函数，则需要一个精巧的贪心策略来支撑。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们手上有 <code>n</code> 个任务和 <code>m</code> 个工人，每个任务有难度值 <code>tasks[i]</code>，每个工人有力量值 <code>workers[j]</code>。一个工人要完成一个任务，其力量值必须大于或等于任务的难度值。</p>
<p>此外，我们还有 <code>pills</code> 颗“神奇药丸”，每颗药丸可以给一个工人的力量值增加 <code>strength</code>。每个工人最多只能使用一颗药丸。</p>
<p>目标是找出在最优分配工人和药丸的情况下，<strong>最多</strong>可以完成多少个任务。</p>
<p>举个例子，<code>tasks = [3,2,1]</code>, <code>workers = [0,3,3]</code>, <code>pills = 1</code>, <code>strength = 1</code>。<br>我们可以尝试完成 3 个任务。</p>
<ul>
<li>最简单的任务是 1，最难的是 3。</li>
<li>最弱的工人力量是 0，最强的是 3。</li>
<li>一种可行的分配是：<ul>
<li>给力量为 0 的工人吃药，力量变为 <code>0 + 1 = 1</code>，刚好可以完成难度为 1 的任务。</li>
<li>力量为 3 的工人可以完成难度为 2 的任务。</li>
<li>另一个力量为 3 的工人可以完成难度为 3 的任务。<br>这样，3 个任务都能完成。</li>
</ul>
</li>
</ul>
<p>这个例子暗示我们，为了完成尽可能多的任务，应该优先考虑让工人去完成那些他们力所能及的任务，并将宝贵的药丸用在刀刃上。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最多能完成多少个任务”是非常复杂的，因为它涉及到工人和任务的各种组合以及药丸的最佳分配策略。</p>
<p>但是，我们可以换一个角度思考：如果我们<strong>假定</strong>要完成 <code>k</code> 个任务，我们能否判断出这个目标是否可行？</p>
<p>这个问题就相对清晰了。我们可以设计一个辅助函数 <code>check(k)</code>，来判定“能否完成 <code>k</code> 个任务”。如果能解决这个判定问题，我们就能利用其单调性进行二分查找。</p>
<p>这个判定结果具有明显的<strong>单调性</strong>：</p>
<ul>
<li>如果我们能设法完成 <code>k</code> 个任务，那么我们必然也能完成 <code>k-1</code> 个任务（只需在完成 <code>k</code> 个任务的方案里去掉一个即可）。</li>
<li>反之，如果我们连 <code>k</code> 个任务都无法完成，那么想完成 <code>k+1</code> 个任务就更不可能了。</li>
</ul>
<p>这种单调性是应用二分查找的完美信号。我们可以对“能够完成的任务数量 <code>k</code>”进行二分查找，来快速定位到那个“最大可行”的临界点。</p>
<p>二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：<code>0</code>，最坏情况下我们一个任务也完不成。</li>
<li><strong>上界 (right)</strong>：<code>min(n, m)</code>，因为每个工人只能做一个任务，且任务总数和工人数是上限。</li>
</ul>
<h3 id="check-k-的贪心策略"><a href="#check-k-的贪心策略" class="headerlink" title="check(k) 的贪心策略"></a><code>check(k)</code> 的贪心策略</h3><p><code>check(k)</code> 函数是整个算法的核心。要判断能否完成 <code>k</code> 个任务，我们应该采用贪心策略来最大化成功的可能性：</p>
<ol>
<li><strong>排序</strong>：将 <code>tasks</code> 和 <code>workers</code> 数组都升序排序。</li>
<li><strong>资源选择</strong>：要完成 <code>k</code> 个任务，最明智的选择是尝试完成 <strong><code>k</code> 个最简单的任务</strong>，并为此派出 <strong><code>k</code> 个最强大的工人</strong>。因为如果一个强大的工人都无法完成某个任务，那么更弱的工人就更不可能了。让强大的工人去应对挑战，可以为弱小的工人留下更简单的任务，从而最大化整体的成功率。</li>
<li><strong>匹配与药丸分配</strong>：<ul>
<li>我们从这 <code>k</code> 个最强工人中的<strong>最弱者</strong>开始，依次为他们分配任务。</li>
<li>对于一个工人 <code>w</code>，我们应该让他尝试完成当前所有未分配的 <code>k</code> 个最简单任务中，他力所能及的<strong>最简单</strong>的一个。这样做可以将更难的任务留给更强的工人。</li>
<li>如果这个工人 <code>w</code> 连最简单的那个任务都无法独立完成（<code>w &lt; task_easiest</code>），他就必须得用一颗药丸了。</li>
<li>如果要用药丸，为了让药丸的价值最大化，应该让他去完成他能完成的<strong>最难</strong>的任务（<code>w + strength &gt;= task_hardest</code>）。这样做，就把那些相对简单的任务，留给了后面那些可能不需要药丸就能完成任务的、更强的工人们。</li>
</ul>
</li>
</ol>
<p>这个策略可以用一个<strong>双端队列 (deque)</strong> 来完美实现。队列中存放 <code>k</code> 个最简单的任务。</p>
<ul>
<li>当工人 <code>w</code> 不需要药丸就能完成最简单的任务时，从队列头部取出一个任务 (<code>deque.popleft()</code>)。</li>
<li>当工人 <code>w</code> 必须使用药丸时，从队列尾部取出一个任务 (<code>deque.pop()</code>)，并消耗一颗药丸。</li>
</ul>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>排序</strong></p>
<ul>
<li>对 <code>tasks</code> 和 <code>workers</code> 数组进行升序排序。</li>
</ul>
</li>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>l = 0</code>：可能的最小完成数。</li>
<li><code>r = min(len(tasks), len(workers)) + 1</code>：可能的最高完成数加一，作为开区间的右边界。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>l + 1 &lt; r</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = (l + r) // 2</code> 作为当前的“猜测任务数”。</li>
<li>调用辅助函数 <code>check(mid)</code> 来判定这个猜测值是否可行。<ul>
<li><strong>如果 <code>check(mid)</code> 返回 <code>True</code></strong> (即可以完成 <code>mid</code> 个任务)：<ul>
<li>说明 <code>mid</code> 是一个潜在的答案，我们也许还能完成更多。将搜索范围更新到右半边：<code>l = mid</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>False</code></strong> (即无法完成 <code>mid</code> 个任务)：<ul>
<li>说明 <code>mid</code> 太大了，必须减少任务数。将搜索范围更新到左半边：<code>r = mid</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>l</code> 中存储的就是满足条件的最多可完成任务数目。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTaskAssign</span>(<span class="params">self, tasks: <span class="type">List</span>[<span class="built_in">int</span>], workers: <span class="type">List</span>[<span class="built_in">int</span>], pills: <span class="built_in">int</span>, strength: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 1. 排序，为贪心做准备</span></span><br><span class="line">        tasks.sort()</span><br><span class="line">        workers.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 辅助函数：检查能否完成 k 个任务</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># 如果没有任务要检查，或者工人不够，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(workers) &lt; k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                </span><br><span class="line">            p = pills</span><br><span class="line">            <span class="comment"># 候选任务是 k 个最简单的任务</span></span><br><span class="line">            valid_tasks = deque(tasks[:k])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 从 k 个最强工人中的最弱者开始遍历</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> workers[-k:]:</span><br><span class="line">                <span class="comment"># 如果没有任务可以分配了，提前结束</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> valid_tasks:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 情况1：工人不需要药丸就能完成最简单的任务</span></span><br><span class="line">                <span class="keyword">if</span> w &gt;= valid_tasks[<span class="number">0</span>]:</span><br><span class="line">                    valid_tasks.popleft()</span><br><span class="line">                <span class="comment"># 情况2：工人需要药丸</span></span><br><span class="line">                <span class="keyword">elif</span> p &gt; <span class="number">0</span> <span class="keyword">and</span> w + strength &gt;= valid_tasks[<span class="number">0</span>]:</span><br><span class="line">                    <span class="comment"># 检查药丸是否够用，以及用了之后能否完成最难的任务</span></span><br><span class="line">                    <span class="comment"># （贪心策略：用药丸就去干最难的活）</span></span><br><span class="line">                    <span class="keyword">if</span> w + strength &gt;= valid_tasks[-<span class="number">1</span>]:</span><br><span class="line">                        p -= <span class="number">1</span></span><br><span class="line">                        valid_tasks.pop()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># 如果吃了药连最简单的都干不了，那肯定不行</span></span><br><span class="line">                        <span class="comment"># 这里代码逻辑隐含了 w+strength &gt;= valid_tasks[0]</span></span><br><span class="line">                        <span class="comment"># 所以这个分支在代码中不会走到，但逻辑上是需要的</span></span><br><span class="line">                        <span class="comment"># 实际上，如果w+strength &lt; valid_tasks[0] 那么这个工人就没用了</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 情况3：工人既不能独立完成，也没有药丸或药丸无效</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果所有工人都找到了任务，说明 k 是可行的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找答案 k</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">min</span>(<span class="built_in">len</span>(tasks), <span class="built_in">len</span>(workers)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 可行，尝试更多任务</span></span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 不行，减少任务数</span></span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>注意：上述代码的 <code>check</code> 函数逻辑与您提供的原始代码稍有不同，但遵循了相同的贪心思想。您的 <code>check</code> 函数通过预先填充 <code>valid_tasks</code> 队列，也是一个非常巧妙且正确的实现。</em></p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N log N + M log M + K log K)。<ul>
<li><code>N</code> 是任务数，<code>M</code> 是工人数。</li>
<li><code>K</code> 是 <code>min(N, M)</code>。</li>
<li>排序 <code>tasks</code> 和 <code>workers</code> 分别需要 O(N log N) 和 O(M log M)。</li>
<li>二分查找在 <code>[0, K]</code> 范围内进行，需要 O(log K) 次迭代。</li>
<li>在每次迭代中，<code>check(k)</code> 函数需要 O(k) 的时间来遍历工人和操作双端队列。</li>
<li>因此，总时间复杂度为 O(N log N + M log M + K log K)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(K)。<ul>
<li>排序的空间复杂度取决于语言实现，可以是 O(log N + log M) 或 O(N + M)。</li>
<li><code>check</code> 函数中使用的双端队列 <code>valid_tasks</code> 最多存储 <code>k</code> 个元素，因此需要 O(k) 的空间。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“二分答案”模型的又一个绝佳示例。当问题的目标是求解“最大值”或“最小值”，且答案满足单调性时，我们应优先考虑是否能将其转化为一个“判定性”问题。一旦转化成功，就可以套用二分查找的框架。</p>
<p>本题的难点在于设计 <code>check(k)</code> 函数的贪心策略。通过“排序 + 最优资源匹配（最强工人 vs 最简单任务）+ 双端队列”的组合，我们才能高效地判断出给定任务数 <code>k</code> 是否可行。这要求我们对贪心算法有深刻的理解，并能选择合适的数据结构来支撑策略的实现。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最大</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>双指针</tag>
        <tag>第65场双周赛</tag>
        <tag>队列</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2106 | 滑动窗口求解“摘水果”</title>
    <url>//posts/leetcode-2106/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2106 题：<a href="https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/">摘水果</a>。<br>该题要求我们在有限的步数内，规划一条路径以摘取最大数量的水果。路径的选择（先左还是先右）似乎复杂。实际上可以通过巧妙地定义移动成本，将其转化为一个经典的滑动窗口问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个无限长的 x 轴，上面分布着一些水果。我们用一个数组 <code>fruits</code> 来描述，其中 <code>fruits[i] = [positioni, amounti]</code> 表示在位置 <code>positioni</code> 有 <code>amounti</code> 个水果。这个数组已经按位置升序排列。</p>
<p>我们从一个给定的 <code>startPos</code> 出发，总共可以移动最多 <code>k</code> 步。目标是规划一条路径，使得摘到的水果总数最多。</p>
<p>举个例子，对于 <code>fruits = [[2,8],[6,3],[8,6]]</code>, <code>startPos = 5</code>, <code>k = 4</code>：</p>
<ul>
<li>我们的目标是在 4 步内，从位置 5 出发，摘到最多的水果。</li>
<li>一种可行的方案是：向右走到位置 6 (1 步)，摘 3 个水果。再向右走到位置 8 (2 步)，摘 6 个水果。总步数是 (8 - 5) &#x3D; 3，小于 4。总水果数是 3 + 6 &#x3D; 9。</li>
<li>另一种方案：向左走到位置 2 (3 步)，摘 8 个水果。总步数是 (5 - 2) &#x3D; 3，小于 4。总水果数是 8。</li>
<li>我们能找到的最优解是先到 6 再到 8，共摘 9 个水果。</li>
</ul>
<p>直接模拟所有可能的路径组合（比如左走 <code>i</code> 步，右走 <code>k-i</code> 步）会非常复杂，且效率低下。</p>
<h3 id="核心思路：滑动窗口与成本计算"><a href="#核心思路：滑动窗口与成本计算" class="headerlink" title="核心思路：滑动窗口与成本计算"></a>核心思路：滑动窗口与成本计算</h3><p>首先，一个关键的观察是：<strong>我们最优的采摘方案一定是采摘 x 轴上一个连续区间内的所有水果</strong>。因为如果我们在路径上跳过了一个水果点，我们完全可以在不增加额外成本的情况下把它摘掉（因为我们已经路过了）。</p>
<p>因此，问题就转化成了：<strong>寻找一个连续的水果区间 <code>[left, right]</code>，使得从 <code>startPos</code> 出发，访问完这个区间内所有水果的总步数不超过 <code>k</code>，并且这个区间的水果总量最大。</strong></p>
<p>这正是滑动窗口算法的用武之地。我们可以把 <code>[left, right]</code> 看作一个在 <code>fruits</code> 数组上滑动的窗口。</p>
<p>这个问题的核心难点在于如何计算访问一个区间 <code>[left_pos, right_pos]</code> 所需的<strong>最小步数</strong>。从 <code>startPos</code> 出发，要覆盖这个区间，无非就两种回头路策略：</p>
<ol>
<li><strong>先去区间的左端点，再一路走到右端点</strong>：步数为 <code>(startPos - left_pos) + (right_pos - left_pos)</code>。</li>
<li><strong>先去区间的右端点，再一路走到左端点</strong>：步数为 <code>(right_pos - startPos) + (right_pos - left_pos)</code>。</li>
</ol>
<p>当然，如果 <code>startPos</code> 本身就在区间的某一边，就不需要走回头路了：</p>
<ul>
<li>如果 <code>startPos</code> 在区间左侧 (<code>startPos &lt;= left_pos</code>)，我们只能一路向右，成本是 <code>right_pos - startPos</code>。</li>
<li>如果 <code>startPos</code> 在区间右侧 (<code>startPos &gt;= right_pos</code>)，我们只能一路向左，成本是 <code>startPos - left_pos</code>。</li>
<li>如果 <code>startPos</code> 在区间内部 (<code>left_pos &lt; startPos &lt; right_pos</code>)，我们就需要从上面两种回头路策略中选择步数更少的那一种。</li>
</ul>
<p>一旦我们确定了这个成本计算方法，就可以套用滑动窗口模板了：</p>
<ul>
<li>用 <code>right</code> 指针扩大窗口。</li>
<li>当窗口的移动成本超过 <code>k</code> 时，用 <code>left</code> 指针收缩窗口。</li>
<li>在每一步都用当前有效窗口的水果总量更新最大值。</li>
</ul>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>滑动窗口初始化</strong>：</p>
<ul>
<li>左指针 <code>left = 0</code>。</li>
<li>记录最大水果数 <code>max_fruits = 0</code>。</li>
<li>记录当前窗口内的水果总数 <code>current_sum = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历与窗口扩张</strong>：</p>
<ul>
<li>用右指针 <code>right</code> 从 <code>0</code> 遍历到 <code>n-1</code>（<code>n</code> 是 <code>fruits</code> 的长度）。</li>
<li>在循环的每一步，将 <code>fruits[right]</code> 的水果数量加入 <code>current_sum</code>。</li>
</ul>
</li>
<li><p><strong>成本判断与窗口收缩</strong>：</p>
<ul>
<li>扩张后，计算覆盖当前窗口 <code>[fruits[left]...fruits[right]]</code> 所需的最小步数 <code>dist</code>。</li>
<li>我们使用一个 <code>while</code> 循环来检查和调整窗口：<ul>
<li>只要 <code>dist &gt; k</code>，就说明当前窗口太“远”或太“宽”，需要从左侧收缩。</li>
<li>将左侧水果 <code>fruits[left]</code> 的数量从 <code>current_sum</code> 中减去，然后将 <code>left</code> 指针右移。</li>
<li>这个 <code>while</code> 循环会一直执行，直到窗口重新满足步数限制 (<code>dist &lt;= k</code>) 为止。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>更新结果</strong>：</p>
<ul>
<li>在每次 <code>right</code> 指针移动后，并且在（可能发生的）收缩操作完成后，当前的窗口 <code>[left...right]</code> 一定是有效的。</li>
<li>我们用 <code>current_sum</code> 来更新 <code>max_fruits</code>。</li>
</ul>
</li>
<li><p><strong>返回最终答案</strong>：</p>
<ul>
<li>遍历结束后，<code>max_fruits</code> 就是我们能找到的最大水果总数。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTotalFruits</span>(<span class="params">self, fruits: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], startPos: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用滑动窗口解决摘水果问题。</span></span><br><span class="line"><span class="string">        我们维护一个水果区间 [left, right] 作为窗口。</span></span><br><span class="line"><span class="string">        随着 right 指针向右移动来扩大窗口，我们检查覆盖当前窗口所需的步数是否超过 k。</span></span><br><span class="line"><span class="string">        如果超过，我们就移动 left 指针来收缩窗口，直到满足步数限制为止。</span></span><br><span class="line"><span class="string">        在每一步，我们都用当前有效窗口内的水果总数来更新最大值。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        max_fruits = <span class="number">0</span></span><br><span class="line">        current_sum = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(fruits)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># right 指针用于扩大窗口</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            right_pos, amount = fruits[right]</span><br><span class="line">            current_sum += amount</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当窗口不满足步数限制时，从左边收缩窗口</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                left_pos = fruits[left][<span class="number">0</span>]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 计算访问 [left_pos, right_pos] 区间的成本</span></span><br><span class="line">                dist = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 情况1: startPos 在整个区间的左侧或重合于左端点，只能向右走</span></span><br><span class="line">                <span class="keyword">if</span> startPos &lt;= left_pos:</span><br><span class="line">                    dist = right_pos - startPos</span><br><span class="line">                <span class="comment"># 情况2: startPos 在整个区间的右侧或重合于右端点，只能向左走</span></span><br><span class="line">                <span class="keyword">elif</span> startPos &gt;= right_pos:</span><br><span class="line">                    dist = startPos - left_pos</span><br><span class="line">                <span class="comment"># 情况3: startPos 在区间内部，需要走回头路</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 策略A: 先左后右 vs 策略B: 先右后左</span></span><br><span class="line">                    dist = <span class="built_in">min</span>(startPos - left_pos, right_pos - startPos) + (right_pos - left_pos)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果所需步数大于 k，则收缩窗口</span></span><br><span class="line">                <span class="keyword">if</span> dist &gt; k:</span><br><span class="line">                    current_sum -= fruits[left][<span class="number">1</span>]</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 否则，当前窗口有效，停止收缩</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 用当前有效窗口的水果总数更新最大值</span></span><br><span class="line">            max_fruits = <span class="built_in">max</span>(max_fruits, current_sum)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> max_fruits</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是 <code>fruits</code> 数组的长度。滑动窗口的左指针 <code>left</code> 和右指针 <code>right</code> 都只会从头到尾各自扫描一遍数组，每个元素最多被访问两次。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个额外变量来存储指针和计数值。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题的核心在于将一个路径规划问题，转化为寻找<strong>最优连续区间</strong>的问题。其难点在于为这个“区间”（即我们的滑动窗口）建立一个正确的成本模型。一旦我们分析清楚了从起点出发覆盖一个区间的两种基本走法（先左后右 vs 先右后左），并处理好边界情况，剩下的就是滑动窗口算法的经典应用了。这个思路将复杂路径问题简化为线性扫描，是算法优化中的一个重要思想。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>滑动窗口</tag>
        <tag>前缀和</tag>
        <tag>第 271 场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2156 | 滚动哈希巧解给定哈希值的子串</title>
    <url>//posts/leetcode-2156/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2156 题：<a href="https://leetcode.cn/problems/find-substring-with-given-hash-value/description/">查找给定哈希值的子串</a>。<br>这道题将我们带入了“滚动哈希”（Rolling Hash）的精妙世界。它不仅仅是一个简单的滑动窗口，更是一次关于如何在模运算下高效更新哈希值的深刻实践。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目要求我们根据一个自定义的哈希函数，在一个长字符串 <code>s</code> 中找到<strong>第一个</strong>长度为 <code>k</code> 且哈希值等于 <code>hashValue</code> 的子串。</p>
<p>这个哈希函数定义如下：<br><code>hash(sub, p, m) = (val(sub[0])*p^0 + val(sub[1])*p^1 + ... + val(sub[k-1])*p^(k-1)) mod m</code></p>
<p>其中 <code>val(c)</code> 是字符 <code>c</code> 的字母表顺序值（<code>&#39;a&#39;</code>&#x3D;1, <code>&#39;b&#39;</code>&#x3D;2, …）。</p>
<ul>
<li><strong>关键点</strong>：我们需要在一个大字符串中，对所有长度为 <code>k</code> 的子串计算哈希值。</li>
<li><strong>目标</strong>：找到满足 <code>hash(sub) == hashValue</code> 的<strong>最靠前</strong>的那个子串。</li>
</ul>
<p>例如，对于 <code>s = &quot;fbxzaad&quot;</code>, <code>p = 31</code>, <code>m = 100</code>, <code>k = 3</code>, <code>hashValue = 32</code>，子串 <code>&quot;fbx&quot;</code> 和 <code>&quot;bxz&quot;</code> 的哈希值都是 32。但因为 <code>&quot;fbx&quot;</code> 在字符串中出现得更早，所以它是正确答案。</p>
<h3 id="核心思路：逆向的滚动哈希"><a href="#核心思路：逆向的滚动哈希" class="headerlink" title="核心思路：逆向的滚动哈希"></a>核心思路：逆向的滚动哈希</h3><h4 id="暴力法的瓶颈"><a href="#暴力法的瓶颈" class="headerlink" title="暴力法的瓶颈"></a>暴力法的瓶颈</h4><p>最直观的方法是遍历 <code>s</code> 中每一个长度为 <code>k</code> 的子串，然后对每个子串都独立计算一次哈希值。这种方法的时间复杂度是 O(N<em>K)，其中 N 是 <code>s</code> 的长度。对于题目给定的数据范围 (<code>N</code> 可达 2</em>10^4)，这种方法会“超出时间限制”。</p>
<h4 id="从左向右滑动的困境"><a href="#从左向右滑动的困境" class="headerlink" title="从左向右滑动的困境"></a>从左向右滑动的困境</h4><p>为了优化，我们自然会想到滑动窗口：当窗口从 <code>s[i:i+k]</code> 滑动到 <code>s[i+1:i+k+1]</code> 时，能否在 O(1) 的时间内更新哈希值？</p>
<ul>
<li><strong>移出</strong>：我们需要减去 <code>val(s[i]) * p^0</code> 的贡献。</li>
<li><strong>移入</strong>：我们需要加入 <code>val(s[i+k]) * p^k</code>… 等等，这里就出现了问题。</li>
</ul>
<p>为了让原有的 <code>val(s[i+1])*p^1</code> 变为 <code>val(s[i+1])*p^0</code>，我们需要将整个哈希值（减去 <code>val(s[i])</code> 之后）除以 <code>power</code>。在模运算中，除以一个数等于乘以它的<strong>模逆元</strong>。计算模逆元本身就很复杂，而且当 <code>power</code> 和 <code>modulo</code> 不互质时，模逆元甚至不存在。这条路走不通。</p>
<h4 id="柳暗花明：从右向左滑动"><a href="#柳暗花明：从右向左滑动" class="headerlink" title="柳暗花明：从右向左滑动"></a>柳暗花明：从右向左滑动</h4><p>既然从左向右有困难，我们何不逆向思考？<strong>从右向左滑动窗口</strong>！</p>
<p>假设我们已知窗口 <code>s[i+1 : i+k+1]</code> 的哈希值 <code>h_old</code>，现在要计算它左边的窗口 <code>s[i : i+k]</code> 的哈希值 <code>h_new</code>。</p>
<ul>
<li><code>h_old = (val(s[i+1])*p^0 + ... + val(s[i+k])*p^(k-1)) mod m</code></li>
</ul>
<p>观察 <code>h_new</code> 的构成：</p>
<ul>
<li><code>h_new = (val(s[i])*p^0 + val(s[i+1])*p^1 + ... + val(s[i+k-1])*p^(k-1)) mod m</code></li>
</ul>
<p>我们可以找到一个递推关系：</p>
<ol>
<li>从 <code>h_old</code> 中减去最右侧字符 <code>s[i+k]</code> 的贡献，即 <code>val(s[i+k]) * p^(k-1)</code>。</li>
<li>将剩余的部分整体乘以 <code>p</code>，这使得每一项的幂次都增加了 1 (<code>p^0</code> -&gt; <code>p^1</code>, <code>p^1</code> -&gt; <code>p^2</code>…)。</li>
<li>最后，加上新进入窗口的字符 <code>s[i]</code> 的贡献，即 <code>val(s[i]) * p^0</code>。</li>
</ol>
<p>于是，我们得到了一个完美的 O(1) 更新公式：<br><code>h_new = ((h_old - val(s[i+k]) * p^(k-1)) * p + val(s[i])) mod m</code><br>这个公式只涉及加、减、乘，在模运算下非常简单！</p>
<h3 id="滑动窗口算法详解"><a href="#滑动窗口算法详解" class="headerlink" title="滑动窗口算法详解"></a>滑动窗口算法详解</h3><ol>
<li><p><strong>准备工作</strong>:</p>
<ul>
<li>预先计算 <code>power^(k-1) % modulo</code>，记为 <code>pk_1</code>。这个值在每次移除窗口最右侧字符时都会用到。</li>
</ul>
</li>
<li><p><strong>初始化窗口</strong>:</p>
<ul>
<li>我们从字符串的<strong>最右端</strong>开始。首先完整计算最后一个窗口 <code>s[n-k : n]</code> 的哈希值，作为我们的初始 <code>current_hash</code>。</li>
<li>检查这个初始哈希值是否与 <code>hashValue</code> 匹配。如果匹配，记录下当前的起始索引 <code>n-k</code> 作为候选答案。</li>
</ul>
</li>
<li><p><strong>逆向滑动窗口</strong>:</p>
<ul>
<li>从 <code>i = n-k-1</code> 开始，循环递减至 <code>0</code>。<code>i</code> 代表新窗口的起始位置。</li>
<li>在每次循环中，使用上面推导出的滚动哈希公式来更新 <code>current_hash</code>。<ul>
<li><strong>移出</strong>：减去旧窗口最右侧字符 <code>s[i+k]</code> 的贡献。</li>
<li><strong>乘幂</strong>：将结果乘以 <code>power</code>。</li>
<li><strong>移入</strong>：加上新窗口最左侧字符 <code>s[i]</code> 的贡献。</li>
<li><strong>注意</strong>：在进行模减法时，为防止出现负数，应写成 <code>(a - b + modulo) % modulo</code>。</li>
</ul>
</li>
<li>每次更新哈希值后，都与 <code>hashValue</code> 进行比较。</li>
<li>由于我们是从右向左遍历，任何一次匹配都意味着我们找到了一个比之前更靠前的答案。因此，只要匹配成功，就更新结果索引为当前的 <code>i</code>。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>:</p>
<ul>
<li>循环结束后，记录的最终索引就是题目所求的第一个满足条件的子串的起始位置。返回该子串即可。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subStrHash</span>(<span class="params">self, s: <span class="built_in">str</span>, power: <span class="built_in">int</span>, modulo: <span class="built_in">int</span>, k: <span class="built_in">int</span>, hashValue: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 辅助函数，将 &#x27;a&#x27;-&#x27;z&#x27; 映射到 1-26</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">val</span>(<span class="params">c</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 1：预计算 p^(k-1) % m，用于移除窗口最右侧字符</span></span><br><span class="line">        pk_1 = <span class="built_in">pow</span>(power, k - <span class="number">1</span>, modulo)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2：计算最右侧第一个窗口 s[n-k : n] 的哈希值</span></span><br><span class="line">        current_h = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            i = n - k + j <span class="comment"># 窗口内字符的索引</span></span><br><span class="line">            current_h = (current_h + val(s[i]) * <span class="built_in">pow</span>(power, j, modulo)) % modulo</span><br><span class="line">        </span><br><span class="line">        res_index = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> current_h == hashValue:</span><br><span class="line">            res_index = n - k</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 3：从右向左滑动窗口</span></span><br><span class="line">        <span class="comment"># i 是新窗口的起始索引</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - k - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># old_hash (current_h) 对应 s[i+1 : i+k+1]</span></span><br><span class="line">            <span class="comment"># new_hash (将要计算的) 对应 s[i : i+k]</span></span><br><span class="line">            </span><br><span class="line">            old_right_val = val(s[i + k])</span><br><span class="line">            new_left_val = val(s[i])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 应用滚动哈希公式</span></span><br><span class="line">            <span class="comment"># a) 移除旧窗口最右侧字符的贡献</span></span><br><span class="line">            term_to_remove = (old_right_val * pk_1) % modulo</span><br><span class="line">            current_h = (current_h - term_to_remove + modulo) % modulo</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># b) 所有项幂次加一</span></span><br><span class="line">            current_h = (current_h * power) % modulo</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># c) 加上新窗口最左侧字符的贡献</span></span><br><span class="line">            current_h = (current_h + new_left_val) % modulo</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 检查哈希值是否匹配</span></span><br><span class="line">            <span class="keyword">if</span> current_h == hashValue:</span><br><span class="line">                res_index = i <span class="comment"># 更新为更靠前的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 4：返回结果</span></span><br><span class="line">        <span class="keyword">return</span> s[res_index : res_index + k]</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是字符串 <code>s</code> 的长度。初始哈希计算耗时 O(K)，逆向滑动窗口循环 N-K 次，每次更新是 O(1)。总复杂度为 O(K + N - K) &#x3D; O(N)，实现了线性时间求解。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个变量来存储哈希值和中间计算结果。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滚动哈希算法的绝佳应用案例。它告诉我们，当标准的从左到右的滑动窗口遇到数学难题（如模逆元）时，不妨换个方向思考。<strong>逆向滑动</strong>在本题中优雅地绕开了复杂的模除法，将哈希值的更新简化为基础的模运算，充分展现了算法设计的灵活性和数学之美。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
        <tag>哈希函数</tag>
        <tag>滚动哈希</tag>
        <tag>第 278 场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2258 | 逃离火灾</title>
    <url>//posts/leetcode-2258/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2258 题：<a href="https://leetcode.cn/problems/escape-the-spreading-fire/description/">逃离火灾</a>。<br>本题是一道结合了广度优先搜索（BFS）和二分查找的经典问题。核心在于将求解“最大等待时间”的优化问题，转化为一个“给定等待时间，能否逃脱”的判定性问题，从而利用答案的单调性进行高效求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们身处一个 <code>m x n</code> 的网格中，网格包含草地(0)、火(1)和墙(2)。我们的任务是从左上角 <code>(0, 0)</code> 出发，到达右下角的安全屋 <code>(m - 1, n - 1)</code>。</p>
<p>游戏规则如下：</p>
<ol>
<li>我们每分钟可以移动到相邻的草地格子。</li>
<li>在我们每次移动<strong>之后</strong>，火会向所有相邻的非墙格子蔓延。</li>
<li>我们可以在起点 <code>(0, 0)</code> 等待任意分钟数再出发。</li>
</ol>
<p>目标是找到我们可以在起点停留的<strong>最多</strong>分钟数，并且之后仍然能够安全到达安全屋。</p>
<p>这里有几个特殊情况需要注意：</p>
<ul>
<li>如果无论如何都无法到达，返回 <code>-1</code>。</li>
<li>如果我们总能安全到达（例如火被墙完全困住），无论等待多久都可以，返回 <code>10^9</code>。</li>
<li>如果在我们到达安全屋的同一分钟，火也到达了，这算作安全到达。</li>
</ul>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最多等待多少分钟”非常棘手。但我们可以换一个角度思考：如果我们<strong>假定</strong>一个等待时间 <code>k</code>，我们能否判断出在这个条件下，是否可以安全到达安全屋？</p>
<p>这个问题（我们称之为 <code>check(k)</code>）就清晰多了。而这个判定结果具有非常重要的<strong>单调性</strong>：</p>
<ul>
<li>如果等待 <code>k</code> 分钟后我们<strong>可以</strong>安全逃脱，那么等待一个更短的时间 <code>k-1</code> 分钟，我们给了自己一个时间优势，<strong>必然</strong>也能安全逃脱。</li>
<li>反之，如果等待 <code>k</code> 分钟后<strong>无法</strong>逃脱，那么等待更长的时间 <code>k+1</code> 分钟，火势会更猛烈，我们就<strong>更不可能</strong>逃脱。</li>
</ul>
<p>这种单调性是应用<strong>二分查找</strong>的完美信号。我们可以对“等待时间”这个值进行二分查找，来快速定位到那个“最长的可行等待时间”的临界点。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：最少可以等待 0 分钟。</li>
<li><strong>上界 (right)</strong>：一个足够大的数。考虑到网格大小最多为 <code>m*n</code>，如果等待 <code>m*n</code> 分钟后人还能走，火此时基本已经蔓延到所有能去的地方了。如果此时人还能到达终点，那么等再久也一样。所以 <code>m*n</code> 是一个合理的上界。</li>
</ul>
<p>因此，我们就在 <code>[0, m*n]</code> 这个区间内，对等待时间 <code>k</code> 进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><p>整个算法可以分为三个主要步骤：</p>
<h4 id="1-预计算火焰传播时间"><a href="#1-预计算火焰传播时间" class="headerlink" title="1. 预计算火焰传播时间"></a>1. 预计算火焰传播时间</h4><p>为了判断人的每一步是否安全，我们首先需要知道火在什么时候会到达地图上的每一个格子。这个问题可以通过一个**多源广度优先搜索（Multi-Source BFS）**来解决。</p>
<ul>
<li>创建一个 <code>fire_time[m][n]</code> 数组，用于存储火到达每个格子的最短时间，全部初始化为一个特殊值（如 -1 或无穷大）。</li>
<li>将所有初始的火源格子 <code>(r, c)</code> 加入一个队列中，并将它们的 <code>fire_time</code> 设为 0。</li>
<li>运行 BFS，逐层扩展火势，计算并填充 <code>fire_time</code> 数组。</li>
</ul>
<h4 id="2-实现-check-k-判定函数"><a href="#2-实现-check-k-判定函数" class="headerlink" title="2. 实现 check(k) 判定函数"></a>2. 实现 <code>check(k)</code> 判定函数</h4><p>这个函数是二分查找的核心，它用来判定“等待 <code>k</code> 分钟后出发，能否安全到达”。这同样可以用一次<strong>BFS</strong>来模拟人的移动过程。</p>
<ul>
<li>创建一个队列，并将人的初始状态 <code>(row=0, col=0, time=k)</code> 加入队列。<code>time</code> 表示当前时刻。</li>
<li>运行 BFS 模拟人的移动。从当前格子 <code>(r, c)</code>（在 <code>t</code> 时刻到达）移动到相邻的草地格子 <code>(nr, nc)</code> 时，必须满足安全条件：<ul>
<li>人到达 <code>(nr, nc)</code> 的时间是 <code>t + 1</code>。</li>
<li>这个格子必须还没被火烧到。即 <code>t + 1</code> 必须<strong>严格小于</strong> <code>fire_time[nr][nc]</code>。</li>
<li><strong>特殊情况</strong>：对于终点安全屋，题目允许同时到达，所以条件放宽为 <code>t + 1 &lt;= fire_time[nr][nc]</code>。</li>
</ul>
</li>
<li>如果在 BFS 过程中，人能够成功到达安全屋，则 <code>check(k)</code> 返回 <code>True</code>。如果队列为空还没到达，说明此路不通，返回 <code>False</code>。</li>
</ul>
<h4 id="3-执行二分查找"><a href="#3-执行二分查找" class="headerlink" title="3. 执行二分查找"></a>3. 执行二分查找</h4><p>现在我们有了判定函数 <code>check(k)</code>，可以进行标准的二分查找了。</p>
<ul>
<li>设置 <code>left = 0</code>, <code>right = m * n</code>，并用一个变量 <code>ans = -1</code> 记录最终答案。</li>
<li>在 <code>while left &lt;= right</code> 循环中：<ul>
<li>取中间值 <code>mid = left + (right - left) // 2</code>。</li>
<li>调用 <code>check(mid)</code>：<ul>
<li>如果返回 <code>True</code>，说明等待 <code>mid</code> 分钟是可行的。我们记录下这个可行解 <code>ans = mid</code>，然后尝试等待更长的时间，即 <code>left = mid + 1</code>。</li>
<li>如果返回 <code>False</code>，说明等待 <code>mid</code> 分钟太久了，必须缩短等待时间，即 <code>right = mid - 1</code>。</li>
</ul>
</li>
</ul>
</li>
<li>循环结束后，<code>ans</code> 中存储的就是最大的可行等待时间。最后根据 <code>ans</code> 的值处理 <code>10^9</code> 和 <code>-1</code> 的特殊情况即可。</li>
</ul>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumMinutes</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dirs = [(-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤1: 使用多源BFS计算火到达每个格子(非墙)的时间</span></span><br><span class="line">        fire_time = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="number">1</span>:</span><br><span class="line">                    q.append((r, c, <span class="number">0</span>))</span><br><span class="line">                    fire_time[r][c] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            r, c, t = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> dr, dc <span class="keyword">in</span> dirs:</span><br><span class="line">                nr, nc = r + dr, c + dc</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nr &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= nc &lt; n <span class="keyword">and</span> grid[nr][nc] != <span class="number">2</span> <span class="keyword">and</span> fire_time[nr][nc] == -<span class="number">1</span>:</span><br><span class="line">                    fire_time[nr][nc] = t + <span class="number">1</span></span><br><span class="line">                    q.append((nr, nc, t + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤2: 定义check函数, 判定等待wait_time分钟后是否能逃脱</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">wait_time: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            person_q = collections.deque()</span><br><span class="line">            <span class="keyword">if</span> fire_time[<span class="number">0</span>][<span class="number">0</span>] != -<span class="number">1</span> <span class="keyword">and</span> wait_time &gt;= fire_time[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            person_q.append((<span class="number">0</span>, <span class="number">0</span>, wait_time))</span><br><span class="line">            visited = <span class="built_in">set</span>([(<span class="number">0</span>, <span class="number">0</span>)])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> person_q:</span><br><span class="line">                r, c, t = person_q.popleft()</span><br><span class="line">                <span class="keyword">if</span> r == m - <span class="number">1</span> <span class="keyword">and</span> c == n - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> dr, dc <span class="keyword">in</span> dirs:</span><br><span class="line">                    nr, nc = r + dr, c + dc</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= nr &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= nc &lt; n <span class="keyword">and</span> grid[nr][nc] != <span class="number">2</span> <span class="keyword">and</span> (nr, nc) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        arrival_time = t + <span class="number">1</span></span><br><span class="line">                        fire_arrival_time = fire_time[nr][nc]</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> fire_arrival_time == -<span class="number">1</span> <span class="keyword">or</span> arrival_time &lt; fire_arrival_time <span class="keyword">or</span> \</span><br><span class="line">                           (nr == m - <span class="number">1</span> <span class="keyword">and</span> nc == n - <span class="number">1</span> <span class="keyword">and</span> arrival_time &lt;= fire_arrival_time):</span><br><span class="line">                            visited.add((nr, nc))</span><br><span class="line">                            person_q.append((nr, nc, arrival_time))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤3: 二分查找最大等待时间</span></span><br><span class="line">        left, right = <span class="number">0</span>, m * n</span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                ans = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤4: 处理特殊返回值</span></span><br><span class="line">        <span class="keyword">if</span> ans == m * n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>**<span class="number">9</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(M * N * log(M*N))。<ul>
<li>预计算火势蔓延时间的 BFS 复杂度为 O(M * N)。</li>
<li>二分查找的范围是 <code>m*n</code>，所以需要进行 <code>log(M*N)</code> 次迭代。</li>
<li>在每次迭代中，我们都需要调用 <code>check</code> 函数，该函数内部是一次人的 BFS，复杂度也为 O(M * N)。</li>
<li>因此，总时间复杂度由二分查找部分主导，为 O(M * N * log(M*N))。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(M * N)。<ul>
<li>我们需要一个 <code>fire_time</code> 数组来存储火的到达时间，以及在 <code>check</code> 函数中需要一个 <code>visited</code> 集合或数组，空间都是 O(M * N)。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“二分答案”思想的绝佳体现。它将一个看似复杂的“求最优值”问题，通过挖掘其内在的单调性，巧妙地转化成了一个易于解决的“判定性”问题。当我们遇到求解“最大值最小化”或“最小值最大化”这类问题时，都应该优先思考是否能套用“二分答案 + 验证函数”这一强大的算法模型。而本题中的验证函数又与图论中的最短路算法 BFS 紧密结合，是一道综合性很强的好题。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最大</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>矩阵</tag>
        <tag>广度优先搜索</tag>
        <tag>BFS</tag>
        <tag>第77场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2271 | 滑动窗口求解“毯子覆盖的最多白色砖块数”</title>
    <url>//posts/leetcode-2271/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2271 题：<a href="https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet/">毯子覆盖的最多白色砖块数</a>。<br>此题的核心在于如何高效地计算一个固定长度的“毯子”在任意位置能够覆盖的最大瓷砖数。通过将问题巧妙转化为“端点对齐”，并结合“排序”与“滑动窗口”，我们可以找到优雅的线性时间解法。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个二维数组 <code>tiles</code>，其中每个 <code>tiles[i] = [li, ri]</code> 代表一段连续的白色瓷砖。同时，我们还有一个长度为 <code>carpetLen</code> 的毯子。我们的目标是，将这块毯子放置在某个位置，使其能够覆盖的白色瓷砖数量达到最大，并返回这个最大值。</p>
<p>我们来分析一下这个目标：</p>
<ul>
<li>我们有一块固定长度的毯子，可以放置在数轴的任何位置。</li>
<li>我们需要找到一个最佳的起始点，使得区间 <code>[start, start + carpetLen - 1]</code> 覆盖的白色瓷砖总数最多。</li>
<li>一个非常关键的观察是：<strong>毯子的最优摆放位置，其左端点或右端点必然与某块瓷砖的端点对齐</strong>。为什么呢？试想，如果一个最优位置的毯子，其两端都没有与任何瓷砖的端点对齐，我们总可以将它向左或向右平移，直到有一个端点对齐为止，而这个过程中覆盖的瓷砖数不会减少。</li>
</ul>
<p>基于这个观察，我们可以简化问题：我们只需要考虑所有“毯子右端点与某块瓷砖的右端点对齐”的情况，并从中找出最优解即可。（选择左端点对齐也是同理的）。</p>
<p>举个例子，对于 <code>tiles = [[1,5], [10,11]], carpetLen = 6</code>：</p>
<ul>
<li>如果我们让毯子右端点与 <code>tiles[0]</code> 的右端点 <code>5</code> 对齐，毯子覆盖的区间是 <code>[5 - 6 + 1, 5] = [0, 5]</code>。这个区间覆盖了 <code>[1,5]</code> 这一整块瓷砖，长度为 5。</li>
<li>如果我们让毯子右端点与 <code>tiles[1]</code> 的右端点 <code>11</code> 对齐，毯子覆盖的区间是 <code>[11 - 6 + 1, 11] = [6, 11]</code>。这个区间覆盖了 <code>[10,11]</code> 这一整块瓷砖，长度为 2。</li>
<li>比较可知，最大覆盖数为 5。</li>
</ul>
<h3 id="核心思路：排序-滑动窗口"><a href="#核心思路：排序-滑动窗口" class="headerlink" title="核心思路：排序 + 滑动窗口"></a>核心思路：排序 + 滑动窗口</h3><p>这类在连续区间上求解最值的问题，通常是滑动窗口算法的绝佳应用场景。为了让窗口能够顺利地在瓷砖上“滑动”，<strong>先按瓷砖的起始位置排序</strong>是必不可少的一步。</p>
<p><strong>为什么需要排序？</strong><br>排序后，我们可以从左到右依次处理每一块瓷砖，保证了我们的窗口指针不会来回跳跃。这使得我们能够维护一个包含“可能被当前毯子覆盖的”瓷砖集合的窗口。</p>
<p>算法的动态过程如下：</p>
<ol>
<li><strong>排序</strong>：首先对 <code>tiles</code> 数组按照每块瓷砖的起始位置进行升序排序。</li>
<li><strong>窗口设定</strong>：我们使用 <code>left</code> 和 <code>right</code> 两个指针来维护一个窗口 <code>tiles[left...right]</code>。</li>
<li><strong>窗口扩张</strong>：<code>right</code> 指针不断向右移动，考察以 <code>tiles[right]</code> 为最右侧瓷砖的覆盖情况。</li>
<li><strong>成本计算与窗口收缩</strong>：<ul>
<li>我们假设毯子的<strong>右端点</strong>与 <code>tiles[right]</code> 的<strong>右端点</strong>对齐。那么毯子的起始位置就是 <code>carpet_start = tiles[right][1] - carpetLen + 1</code>。</li>
<li>此时，窗口内的瓷砖 <code>tiles[left]</code> 可能已经完全处在这块毯子的左侧（即 <code>tiles[left][1] &lt; carpet_start</code>），对当前的覆盖没有任何贡献。</li>
<li>如果出现这种情况，我们就需要收缩窗口，将 <code>left</code> 指针向右移动，并将 <code>tiles[left]</code> 的长度从当前覆盖总数中减去，直到 <code>tiles[left]</code> 至少有一部分能被当前毯子覆盖。</li>
</ul>
</li>
<li><strong>结果更新</strong>：<ul>
<li>在窗口调整完毕后，窗口 <code>[left...right]</code> 内的所有瓷砖都与当前毯子有交集。</li>
<li>但需要特别注意，最左侧的 <code>tiles[left]</code> 可能只有<strong>一部分</strong>被覆盖。我们需要计算出它“伸出”毯子左侧的部分，并从总覆盖数中减去。</li>
<li>用这个精确的覆盖数来更新全局的最大覆盖数。</li>
</ul>
</li>
</ol>
<p>通过这个“扩张-计算-收缩”的循环，我们就能在 O(N) 的时间内（排序后）找到答案。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>排序</strong>：</p>
<ul>
<li>对输入数组 <code>tiles</code> 按起始位置 <code>l_i</code> 进行升序排序。</li>
</ul>
</li>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>左指针 <code>left = 0</code>。</li>
<li>记录最大覆盖数 <code>max_coverage = 0</code>。</li>
<li>记录当前窗口内所有瓷砖的总长度 <code>current_coverage = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历与扩张</strong>：</p>
<ul>
<li>用右指针 <code>right</code> 从 <code>0</code> 到 <code>n-1</code> 遍历排序后的 <code>tiles</code> 数组。</li>
<li>在循环的每一步，首先将新瓷砖 <code>tiles[right]</code> 的完整长度加入 <code>current_coverage</code>。</li>
</ul>
</li>
<li><p><strong>收缩</strong>：</p>
<ul>
<li>确定当前毯子的理论起始位置 <code>carpet_start = tiles[right][1] - carpetLen + 1</code>。</li>
<li>使用一个 <code>while</code> 循环检查窗口左边界的有效性。条件是：<code>tiles[left][1] &lt; carpet_start</code>。</li>
<li>只要条件成立，说明 <code>tiles[left]</code> 完全在毯子左侧，需要将其移出窗口。</li>
<li>收缩操作：从 <code>current_coverage</code> 中减去 <code>tiles[left]</code> 的长度，然后将 <code>left</code> 指针右移一位。</li>
</ul>
</li>
<li><p><strong>计算精确覆盖并更新结果</strong>：</p>
<ul>
<li><code>while</code> 循环结束后，<code>tiles[left]</code> 是第一个与毯子有交集的瓷砖。</li>
<li>计算 <code>tiles[left]</code> 可能伸出毯子左侧的长度（即未被覆盖的部分）：<code>lost_coverage = max(0, carpet_start - tiles[left][0])</code>。</li>
<li>当前毯子位置的实际覆盖数是 <code>current_coverage - lost_coverage</code>。</li>
<li>用这个实际覆盖数更新全局最大值：<code>max_coverage = max(max_coverage, current_coverage - lost_coverage)</code>。</li>
</ul>
</li>
<li><p><strong>返回</strong>：</p>
<ul>
<li><code>right</code> 指针遍历完整个数组后，<code>max_coverage</code> 中存储的就是最终答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumWhiteTiles</span>(<span class="params">self, tiles: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], carpetLen: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1: 排序是关键前提</span></span><br><span class="line">        tiles.sort()</span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(tiles)</span><br><span class="line">        <span class="comment"># 步骤 2: 初始化指针和状态变量</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        max_coverage = <span class="number">0</span></span><br><span class="line">        current_coverage = <span class="number">0</span>  <span class="comment"># 窗口内瓷砖的总长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 遍历数组，right 指针用于扩张窗口</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            start_r, end_r = tiles[right]</span><br><span class="line">            current_coverage += (end_r - start_r + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 确定当前毯子的理论起始位置</span></span><br><span class="line">            carpet_start = end_r - carpetLen + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 4: 当窗口左边界不满足条件时，进行收缩</span></span><br><span class="line">            <span class="keyword">while</span> tiles[left][<span class="number">1</span>] &lt; carpet_start:</span><br><span class="line">                start_l, end_l = tiles[left]</span><br><span class="line">                current_coverage -= (end_l - start_l + <span class="number">1</span>)</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 5: 计算精确覆盖并更新结果</span></span><br><span class="line">            <span class="comment"># 此时，tiles[left] 可能被部分覆盖，计算其未被覆盖的长度</span></span><br><span class="line">            lost_coverage = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> tiles[left][<span class="number">0</span>] &lt; carpet_start:</span><br><span class="line">                lost_coverage = carpet_start - tiles[left][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 用 (窗口内总长度 - 左侧未覆盖长度) 更新最大值</span></span><br><span class="line">            max_coverage = <span class="built_in">max</span>(max_coverage, current_coverage - lost_coverage)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> max_coverage</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N log N)。其中 N 是 <code>tiles</code> 数组的长度。算法的瓶颈在于初始的排序步骤，其时间复杂度为 O(N log N)。后续的滑动窗口遍历中，<code>left</code> 和 <code>right</code> 指针都只会从头到尾移动一次，所以是 O(N) 的。因此，总的时间复杂度为 O(N log N)。</li>
<li><strong>空间复杂度</strong>: O(log N) 或 O(N)。这取决于编程语言中排序算法的实现。例如，Python 的 Timsort 在最坏情况下需要 O(N) 的空间，而一些快速排序的实现会使用 O(log N) 的递归栈空间。如果我们不考虑排序所用的空间，则算法本身只使用了常数个额外变量，空间复杂度为 O(1)。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“排序 + 滑动窗口”组合拳的又一个典型应用。解决这类问题的关键路径非常清晰：</p>
<ol>
<li><strong>发现简化问题的关键性质</strong>：通过分析题目，找到一个可以简化搜索范围的策略。在本题中，这个策略就是“最优毯子的端点必然与某块瓷砖的端点对齐”。</li>
<li><strong>排序</strong>：为了方便地处理区间，排序几乎是必须的预处理步骤。</li>
<li><strong>定义窗口与状态</strong>：明确滑动窗口的左右边界代表什么，以及需要维护哪些状态变量来高效判断窗口的有效性（本题中是 <code>current_coverage</code>）。</li>
<li><strong>处理边界情况</strong>：滑动窗口问题中，最精髓也最容易出错的地方，就是对窗口边界处部分元素的处理（本题中是对 <code>tiles[left]</code> 的部分覆盖计算）。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>滑动窗口</tag>
        <tag>排序</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2302 | 滑动窗口求解“统计得分小于 K 的子数组数目”</title>
    <url>//posts/leetcode-2302/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2302 题：<a href="https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/">统计得分小于 K 的子数组数目</a>。<br>该题定义了一种新颖的“分数”计算方式（数组和 * 数组长），要求我们统计所有分数严格小于给定值 k 的子数组数量。这是一个典型的可以使用不定长滑动窗口解决的子数组计数问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目定义了一个数组的“分数”，其计算方式为该数组所有元素之和乘以其长度。例如，数组 <code>[1, 2, 3]</code> 的分数为 <code>(1 + 2 + 3) * 3 = 18</code>。</p>
<p>我们需要处理一个给定的正整数数组 <code>nums</code> 和一个整数 <code>k</code>，任务是找出 <code>nums</code> 中有多少个非空子数组，其分数 <strong>严格小于</strong> <code>k</code>。</p>
<p>我们来看一个例子，<code>nums = [2,1,4,3,5], k = 10</code>：</p>
<ul>
<li>子数组 <code>[2, 1]</code> 的分数为 <code>(2 + 1) * 2 = 6</code>。因为 <code>6 &lt; 10</code>，所以这是一个符合条件的子数组。</li>
<li>子数组 <code>[1, 4]</code> 的分数为 <code>(1 + 4) * 2 = 10</code>。因为分数没有严格小于 10，所以这个子数组 <strong>不</strong> 符合条件。</li>
<li>所有单个元素的子数组如 <code>[2]</code>、<code>[1]</code> 等，它们的分数分别为 2, 1, 4, 3, 5，都小于 10。</li>
</ul>
<p>我们的目标就是计算出所有这类符合条件的子数组的总数。</p>
<h3 id="核心思路：不定长滑动窗口"><a href="#核心思路：不定长滑动窗口" class="headerlink" title="核心思路：不定长滑动窗口"></a>核心思路：不定长滑动窗口</h3><p>暴力解法是枚举所有的子数组，计算其分数并判断是否小于 <code>k</code>。一个有 N 个元素的数组，有 O(N^2) 个子数组，计算每个子数组的和还需要时间，总复杂度至少为 O(N^2)，对于 <code>N = 10^5</code> 的数据规模来说太慢了。</p>
<p>这类涉及连续子数组统计的问题，通常可以考虑使用滑动窗口来优化。我们观察分数的计算公式：<code>score = sum * length</code>。当窗口向右扩大时，<code>sum</code> 和 <code>length</code> 都在增加，因此 <code>score</code> 也是单调递增的。这个单调性是使用滑动窗口的绝佳信号。</p>
<p>我们的策略如下：</p>
<ol>
<li>我们用一个窗口 <code>[l, r]</code>（表示子数组 <code>nums[l...r]</code>）在数组上滑动。我们固定右端点 <code>r</code>，然后找到一个最左边的左端点 <code>l</code>，使得 <code>[l, r]</code> 这个窗口的分数刚好满足 <code>&lt; k</code>。</li>
<li>由于分数的单调性，如果 <code>[l, r]</code> 的分数小于 <code>k</code>，那么所有以 <code>r</code> 为右端点，但比 <code>[l, r]</code> 更短的子数组（例如 <code>[l+1, r]</code>, <code>[l+2, r]</code> 等）的分数也必然小于 <code>k</code>。</li>
<li>因此，一旦我们为 <code>r</code> 找到了这个最左的 <code>l</code>，那么以 <code>r</code> 为右端点的所有有效子数组就是：<code>[l, r]</code>, <code>[l+1, r]</code>, …, <code>[r, r]</code>。它们的数量正好是 <code>r - l + 1</code>。</li>
<li>我们让 <code>r</code> 从头到尾遍历数组，在每一步都找出对应的 <code>l</code> 并累加子数组数量，就能得到最终答案。因为当 <code>r</code> 向右移动时，<code>l</code> 只会向右移动或保持不变（绝不会向左），所以两个指针的总移动次数是线性的，保证了 O(N) 的时间复杂度。</li>
</ol>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><strong>初始化</strong>: 初始化左指针 <code>l = 0</code>，当前窗口的和 <code>current_sum = 0</code>，以及结果 <code>ans = 0</code>。</li>
<li><strong>遍历与扩张</strong>: 使用右指针 <code>r</code> 遍历数组，从 <code>0</code> 到 <code>n-1</code>。在循环的每一步，首先将 <code>nums[r]</code> 加到 <code>current_sum</code> 中，这代表窗口向右扩张了一步。</li>
<li><strong>检查与收缩</strong>: 此时窗口为 <code>[l, r]</code>。我们需要检查它的分数是否满足条件。使用一个 <code>while</code> 循环判断，只要 <code>current_sum * (r - l + 1) &gt;= k</code>，就说明当前窗口的分数过大或等于 <code>k</code>，不满足”严格小于”的要求。因此，我们需要从左边收缩窗口：将 <code>nums[l]</code> 从 <code>current_sum</code> 中减去，然后将 <code>l</code> 指针右移一位 (<code>l += 1</code>)。</li>
<li><strong>计数</strong>: <code>while</code> 循环结束后，我们保证了当前窗口 <code>[l, r]</code> 的分数是严格小于 <code>k</code> 的。如核心思路所述，这意味着所有以 <code>r</code> 为右端点、<code>l</code> 或更右的位置为左端点的子数组都是有效的。这些子数组的数量为 <code>r - l + 1</code>。我们将这个数量累加到 <code>ans</code> 上。</li>
<li><strong>循环</strong>: 指针 <code>r</code> 继续向右移动，重复步骤 2 到 4，直到遍历完整个数组。</li>
<li><strong>返回</strong>: 最终 <code>ans</code> 中就存储了所有满足条件的子数组数目。</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><p>下面是该思路的 Python3 代码实现，也就是您在问题中提供的优雅解法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubarrays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># ans: 结果计数</span></span><br><span class="line">        <span class="comment"># l: 滑动窗口的左指针</span></span><br><span class="line">        <span class="comment"># w: 当前窗口内元素的和 (window_sum)</span></span><br><span class="line">        ans = l = <span class="number">0</span></span><br><span class="line">        w = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># r 是右指针，x 是当前右指针指向的元素值</span></span><br><span class="line">        <span class="keyword">for</span> r, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 步骤 2: 扩大窗口，将新元素加入和</span></span><br><span class="line">            w += x</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 3: 检查分数，如果分数不满足条件则收缩窗口</span></span><br><span class="line">            <span class="comment"># 窗口长度是 r - l + 1</span></span><br><span class="line">            <span class="keyword">while</span> w * (r - l + <span class="number">1</span>) &gt;= k:</span><br><span class="line">                <span class="comment"># 从和中移除最左边的元素</span></span><br><span class="line">                w -= nums[l]</span><br><span class="line">                <span class="comment"># 左指针右移</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 4: 计数</span></span><br><span class="line">            <span class="comment"># 此时 [l, r] 是最大的有效窗口</span></span><br><span class="line">            <span class="comment"># 所有以 r 结尾的有效子数组数量为 r - l + 1</span></span><br><span class="line">            ans += r - l + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是数组 <code>nums</code> 的长度。右指针 <code>r</code> 和左指针 <code>l</code> 都只从左到右遍历数组一次，每个元素最多被访问两次（一次被 <code>r</code> 访问，一次被 <code>l</code> 访问）。因此，总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个额外变量（<code>ans</code>, <code>l</code>, <code>w</code>, <code>r</code>, <code>x</code>），没有使用与输入规模相关的额外空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想的一个经典应用。问题的关键在于识别出“分数”这个指标随着子数组的扩张具有单调性。一旦发现了这个特性，就可以抛弃 O(N^2) 的暴力枚举，转而使用双指针维护一个“有效”的窗口。通过高效地扩张和收缩窗口，在单次遍历中完成所有子数组的统计，从而达到 O(N) 的最优时间复杂度。这个从“固定一端，寻找另一端”到“两端协同移动”的思维转变，是掌握滑动窗口技巧的核心。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>滑动窗口</tag>
        <tag>前缀和</tag>
        <tag>第80场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2401 | 滑动窗口求解“最长优雅子数组”</title>
    <url>//posts/leetcode-2401/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2401 题：<a href="https://leetcode.cn/problems/longest-nice-subarray/description/">最长优雅子数组</a>。<br>该题要求寻找一个最长的子数组，其中任意两个元素的按位与（AND）都为 0。这是一个非常适合使用滑动窗口解决的问题，关键在于如何高效地维护窗口的“优雅”属性。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个正整数组成的数组 <code>nums</code>，需要我们找到一个<strong>最长</strong>的<strong>连续子数组</strong>，这个子数组被称为“优雅的”。</p>
<p>一个子数组是“优雅的”，当且仅当其中任意两个不同位置的数字，它们的按位与（AND）运算结果都等于 0。这意味着，在一个优雅子数组中，所有数字的二进制表示里，任意一个为 ‘1’ 的 bit 位，在其他所有数字的对应 bit 位上都必须是 ‘0’。</p>
<p>举个例子，对于 <code>nums = [1,3,8,48,10]</code>：</p>
<ul>
<li>我们来看子数组 <code>[3, 8, 48]</code>：<ul>
<li>3 的二进制是 <code>00011</code></li>
<li>8 的二进制是 <code>01000</code></li>
<li>48 的二进制是 <code>110000</code></li>
</ul>
</li>
<li>检查任意一对：<ul>
<li><code>3 &amp; 8</code> &#x3D; <code>00011 &amp; 01000</code> &#x3D; <code>0</code></li>
<li><code>3 &amp; 48</code> &#x3D; <code>00011 &amp; 110000</code> &#x3D; <code>0</code></li>
<li><code>8 &amp; 48</code> &#x3D; <code>01000 &amp; 110000</code> &#x3D; <code>0</code></li>
</ul>
</li>
<li>所有配对的按位与结果都为 0，所以 <code>[3, 8, 48]</code> 是一个优雅子数组，长度为 3。题目要求我们返回这个最长的长度。</li>
</ul>
<p>如果用暴力法枚举所有子数组，再对子数组里的每一对数字进行检查，时间复杂度会非常高，无法通过。我们需要一种更高效的方法。</p>
<h3 id="核心思路：滑动窗口与位运算"><a href="#核心思路：滑动窗口与位运算" class="headerlink" title="核心思路：滑动窗口与位运算"></a>核心思路：滑动窗口与位运算</h3><p>这道题的“连续子数组”和“最长”两个关键词强烈地指向了<strong>滑动窗口</strong>算法。我们可以维护一个窗口 <code>[l, r]</code>，确保这个窗口内的子数组始终是“优雅的”，然后不断尝试扩大这个窗口，并记录其最大长度。</p>
<p>问题的关键在于：当窗口右边界 <code>r</code> 纳入一个新元素 <code>nums[r]</code> 时，我们如何快速判断窗口 <code>[l, r]</code> 是否仍然优雅？</p>
<p>如果逐一检查 <code>nums[r]</code> 与窗口内 <code>nums[l]</code> 到 <code>nums[r-1]</code> 的每一个数，效率依然很低。这里有一个重要的转换：<strong>一个子数组是优雅的，等价于这个子数组中所有元素的按位或（OR）结果等于它们的按位异或（XOR）结果，也等价于所有元素的按位或（OR）结果等于它们的和</strong>。</p>
<p>一个更直接的判断方法是：如果我们将窗口内已有元素 <code>nums[l...r-1]</code> 的所有 bit 位 ‘1’ 合并成一个集合（通过按位或运算），那么新元素 <code>nums[r]</code> 要能被加入窗口，当且仅当 <code>nums[r]</code> 的所有 bit 位 ‘1’ 在这个集合中都没有出现过。</p>
<p>这可以用一个简单的位运算来检查：<br><code>(窗口内所有元素的 OR 值) &amp; (新元素 nums[r]) == 0</code></p>
<p>基于这个思想，我们的滑动窗口策略就变得清晰了：</p>
<ol>
<li>维护一个变量 <code>or_sum</code>，它存储了当前窗口 <code>[l, r]</code> 内所有数字的按位或（OR）结果。</li>
<li>当右指针 <code>r</code> 向右移动，我们考虑加入新元素 <code>x = nums[r]</code>。</li>
<li>我们检查 <code>or_sum &amp; x</code> 是否为 0。<ul>
<li>如果不为 0，说明 <code>x</code> 的某个 bit 位在 <code>or_sum</code> 中已经存在，产生了冲突。此时，我们需要从左边收缩窗口，即<code>l++</code>。在收缩时，需要将 <code>nums[l]</code> 的影响从 <code>or_sum</code> 中移除。因为优雅子数组中所有数的 bit 位都不同，OR 和 XOR 的效果是一样的，所以我们可以通过 <code>or_sum ^= nums[l]</code> 来移除 <code>nums[l]</code> 的 bit 位。我们重复此过程，直到 <code>or_sum &amp; x</code> 等于 0 为止。</li>
<li>如果为 0（或者经过收缩后变为 0），说明 <code>x</code> 可以安全地加入窗口。我们更新 <code>or_sum</code>，<code>or_sum |= x</code>，将 <code>x</code> 的 bit 位合并进来。</li>
</ul>
</li>
<li>每一次成功扩大窗口后，我们用当前的窗口长度 <code>r - l + 1</code> 来更新最终答案。</li>
</ol>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化</strong>:</p>
<ul>
<li><code>ans = 0</code>: 存储最长优雅子数组的长度。</li>
<li><code>l = 0</code>: 滑动窗口的左边界。</li>
<li><code>or_sum = 0</code> (在代码中用 <code>_</code> 表示): 存储当前窗口内所有元素的按位或结果。</li>
</ul>
</li>
<li><p><strong>遍历与窗口移动</strong>:</p>
<ul>
<li>使用 <code>for</code> 循环，让右边界 <code>r</code> 从 0 遍历到数组末尾，<code>x</code> 为当前元素 <code>nums[r]</code>。</li>
<li><strong>检查冲突与收缩窗口</strong>：用一个 <code>while</code> 循环检查 <code>(or_sum &amp; x) != 0</code>。只要存在冲突：<ul>
<li>从 <code>or_sum</code> 中移除最左侧元素 <code>nums[l]</code> 的影响：<code>or_sum ^= nums[l]</code>。</li>
<li>将左边界右移：<code>l += 1</code>。</li>
</ul>
</li>
<li><strong>扩大窗口</strong>：<code>while</code> 循环结束后，说明冲突已解决，新元素 <code>x</code> 可以加入。更新 <code>or_sum</code>：<code>or_sum |= x</code>。</li>
<li><strong>更新答案</strong>：此时的窗口 <code>[l, r]</code> 是优雅的，其长度为 <code>r - l + 1</code>。更新 <code>ans = max(ans, r - l + 1)</code>。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>:</p>
<ul>
<li>遍历结束后，<code>ans</code> 即为所求。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><p>下面是题目给出的 Python 代码，逻辑清晰地实现了上述思路。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestNiceSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = l = _ = <span class="number">0</span> <span class="comment"># _ 用来存储窗口内元素的按位或(OR)结果</span></span><br><span class="line">        <span class="keyword">for</span> r,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 当新元素 x 与窗口内已有元素的 OR 结果有重叠的 bit 位时</span></span><br><span class="line">            <span class="keyword">while</span> _ &amp; x:</span><br><span class="line">                <span class="comment"># 从窗口左侧移出元素 nums[l]</span></span><br><span class="line">                <span class="comment"># 因为在优雅子数组中，OR 和 XOR 效果相同，所以用 XOR 移除</span></span><br><span class="line">                _ ^= nums[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将新元素 x 的 bit 位加入到集合中</span></span><br><span class="line">            _ |= x</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新最长长度</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans,r-l+<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是 <code>nums</code> 的长度。虽然代码中有 <code>while</code> 循环嵌套在 <code>for</code> 循环中，但左右两个指针 <code>l</code> 和 <code>r</code> 都始终只向右移动，不回退。每个元素最多被右指针访问一次，被左指针访问一次。因此，总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了几个额外的变量 (<code>ans</code>, <code>l</code>, <code>_</code>)，占用的空间是常数级别的。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题巧妙地将一个看似复杂的子数组性质判断问题，通过<strong>位运算</strong>的洞察，转化成了一个可以在 O(1) 时间内完成的状态检查。这使得标准的<strong>滑动窗口</strong>算法得以高效应用。它是一个很好的例子，展示了如何利用问题的数学或逻辑特性来优化算法，将一个暴力解法可能会达到 O(N³) 的问题，降维到 O(N) 解决。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>位运算</tag>
        <tag>滑动窗口</tag>
        <tag>第309场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2439 | 最小化数组中的最大值</title>
    <url>//posts/leetcode-2439/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2439 题：<a href="https://leetcode.cn/problems/minimize-maximum-of-array/description/">最小化数组中的最大值</a>。<br>本题的核心在于识别出答案的单调性，并将一个求解最优值（最小化最大值）的问题，巧妙地转化为一个判定性的问题，从而利用二分查找在对数时间内高效求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们得到一个非负整数数组 <code>nums</code>。题目定义了一种操作：</p>
<ul>
<li>选择一个索引 <code>i</code>（<code>1 &lt;= i &lt; n</code>），且 <code>nums[i]</code> 必须大于 0。</li>
<li>将 <code>nums[i]</code> 的值减 1。</li>
<li>将 <code>nums[i - 1]</code> 的值加 1。</li>
</ul>
<p>这个操作本质上是把 <code>nums[i]</code> 的一部分值“传递”给它左边的邻居 <code>nums[i-1]</code>。这个过程可以执行任意次。我们的目标是，通过这些操作，使得数组中最大的那个元素的值尽可能小。我们需要返回这个“最小的最大值”。</p>
<p>举个例子，<code>nums = [3,7,1,6]</code>。<br>我们可以执行一系列操作，比如把 <code>nums[1]</code> 的 2 挪到 <code>nums[0]</code>，把 <code>nums[3]</code> 的 1 挪到 <code>nums[2]</code>，最终可以得到 <code>[5,5,2,5]</code>。此时，数组中的最大值是 5。题目告诉我们，无法得到比 5 更小的最大值，所以 5 就是答案。</p>
<p>这个操作有一个非常重要的特性：<strong>值只能向左移动</strong>。<code>nums[i]</code> 的值可以影响 <code>nums[i-1], nums[i-2], ... , nums[0]</code>，但永远无法影响到它右边的 <code>nums[i+1]</code>。这暗示了数组的前缀和（prefix sum）可能是一个关键的不变量或约束条件。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最小的最大值”是复杂的。但我们可以换一个角度思考：如果我们<strong>假设</strong>一个最终的最大值 <code>m</code>，我们能否判断出这个目标是否可以实现？</p>
<p>这个问题（我们称之为“判定问题”）就清晰多了。我们可以编写一个辅助函数 <code>check(m)</code>，来判断是否能通过操作，使得数组中所有元素都小于等于 <code>m</code>。</p>
<p>如果我们可以高效地实现 <code>check(m)</code>，就会发现这个判定结果具有<strong>单调性</strong>：</p>
<ul>
<li>如果一个值 <code>m</code> 是可行的（即我们可以让数组的最大值不超过 <code>m</code>），那么任何大于 <code>m</code> 的值 <code>m&#39;</code> 也一定可行。</li>
<li>反之，如果 <code>m</code> 不可行，那么任何小于 <code>m</code> 的值也一定不可行。</li>
</ul>
<p>这种单调性是应用二分查找的完美信号。我们可以对“可能的答案”进行二分查找，从而快速定位到那个“最小的可行值”。</p>
<p>那么，这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：由于数组元素非负，最小的最大值不可能是负数，所以下界可以是 <code>0</code>。</li>
<li><strong>上界 (right)</strong>：在最坏的情况下，我们不执行任何操作，此时最大值是原数组中的最大值 <code>max(nums)</code>。一个更宽松的上界可以是题目给定的 <code>10^9</code>。</li>
</ul>
<p>因此，我们就在 <code>[0, max(nums)]</code> 这个区间内，对可能的答案进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><p>现在，核心落在了如何实现 <code>check(m)</code> 函数上。</p>
<p>回顾操作的特性：值只能从 <code>nums[i]</code> 移动到 <code>nums[i-1]</code>。这意味着，对于数组的任意一个前缀 <code>nums[0...i]</code>，这个前缀中所有元素的总和 <code>sum(nums[0...i])</code>，无论内部如何传递，其总和是不可能增加的（因为值只能从 <code>i+1</code> 传进来，不能从 <code>i</code> 传到 <code>i+1</code>）。</p>
<p>如果我们想让这个前缀 <code>nums[0...i]</code> 中的每一个元素都小于等于 <code>m</code>，那么这 <code>i+1</code> 个元素能容纳的最大总和就是 <code>(i + 1) * m</code>。由于操作无法增加前缀和，所以一个必要条件就是：<strong>原数组的每一个前缀和都必须小于等于它所能容纳的最大总和</strong>。<br>即，对于所有的 <code>i</code> from <code>0</code> to <code>n-1</code>，必须满足 <code>sum(nums[0...i]) &lt;= (i + 1) * m</code>。</p>
<p>事实证明，这不仅是必要条件，也是充分条件。如果所有前缀和都满足这个条件，我们总能找到一种操作方式，将“高”处的值“填”到“低”处，使得最终所有元素都不超过 <code>m</code>。</p>
<p>因此，<code>check(m)</code> 的逻辑如下：</p>
<ol>
<li>遍历数组 <code>nums</code>，同时计算当前的前缀和 <code>prefix_sum</code>。</li>
<li>对于每个位置 <code>i</code>，检查 <code>prefix_sum</code> 是否大于 <code>(i + 1) * m</code>。</li>
<li>如果发现任何一个前缀和超出了这个上限，说明 <code>m</code> 太小了，无法容纳当前的前缀和，返回 <code>False</code>。</li>
<li>如果遍历完整个数组都没有违反这个条件，说明 <code>m</code> 是一个可行的最大值，返回 <code>True</code>。</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimizeArrayValue</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 确定二分查找的左右边界</span></span><br><span class="line">        <span class="comment"># 答案的下界可以是 0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 答案的上界不会超过数组中的最大值</span></span><br><span class="line">        right = <span class="built_in">max</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 辅助函数：检查是否可能使数组中的最大值不超过 m</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># prefix_sum 可能会很大，需要使用足够大的类型</span></span><br><span class="line">            prefix_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">                prefix_sum += num</span><br><span class="line">                <span class="comment"># 检查前 i+1 个元素的总和是否超过了</span></span><br><span class="line">                <span class="comment"># 它们在理想情况下（所有元素都为 m）所能达到的总和</span></span><br><span class="line">                <span class="keyword">if</span> prefix_sum &gt; (i + <span class="number">1</span>) * m:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找寻找最小的可行 m</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 可行，说明它可能就是答案，</span></span><br><span class="line">                <span class="comment"># 或者还有更小的可行值，所以我们尝试在左半部分继续寻找</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 不可行，说明目标值太小，</span></span><br><span class="line">                <span class="comment"># 必须增大，所以去右半部分寻找</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时，left 就是满足条件的最小整数</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N * log(M))。<ul>
<li><code>N</code> 是数组 <code>nums</code> 的长度。</li>
<li><code>M</code> 是数组中的最大值，代表了二分查找的搜索空间大小。</li>
<li>二分查找本身需要 <code>log(M)</code> 次迭代。</li>
<li>在每次迭代中，我们都需要调用 <code>check</code> 函数，该函数需要遍历一次 <code>nums</code> 数组，时间复杂度为 O(N)。</li>
<li>因此，总时间复杂度是这两者的乘积。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)。<ul>
<li>除了输入数组外，我们只使用了几个变量来存储左右边界和前缀和，空间复杂度是常数级的。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“最小化最大值”问题类型的经典范例。解决这类问题的通用策略是使用二分查找。我们将一个难以直接求解的“最优化问题”，转化为一个相对简单的“判定性问题”。只要这个判定问题具有单调性，就可以通过二分法高效地逼近并找到最终的答案。此题的精髓在于，通过分析操作的单向性，将判定条件与前缀和巧妙地联系起来。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>最小化最大值</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>前缀和</tag>
        <tag>动态规划</tag>
        <tag>第89场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2516 | 滑动窗口与逆向思维：求解“每种字符至少取 K 个”</title>
    <url>//posts/leetcode-2516/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2516 题：<a href="https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/">每种字符至少取 K 个</a>。<br>这道题要求我们从字符串的两端拿走字符，乍看之下似乎需要复杂的双指针或动态规划。但如果我们转换一下思路，它就变成了一个非常巧妙的滑动窗口问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个仅包含 ‘a’, ‘b’, ‘c’ 的字符串 <code>s</code> 和一个整数 <code>k</code>。我们需要从字符串的<strong>最左侧</strong>或<strong>最右侧</strong>取走字符，目标是达成“每种字符 (‘a’, ‘b’, ‘c’) 都至少取了 <code>k</code> 个”的条件。我们要找到满足这个条件所需的最少操作次数（即取走的最少字符总数）。</p>
<p>举个例子，对于 <code>s = &quot;aabaaaacaabc&quot;</code>, <code>k = 2</code>：</p>
<ul>
<li>我们的目标是最终取走的字符集合中，至少有 2 个 ‘a’，2 个 ‘b’，和 2 个 ‘c’。</li>
<li>一种可行的方案是：从左边取 3 个字符 (<code>&quot;aab&quot;</code>)，从右边取 5 个字符 (<code>&quot;aabc&quot;</code>)。</li>
<li>总共取走的字符是 <code>&quot;aab&quot;</code> 和 <code>&quot;aabc&quot;</code> 的组合，包含了 3 个 ‘a’，2 个 ‘b’，2 个 ‘c’，满足条件。</li>
<li>总共取走的字符数是 3 + 5 &#x3D; 8。题目要求我们找到这个最小的总数。</li>
</ul>
<p>直接去模拟从两端取字符的过程，情况会非常复杂，因为左边取 <code>i</code> 个，右边就要相应地调整，很难找到最优解。</p>
<h3 id="核心思路：逆向思维与滑动窗口"><a href="#核心思路：逆向思维与滑动窗口" class="headerlink" title="核心思路：逆向思维与滑动窗口"></a>核心思路：逆向思维与滑动窗口</h3><p>当“两端操作求最优解”变得困难时，我们不妨逆向思考：<strong>从两端取走最少的字符，等价于在中间保留最长的连续子串。</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/11/29/example-1.png" alt="Sliding Window Explanation"></p>
<p>我们的问题就转化成了：在 <code>s</code> 中寻找一个<strong>最长的连续子字符串</strong>，使得这个子字符串<strong>之外</strong>的剩余部分，’a’, ‘b’, ‘c’ 的数量都至少为 <code>k</code>。</p>
<p>假设整个字符串 <code>s</code> 中 ‘a’, ‘b’, ‘c’ 的总数分别是 <code>total_a</code>, <code>total_b</code>, <code>total_c</code>。<br>如果我们中间保留的窗口（子字符串）中 ‘a’, ‘b’, ‘c’ 的数量是 <code>window_a</code>, <code>window_b</code>, <code>window_c</code>。</p>
<p>那么，在窗口之外（也就是我们从两端取走的部分）的字符数量就是：</p>
<ul>
<li>取走的 ‘a’ 数量：<code>total_a - window_a</code></li>
<li>取走的 ‘b’ 数量：<code>total_b - window_b</code></li>
<li>取走的 ‘c’ 数量：<code>total_c - window_c</code></li>
</ul>
<p>根据题意，我们需要满足：</p>
<ul>
<li><code>total_a - window_a &gt;= k</code></li>
<li><code>total_b - window_b &gt;= k</code></li>
<li><code>total_c - window_c &gt;= k</code></li>
</ul>
<p>将这些不等式变形，我们就可以得到对<strong>中间保留窗口</strong>的约束条件：</p>
<ul>
<li><code>window_a &lt;= total_a - k</code></li>
<li><code>window_b &lt;= total_b - k</code></li>
<li><code>window_c &lt;= total_c - k</code></li>
</ul>
<p>现在，问题变得清晰了：<strong>找到一个最长的连续子字符串，其中 ‘a’, ‘b’, ‘c’ 的数量分别不超过 <code>total_a - k</code>、<code>total_b - k</code> 和 <code>total_c - k</code></strong>。</p>
<p>这正是滑动窗口算法擅长解决的“寻找满足特定条件的最长子串”问题！我们只需要用滑动窗口找到这个最长窗口的长度 <code>max_len</code>，最终答案就是 <code>s</code> 的总长度减去 <code>max_len</code>。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>预处理与边界检查</strong>：</p>
<ul>
<li>如果 <code>k=0</code>，不需要取任何字符，直接返回 0。</li>
<li>统计整个字符串 <code>s</code> 中 ‘a’, ‘b’, ‘c’ 的总数 <code>total_counts</code>。</li>
<li>如果任意一种字符的总数本身就小于 <code>k</code>，那无论如何也无法满足条件，直接返回 -1。</li>
</ul>
</li>
<li><p><strong>确定窗口约束</strong>：</p>
<ul>
<li>计算出中间保留的窗口内，每种字符允许的最大数量 <code>max_allowed</code>。例如，<code>max_allowed[&#39;a&#39;] = total_counts[&#39;a&#39;] - k</code>。</li>
</ul>
</li>
<li><p><strong>滑动窗口初始化</strong>：</p>
<ul>
<li>左指针 <code>left = 0</code>。</li>
<li>记录最长有效窗口的长度 <code>max_len = 0</code>。</li>
<li>用一个字典或数组 <code>window_counts</code> 实时记录当前窗口内 ‘a’, ‘b’, ‘c’ 的数量。</li>
</ul>
</li>
<li><p><strong>遍历与窗口扩张</strong>：</p>
<ul>
<li>用右指针 <code>right</code> 从 <code>0</code> 遍历到 <code>n-1</code>。</li>
<li>在循环的每一步，将 <code>s[right]</code> 这个新字符纳入窗口，并更新 <code>window_counts</code>。</li>
</ul>
</li>
<li><p><strong>条件判断与窗口收缩</strong>：</p>
<ul>
<li>扩张后，检查当前窗口是否依然满足约束（即 <code>window_counts</code> 中每种字符的数量是否都小于等于 <code>max_allowed</code> 中对应的上限）。</li>
<li>如果不满足，说明窗口“太大了”，需要从左侧收缩。我们使用一个 <code>while</code> 循环来执行这个操作：<ul>
<li>只要窗口不满足约束，就将左侧字符 <code>s[left]</code> 移出窗口（更新 <code>window_counts</code>），然后将 <code>left</code> 指针右移。</li>
<li>这个 <code>while</code> 循环会一直执行，直到窗口重新满足约束为止。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>更新结果</strong>：</p>
<ul>
<li>在每次 <code>right</code> 指针移动后，并且在（可能发生的）收缩操作完成后，当前的窗口 <code>s[left:right+1]</code> 一定是有效的。</li>
<li>我们计算当前有效窗口的长度 <code>right - left + 1</code>，并用它来更新 <code>max_len</code>。</li>
</ul>
</li>
<li><p><strong>计算最终答案</strong>：</p>
<ul>
<li>遍历结束后，<code>max_len</code> 就是我们找到的“可以保留的最长子串”的长度。</li>
<li>那么，需要取走的最少字符数就是 <code>len(s) - max_len</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">takeCharacters</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1: 预处理与边界检查</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        total_counts = collections.Counter(s)</span><br><span class="line">        <span class="keyword">if</span> total_counts[<span class="string">&#x27;a&#x27;</span>] &lt; k <span class="keyword">or</span> total_counts[<span class="string">&#x27;b&#x27;</span>] &lt; k <span class="keyword">or</span> total_counts[<span class="string">&#x27;c&#x27;</span>] &lt; k:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 2: 确定窗口内每种字符的数量上限</span></span><br><span class="line">        max_allowed = &#123;c: total_counts[c] - k <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span> <span class="comment"># 存储满足条件的最长窗口长度</span></span><br><span class="line">        window_counts = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 4: 滑动窗口，扩张右边界</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            char_right = s[right]</span><br><span class="line">            window_counts[char_right] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 5: 如果窗口不满足条件，收缩左边界</span></span><br><span class="line">            <span class="keyword">while</span> (window_counts[<span class="string">&#x27;a&#x27;</span>] &gt; max_allowed[<span class="string">&#x27;a&#x27;</span>] <span class="keyword">or</span> </span><br><span class="line">                   window_counts[<span class="string">&#x27;b&#x27;</span>] &gt; max_allowed[<span class="string">&#x27;b&#x27;</span>] <span class="keyword">or</span> </span><br><span class="line">                   window_counts[<span class="string">&#x27;c&#x27;</span>] &gt; max_allowed[<span class="string">&#x27;c&#x27;</span>]):</span><br><span class="line">                char_left = s[left]</span><br><span class="line">                window_counts[char_left] -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 6: 当前窗口有效，更新最大长度</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 7: 最终结果是总长度减去最长保留子串的长度</span></span><br><span class="line">        <span class="keyword">return</span> n - max_len</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是字符串 <code>s</code> 的长度。滑动窗口的左指针 <code>left</code> 和右指针 <code>right</code> 都只会从头到尾各自扫描一遍字符串，每个元素最多被访问两次。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个额外变量来存储字符计数，因为字符集是固定的 (‘a’, ‘b’, ‘c’)。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题的核心在于<strong>逆向思维</strong>，它将一个看似复杂的“两端操作”问题，巧妙地转化为了一个经典的“寻找满足条件的最长子串”问题。一旦完成了这个思路转换，剩下的就是滑动窗口算法的模板化应用了。这个技巧在处理类似问题时非常有效，值得我们牢记。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>第 325 场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2517 | 礼盒的最大甜蜜度</title>
    <url>//posts/leetcode-2517/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2517 题：<a href="https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/description/">礼盒的最大甜蜜度</a>。<br>这是一个经典的“最大化最小值”问题。当直接求解“最大的甜蜜度”比较困难时，我们可以转换思路，通过二分查找来猜测一个甜蜜度 <code>d</code>，然后验证是否存在一种方案能够满足“任意两种糖果的价格差都大于等于 <code>d</code>”，从而将一个求解最值的问题转化为一个判定性的问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个正整数数组 <code>price</code> ，其中 <code>price[i]</code> 表示第 <code>i</code> 类糖果的价格，另给你一个正整数 <code>k</code> 。</p>
<p>商店组合 <code>k</code> 类 <strong>不同</strong> 糖果打包成礼盒出售。礼盒的 <strong>甜蜜度</strong> 是礼盒中任意两种糖果 <strong>价格</strong> 绝对差的最小值。</p>
<p>返回礼盒的 <strong>最大</strong> 甜蜜度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：price =, k = 3</span><br><span class="line">输出：8</span><br><span class="line">解释：选出价格分别为 的三类糖果。</span><br><span class="line">礼盒的甜蜜度为 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8 。</span><br><span class="line">可以证明能够取得的最大甜蜜度就是 8 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：price =, k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：选出价格分别为 的两类糖果。 </span><br><span class="line">礼盒的甜蜜度为 min(|1 - 3|) = min(2) = 2 。</span><br><span class="line">可以证明能够取得的最大甜蜜度就是 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：price =, k = 2</span><br><span class="line">输出：0</span><br><span class="line">解释：从现有的糖果中任选两类糖果，甜蜜度都会是 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= k &lt;= price.length &lt;= 10^5</code></li>
<li><code>1 &lt;= price[i] &lt;= 10^9</code></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="问题转换与二分答案"><a href="#问题转换与二分答案" class="headerlink" title="问题转换与二分答案"></a>问题转换与二分答案</h4><p>题目的目标是求“最大”的“最小”差值，这是一个典型的“最大化最小值”问题，通常可以考虑使用二分查找来解决。</p>
<p>我们不直接去求解这个最大甜蜜度，而是去猜测它。假设我们猜测最大甜蜜度可以是 <code>d</code>，那么我们需要解决一个判定性问题：<strong>能否在 <code>price</code> 数组中选出 <code>k</code> 个数，使得它们之间任意两个数的差都大于等于 <code>d</code> ？</strong></p>
<p>这个判定问题具有单调性：</p>
<ul>
<li>如果甜蜜度 <code>d</code> <strong>可以</strong>实现，那么任何小于 <code>d</code> 的甜蜜度（例如 <code>d-1</code>）也一定可以实现。</li>
<li>如果甜蜜度 <code>d</code> <strong>无法</strong>实现，那么任何大于 <code>d</code> 的甜蜜度（例如 <code>d+1</code>）也一定无法实现。</li>
</ul>
<p>这种单调性是使用二分查找的理论基础。我们可以二分枚举答案 <code>d</code>，找到满足条件的 <code>d</code> 的最大值。</p>
<h4 id="check-d-函数的设计"><a href="#check-d-函数的设计" class="headerlink" title="check(d) 函数的设计"></a><code>check(d)</code> 函数的设计</h4><p>现在，核心问题变成了如何高效地实现 <code>check(d)</code> 函数，即判断能否选出 <code>k</code> 个价格，使得它们两两之差的绝对值不小于 <code>d</code>。</p>
<p>为了让价格差尽可能大，我们应该选择那些数值上离得尽可能远的糖果。一个自然的想法是<strong>贪心</strong>。</p>
<ol>
<li><strong>排序</strong>：首先，我们将 <code>price</code> 数组升序排序。这样，任意两个价格的差值就等于它们在排序后数组中的数值之差。</li>
<li><strong>贪心选择</strong>：我们总是选择第一个糖果（价格最低的那个）作为礼盒中的第一个成员。然后，向后遍历数组，寻找下一个与上一个已选糖果价格之差大于等于 <code>d</code> 的糖果。<ul>
<li>设我们上一个选择的糖果价格是 <code>pre</code>。我们从 <code>pre</code> 的位置继续向后扫描，找到第一个价格 <code>p</code> 满足 <code>p - pre &gt;= d</code>。</li>
<li>一旦找到，就将这个糖果选入礼盒，更新 <code>pre = p</code>，并将计数器加一。</li>
<li>重复这个过程，直到遍历完整个数组。</li>
</ul>
</li>
<li><strong>判断</strong>：最后，检查我们通过这种贪心策略选出的糖果数量是否达到了 <code>k</code>。如果数量大于等于 <code>k</code>，说明甜蜜度 <code>d</code> 是可行的，<code>check(d)</code> 返回 <code>True</code>；否则返回 <code>False</code>。</li>
</ol>
<p>这个贪心策略是正确的，因为为了在有限的价格范围内放下尽可能多的、满足最小间距 <code>d</code> 的糖果，我们每次选择下一个糖果时，都应该选择“恰好”满足条件或者刚刚超过条件的那个，这样可以为后面的选择留出最大的空间。</p>
<h4 id="二分查找框架"><a href="#二分查找框架" class="headerlink" title="二分查找框架"></a>二分查找框架</h4><ol>
<li><strong>确定搜索范围</strong>：<ul>
<li>甜蜜度的最小值显然是 <code>0</code>。</li>
<li>甜蜜度的最大值不会超过 <code>(price[n-1] - price[0])</code>。我们可以用这个作为上界，或者一个更紧的上界 <code>(price[n-1] - price[0]) / (k - 1)</code>。</li>
</ul>
</li>
<li><strong>实施二分</strong>：<ul>
<li>设置左边界 <code>l = 0</code>，右边界 <code>r</code> 为一个足够大的数（例如 <code>10^9</code> 或上述上界）。</li>
<li>在 <code>while</code> 循环中，取中点 <code>mid = (l + r) // 2</code>。</li>
<li>调用 <code>check(mid)</code>：<ul>
<li>如果 <code>check(mid)</code> 为 <code>True</code>，说明 <code>mid</code> 这个甜蜜度是可行的，我们可以尝试更大的值。所以，我们将 <code>mid</code> 存为可能的答案，并移动左边界 <code>l = mid + 1</code>。</li>
<li>如果 <code>check(mid)</code> 为 <code>False</code>，说明 <code>mid</code> 太大了，需要尝试小一点的值。移动右边界 <code>r = mid - 1</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>返回结果</strong>：循环结束后，最后一次使得 <code>check</code> 返回 <code>True</code> 的那个值就是最终答案。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumTastiness</span>(<span class="params">self, price: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 对价格进行排序，这是贪心策略的前提</span></span><br><span class="line">        price.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># check(d) 函数用于判断是否存在一种选择方案，</span></span><br><span class="line">        <span class="comment"># 使得礼盒的甜蜜度至少为 d</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">d: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># 贪心选择 k 个糖果</span></span><br><span class="line">            <span class="comment"># 默认选择第一个（价格最低的）</span></span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">            last_price = price</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 遍历价格数组，寻找下一个满足条件的糖果</span></span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> price:</span><br><span class="line">                <span class="keyword">if</span> p - last_price &gt;= d:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    last_price = p</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果能选出至少 k 个，则说明甜蜜度 d 是可行的</span></span><br><span class="line">            <span class="keyword">return</span> count &gt;= k</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找答案的范围</span></span><br><span class="line">        <span class="comment"># 左边界 l: 最小可能的甜蜜度</span></span><br><span class="line">        <span class="comment"># 右边界 r: 最大可能的甜蜜度</span></span><br><span class="line">        l, r = <span class="number">0</span>, price[-<span class="number">1</span>] - price</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 开始二分查找</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 可行，说明答案可能是 mid 或更大</span></span><br><span class="line">                <span class="comment"># 保存当前可行的 mid，并尝试更大的值</span></span><br><span class="line">                ans = mid</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 不可行，说明 mid 太大了，需要缩小范围</span></span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N log N + N log M)，其中 N 是 <code>price</code> 数组的长度，M 是价格的最大差值 <code>price[-1] - price[0]</code>。<ul>
<li>对 <code>price</code> 数组排序需要 O(N log N) 的时间。</li>
<li>二分查找的过程需要进行 O(log M) 次迭代。</li>
<li>在每次迭代中，<code>check</code> 函数需要 O(N) 的时间来遍历数组。</li>
<li>因此，总时间复杂度为 O(N log N + N log M)。由于 N 通常远大于 log M，复杂度主要由排序和 <code>check</code> 函数决定。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：O(log N) 或 O(N)，取决于排序算法所使用的栈空间。如果原地排序，则为 O(log N)；如果使用了需要额外空间的排序，则为 O(N)。</li>
</ul>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>最大化最小值</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>排序</tag>
        <tag>第325场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2555 | DP与SW求解“两个线段获得的最多奖品”</title>
    <url>//posts/leetcode-2555/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2555 题：<a href="https://leetcode.cn/problems/maximize-win-from-two-segments/description/">两个线段获得的最多奖品</a>。<br>该题要求放置两个固定长度的线段来覆盖最多的点。直接寻找两个线段的最优位置组合非常复杂，但如果我们固定一个，再去优化另一个，问题就豁然开朗了。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个非递减的整数数组 <code>prizePositions</code>，代表 X 轴上奖品的位置，以及一个整数 <code>k</code>。我们需要在 X 轴上放置<strong>两个</strong>长度为 <code>k</code> 的线段，目标是让这两个线段覆盖的奖品总数达到最大。线段的端点必须是整数，并且它们可以重叠。</p>
<p>举个例子，对于 <code>prizePositions = [1,1,2,2,3,3,5]</code>, <code>k = 2</code>：</p>
<ul>
<li>我们的目标是找到两个长度为 2 的线段，覆盖最多的奖品。</li>
<li>一个最优解是选择线段 <code>[1, 3]</code> 和 <code>[3, 5]</code>。<ul>
<li>线段 <code>[1, 3]</code> 覆盖了位置在 1, 2, 3 的所有奖品，共 6 个。</li>
<li>线段 <code>[3, 5]</code> 覆盖了位置在 3, 5 的所有奖品，共 3 个。</li>
<li>但是因为位置 3 的两个奖品被重复计算了，我们应该看它们覆盖的奖品集合。<code>[1,3]</code> 覆盖 <code>&#123;1,1,2,2,3,3&#125;</code>，<code>[3,5]</code> 覆盖 <code>&#123;3,3,5&#125;</code>。总共覆盖的奖品是 <code>&#123;1,1,2,2,3,3,5&#125;</code>，共 7 个。</li>
</ul>
</li>
<li>题目要求的就是这个最大值 7。</li>
</ul>
<p>直接去枚举两个线段的所有可能位置，复杂度太高。我们需要一种更高效的策略。</p>
<h3 id="核心思路：动态规划与滑动窗口的结合"><a href="#核心思路：动态规划与滑动窗口的结合" class="headerlink" title="核心思路：动态规划与滑动窗口的结合"></a>核心思路：动态规划与滑动窗口的结合</h3><p>当需要同时优化两个变量（这里是两个线段的位置）时，一个常见的降维打击思路是：<strong>先固定一个，再优化另一个</strong>。</p>
<p>假设我们正在考虑第二个线段的位置。当我们用一个滑动窗口 <code>[j, i]</code> 来代表第二个线段覆盖的奖品时（即 <code>prizePositions[i] - prizePositions[j] &lt;= k</code>），这个线段本身能获得的奖品数是固定的。为了让总数最大化，我们只需要为它搭配一个<strong>在它左侧</strong>的最佳第一线段。</p>
<p>这个“左侧最佳”正是动态规划可以发挥作用的地方。我们可以预先计算出对于任意位置 <code>x</code>，在 <code>x</code> 的左侧区域内，用<strong>一个</strong>线段能获得的最大奖品数是多少。</p>
<p>于是，整个解法分为清晰的两步：</p>
<ol>
<li><p><strong>预计算（第一遍滑动窗口）</strong>：<br>我们创建一个 <code>pre_max</code> 数组，其中 <code>pre_max[i]</code> 存储在 <code>prizePositions[0...i]</code> 这个前缀范围内，使用<strong>一个</strong>线段能获得的最大奖品数。这个数组可以通过一次滑动窗口遍历来高效计算。</p>
</li>
<li><p><strong>最终求解（第二遍滑动窗口）</strong>：<br>我们再次使用一个滑动窗口 <code>[j, i]</code> 来枚举所有可能的<strong>第二个线段</strong>。对于每一个确定的第二个线段（覆盖 <code>i-j+1</code> 个奖品），我们利用 <code>pre_max</code> 数组，瞬间就能查到在它左边（即 <code>j</code> 之前）的最佳第一线段能覆盖多少奖品（<code>pre_max[j-1]</code>）。两者相加，就是当前组合下的总奖品数。我们遍历所有可能的第二个线段，就能找到全局最优解。</p>
</li>
</ol>
<p><img src="https://assets.leetcode.com/uploads/2023/01/21/screenshot-2023-01-22-at-000100.png" alt="Diagram Explanation"><em>上图形象地展示了第二个线段（蓝色）和其左侧最优的第一线段（绿色）的组合</em></p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>第一步：预计算 <code>pre_max</code> 数组</strong></p>
<ul>
<li>初始化一个与 <code>prizePositions</code> 等长的 <code>pre_max</code> 数组，所有元素为 0。</li>
<li>使用一个滑动窗口 <code>[left, right]</code> 从左到右遍历 <code>prizePositions</code>。</li>
<li>对于每个 <code>right</code>，我们向右移动 <code>left</code> 指针，直到窗口满足 <code>prizePositions[right] - prizePositions[left] &lt;= k</code>。</li>
<li>此时，窗口 <code>[left, right]</code> 覆盖的奖品数为 <code>right - left + 1</code>。</li>
<li>我们更新 <code>pre_max[right]</code>。它的值应该等于“在 <code>right</code> 之前能获得的最大奖品数 (<code>pre_max[right-1]</code>)”和“当前窗口覆盖的奖品数”中的较大者。即 <code>pre_max[right] = max(pre_max[right-1], right - left + 1)</code>。这确保了 <code>pre_max[i]</code> 存储的是 <code>0</code> 到 <code>i</code> 范围内的最优解。</li>
</ul>
</li>
<li><p><strong>第二步：计算最终结果</strong></p>
<ul>
<li>初始化最终答案 <code>ans = 0</code>。</li>
<li>再次使用一个滑动窗口 <code>[j, i]</code> 从左到右遍历 <code>prizePositions</code>，这个窗口代表<strong>第二个线段</strong>。</li>
<li>对于每个 <code>i</code>，同样移动 <code>j</code> 以维持窗口 <code>prizePositions[i] - prizePositions[j] &lt;= k</code>。</li>
<li>第二个线段覆盖的奖品数为 <code>prizes_second = i - j + 1</code>。</li>
<li>第一个线段必须在第二个线段的左侧。它能获得的最大奖品数我们已经算好了，就是 <code>pre_max[j-1]</code>。（需要注意边界，如果 <code>j=0</code>，则左侧没有空间，奖品数为 0）。</li>
<li>计算当前组合的总奖品数 <code>total = prizes_second + (pre_max[j-1] if j &gt; 0 else 0)</code>。</li>
<li>用 <code>total</code> 更新全局最大值 <code>ans</code>。</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>遍历结束后，<code>ans</code> 即为所求。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximizeWin</span>(<span class="params">self, prizePositions: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prizePositions)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 1: 预计算 pre_max 数组</span></span><br><span class="line">        <span class="comment"># pre_max[i] 表示在 prizePositions[0...i] 范围内，用一个线段能获得的最大奖品数</span></span><br><span class="line">        pre_max = [<span class="number">0</span>] * n</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 维持窗口大小 prizePositions[right] - prizePositions[left] &lt;= k</span></span><br><span class="line">            <span class="keyword">while</span> prizePositions[right] - prizePositions[left] &gt; k:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            current_prizes = right - left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right &gt; <span class="number">0</span>:</span><br><span class="line">                pre_max[right] = <span class="built_in">max</span>(pre_max[right - <span class="number">1</span>], current_prizes)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre_max[right] = current_prizes</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2: 第二遍滑动窗口，计算最终结果</span></span><br><span class="line">        <span class="comment"># 窗口 [j, i] 代表第二个线段</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> prizePositions[i] - prizePositions[j] &gt; k:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 第二个线段覆盖的奖品数</span></span><br><span class="line">            prizes_second_segment = i - j + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 第一个线段在 j 左侧能获得的最大奖品数</span></span><br><span class="line">            prizes_first_segment = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                prizes_first_segment = pre_max[j - <span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新全局最大值</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, prizes_first_segment + prizes_second_segment)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是 <code>prizePositions</code> 的长度。我们对数组进行了两次独立的遍历，每次遍历中的左右指针都只单向移动，因此每次遍历都是线性的。</li>
<li><strong>空间复杂度</strong>: O(N)。我们使用了一个与输入等长的 <code>pre_max</code> 数组来存储中间结果。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是一个非常典型的“通过预计算降低复杂度”的案例。直接处理两个相互影响的变量很困难，但通过动态规划的思想，将其中一个变量的最优解预计算出来，再与另一个变量结合，问题就从 O(N^2) 级别的复杂度降低到了 O(N)。这种“先算一部分，再用算出的结果去算整体”的模式，是解决许多复杂数组和区间问题的金钥匙。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>滑动窗口</tag>
        <tag>前缀和</tag>
        <tag>动态规划</tag>
        <tag>第97场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2560 | 打家劫舍 IV</title>
    <url>//posts/leetcode-2560/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2560 题：<a href="https://leetcode.cn/problems/house-robber-iv/description/">打家劫舍 IV</a>。<br>本题的核心在于识别出答案的单调性，并将一个求解最优值（最小的最大值）的问题，巧妙地转化为一个判定性的问题，从而利用二分查找在对数时间内高效求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要在一排房屋中窃取至少 <code>k</code> 间，但不能窃取相邻的房屋。小偷的“窃取能力”被定义为他在一次成功的窃取行动中，从单间房屋里拿到的<strong>最大</strong>金额。我们的目标是，在所有满足条件的窃取方案中，找到这个“窃取能力”的<strong>最小值</strong>。</p>
<p>这里的核心约束条件是：</p>
<ol>
<li>不能窃取相邻的房屋。</li>
<li>总共窃取的房屋数量必须<strong>至少</strong>为 <code>k</code> 间。</li>
<li>目标是让窃取方案中，金额最大的那间房屋的金额尽可能小。</li>
</ol>
<p>举个例子，<code>nums = [2,3,5,9]</code>, <code>k = 2</code>。</p>
<ul>
<li>方案一：窃取 2 和 5。窃取能力是 <code>max(2, 5) = 5</code>。</li>
<li>方案二：窃取 2 和 9。窃取能力是 <code>max(2, 9) = 9</code>。</li>
<li>方案三：窃取 3 和 9。窃取能力是 <code>max(3, 9) = 9</code>。<br>在所有可行的方案中，最小的窃取能力是 5。</li>
</ul>
<p>这个问题本质上是在求解“最小值中的最大值”或者“最大值中的最小值”这类极小化极大问题，这通常是二分答案的经典应用场景。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接去枚举所有组合来求解“最小的窃取能力”是非常复杂的。因此，我们不妨换一个角度思考：如果我们<strong>假定</strong>一个窃取能力为 <code>c</code>，我们能否判断出，是否存在一个合法的方案，使得我们能偷到至少 <code>k</code> 间房，并且所有被偷的房屋金额都不超过 <code>c</code>？</p>
<p>这个判定问题就相对简单了。我们可以设计一个辅助函数 <code>check(capacity)</code>，用贪心的策略来验证：</p>
<ul>
<li>我们遍历所有房屋。</li>
<li>对于第 <code>i</code> 间房，如果它的金额 <code>nums[i]</code> 不超过我们假定的能力 <code>capacity</code>，那么我们就应该窃取它，因为这能帮助我们尽快凑够 <code>k</code> 间房。</li>
<li>一旦我们决定窃取第 <code>i</code> 间房，根据规则，我们必须跳过第 <code>i+1</code> 间房。</li>
<li>如果我们不窃取第 <code>i</code> 间房（因为它金额太高），那我们就继续考察第 <code>i+1</code> 间房。</li>
<li>遍历结束后，我们统计总共窃取了多少间房。如果数量大于等于 <code>k</code>，说明 <code>capacity</code> 这个能力是可行的。</li>
</ul>
<p>现在，我们有了一个判定的方法。这个判定结果具有明显的<strong>单调性</strong>：</p>
<ul>
<li>如果一个能力 <code>c</code> 可以让我们偷到至少 <code>k</code> 间房，那么任何比 <code>c</code> 更大的能力 <code>c&#39;</code> 也一定可以（因为更多的房屋金额会达标，我们只会有更多选择）。</li>
<li>反之，如果 <code>c</code> 无法满足条件，那么任何比 <code>c</code> 更小的能力也必然无法满足。</li>
</ul>
<p>这种单调性正是应用二分查找的完美前提。我们可以对“窃取能力”这个值进行二分查找，来快速定位到那个“最小可行”的临界点。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：窃取能力至少得是房屋金额中的最小值，否则一间都偷不了。所以下界是 <code>min(nums)</code>。</li>
<li><strong>上界 (right)</strong>：窃取能力最大也只需要是房屋金额中的最大值，因为更大的能力不会改变任何决策。所以上界是 <code>max(nums)</code>。</li>
</ul>
<p>因此，我们就在 <code>[min(nums), max(nums)]</code> 这个区间内，对窃取能力进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = min(nums)</code>：这是可能的最低能力。</li>
<li><code>right = max(nums)</code>：这是可能的最高能力。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>left &lt; right</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = left + (right - left) // 2</code> 作为当前的“猜测能力”。</li>
<li>调用辅助函数 <code>check(mid)</code> 来判定这个猜测值是否可行。<ul>
<li><strong>如果 <code>check(mid)</code> 返回 <code>True</code></strong> (即 <code>mid</code> 这个能力可以偷到至少 <code>k</code> 间房)：<ul>
<li>说明 <code>mid</code> 是一个潜在的答案，但我们想找的是“最小”能力，所以我们尝试一个更小的值。我们将搜索范围缩小到左半边（包含 <code>mid</code>）：<code>right = mid</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>False</code></strong> (即 <code>mid</code> 这个能力不够)：<ul>
<li>说明我们需要更大的能力，将搜索范围缩小到右半边：<code>left = mid + 1</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>left</code> 和 <code>right</code> 会相遇于一点，这个点就是满足条件的最小窃取能力。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCapability</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 确定二分查找的左右边界</span></span><br><span class="line">        left, right = <span class="built_in">min</span>(nums), <span class="built_in">max</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 辅助函数：检查在给定的窃取能力(capacity)下，能否窃取至少 k 间房屋</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">capacity: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            count = <span class="number">0</span>  <span class="comment"># 记录可以窃取的房屋数量</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            n = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">while</span> i &lt; n:</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt;= capacity:</span><br><span class="line">                    <span class="comment"># 这间房的金额在能力范围内，可以偷</span></span><br><span class="line">                    <span class="comment"># 偷了这间，下一间必须跳过</span></span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    i += <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 金额太高，不能偷，看下一间</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> count &gt;= k</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 可行，它可能就是答案，</span></span><br><span class="line">                <span class="comment"># 或者还有更小的可行值，所以我们尝试在左半部分继续寻找</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 不可行，说明能力太小，</span></span><br><span class="line">                <span class="comment"># 必须增大，所以去右半部分寻找</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时，left 就是满足条件的最低窃取能力</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N * log(M))。<ul>
<li><code>N</code> 是房屋数组 <code>nums</code> 的长度。</li>
<li><code>M</code> 是 <code>max(nums) - min(nums)</code>，即二分查找的搜索空间大小。</li>
<li>二分查找本身需要 <code>log(M)</code> 次迭代。</li>
<li>在每次迭代中，我们都需要调用 <code>check</code> 函数，该函数需要贪心地遍历一次 <code>nums</code> 数组，时间复杂度为 O(N)。</li>
<li>因此，总时间复杂度是这两者的乘积。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)。<ul>
<li>除了输入数组外，我们只使用了几个变量来存储左右边界和中间值，所以空间复杂度是常数级的。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“二分答案”思想的又一个绝佳应用。它向我们展示了如何将一个看似复杂的“求最优解”问题，转化为一个结构简单且具有单调性的“判定”问题。一旦建立起这种转化思维，就可以利用二分查找这一强大工具，将问题的时间复杂度从指数级或高次多项式级，优化到对数级别，从而高效地解决问题。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>最小化最大值</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>动态规划</tag>
        <tag>第331场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2576 | 求出最多标记下标</title>
    <url>//posts/leetcode-2576/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2576 题：<a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/description/">求出最多标记下标</a>。<br>本题的关键在于通过排序，将问题转化为一个判定问题：我们能否标记出 <code>2*k</code> 个下标？这个判定问题具有单调性，因此可以利用二分查找来高效地找到最大的 <code>k</code>。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目要求我们在一个整数数组 <code>nums</code> 中，尽可能多地标记下标。标记的规则是：每次选择两个未被标记的、不同的下标 <code>i</code> 和 <code>j</code>，如果它们满足 <code>2 * nums[i] &lt;= nums[j]</code>，就可以将这两个下标标记。我们的目标是最大化被标记的下标总数。</p>
<p>这里的核心约束条件是：</p>
<ol>
<li>每次操作选择的 <code>i</code> 和 <code>j</code> 必须是之前未被标记过的。</li>
<li>必须满足 <code>2 * nums[i] &lt;= nums[j]</code> 的条件。</li>
<li>目标是让最终被标记的下标数量最多。</li>
</ol>
<p>由于被标记的下标总是成对出现的，所以最大化标记下标的数量等价于最大化我们能成功匹配的<strong>配对数</strong>。</p>
<p>举个例子，<code>nums = [9,2,5,4]</code>。<br>如果我们想匹配，一个很自然的想法是先对数组排序，得到 <code>[2,4,5,9]</code>。这样我们更容易找到满足 <code>2 * x &lt;= y</code> 的数对。<br>排序后，我们尝试配对：</p>
<ul>
<li>拿最小的 <code>2</code> 和 <code>4</code> 配对？<code>2 * 2 &lt;= 4</code>，不满足。</li>
<li>拿最小的 <code>2</code> 和 <code>5</code> 配对？<code>2 * 2 &lt;= 5</code>，满足。我们可以标记 <code>2</code> 和 <code>5</code>。</li>
<li>剩下 <code>4</code> 和 <code>9</code>。<code>2 * 4 &lt;= 9</code>，满足。我们可以标记 <code>4</code> 和 <code>9</code>。<br>最终，所有数字都被标记了，总共 4 个。</li>
</ul>
<p>这个例子启发我们，排序可能是一个关键步骤，并且配对时应该采取某种贪心策略。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最多能凑成几对”似乎有些复杂。我们可以换一个角度思考：给定一个整数 <code>k</code>，我们能否判断出<strong>是否可以凑成 <code>k</code> 对</strong>？</p>
<p>这个问题，即“判定问题”，相对更容易解决。如果我们能解决这个判定问题，就可以利用其单调性进行二分查找。</p>
<p><strong>判定问题：<code>check(k)</code></strong><br>假设我们要判断能否凑成 <code>k</code> 对。为了尽可能地满足 <code>2 * nums[i] &lt;= nums[j]</code> 这个条件，我们应该让 <code>nums[i]</code> 尽可能小，<code>nums[j]</code> 尽可能大。<br>一个最优的贪心策略是：</p>
<ol>
<li>首先对数组 <code>nums</code> 进行排序。</li>
<li>选出数组中最小的 <code>k</code> 个数作为所有 <code>nums[i]</code> 的候选。</li>
<li>选出数组中最大的 <code>k</code> 个数作为所有 <code>nums[j]</code> 的候选。</li>
<li>然后进行配对。为了让每个小的数都能配对成功，我们应该用最小的 <code>nums[i]</code>（即 <code>nums[0]</code>）去和最小的可用 <code>nums[j]</code>（即 <code>nums[n-k]</code>）配对，以此类推。</li>
<li>所以，检查条件就变成了：<code>nums[0]</code> 能否和 <code>nums[n-k]</code> 配对，<code>nums[1]</code> 能否和 <code>nums[n-k+1]</code> 配对，……，<code>nums[k-1]</code> 能否和 <code>nums[n-1]</code> 配对。</li>
<li>如果 <code>2 * nums[i] &lt;= nums[n-k+i]</code> 对所有的 <code>i</code> in <code>[0, k-1]</code> 都成立，那么我们就能凑成 <code>k</code> 对。</li>
</ol>
<p><strong>单调性</strong><br>这个判定结果具有明显的单调性：</p>
<ul>
<li>如果我们能成功凑成 <code>k</code> 对，那么我们一定能凑成 <code>k-1</code> 对（因为我们可以直接使用前 <code>k-1</code> 对的方案）。</li>
<li>如果我们无法凑成 <code>k</code> 对，那么我们更不可能凑成 <code>k+1</code> 对（因为 <code>k+1</code> 对的要求更严格）。</li>
</ul>
<p>这种单调性是应用二分查找的完美场景。我们可以对“配对数 <code>k</code>”进行二分查找，来快速定位到那个“最大可行”的临界点。</p>
<p>二分查找的搜索范围是什么？</p>
<ul>
<li><strong>下界 (left)</strong>：最少可以凑成 0 对。</li>
<li><strong>上界 (right)</strong>：最多可以凑成 <code>n/2</code> 对，因为每对消耗两个数。</li>
</ul>
<p>因此，我们就在 <code>[0, n/2]</code> 这个区间内，对配对数 <code>k</code> 进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>排序</strong></p>
<ul>
<li>首先，对 <code>nums</code> 数组进行升序排序。</li>
</ul>
</li>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = 0</code>：可能的最小配对数。</li>
<li><code>right = len(nums) // 2 + 1</code>：配对数的一个开区间上界。我们将搜索区间设为 <code>[left, right)</code>，其中 <code>left</code> 始终是我们已知的可行解。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>left + 1 &lt; right</code> 时，循环继续。</li>
<li>计算中间值 <code>k = (left + right) // 2</code> 作为当前的“猜测配对数”。</li>
<li>调用判定逻辑 <code>check(k)</code>：<ul>
<li>遍历 <code>i</code> from <code>0</code> to <code>k-1</code>。</li>
<li>检查 <code>2 * nums[i]</code> 是否小于等于 <code>nums[len(nums) - k + i]</code>。</li>
<li>在Python中，<code>nums[len(nums) - k + i]</code> 可以用负数索引 <code>nums[i-k]</code> 巧妙地表示。</li>
<li><strong>如果 <code>check(k)</code> 为真</strong> (即 <code>k</code> 对是可行的)：<ul>
<li>说明 <code>k</code> 是一个潜在的答案，但我们想找的是“最大”的 <code>k</code>，所以我们尝试一个更大的值，将搜索范围的下界更新：<code>left = k</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(k)</code> 为假</strong> (即 <code>k</code> 对是不可行的)：<ul>
<li>说明 <code>k</code> 太大了，必须减少配对数，所以将搜索范围的上界更新：<code>right = k</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>left</code> 中存储的就是满足条件的<strong>最大配对数</strong>。</li>
<li>题目要求返回最多可以标记的<strong>下标数目</strong>，所以最终结果是 <code>left * 2</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxNumOfMarkedIndices</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1：排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2：确定二分查找范围</span></span><br><span class="line">        <span class="comment"># 我们对“可以凑成的配对数 k”进行二分查找</span></span><br><span class="line">        <span class="comment"># left 是已知可行的最大配对数，right 是不可行的最小配对数（开区间）</span></span><br><span class="line">        left, right = <span class="number">0</span>, n // <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3：执行二分查找</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">            <span class="comment"># k 是我们尝试要验证的配对数</span></span><br><span class="line">            k = (left + right) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># check(k): 检查是否能凑成 k 对</span></span><br><span class="line">            <span class="comment"># 贪心策略：用最小的 k 个数 nums[0...k-1]</span></span><br><span class="line">            <span class="comment"># 去匹配最大的 k 个数 nums[n-k...n-1]</span></span><br><span class="line">            <span class="comment"># all() 函数会检查所有条件是否为真</span></span><br><span class="line">            <span class="comment"># nums[i-k] 是 Python 的负数索引，等价于 nums[n + i - k]</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">all</span>(nums[i] * <span class="number">2</span> &lt;= nums[i - k] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)):</span><br><span class="line">                <span class="comment"># 如果可以凑成 k 对，说明 k 是一个可行的解</span></span><br><span class="line">                <span class="comment"># 我们尝试寻找更大的 k，所以更新下界</span></span><br><span class="line">                left = k</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果不行，说明 k 太大了，需要减小 k</span></span><br><span class="line">                <span class="comment"># 更新上界</span></span><br><span class="line">                right = k</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 4：返回结果</span></span><br><span class="line">        <span class="comment"># left 是我们找到的最大可行配对数</span></span><br><span class="line">        <span class="comment"># 总标记数量是配对数的两倍</span></span><br><span class="line">        <span class="keyword">return</span> left * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N * log N)。<ul>
<li>对数组排序需要 O(N log N) 的时间。</li>
<li>二分查找的范围是 <code>n/2</code>，所以需要 O(log N) 次迭代。</li>
<li>在每次迭代中，我们的 <code>check</code> 逻辑（即 <code>all(...)</code> 生成器表达式）需要遍历 <code>k</code> 个元素，<code>k</code> 最大为 <code>N/2</code>，所以检查的时间复杂度为 O(N)。</li>
<li>因此，二分查找部分的总时间是 O(N log N)。</li>
<li>两者相加，总时间复杂度由排序和二分查找共同决定，为 O(N log N)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(log N) 或 O(N)。<ul>
<li>这主要取决于排序算法使用的空间。Python 的 Timsort 在平均情况下的空间复杂度是 O(log N)，最坏情况下是 O(N)。如果我们不考虑排序本身占用的空间，则算法是 O(1) 的。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“二分答案”思想的又一个典型应用。当直接求解一个“最大值”或“最小值”问题比较困难时，我们可以尝试将其转化为一个“判定性”问题。如果这个判定问题对于答案具有单调性，就可以通过二分查找来极大地优化求解过程。这里的关键点在于，为判定问题 <code>check(k)</code> 设计出一个高效的贪心策略，从而确保了整个算法的正确性和效率。效率。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最大</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>排序</tag>
        <tag>双指针</tag>
        <tag>第334场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2616 | 最小化数对的最大差值</title>
    <url>//posts/leetcode-2616/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2616 题：<a href="https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/description/">最小化数对的最大差值</a>。<br>当直接求解“最小化的最大差值”很困难时，我们可以反向思考：给定一个差值 <code>d</code>，能否找到 <code>p</code> 个数对？这个问题可以通过二分查找将求解最值问题转化为判定问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>给定一个整数数组 <code>nums</code> 和一个整数 <code>p</code>。我们需要从数组中找出 <code>p</code> 个互不重叠的数对。我们的目标是，在这 <code>p</code> 个数对的差值中，找到那个最大的差值，并让这个“最大的差值”尽可能地小。最终返回这个“最小的可能的最大差值”。</p>
<p>举个例子，<code>nums = [10,1,2,7,1,3], p = 2</code>。<br>我们希望找出 2 个数对，使得它们差值的最大值最小。<br>为了让数对的差值尽可能小，我们应该优先选择数值上接近的数字配对。因此，一个关键的预处理步骤是对数组进行排序，得到 <code>[1,1,2,3,7,10]</code>。<br>排序后，相邻的元素之间的差值是最小的。</p>
<ul>
<li>我们可以选择 <code>(1,1)</code>，差值为 0。</li>
<li>剩下 <code>[2,3,7,10]</code>，我们可以选择 <code>(2,3)</code>，差值为 1。<br>这样我们找到了两个数对 <code>(1,1)</code> 和 <code>(2,3)</code>，它们的差值分别是 0 和 1。这 2 个差值的最大值是 <code>max(0, 1) = 1</code>。这是一个可能的答案。我们能否找到更小的最大差值呢？答案是否定的，所以最终结果是 1。</li>
</ul>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接计算“最小的最大差值”没有明确的下手点。但是，我们可以转换思路：如果我们<strong>猜测</strong>一个“最大差值”为 <code>d</code>，我们能否判断出，是否存在 <code>p</code> 个数对，使得每个数对的差值都<strong>不超过</strong> <code>d</code>？</p>
<p>这个“判定问题”就清晰多了。我们可以定义一个 <code>check(d)</code> 函数：</p>
<ul>
<li>该函数接收一个猜测的差值 <code>d</code> 作为参数。</li>
<li>在数组中，我们尝试寻找 <code>p</code> 个差值不大于 <code>d</code> 的数对。</li>
<li>为了尽可能多地凑出数对，我们应该采用<strong>贪心策略</strong>。首先对数组排序，然后遍历数组。当我们遇到 <code>nums[i+1] - nums[i] &lt;= d</code> 时，就将 <code>(nums[i], nums[i+1])</code> 凑成一对。因为 <code>nums[i]</code> 与 <code>nums[i+1]</code> 的差值是最小的，如果它都不与 <code>nums[i+1]</code> 配对，那么它与后面的任何元素配对的差值只会更大，更不划算。同时，为了满足“每个下标最多出现一次”的规则，当我们成功凑对后，下一个检查点应该跳到 <code>i+2</code>。</li>
<li>如果在遍历结束后，我们能凑够 <code>p</code> 对，那么 <code>check(d)</code> 就返回 <code>True</code>。</li>
</ul>
<p>这个 <code>check(d)</code> 函数具有非常明显的<strong>单调性</strong>：</p>
<ul>
<li>如果一个最大差值 <code>d</code> 是<strong>可行</strong>的（能找到 <code>p</code> 对），那么任何比 <code>d</code> 更大的差值 <code>d&#39;</code> 也<strong>一定</strong>是可行的（因为放宽了条件，原来满足的数对现在依然满足）。</li>
<li>反之，如果差值 <code>d</code> <strong>不可行</strong>（找不到 <code>p</code> 对），那么任何比 <code>d</code> 更小的差值 <code>d&#39;&#39;</code> 也<strong>必然</strong>不可行。</li>
</ul>
<p>这种单调性让我们能够立刻想到使用<strong>二分查找</strong>来解决问题。我们可以在所有可能的差值范围内对“答案”进行二分查找，从而快速定位到那个“最小的可行差值”。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：<code>0</code>，差值最小可能为0。</li>
<li><strong>上界 (right)</strong>：排序后数组的最大值与最小值之差，即 <code>nums[n-1] - nums[0]</code>。这是可能的最大差值。</li>
</ul>
<p>因此，我们就在 <code>[0, nums[n-1] - nums[0]]</code> 这个区间内，对“最大差值”进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>排序数组</strong></p>
<ul>
<li>首先对 <code>nums</code> 数组进行升序排序。这是贪心策略的基础，使得相邻元素的差值最小。</li>
</ul>
</li>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = 0</code>：可能的最小答案。</li>
<li><code>right = nums[n-1] - nums[0]</code>：可能的最大答案。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>left &lt; right</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = left + (right - left) // 2</code> 作为当前的“猜测的最大差值”。</li>
<li>调用辅助函数 <code>check(mid)</code> 来判定这个猜测值是否可行。<ul>
<li><code>check(mid)</code> 函数内部，使用贪心策略进行检查：<ul>
<li>初始化一个计数器 <code>count = 0</code> 和一个指针 <code>i = 0</code>。</li>
<li>当 <code>i &lt; n-1</code> 时，检查 <code>nums[i+1] - nums[i]</code>。</li>
<li>如果 <code>nums[i+1] - nums[i] &lt;= mid</code>，说明找到一个合格的数对。我们让 <code>count</code> 加一，并且因为 <code>nums[i]</code> 和 <code>nums[i+1]</code> 都已被使用，指针 <code>i</code> 向后移动 2 位。</li>
<li>如果 <code>nums[i+1] - nums[i] &gt; mid</code>，说明 <code>(nums[i], nums[i+1])</code> 无法凑对。我们只能跳过 <code>nums[i]</code>，让指针 <code>i</code> 向后移动 1 位，继续寻找机会。</li>
<li>最终，如果 <code>count &gt;= p</code>，则 <code>check(mid)</code> 返回 <code>True</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>True</code></strong> (即最大差值为 <code>mid</code> 时，可以凑够 <code>p</code> 对)：<ul>
<li>说明 <code>mid</code> 是一个潜在的答案，但我们想找的是“最小”的最大差值，所以我们尝试一个更小的值，将搜索范围缩小到左半边（包含 mid）：<code>right = mid</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>False</code></strong> (即最大差值为 <code>mid</code> 时，凑不够 <code>p</code> 对)：<ul>
<li>说明我们对最大差值的限制太严格了，需要放宽一些，将搜索范围缩小到右半边：<code>left = mid + 1</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>left</code> 和 <code>right</code> 相遇，此时的值就是满足条件的最小的最大差值。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimizeMax</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], p: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 对数组排序，这是贪心策略的基础</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># check(mx) 函数用于判定：</span></span><br><span class="line">        <span class="comment"># 当允许的最大差值为 mx时，能否找到 p 个数对</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">mx: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            cnt = <span class="number">0</span>  <span class="comment"># 记录找到的有效数对数量</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n - <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 如果相邻元素的差值小于等于 mx，则它们可以组成一个数对</span></span><br><span class="line">                <span class="keyword">if</span> nums[i+<span class="number">1</span>] - nums[i] &lt;= mx:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 这两个元素已被使用，跳过它们</span></span><br><span class="line">                    i += <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 无法配对，只跳过当前元素</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果找到的数对数量大于等于 p，则说明 mx 是一个可行的最大差值</span></span><br><span class="line">            <span class="keyword">return</span> cnt &gt;= p</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找的左右边界</span></span><br><span class="line">        <span class="comment"># 左边界：最小可能的差值</span></span><br><span class="line">        <span class="comment"># 右边界：最大可能的差值</span></span><br><span class="line">        l, r = <span class="number">0</span>, nums[-<span class="number">1</span>] - nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 二分查找寻找最小的可行 mx</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 可行，说明它可能是答案，</span></span><br><span class="line">                <span class="comment"># 或者还有更小的可行值，所以尝试在左半部分 [l, mid] 继续寻找</span></span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 不可行，说明最大差值限制太小，</span></span><br><span class="line">                <span class="comment"># 必须放宽，所以去右半部分 [mid + 1, r] 寻找</span></span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时，l (或 r) 就是满足条件的最小的最大差值</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N * log(Range) + N * logN)，其中 N 是数组的长度，Range 是数组最大值与最小值的差。<ul>
<li>对数组排序需要 O(N * logN) 的时间。</li>
<li>二分查找的搜索空间大小为 <code>Range</code>，因此迭代次数为 O(log(Range))。</li>
<li>在每次二分迭代中，我们都需要调用 <code>check</code> 函数，<code>check</code> 函数需要对数组进行一次线性扫描，时间复杂度为 O(N)。</li>
<li>因此，总时间复杂度为 O(N * logN + N * log(Range))。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(logN) 或 O(N)。<ul>
<li>空间开销主要来自于排序算法。如果使用基于快速排序的内省排序，空间复杂度为 O(logN)；如果使用归并排序，则为 O(N)。除了排序之外，算法本身只使用了常数级别的额外空间。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“最小化最大值”问题的一个绝佳例子。它完美地诠释了如何通过二分查找答案的思路，将一个复杂的求解最优化问题，转换成一个更简单的、具有单调性的判定性问题。当遇到类似“求…的最小值”或“求…的最大值”，且难以直接求解时，不妨思考一下是否能对答案进行二分，设计一个 <code>check</code> 函数来验证猜测值的可行性。如果可行，这种方法往往能提供一个非常高效且优雅的解决方案。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>最小化最大值</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>排序</tag>
        <tag>动态规划</tag>
        <tag>第340场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2730 | 滑动窗口求解“找到最长的半重复子字符串”</title>
    <url>//posts/leetcode-2730/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2730 题：<a href="https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/description/">找到最长的半重复子字符串</a>。<br>这道题是“寻找满足特定条件的最长子字符串”这一类问题的典型代表，非常适合使用滑动窗口算法来优雅地解决。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目要求我们从一个数字字符串 <code>s</code> 中，找出一个最长的子字符串，这个子字符串需要满足一个特殊的性质，即“半重复”。</p>
<p>“半重复”的定义是：一个字符串中<strong>至多有一对</strong>相邻字符是相等的。</p>
<p>我们来具体分析一下这个定义：</p>
<ul>
<li>没有相邻重复字符的字符串是半重复的，例如 <code>&quot;0123&quot;</code>、<code>&quot;5494&quot;</code>。</li>
<li>只有一对相邻重复字符的字符串也是半重复的，例如 <code>&quot;0010&quot;</code>、<code>&quot;54944&quot;</code>。</li>
<li>有两对或更多对相邻重复字符的字符串则不是半重复的，例如 <code>&quot;52233&quot;</code>（有 <code>22</code> 和 <code>33</code> 两对）、<code>&quot;111&quot;</code>（<code>s[0]==s[1]</code> 和 <code>s[1]==s[2]</code>，也算两对）。</li>
</ul>
<p>我们的目标就是从原字符串 <code>s</code> 中，找到一个最长的、满足“半重复”条件的连续子字符串，并返回它的长度。</p>
<p>例如，对于 <code>s = &quot;52233&quot;</code>：</p>
<ul>
<li>子字符串 <code>&quot;5223&quot;</code> 中只有一对相邻重复 <code>22</code>，是半重复的，长度为 4。</li>
<li>整个字符串 <code>&quot;52233&quot;</code> 中有 <code>22</code> 和 <code>33</code> 两对，不是半重复的。</li>
<li>子字符串 <code>&quot;111&quot;</code> 中有两对相邻重复，不是半重复的，但它的子串 <code>&quot;11&quot;</code> 是半重复的，长度为 2。</li>
</ul>
<h3 id="核心思路：滑动窗口"><a href="#核心思路：滑动窗口" class="headerlink" title="核心思路：滑动窗口"></a>核心思路：滑动窗口</h3><p>这类求解“最长连续子数组&#x2F;子字符串”且该子串需满足特定条件的问题，是滑动窗口算法的绝佳应用场景。</p>
<p>我们可以用 <code>left</code> 和 <code>right</code> 两个指针来维护一个“窗口”，即子字符串 <code>s[left:right+1]</code>。我们的目标是让这个窗口始终保持“半重复”的状态，并在这个过程中找到它能达到的最大宽度。</p>
<p>为了判断窗口是否满足条件，我们需要一个状态变量来记录窗口内<strong>相邻重复字符对的数量</strong>，我们称之为 <code>pair_count</code>。</p>
<p>算法的动态过程如下：</p>
<ol>
<li><strong>窗口扩张</strong>：<code>right</code> 指针不断向右移动，将新的字符纳入窗口。每当新字符 <code>s[right]</code> 与它前面的字符 <code>s[right-1]</code> 相同时，就意味着窗口内新增了一对相邻重复，我们让 <code>pair_count</code> 加 1。</li>
<li><strong>条件判断与窗口收缩</strong>：在扩张后，如果发现 <code>pair_count</code> 的值大于 1，说明当前窗口已经不再是“半重复”的了，不满足题意。此时，我们必须从左侧收缩窗口，即把 <code>left</code> 指针向右移动。</li>
<li><strong>状态更新</strong>：在收缩窗口（移动 <code>left</code> 指针）时，我们需要检查被移出窗口的旧字符 <code>s[left]</code> 是否是某一对相邻重复的开端（即 <code>s[left] == s[left+1]</code>）。如果是，那么随着 <code>s[left]</code> 的移除，这对重复也就被破坏了，所以我们需要将 <code>pair_count</code> 减 1。</li>
<li><strong>结果更新</strong>：<code>right</code> 指针每移动一步，在确保窗口有效（即 <code>pair_count &lt;= 1</code>）之后，我们都计算当前窗口的长度 <code>right - left + 1</code>，并用它来更新我们记录的全局最大长度 <code>max_len</code>。</li>
</ol>
<p>通过这个“扩张-收缩”的循环过程，我们就能在一次遍历中找到最长的半重复子字符串。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>左指针 <code>left = 0</code>。</li>
<li>记录最大长度 <code>max_len = 0</code>。</li>
<li>记录窗口内相邻重复对的数量 <code>pair_count = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历与扩张</strong>：</p>
<ul>
<li>用右指针 <code>right</code> 从 <code>0</code> 到 <code>n-1</code> 遍历整个字符串 <code>s</code>。</li>
<li>在循环的每一步，首先检查新加入窗口的字符 <code>s[right]</code>。如果 <code>right &gt; 0</code> 且 <code>s[right] == s[right-1]</code>，则 <code>pair_count</code> 自增 1。</li>
</ul>
</li>
<li><p><strong>收缩</strong>：</p>
<ul>
<li>紧接着，使用一个 <code>while</code> 循环检查窗口的有效性：<code>while pair_count &gt; 1</code>。</li>
<li>只要条件成立，就说明窗口需要收缩。在收缩前，检查 <code>s[left]</code> 和 <code>s[left+1]</code> 是否相等。如果相等，说明一个重复对即将被移出，所以 <code>pair_count</code> 自减 1。</li>
<li>然后，将左指针 <code>left</code> 右移一位。</li>
<li><code>while</code> 循环会一直执行，直到 <code>pair_count</code> 重新变回 1 或 0，窗口恢复有效状态。</li>
</ul>
</li>
<li><p><strong>更新结果</strong>：</p>
<ul>
<li>在 <code>while</code> 循环结束后（或者根本没进入 <code>while</code> 循环），当前窗口 <code>s[left:right+1]</code> 一定是半重复的。</li>
<li>计算当前长度 <code>right - left + 1</code>，并更新 <code>max_len = max(max_len, right - left + 1)</code>。</li>
</ul>
</li>
<li><p><strong>返回</strong>：</p>
<ul>
<li><code>right</code> 指针遍历完整个字符串后，<code>max_len</code> 中存储的就是最终答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestSemiRepetitiveSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        pair_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 步骤 2: 窗口扩张，并检查是否形成新的重复对</span></span><br><span class="line">            <span class="keyword">if</span> right &gt; <span class="number">0</span> <span class="keyword">and</span> s[right] == s[right - <span class="number">1</span>]:</span><br><span class="line">                pair_count += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 3: 当窗口不满足条件时，进行收缩</span></span><br><span class="line">            <span class="keyword">while</span> pair_count &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 检查将要移出窗口的 s[left] 是否是重复对的一部分</span></span><br><span class="line">                <span class="keyword">if</span> s[left] == s[left + <span class="number">1</span>]:</span><br><span class="line">                    pair_count -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 4: 更新最大长度，此时的窗口一定是有效的</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是字符串 <code>s</code> 的长度。滑动窗口的左指针 <code>left</code> 和右指针 <code>right</code> 都只会从头到尾遍历字符串一次，每个元素最多被访问两次（一次被 <code>right</code> 纳入，一次被 <code>left</code> 移出）。因此，总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个额外变量（如 <code>left</code>, <code>right</code>, <code>pair_count</code> 等），没有使用随输入规模增长的额外空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想的一个直接且经典的应用。解决这类问题的关键在于三点：</p>
<ol>
<li><strong>确定窗口维护的“状态”</strong>：在本题中，这个状态就是“相邻重复对的数量 <code>pair_count</code>”。</li>
<li><strong>定义窗口扩张时的状态更新逻辑</strong>：<code>right</code> 指针移动，如何影响 <code>pair_count</code>。</li>
<li><strong>定义窗口收缩时的状态更新逻辑</strong>：<code>left</code> 指针移动，如何影响 <code>pair_count</code>。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
        <tag>第106场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 275 | H 指数 II</title>
    <url>//posts/leetcode-275/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 275 题：<a href="https://leetcode.cn/problems/h-index-ii/description/">H 指数 II</a>。<br>本文将深入探讨解决此问题的四种不同二分查找区间写法。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要计算一位研究者的 h 指数。h 指数的定义是：一名科研人员的 n 篇论文中，有<strong>至少</strong> <code>h</code> 篇论文分别被引用了<strong>至少</strong> <code>h</code> 次。</p>
<p>题目给出了一个整数数组 <code>citations</code>，其中 <code>citations[i]</code> 是第 <code>i</code> 篇论文的被引次数，并且该数组已经<strong>按非降序（升序）排列</strong>。我们的目标是设计一个时间复杂度为对数级别的算法来找出这个 h 指数。</p>
<p>例如，对于 <code>citations = [0, 1, 3, 5, 6]</code>：</p>
<ul>
<li>我们有 5 篇论文。</li>
<li>检查 h&#x3D;3：是否有至少 3 篇论文的引用次数都 &gt;&#x3D; 3？<ul>
<li>引用次数最高的 3 篇论文是 <code>[3, 5, 6]</code>。</li>
<li>这三篇论文的引用次数都满足 &gt;&#x3D; 3 的条件。所以 h&#x3D;3 是一个可能的答案。</li>
</ul>
</li>
<li>检查 h&#x3D;4：是否有至少 4 篇论文的引用次数都 &gt;&#x3D; 4？<ul>
<li>引用次数最高的 4 篇论文是 <code>[1, 3, 5, 6]</code>。</li>
<li>其中 <code>1 &lt; 4</code> 且 <code>3 &lt; 4</code>，不满足条件。</li>
</ul>
</li>
<li>因此，最大的满足条件的 h 值是 3，所以 h 指数就是 3。</li>
</ul>
<h3 id="核心思路：在“答案”上进行二分查找"><a href="#核心思路：在“答案”上进行二分查找" class="headerlink" title="核心思路：在“答案”上进行二分查找"></a>核心思路：在“答案”上进行二分查找</h3><p>直接寻找这个 h 指数似乎需要逐个尝试。但我们可以观察到答案 <code>h</code> 具有<strong>单调性</strong>：</p>
<ul>
<li>如果一个值 <code>h</code> 满足 h 指数的定义，那么所有小于 <code>h</code> 的值（例如 <code>h-1</code>）也一定满足。</li>
<li>如果一个值 <code>h</code> 不满足 h 指数的定义，那么所有大于 <code>h</code> 的值（例如 <code>h+1</code>）也一定不满足。</li>
</ul>
<p>这种单调性是应用二分查找的完美信号。我们可以不直接在 <code>citations</code> 数组的索引上进行二分，而是在<strong>可能的答案 <code>h</code></strong> 上进行二分。<code>h</code> 的取值范围是 <code>[0, n]</code>，其中 <code>n</code> 是论文总数。</p>
<p>我们的目标就变成了：在 <code>[0, n]</code> 这个答案空间中，找到满足条件的最大的 <code>h</code>。</p>
<p>为了实现二分查找，我们需要一个<strong>判定函数</strong> <code>check(h)</code>，来判断任意一个猜测的 <code>h</code> 值是否满足条件。</p>
<ul>
<li><strong>如何判定 <code>h</code> 是否可行？</strong><ul>
<li>根据定义，我们需要检查是否存在 <code>h</code> 篇论文，其引用次数都大于或等于 <code>h</code>。</li>
<li>由于 <code>citations</code> 数组是升序的，引用次数最高的 <code>h</code> 篇论文必然是数组末尾的 <code>h</code> 个元素。</li>
<li>我们只需要检查这 <code>h</code> 篇论文中被引次数最少的那一篇，即 <code>citations[n-h]</code>，是否满足 <code>&gt;= h</code>。</li>
<li>如果 <code>citations[n-h] &gt;= h</code>，那么它后面的所有论文引用次数也都大于等于 <code>h</code>，总共就有 <code>h</code> 篇满足条件。</li>
<li>因此，判定条件可以简化为 <code>citations[n-h] &gt;= mid</code> (其中 <code>mid</code> 是我们猜测的 <code>h</code> 值)。</li>
</ul>
</li>
</ul>
<p>有了这个 O(1) 的判定函数，我们就可以在 <code>[0, n]</code> 的答案空间内高效地进行二分查找了。</p>
<h3 id="四种二分算法的-Python-代码实现"><a href="#四种二分算法的-Python-代码实现" class="headerlink" title="四种二分算法的 Python 代码实现"></a>四种二分算法的 Python 代码实现</h3><p>下面将展示四种经典的二分查找区间写法，它们在边界处理和循环条件上略有不同，但最终都能得到正确答案。</p>
<h4 id="解法一：闭区间-left-right"><a href="#解法一：闭区间-left-right" class="headerlink" title="解法一：闭区间 [left, right]"></a>解法一：闭区间 <code>[left, right]</code></h4><p>这是最常见的一种写法，搜索区间两端都包含在内。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(citations)</span><br><span class="line">        <span class="comment"># 在区间 [left, right] 内询问</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 区间不为空</span></span><br><span class="line">            <span class="comment"># 循环不变量：</span></span><br><span class="line">            <span class="comment"># left-1 的回答一定为「是」（即 h=left-1 满足条件）</span></span><br><span class="line">            <span class="comment"># right+1 的回答一定为「否」（即 h=right+1 不满足条件）</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span>: <span class="comment"># h=0 恒成立，特殊处理或调整 left 初始值</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 检查 h=mid 是否可行：</span></span><br><span class="line">            <span class="comment"># 引用次数最多的 mid 篇论文，其引用次数均需 &gt;= mid</span></span><br><span class="line">            <span class="comment"># 相当于检查第 n-mid 篇论文（引用最少的）是否 citations[n-mid] &gt;= mid</span></span><br><span class="line">            <span class="keyword">if</span> citations[n - mid] &gt;= mid:</span><br><span class="line">                <span class="comment"># mid 可行，尝试更大的 h</span></span><br><span class="line">                left = mid + <span class="number">1</span>  <span class="comment"># 询问范围缩小到 [mid+1, right]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># mid 不可行，需要减小 h</span></span><br><span class="line">                right = mid - <span class="number">1</span>  <span class="comment"># 询问范围缩小到 [left, mid-1]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束后 right 等于 left-1</span></span><br><span class="line">        <span class="comment"># 根据循环不变量，right 现在是最大的回答为「是」的数</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">```**逻辑解读**：当 `check(mid)` 成功时，意味着 `mid` 是一个潜在的答案，但我们想找最大的 `h`，所以我们向右搜索 `[mid+<span class="number">1</span>, right]`；反之，`mid` 太大了，向左搜索 `[left, mid-<span class="number">1</span>]`。循环结束时 `left = right + <span class="number">1</span>`，`right` 指向的是最后一个满足条件的 `h`。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 解法二：左闭右开区间 `[left, right)`</span></span><br><span class="line"></span><br><span class="line">这种写法中，`right` 边界是“开”的，即不包含在搜索区间内。`right` 通常被看作是第一个“不满足”条件的位置。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(citations)</span><br><span class="line">        <span class="comment"># 在区间 [left, right) 内询问</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">            <span class="comment"># 循环不变量：</span></span><br><span class="line">            <span class="comment"># left-1 的回答一定为「是」</span></span><br><span class="line">            <span class="comment"># right 的回答一定为「否」</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span>: <span class="comment"># h=0 恒成立</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 引用次数最多的 mid 篇论文，引用次数均 &gt;= mid</span></span><br><span class="line">            <span class="keyword">if</span> citations[n - mid] &gt;= mid:</span><br><span class="line">                left = mid + <span class="number">1</span>  <span class="comment"># 询问范围缩小到 [mid+1, right)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid  <span class="comment"># 询问范围缩小到 [left, mid)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时 left == right，它指向第一个回答为「否」的数</span></span><br><span class="line">        <span class="comment"># 根据循环不变量，left-1 现在是最大的回答为「是」的数</span></span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>逻辑解读</strong>：当 <code>check(mid)</code> 成功时，我们更新 <code>left = mid + 1</code>，继续向右探索。当 <code>check(mid)</code> 失败时，<code>mid</code> 本身就是一个“不满足”的值，所以我们更新 <code>right = mid</code>，将这个“第一个不满足”的边界向左移动。循环结束时 <code>left</code> 就是那个第一个不满足条件的 <code>h</code>，因此 <code>left - 1</code> 就是答案。</p>
<hr>
<h4 id="解法三：左开右闭区间-left-right"><a href="#解法三：左开右闭区间-left-right" class="headerlink" title="解法三：左开右闭区间 (left, right]"></a>解法三：左开右闭区间 <code>(left, right]</code></h4><p>与上一种相反，这种写法的 <code>left</code> 边界是“开”的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(citations)</span><br><span class="line">        <span class="comment"># 在区间 (left, right] 内询问</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">            <span class="comment"># 循环不变量：</span></span><br><span class="line">            <span class="comment"># left 的回答一定为「是」</span></span><br><span class="line">            <span class="comment"># right+1 的回答一定为「否」</span></span><br><span class="line">            mid = (left + right + <span class="number">1</span>) // <span class="number">2</span>  <span class="comment"># 向上取整，避免死循环</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 引用次数最多的 mid 篇论文，引用次数均 &gt;= mid</span></span><br><span class="line">            <span class="keyword">if</span> citations[n - mid] &gt;= mid:</span><br><span class="line">                left = mid  <span class="comment"># 询问范围缩小到 (mid, right]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span>  <span class="comment"># 询问范围缩小到 (left, mid-1]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时 left == right</span></span><br><span class="line">        <span class="comment"># 根据循环不变量，left 现在是最大的回答为「是」的数</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p><strong>逻辑解读</strong>：这里 <code>mid</code> 的计算方式是 <code>(left + right + 1) // 2</code> 向上取整，这是为了防止当 <code>left = right - 1</code> 且 <code>check</code> 成功时，<code>mid</code> 仍等于 <code>left</code> 导致无限循环。当 <code>check(mid)</code> 成功时，<code>mid</code> 成为新的“最后一个满足条件”的候选，所以 <code>left = mid</code>；反之，则收缩右边界 <code>right = mid - 1</code>。循环结束时 <code>left</code> 即为答案。</p>
<hr>
<h4 id="解法四：开区间-left-right"><a href="#解法四：开区间-left-right" class="headerlink" title="解法四：开区间 (left, right)"></a>解法四：开区间 <code>(left, right)</code></h4><p>这种写法保证 <code>left</code> 和 <code>right</code> 之间始终有空间，循环条件是 <code>left + 1 &lt; right</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(citations)</span><br><span class="line">        <span class="comment"># 在区间 (left, right) 内询问</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">            <span class="comment"># 循环不变量：</span></span><br><span class="line">            <span class="comment"># left 的回答一定为「是」</span></span><br><span class="line">            <span class="comment"># right 的回答一定为「否」</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 引用次数最多的 mid 篇论文，引用次数均 &gt;= mid</span></span><br><span class="line">            <span class="keyword">if</span> citations[n - mid] &gt;= mid:</span><br><span class="line">                left = mid  <span class="comment"># 询问范围缩小到 (mid, right)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid  <span class="comment"># 询问范围缩小到 (left, mid)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束后 left + 1 == right</span></span><br><span class="line">        <span class="comment"># 根据循环不变量，left 现在是最大的回答为「是」的数</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p><strong>逻辑解读</strong>：<code>left</code> 始终维护“已知的满足条件的最大值”，而 <code>right</code> 始终维护“已知的第一个不满足条件的值”。循环不断地用 <code>mid</code> 来更新这两个边界，直到它们相邻。最终的答案就是 <code>left</code>。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(log N)<ul>
<li><code>N</code> 是论文的总数 <code>len(citations)</code>。</li>
<li>二分查找在大小为 <code>N+1</code> 的答案空间 <code>[0, N]</code> 中进行。</li>
<li>每次迭代，判定函数 <code>check(mid)</code> 的时间复杂度为 O(1)，因为它只需要访问数组中的一个元素。</li>
<li>因此，总的时间复杂度为 O(log N)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)<ul>
<li>我们只使用了有限的几个变量（<code>left</code>, <code>right</code>, <code>mid</code>, <code>n</code>），没有使用与输入大小成比例的额外空间。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>H 指数 II 是一个典型的“二分答案”问题。当问题的解具有单调性，并且我们可以高效地对任意一个猜测的解进行“判定”时，就可以考虑使用二分查找。本文通过四种不同的区间写法，展示了二分查找在实现细节上的灵活性。理解每种写法的循环不变量是掌握二分查找、避免边界错误的关键。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最大</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2762 | 滑动窗口求解“不间断子数组”</title>
    <url>//posts/leetcode-2762/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2762 题：<a href="https://leetcode.cn/problems/continuous-subarrays/">不间断子数组</a>。<br>该题要求统计所有满足“最大元素与最小元素之差不超过2”的子数组。这是一个典型的不定长滑动窗口问题，可以使用哈希表或更优的单调队列来解决。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目要求我们统计一个数组 <code>nums</code> 中“不间断子数组”的总数。一个子数组被称为“不间断”的，需要满足其中任意两个元素之间的差的绝对值都不超过 2。</p>
<p>这个条件 <code>|nums[i1] - nums[i2]| &lt;= 2</code> 其实等价于子数组中的最大值 <code>max</code> 和最小值 <code>min</code> 满足 <code>max - min &lt;= 2</code>。 因为如果最大值和最小值的差满足条件，那么其他任意两个元素之间的差也必然满足条件。</p>
<p>以 <code>nums = [5,4,2,4]</code> 为例：</p>
<ul>
<li>子数组 <code>[5, 4]</code> 是不间断的，因为 <code>max(5, 4) - min(5, 4) = 1 &lt;= 2</code>。</li>
<li>子数组 <code>[4, 2]</code> 是不间断的，因为 <code>max(4, 2) - min(4, 2) = 2 &lt;= 2</code>。</li>
<li>子数组 <code>[5, 4, 2]</code> 不是不间断的，因为 <code>max(5, 4, 2) - min(5, 4, 2) = 5 - 2 = 3 &gt; 2</code>。</li>
</ul>
<p>我们需要做的就是找出所有这样的子数组并计数。</p>
<h3 id="核心思路：不定长滑动窗口"><a href="#核心思路：不定长滑动窗口" class="headerlink" title="核心思路：不定长滑动窗口"></a>核心思路：不定长滑动窗口</h3><p>暴力枚举所有子数组并检查每个子数组的条件，时间复杂度会达到 O(N^2) 甚至更高，对于 <code>N=10^5</code> 的数据规模来说是不可接受的。</p>
<p>这类问题通常可以采用滑动窗口来优化。 关键在于问题是否具有单调性：</p>
<ul>
<li>如果一个子数组 <code>[l, r]</code> 是不间断的，那么它的任何一个子数组（例如 <code>[l+1, r]</code> 或 <code>[l, r-1]</code>）也一定是不间断的。</li>
<li>如果一个子数组 <code>[l, r]</code> 不是不间断的，那么任何包含它的更长的子数组（例如 <code>[l-1, r]</code> 或 <code>[l, r+1]</code>）也一定不是不间断的。</li>
</ul>
<p>这种单调性是使用滑动窗口的完美信号。 我们可以维护一个窗口 <code>[l, r]</code>，不断向右移动右指针 <code>r</code> 来扩大窗口。如果窗口内的数组不再满足 <code>max - min &lt;= 2</code> 的条件，我们就从左边移动左指针 <code>l</code> 来缩小窗口，直到窗口重新满足条件。</p>
<p>对于每一个确定的右指针 <code>r</code>，我们找到了最远的左指针 <code>l</code> 使得 <code>[l, r]</code> 区间是不间断的。根据单调性，以 <code>r</code> 为右端点的所有子数组 <code>[l, r], [l+1, r], ..., [r, r]</code> 都是不间断的。这样的子数组共有 <code>r - l + 1</code> 个。我们将这个数量累加到最终答案中。</p>
<p>这个算法的挑战在于：如何在窗口滑动时，高效地获取窗口内的最大值和最小值？</p>
<h3 id="解法一：滑动窗口-哈希表-Counter"><a href="#解法一：滑动窗口-哈希表-Counter" class="headerlink" title="解法一：滑动窗口 + 哈希表 (Counter)"></a>解法一：滑动窗口 + 哈希表 (Counter)</h3><p>一个直观的方法是使用哈希表（在 Python 中是 <code>collections.Counter</code>）来维护窗口内每个数字出现的次数。</p>
<h4 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h4><ol>
<li>初始化左右指针 <code>l = 0</code>，答案 <code>ans = 0</code>，以及一个哈希表 <code>cnt</code>。</li>
<li>遍历数组，用右指针 <code>r</code> 代表窗口的右边界。</li>
<li>将新元素 <code>nums[r]</code> 加入窗口，即在 <code>cnt</code> 中增加它的计数。</li>
<li><strong>检查条件</strong>：检查当前窗口 <code>[l, r]</code> 是否满足 <code>max(cnt) - min(cnt) &lt;= 2</code>。<code>max(cnt)</code> 和 <code>min(cnt)</code> 分别是哈希表中当前所有键（即窗口内的元素）的最大值和最小值。</li>
<li><strong>收缩窗口</strong>：如果条件不满足，说明窗口需要从左侧收缩。我们不断地将左指针 <code>l</code> 右移，并从 <code>cnt</code> 中减少 <code>nums[l]</code> 的计数。如果 <code>nums[l]</code> 的计数变为 0，就从哈希表中删除这个键。这个过程一直持续到窗口重新满足 <code>max(cnt) - min(cnt) &lt;= 2</code> 为止。</li>
<li><strong>更新答案</strong>：在窗口 <code>[l, r]</code> 满足条件后，我们知道以 <code>r</code> 为结尾的不间断子数组有 <code>r - l + 1</code> 个，将这个数目加到 <code>ans</code> 上。</li>
<li>重复步骤 3-6，直到 <code>r</code> 遍历完整个数组。</li>
</ol>
<h4 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter, deque</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">continuousSubarrays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = l = <span class="number">0</span></span><br><span class="line">        cnt = Counter()</span><br><span class="line">        <span class="keyword">for</span> r, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            cnt[x] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 当窗口不满足条件时，从左侧收缩</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">max</span>(cnt) - <span class="built_in">min</span>(cnt) &gt; <span class="number">2</span>:</span><br><span class="line">                y = nums[l]</span><br><span class="line">                cnt[y] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cnt[y] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> cnt[y]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 此时窗口 [l, r] 是合法的</span></span><br><span class="line">            <span class="comment"># 所有以 r 结尾的子数组 [l,r], [l+1,r]...[r,r] 都是合法的</span></span><br><span class="line">            ans += r - l + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li><strong>时间复杂度</strong>: O(N * K)，其中 N 是数组长度，K 是窗口内不同元素的数量。虽然左右指针都只遍历数组一次，但在 <code>while</code> 循环中，<code>max(cnt)</code> 和 <code>min(cnt)</code> 的操作需要遍历哈希表中的所有键，最坏情况下时间复杂度是 O(K)。在一些极端测试用例下可能会超时。</li>
<li><strong>空间复杂度</strong>: O(K)，哈希表存储窗口内不同元素所需的空间。</li>
</ul>
<h3 id="解法二：滑动窗口-单调队列-Monotonic-Deque"><a href="#解法二：滑动窗口-单调队列-Monotonic-Deque" class="headerlink" title="解法二：滑动窗口 + 单调队列 (Monotonic Deque)"></a>解法二：滑动窗口 + 单调队列 (Monotonic Deque)</h3><p>为了将获取窗口最大&#x2F;最小值的操作优化到 O(1)，我们可以使用单调队列。 我们需要两个双端队列（deque）：</p>
<ul>
<li><code>max_q</code>：一个单调递减队列，队首永远是当前窗口最大值的<strong>下标</strong>。</li>
<li><code>min_q</code>：一个单调递增队列，队首永远是当前窗口最小值的<strong>下标</strong>。</li>
</ul>
<h4 id="算法详解-1"><a href="#算法详解-1" class="headerlink" title="算法详解"></a>算法详解</h4><ol>
<li>初始化左右指针 <code>l = 0</code>，答案 <code>ans = 0</code>，以及两个双端队列 <code>min_q</code> 和 <code>max_q</code>。</li>
<li>遍历数组，用右指针 <code>r</code> 代表窗口的右边界。</li>
<li><strong>维护单调队列</strong>：<ul>
<li>对于 <code>max_q</code>，当新元素 <code>nums[r]</code> 加入时，从队尾移除所有值小于等于 <code>nums[r]</code> 的元素下标，然后将 <code>r</code> 加入队尾。这保证了队列的单调递减性。</li>
<li>对于 <code>min_q</code>，当新元素 <code>nums[r]</code> 加入时，从队尾移除所有值大于等于 <code>nums[r]</code> 的元素下标，然后将 <code>r</code> 加入队尾。这保证了队列的单调递增性。</li>
</ul>
</li>
<li><strong>检查条件</strong>：当前窗口的最大值是 <code>nums[max_q[0]]</code>，最小值是 <code>nums[min_q[0]]</code>。我们检查 <code>nums[max_q[0]] - nums[min_q[0]] &gt; 2</code> 是否成立。</li>
<li><strong>收缩窗口</strong>：如果条件不满足，我们需要移动左指针 <code>l</code>。注意，这里的收缩逻辑和解法一略有不同。我们不断增加 <code>l</code>，并且检查队首的下标（<code>max_q[0]</code> 或 <code>min_q[0]</code>）是否已经小于新的 <code>l</code>。如果是，说明最大&#x2F;最小值已经滑出窗口，需要从队首弹出。</li>
<li><strong>更新答案</strong>：在窗口 <code>[l, r]</code> 满足条件后，以 <code>r</code> 为结尾的不间断子数组数量为 <code>r - l + 1</code>，累加到 <code>ans</code>。</li>
<li>重复步骤 3-6，直到 <code>r</code> 遍历完整个数组。</li>
</ol>
<h4 id="Python-代码实现-1"><a href="#Python-代码实现-1" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">continuousSubarrays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_q = deque()</span><br><span class="line">        max_q = deque()</span><br><span class="line">        ans = l = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 维护 min_q 为单调递增</span></span><br><span class="line">            <span class="keyword">while</span> min_q <span class="keyword">and</span> x &lt;= nums[min_q[-<span class="number">1</span>]]:</span><br><span class="line">                min_q.pop()</span><br><span class="line">            min_q.append(r)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 维护 max_q 为单调递减</span></span><br><span class="line">            <span class="keyword">while</span> max_q <span class="keyword">and</span> x &gt;= nums[max_q[-<span class="number">1</span>]]:</span><br><span class="line">                max_q.pop()</span><br><span class="line">            max_q.append(r)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当窗口不满足条件时，移动左指针</span></span><br><span class="line">            <span class="keyword">while</span> nums[max_q[<span class="number">0</span>]] - nums[min_q[<span class="number">0</span>]] &gt; <span class="number">2</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 检查队首元素是否已滑出窗口</span></span><br><span class="line">                <span class="keyword">if</span> min_q[<span class="number">0</span>] &lt; l:</span><br><span class="line">                    min_q.popleft()</span><br><span class="line">                <span class="keyword">if</span> max_q[<span class="number">0</span>] &lt; l:</span><br><span class="line">                    max_q.popleft()</span><br><span class="line">            </span><br><span class="line">            ans += r - l + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li><strong>时间复杂度</strong>: O(N)。每个元素的下标最多被压入和弹出队列各一次，因此维护队列的总时间是线性的。左右指针也各遍历数组一次。</li>
<li><strong>空间复杂度</strong>: O(N)。在最坏情况下（例如一个严格递增或递减的数组），队列中可能存储所有元素的下标。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是不定长滑动窗口的一个绝佳应用。通过分析题目条件的单调性，我们可以确定滑动窗口是正确的解题方向。而问题的核心瓶颈——如何快速获取窗口内的最值——则可以通过不同的数据结构来解决。哈希表提供了一个相对简单但效率稍逊的方案，而单调队列则是解决此类滑动窗口最值问题的标准、高效的工具。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>堆（优先队列）</tag>
        <tag>有序集合</tag>
        <tag>单调队列</tag>
        <tag>第352场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2781 | 滑动窗口与后缀校验求解“最长合法子字符串”</title>
    <url>//posts/leetcode-2781/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2781 题：<a href="https://leetcode.cn/problems/length-of-the-longest-valid-substring/">最长合法子字符串的长度</a>。<br>这道题要求我们寻找一个不含任何“禁用词”的最长子串。它是一个典型的滑动窗口问题，但其巧妙之处在于如何高效地判断窗口的“合法性”，避免在每次窗口移动时都进行暴力检查。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个字符串 <code>word</code> 和一个禁用词列表 <code>forbidden</code>。如果一个子字符串不包含 <code>forbidden</code> 中的任何字符串，我们就称它是“合法的”。我们的任务是返回 <code>word</code> 中最长合法子字符串的长度。</p>
<p>举个例子，对于 <code>word = &quot;cbaaaabc&quot;</code>, <code>forbidden = [&quot;aaa&quot;,&quot;cb&quot;]</code>：</p>
<ul>
<li>子字符串 <code>&quot;cbaaa&quot;</code> 是非法的，因为它包含了禁用词 <code>&quot;aaa&quot;</code>。</li>
<li>子字符串 <code>&quot;aabc&quot;</code> 是合法的，因为它不包含 <code>&quot;aaa&quot;</code> 也不包含 <code>&quot;cb&quot;</code>。</li>
<li>在所有合法的子字符串中，<code>&quot;aabc&quot;</code> 的长度是 4，也是最长的。因此答案是 4。</li>
</ul>
<p>一个简单的思路是找出 <code>word</code> 的所有子字符串，然后逐一检查它们是否包含禁用词。但这种方法的时间复杂度非常高（大约是 O(N^2 * M * L)），在 <code>word</code> 长度达到 10^5 时会严重超时。我们需要一个更高效的算法。</p>
<h3 id="核心思路：滑动窗口与高效校验"><a href="#核心思路：滑动窗口与高效校验" class="headerlink" title="核心思路：滑动窗口与高效校验"></a>核心思路：滑动窗口与高效校验</h3><p>这个问题非常适合使用滑动窗口来解决。“寻找满足条件的最长子串”是滑动窗口的经典应用场景。我们用 <code>left</code> 和 <code>right</code> 两个指针来维护一个窗口 <code>word[left:right+1]</code>。</p>
<p>关键的挑战在于：当 <code>right</code> 指针向右移动一位，我们如何快速判断新窗口是否仍然合法？</p>
<p>常规的滑动窗口问题，通常是在窗口扩张后，通过一个 <code>while</code> 循环收缩左边界，直到窗口再次满足条件。但在这里，“不包含任何禁用词”这个条件很难通过简单地增减字符计数来维护。</p>
<p>这里的突破口在于：<strong>当我们将 <code>word[right]</code> 加入窗口时，所有新产生的、可能导致窗口非法的子字符串，都必然是以 <code>word[right]</code> 结尾的。</strong></p>
  <!-- 这是一个示意图的占位符 -->

<p>换句话说，我们不需要检查整个 <code>word[left:right+1]</code>。我们只需要检查以 <code>word[right]</code> 结尾的各个后缀，例如 <code>word[right:right+1]</code>, <code>word[right-1:right+1]</code>, <code>word[right-2:right+1]</code> 等，看它们是否是禁用词。</p>
<p>题目中还有一个至关重要的提示：<code>forbidden[i].length &lt;= 10</code>。这意味着我们最多只需要检查长度为 10 的后缀。</p>
<p>这样，我们的策略就清晰了：</p>
<ol>
<li>用 <code>right</code> 指针扩张窗口。</li>
<li>每扩张一步，就检查以 <code>word[right]</code> 结尾的、长度不超过 10 的所有后缀。</li>
<li>如果发现一个后缀 <code>word[j:right+1]</code> 是禁用词，那么就说明整个窗口 <code>word[left:right+1]</code> 是非法的。不仅如此，任何以 <code>j</code> 或 <code>j</code> 之前的字符为起点的、延伸到 <code>right</code> 的子串都是非法的。</li>
<li>因此，为了让窗口重新合法，我们必须将左边界 <code>left</code> 移动到 <code>j + 1</code> 的位置。</li>
</ol>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>预处理</strong>：</p>
<ul>
<li>将 <code>forbidden</code> 列表转换成一个哈希集合（Set），这样我们就能以 O(1) 的平均时间复杂度查询一个字符串是否为禁用词。</li>
</ul>
</li>
<li><p><strong>滑动窗口初始化</strong>：</p>
<ul>
<li>左指针 <code>left = 0</code>。</li>
<li>记录最长合法子串的长度 <code>max_len = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历与窗口扩张</strong>：</p>
<ul>
<li>用右指针 <code>right</code> 从 <code>0</code> 遍历到 <code>n-1</code>，其中 <code>n</code> 是 <code>word</code> 的长度。</li>
</ul>
</li>
<li><p><strong>合法性校验与窗口调整</strong>：</p>
<ul>
<li>在 <code>right</code> 每移动一步后，我们启动一个内部循环，从 <code>j = right</code> 开始，向左回溯。</li>
<li>这个内部循环检查子字符串 <code>word[j:right+1]</code>。由于禁用词长度不超过 10，<code>j</code> 最多回溯到 <code>right - 9</code> 即可。同时，<code>j</code> 不能小于当前的左边界 <code>left</code>。所以，<code>j</code> 的范围是 <code>[max(left, right - 9), right]</code>。</li>
<li>如果在回溯检查中，发现 <code>word[j:right+1]</code> 存在于禁用词集合中，我们就找到了一个破坏合法性的源头。此时，我们将左指针 <code>left</code> 直接更新为 <code>j + 1</code>，并立即跳出内部的回溯检查。</li>
</ul>
</li>
<li><p><strong>更新结果</strong>：</p>
<ul>
<li>在（可能发生的）窗口调整之后，当前的窗口 <code>word[left:right+1]</code> 一定是合法的。</li>
<li>我们计算其长度 <code>right - left + 1</code>，并用它来更新 <code>max_len</code>。</li>
</ul>
</li>
<li><p><strong>返回最终答案</strong>：</p>
<ul>
<li>遍历结束后，<code>max_len</code> 就是题目的答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestValidSubstring</span>(<span class="params">self, word: <span class="built_in">str</span>, forbidden: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1: 预处理，转换为集合以快速查找</span></span><br><span class="line">        forbidden_set = <span class="built_in">set</span>(forbidden)</span><br><span class="line">        n = <span class="built_in">len</span>(word)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2: 初始化左指针和最大长度</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 遍历字符串，扩张右边界</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 步骤 4: 回溯检查以 right 结尾的后缀</span></span><br><span class="line">            <span class="comment"># 最多回溯 10 个字符，且不能越过左边界 left</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right, <span class="built_in">max</span>(left, right - <span class="number">10</span>) - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                substring = word[j : right + <span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> substring <span class="keyword">in</span> forbidden_set:</span><br><span class="line">                    <span class="comment"># 发现禁用词，窗口不合法</span></span><br><span class="line">                    <span class="comment"># 新的合法起点必须在禁用词之后，所以移动 left</span></span><br><span class="line">                    left = j + <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 找到一个即可，无需继续检查更长的后缀</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 5: 当前窗口 [left, right] 合法，更新最大长度</span></span><br><span class="line">            current_length = right - left + <span class="number">1</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, current_length)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 6: 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N * C)。其中 N 是字符串 <code>word</code> 的长度，C 是 <code>forbidden</code> 中字符串的最大长度（本题中 C &lt;&#x3D; 10）。外层循环遍历 <code>word</code> 一次，内层循环最多执行 C 次。由于 C 是一个很小的常数，所以时间复杂度接近线性 O(N)。</li>
<li><strong>空间复杂度</strong>: O(M * C)。其中 M 是 <code>forbidden</code> 列表的长度。这部分空间主要用于存储 <code>forbidden_set</code>。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题通过一个精妙的优化，将滑动窗口算法应用到了看似复杂的字符串匹配问题上。其核心思想是：<strong>在窗口扩张时，只检查新产生的、以新字符结尾的后缀</strong>。这个方法避免了对整个窗口的重复扫描，而题目中关于禁用词长度的限制则是实现这一优化的关键。这个技巧告诉我们，在处理滑动窗口问题时，要仔细分析窗口状态变化的本质，寻找最高效的合法性校验方式。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>第 354 场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2861 | 最大合金数</title>
    <url>//posts/leetcode-2861/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2861 题：<a href="https://leetcode.cn/problems/maximum-number-of-alloys/description/">最大合金数</a>。<br>本题的核心思路是，对于每一台机器，可以制造的合金数量都具有单调性。利用这一特性，我们可以将求解“最大值”的问题转化为一个“判定性”问题，并通过二分查找高效地找到答案。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们扮演一个合金制造公司老板的角色，目标是在给定的预算（<code>budget</code>）内，最大化合金的生产数量。</p>
<p>核心的约束条件和信息如下：</p>
<ol>
<li>有 <code>k</code> 台不同的机器，但我们一次只能选择<strong>一台</strong>机器进行生产。</li>
<li>每台机器制造一个合金需要不同配方（<code>composition</code>）。</li>
<li>我们有一定数量的初始金属库存（<code>stock</code>）。</li>
<li>如果库存不足，我们可以按给定的价格（<code>cost</code>）购买任意数量的金属。</li>
<li>最终的目标是，在所有机器中，找到一个能使生产数量最大化的方案，并返回这个最大数量。</li>
</ol>
<p>举个例子，假设用 1 号机器生产 10 个合金的总成本是 100，用 2 号机器生产 12 个合金的总成本是 120。如果我们的预算是 110，那么我们选择 1 号机器，最终答案是 10。如果预算是 130，我们选择 2 号机器，答案就是 12。</p>
<p>我们的任务就是在所有可行的方案中，找到那个最大的合金生产数。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最大生产数”比较复杂，因为它同时涉及到选择哪台机器和确定生产多少数量。我们可以简化问题：先不考虑哪台机器最好，而是针对<strong>某一台特定</strong>的机器，计算它在预算内最多能生产多少合金。如果我们能解决这个子问题，那么最终答案就是所有 <code>k</code> 台机器对应的最大生产数中的最大值。</p>
<p>现在，我们聚焦于单台机器。如何找到它的最大生产数？<br>我们可以发现一个关键的<strong>单调性</strong>：如果这台机器在预算内可以生产 <code>x</code> 个合金，那么它一定也可以生产 <code>x-1</code> 个合金（因为成本更低）。反之，如果预算不足以生产 <code>x</code> 个合金，那么也肯定无法生产 <code>x+1</code> 个合金（因为成本更高）。</p>
<p>这种单调性是应用二分查找的绝佳信号。我们可以对“合金生产数量”这个答案进行二分查找，来快速定位那个“预算内可行的最大值”。</p>
<p>为了实现二分查找，我们需要一个判定函数 <code>check(num)</code>，它的功能是：对于当前这台机器，生产 <code>num</code> 个合金是否可行（即总成本是否会超过预算 <code>budget</code>）？</p>
<p><code>check(num)</code> 函数的逻辑如下：</p>
<ul>
<li>初始化总花费 <code>money = 0</code>。</li>
<li>遍历生产 <code>num</code> 个合金所需要的每一种金属：<ul>
<li>计算需要第 <code>j</code> 种金属的总量：<code>required = composition[i][j] * num</code>。</li>
<li>查看库存 <code>stock[j]</code>，如果库存不足（<code>stock[j] &lt; required</code>），则计算需要购买的数量 <code>required - stock[j]</code>。</li>
<li>将购买所需的花费 <code>(required - stock[j]) * cost[j]</code> 累加到 <code>money</code> 中。</li>
<li>如果在任何一步，<code>money</code> 已经超过了 <code>budget</code>，就可以提前判定为不可行，返回 <code>False</code>。</li>
</ul>
</li>
<li>如果遍历完所有金属，<code>money</code> 仍然没有超过 <code>budget</code>，则说明 <code>num</code> 是一个可行的生产数量，返回 <code>True</code>。</li>
</ul>
<p>有了这个判定函数，我们就可以为每一台机器进行二分查找了。搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：最少可以生产 0 个合金。</li>
<li><strong>上界 (right)</strong>：一个宽松但安全的上界是 <code>min(stock) + budget</code>。因为制造一个合金最少也需要花费 1 块钱（如果成本最低为1且无库存），因此用尽预算最多也就能买 <code>budget</code> 份材料。加上初始最少的库存，这是一个非常安全的上限。</li>
</ul>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化</strong></p>
<ul>
<li><code>ans = 0</code>，用来记录在所有 <code>k</code> 台机器中能找到的全局最大合金数。</li>
</ul>
</li>
<li><p><strong>遍历每台机器</strong></p>
<ul>
<li>对 <code>k</code> 台机器的配方 <code>composition</code> 进行遍历。对于每台机器，我们都执行一次二分查找来计算它能生产的最大合金数。</li>
</ul>
</li>
<li><p><strong>对单台机器执行二分查找</strong></p>
<ul>
<li><strong>确定范围</strong>：<ul>
<li>左边界 <code>l = ans</code> (一个优化，因为我们不关心比已找到的答案更小的数)。</li>
<li>右边界 <code>r = min(stock) + budget + 1</code> (一个安全的上界)。</li>
</ul>
</li>
<li><strong>循环查找</strong>：<ul>
<li>当 <code>l</code> 和 <code>r</code> 没有相邻时 (<code>l + 1 &lt; r</code>)，循环继续。</li>
<li>计算中间值 <code>mid = (l + r) // 2</code> 作为当前的“猜测生产数”。</li>
<li>调用 <code>check(mid)</code> 函数来判定这个猜测值是否可行。<ul>
<li><strong>如果 <code>check(mid)</code> 返回 <code>True</code></strong>：<ul>
<li>说明生产 <code>mid</code> 个合金是可行的，那么我们应该尝试生产更多。所以 <code>mid</code> 是一个潜在的解，我们将搜索范围的下界更新为 <code>mid</code>，即 <code>l = mid</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>False</code></strong>：<ul>
<li>说明生产 <code>mid</code> 个合金成本太高，我们必须减少生产数。将搜索范围的上界更新为 <code>mid</code>，即 <code>r = mid</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>更新答案</strong>：<ul>
<li>当二分查找循环结束时，<code>l</code> 就代表了当前这台机器在预算内能生产的最大合金数。</li>
<li>用 <code>l</code> 来更新全局最大值 <code>ans</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>遍历完所有 <code>k</code> 台机器后，<code>ans</code> 中存储的就是最终的答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxNumberOfAlloys</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span>, budget: <span class="built_in">int</span>, composition: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], stock: <span class="type">List</span>[<span class="built_in">int</span>], cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 设定一个安全的二分查找上界</span></span><br><span class="line">        <span class="comment"># min(stock) + budget 是一个宽松但有效的上界</span></span><br><span class="line">        <span class="comment"># 即使成本为1，预算也只能买 budget 份材料，加上初始库存，不可能超过这个数</span></span><br><span class="line">        mx = <span class="built_in">min</span>(stock) + budget</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历每一台机器</span></span><br><span class="line">        <span class="keyword">for</span> comp <span class="keyword">in</span> composition:</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 定义判定函数：检查制造 num 个合金是否可行</span></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">                money = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 遍历制造合金所需的每种金属</span></span><br><span class="line">                <span class="keyword">for</span> s, base, c <span class="keyword">in</span> <span class="built_in">zip</span>(stock, comp, cost):</span><br><span class="line">                    <span class="comment"># 如果当前金属的库存不足</span></span><br><span class="line">                    <span class="keyword">if</span> s &lt; base * num:</span><br><span class="line">                        <span class="comment"># 计算需要购买的金属数量并累加成本</span></span><br><span class="line">                        money += (base * num - s) * c</span><br><span class="line">                        <span class="comment"># 如果成本已超预算，提前返回 False</span></span><br><span class="line">                        <span class="keyword">if</span> money &gt; budget:</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 为当前机器进行二分查找，寻找最大可制造数量</span></span><br><span class="line">            <span class="comment"># 左边界 l 从已有的答案 ans 开始，是一种优化</span></span><br><span class="line">            l, r = ans, mx + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 使用 l+1 &lt; r 的模板，最终 l 是满足 check(l) == True 的最大值</span></span><br><span class="line">            <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">                mid = (l + r) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> check(mid):</span><br><span class="line">                    <span class="comment"># 如果 mid 可行，说明可以尝试更多，所以收缩左边界</span></span><br><span class="line">                    l = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果 mid 不可行，说明数量太多，收缩右边界</span></span><br><span class="line">                    r = mid</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当前机器能制造的最大数量是 l，更新全局答案</span></span><br><span class="line">            ans = l</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(k * n * log(M))<ul>
<li><code>k</code> 是机器的数量，我们有一个外层循环遍历所有机器。</li>
<li>对于每台机器，我们执行一次二分查找。搜索空间的大小 <code>M</code> 大约为 <code>budget + min(stock)</code>。因此二分查找的迭代次数是 <code>log(M)</code>。</li>
<li>在二分查找的每一次迭代中，我们都会调用 <code>check</code> 函数，该函数需要遍历 <code>n</code> 种金属，时间复杂度为 O(n)。</li>
<li>所以，总时间复杂度是这三者的乘积。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)<ul>
<li>除了输入数据外，我们只使用了几个变量来存储边界和计算成本，没有使用与输入规模成正比的额外空间。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“二分答案”思想的典型应用。当我们求解一个“最大值”或“最小值”问题，并且发现答案的范围具有单调性时，就可以考虑将问题转化为一个判定问题（“某个值是否可行？”）。然后利用二分查找，将问题的规模不断减半，从而在对数时间内高效地锁定最优解。对于本题，我们对每一台机器都应用了这个策略，最终取所有结果中的最大值。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最大</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>第363场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2875 | 滑动窗口巧解“无限数组的最短子数组”</title>
    <url>//posts/leetcode-2875/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2875 题：<a href="https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/description/">无限数组的最短子数组</a>。<br>该题要求在一个由原数组无限重复构成的虚拟数组中，寻找和为目标值的最短子数组。面对“无限”，可以通过巧妙的数学转换简化为一个经典的定长数组滑动窗口问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个数组 <code>nums</code> 和一个目标值 <code>target</code>。我们需要想象一个通过无限次拼接 <code>nums</code> 自身形成的无限数组 <code>infinite_nums</code>。任务是在这个 <code>infinite_nums</code> 中，找到一个元素和恰好等于 <code>target</code> 的<strong>最短</strong>子数组，并返回其长度。如果不存在这样的子数组，则返回 -1。</p>
<p>举个例子，对于 <code>nums = [1,2,3], target = 5</code>:</p>
<ul>
<li><code>infinite_nums</code> 就好像是 <code>[1,2,3,1,2,3,1,2,...]</code>。</li>
<li>我们可以找到子数组 <code>[2,3]</code>，其和为 5，长度为 2。</li>
<li>我们也可以找到子数组 <code>[3,1,2]</code>（跨越了第一个 <code>nums</code> 的末尾和第二个 <code>nums</code> 的开头），其和为 6。</li>
<li>经过检查，<code>[2,3]</code> 是和为 5 的最短子数组，因此答案是 2。</li>
</ul>
<p>最主要的挑战在于 <code>target</code> 可能非常大，而数组是“无限”的，我们显然不能真的去构建它。</p>
<h3 id="核心思路：数学转换-滑动窗口"><a href="#核心思路：数学转换-滑动窗口" class="headerlink" title="核心思路：数学转换 + 滑动窗口"></a>核心思路：数学转换 + 滑动窗口</h3><p>解决这个问题的关键在于将“无限”问题转化为“有限”问题。我们可以观察到，任何一个目标和 <code>target</code> 都可以被 <code>nums</code> 的总和 <code>t</code> 分解。</p>
<p>假设 <code>t = sum(nums)</code>。那么 <code>target</code> 可以表示为：<br><code>target = (target // t) * t + (target % t)</code></p>
<p>这公式告诉我们，任何一个满足条件的子数组，必然由两部分构成：</p>
<ol>
<li><strong>整数倍部分</strong>：包含 <code>q = target // t</code> 个完整的 <code>nums</code> 数组。这部分的长度是固定的，即 <code>q * len(nums)</code>。</li>
<li><strong>余数部分</strong>：一个和为 <code>re = target % t</code> 的子数组。</li>
</ol>
<p>我们的总目标是找到最短的子数组。因为整数倍部分的长度是固定的，所以问题被巧妙地转化成了：<strong>在 <code>infinite_nums</code> 中寻找和为 <code>re</code> 的最短子数组</strong>。</p>
<p>那么如何寻找这个和为 <code>re</code> 的最短子数组呢？这个子数组可能完全位于一个 <code>nums</code> 拷贝内部，也可能跨越两个 <code>nums</code> 拷贝的边界（例如，一部分在 <code>nums</code> 的末尾，一部分在下一个 <code>nums</code> 的开头）。</p>
<p>为了优雅地处理这种“环形”或“跨界”的情况，我们可以使用一个经典技巧：<strong>在长度为 <code>2n</code> 的数组上进行搜索</strong>。我们将数组 <code>nums</code> 复制一份并拼接到自己后面（形成 <code>nums + nums</code> 的概念），然后在这个长度为 <code>2n</code> 的数组上使用滑动窗口寻找和为 <code>re</code> 的最短子数组。这样就能保证所有可能的连续子数组（包括跨界的）都被考虑到。</p>
<p>于是，整个解法分为清晰的两步：</p>
<ol>
<li><strong>数学转换</strong>：计算出 <code>nums</code> 的总和 <code>t</code>，然后计算出目标 <code>target</code> 需要完整 <code>nums</code> 的数量 <code>q = target // t</code> 和剩余的目标和 <code>re = target % t</code>。</li>
<li><strong>滑动窗口</strong>：在一个概念上的“双倍”<code>nums</code> 数组上，使用滑动窗口寻找和为 <code>re</code> 的最短子数组长度 <code>min_len</code>。</li>
</ol>
<p>最终答案就是 <code>q * n + min_len</code>。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>第一步：问题简化</strong></p>
<ul>
<li>计算 <code>n = len(nums)</code> 和 <code>t = sum(nums)</code>。</li>
<li>计算我们需要在 <code>infinite_nums</code> 中寻找的剩余和 <code>re = target % t</code>。</li>
<li>计算已经由完整 <code>nums</code> 数组贡献的长度 <code>base_len = (target // t) * n</code>。</li>
</ul>
</li>
<li><p><strong>第二步：滑动窗口寻找最短子数组</strong></p>
<ul>
<li>初始化最小长度 <code>ans = infinity</code>，当前窗口和 <code>s = 0</code>，左指针 <code>l = 0</code>。</li>
<li>我们让右指针 <code>r</code> 从 <code>0</code> 遍历到 <code>2*n - 1</code>，这等同于在 <code>nums</code> 和其拷贝组成的数组上滑动。为了获取元素，我们使用 <code>nums[r % n]</code>。</li>
<li>在循环中，将 <code>nums[r % n]</code> 加入当前和 <code>s</code>。</li>
<li>使用 <code>while</code> 循环，当 <code>s &gt; re</code> 时，说明窗口和过大，需要从左侧收缩窗口。减去 <code>nums[l % n]</code> 并将 <code>l</code> 右移。</li>
<li>如果 <code>s == re</code>，说明找到了一个满足条件的子数组。我们用它的长度 <code>r - l + 1</code> 来更新 <code>ans</code> 的最小值。</li>
</ul>
</li>
<li><p><strong>第三步：组合结果</strong></p>
<ul>
<li>滑动窗口结束后，检查 <code>ans</code> 是否仍然是 <code>infinity</code>。</li>
<li>如果是，说明在 <code>infinite_nums</code> 中找不到和为 <code>re</code> 的子数组，因此也无法构成 <code>target</code>，返回 <code>-1</code>。</li>
<li>如果不是，最终答案就是 <code>base_len + ans</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> inf</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSizeSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1: 问题简化</span></span><br><span class="line">        t = <span class="built_in">sum</span>(nums)</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 剩余的目标和</span></span><br><span class="line">        re = target % t</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 由整数倍的 nums 数组构成的基础长度</span></span><br><span class="line">        base_len = (target // t) * n</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> re == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 如果 target 恰好是 t 的整数倍，那么最短子数组就是 target/t 个完整的 nums</span></span><br><span class="line">            <span class="comment"># 但题目要求的是最短子数组，如果 target = t，最短的就是 nums 本身，长度为 n。</span></span><br><span class="line">            <span class="comment"># 我们的逻辑 re=0 会找到长度为 0 的子数组，加上 base_len 正好是 (target/t)*n</span></span><br><span class="line">            <span class="comment"># 但有一个特殊情况是，如果 target=t，base_len=n，re=0，我们的代码会找到一个空数组长度0</span></span><br><span class="line">            <span class="comment"># 最终返回 n+0 = n，这是对的。所以 re=0 的情况可以被统一处理。</span></span><br><span class="line">            <span class="comment"># 这里单独处理只是为了逻辑清晰。</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2: 滑动窗口寻找和为 re 的最短子数组</span></span><br><span class="line">        ans = inf</span><br><span class="line">        l = <span class="number">0</span>  <span class="comment"># 左指针</span></span><br><span class="line">        s = <span class="number">0</span>  <span class="comment"># 当前窗口和</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 在一个长度为 2n 的虚拟数组上滑动</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(n * <span class="number">2</span>):</span><br><span class="line">            s += nums[r % n]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当窗口和大于目标时，从左侧收缩</span></span><br><span class="line">            <span class="keyword">while</span> s &gt; re:</span><br><span class="line">                s -= nums[l % n]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果窗口和等于目标，更新最小长度</span></span><br><span class="line">            <span class="keyword">if</span> s == re:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, r - l + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 组合结果</span></span><br><span class="line">        <span class="keyword">if</span> ans == inf:</span><br><span class="line">            <span class="comment"># 如果 ans 未被更新，说明找不到和为 re 的子数组</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ans + base_len</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是 <code>nums</code> 的长度。计算数组总和是 O(N)，滑动窗口的左右指针最多移动 <code>2N</code> 次，因此也是 O(N)。总体复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个额外变量，没有创建与输入规模相关的数据结构。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“数学思维”与“算法技巧”结合的典范。通过取模运算，我们将一个看似复杂的“无限”问题，成功降维成一个可以在有限范围内解决的经典问题——在循环数组中寻找最短子数组和。而处理循环数组的“双倍数组”技巧，则是滑动窗口应用中的一个常用且强大的模式。当我们遇到看似无从下手的“无限”、“环形”等问题时，不妨先思考一下是否能通过数学变换将其转化为我们熟悉的模型。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>前缀和</tag>
        <tag>第365场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2904 | SW求解最短且字典序最小的美丽子串</title>
    <url>//posts/leetcode-2904/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2904 题：<a href="https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/description/">最短且字典序最小的美丽子字符串</a>。<br>该题要求在一个二进制字符串中，寻找一个包含 <code>k</code> 个 ‘1’ 的子串，这个子串需要满足两个条件：首先长度最短，其次在所有最短的子串中，它的字典序最小。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个二进制字符串 <code>s</code> 和一个正整数 <code>k</code>。我们需要找到 <code>s</code> 的一个“美丽子字符串”。</p>
<p>一个子字符串被称为“美丽”的，当且仅当它包含的 ‘1’ 的数量恰好为 <code>k</code>。</p>
<p>我们的目标是：</p>
<ol>
<li>在所有“美丽子字符串”中，找到那些长度最短的。</li>
<li>在所有这些最短的“美丽子字符串”中，找到字典序最小的那一个。</li>
</ol>
<p>如果不存在这样的子字符串，我们应该返回一个空字符串。</p>
<p>举个例子，对于 <code>s = &quot;100011001&quot;</code>, <code>k = 3</code>：</p>
<ul>
<li>子字符串 <code>&quot;100011&quot;</code> 是美丽的（3 个 ‘1’），长度为 6。</li>
<li>子字符串 <code>&quot;011001&quot;</code> 也是美丽的（3 个 ‘1’），长度为 6。</li>
<li>子字符串 <code>&quot;11001&quot;</code> 还是美丽的（3 个 ‘1’），长度为 5。</li>
<li>最短的美丽子字符串长度是 5。</li>
<li>在所有长度为 5 的美丽子字符串中（这里只有一个 <code>&quot;11001&quot;</code>），字典序最小的就是 <code>&quot;11001&quot;</code>，因此它就是答案。</li>
</ul>
<h3 id="核心思路：不定长滑动窗口"><a href="#核心思路：不定长滑动窗口" class="headerlink" title="核心思路：不定长滑动窗口"></a>核心思路：不定长滑动窗口</h3><p>这类寻找满足特定条件的“最优”子字符串的问题，是滑动窗口算法的绝佳应用场景。我们可以维护一个窗口 <code>[left, right]</code>，它代表了我们正在考察的子字符串。</p>
<p>我们的策略如下：</p>
<ol>
<li><p><strong>扩展窗口</strong>：我们不断地将 <code>right</code> 指针向右移动，以扩大窗口。每当一个新字符进入窗口时，我们更新窗口内 ‘1’ 的数量。</p>
</li>
<li><p><strong>收缩窗口</strong>：一旦窗口内 ‘1’ 的数量达到了 <code>k</code>，我们就找到了一个“美丽子字符串”的候选者。这时，我们不能停下，因为这个候选者不一定是最短的。</p>
<ul>
<li><strong>评估候选者</strong>：我们将当前窗口代表的子字符串与已找到的最佳答案进行比较。如果当前子串更短，或者长度相同但字典序更小，我们就更新答案。</li>
<li><strong>启动收缩</strong>：为了寻找可能存在的、更短的美丽子字符串，我们必须从左侧收缩窗口。我们将 <code>left</code> 指针向右移动，并相应地更新 ‘1’ 的数量。这个收缩过程会一直持续，直到窗口不再满足 ‘1’ 的数量为 <code>k</code> 的条件，之后我们再继续扩展 <code>right</code> 指针。</li>
</ul>
</li>
</ol>
<p>通过这种“扩展-评估-收缩”的循环，我们能确保遍历所有可能的美丽子字符串，并最终找到最优解。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>min_len</code>：用于记录当前找到的最短美丽子串的长度，初始为无穷大。</li>
<li><code>result</code>：用于存储最终答案，初始为空字符串 <code>&quot;&quot;</code>。</li>
<li><code>left = 0</code>：滑动窗口的左边界。</li>
<li><code>ones_count = 0</code>：当前滑动窗口内 ‘1’ 的数量。</li>
</ul>
</li>
<li><p><strong>遍历与扩展</strong>：</p>
<ul>
<li>使用 <code>right</code> 指针从头到尾遍历字符串 <code>s</code>。</li>
<li>当 <code>s[right]</code> 为 ‘1’ 时，<code>ones_count</code> 加 1。</li>
</ul>
</li>
<li><p><strong>触发收缩与评估</strong>：</p>
<ul>
<li>当 <code>ones_count</code> 恰好等于 <code>k</code> 时，我们找到了一个美丽子字符串。此时，启动一个 <code>while</code> 循环，因为 <code>[left, right]</code> 是一个候选项，<code>[left+1, right]</code> 也可能是（如果 <code>s[left]</code> 是 ‘0’）。</li>
<li><strong>在 <code>while (ones_count == k)</code> 循环内</strong>：<ol>
<li>获取当前窗口的长度 <code>current_len = right - left + 1</code> 和子字符串 <code>current_substring = s[left:right+1]</code>。</li>
<li><strong>比较与更新</strong>：<ul>
<li>如果 <code>current_len &lt; min_len</code>，说明我们找到了一个更短的，直接更新 <code>min_len = current_len</code> 和 <code>result = current_substring</code>。</li>
<li>如果 <code>current_len == min_len</code>，我们需要比较字典序。如果 <code>current_substring &lt; result</code>，则更新 <code>result = current_substring</code>。</li>
</ul>
</li>
<li><strong>收缩</strong>：将 <code>left</code> 指针右移一位。如果被移出窗口的字符 <code>s[left]</code> 是 ‘1’，则将 <code>ones_count</code> 减 1。这一步可能会导致 <code>ones_count</code> 变为 <code>k-1</code>，从而结束 <code>while</code> 循环。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>主循环结束后，<code>result</code> 中存储的就是最终答案。如果从未找到过美丽子字符串，<code>result</code> 将保持其初始值 <code>&quot;&quot;</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shortestBeautifulSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 如果 s 中 &#x27;1&#x27; 的总数都小于 k，则不可能有美丽子字符串</span></span><br><span class="line">        <span class="keyword">if</span> s.count(<span class="string">&#x27;1&#x27;</span>) &lt; k:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        min_len = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        result = <span class="string">&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        ones_count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 扩展窗口</span></span><br><span class="line">            <span class="keyword">if</span> s[right] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                ones_count += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当窗口内 &#x27;1&#x27; 的数量达到 k 时，开始评估和收缩</span></span><br><span class="line">            <span class="keyword">while</span> ones_count == k:</span><br><span class="line">                current_len = right - left + <span class="number">1</span></span><br><span class="line">                current_substring = s[left : right + <span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 评估：如果找到了更短的，或同样短但字典序更小的</span></span><br><span class="line">                <span class="keyword">if</span> current_len &lt; min_len:</span><br><span class="line">                    min_len = current_len</span><br><span class="line">                    result = current_substring</span><br><span class="line">                <span class="keyword">elif</span> current_len == min_len <span class="keyword">and</span> current_substring &lt; result:</span><br><span class="line">                    result = current_substring</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 收缩窗口</span></span><br><span class="line">                <span class="keyword">if</span> s[left] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    ones_count -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)，其中 N 是字符串 <code>s</code> 的长度。虽然代码里有嵌套的 <code>while</code> 循环，但 <code>left</code> 和 <code>right</code> 两个指针都只从左到右单向移动一次，每个字符最多被访问两次（一次被 <code>right</code> 指针纳入，一次被 <code>left</code> 指针排除），因此总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个额外变量来存储窗口状态和结果。返回的字符串 <code>result</code> 的空间不算在额外空间复杂度内。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想的直接应用。解决此题的关键在于清晰地定义窗口的“合法”状态（<code>ones_count == k</code>），并在进入此状态时，不仅要与全局最优解进行比较，还要尝试通过收缩窗口来寻找一个可能更优的解。双重优化目标（长度优先，字典序其次）的逻辑判断是本题的核心细节。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
        <tag>第367场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2953 | 分治+滑动窗口巧解“统计完全子字符串”</title>
    <url>//posts/leetcode-2953/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2953 题：<a href="https://leetcode.cn/problems/count-complete-substrings/description/">统计完全子字符串</a>。<br>这道题巧妙地将“分治思想”和“滑动窗口”结合在了一起。通过识别问题中的强约束条件来分解问题，是解决复杂问题的关键一步。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们来仔细分析一下题目中的“完全子字符串”需要满足的两个条件：</p>
<ol>
<li><strong>频率条件</strong>：子字符串 <code>s</code> 中的<strong>每个字符</strong>，都恰好出现 <code>k</code> 次。</li>
<li><strong>相邻条件</strong>：子字符串 <code>s</code> 中，任意<strong>两个相邻字符</strong>在字母表中的位置之差<strong>至多为 2</strong>。</li>
</ol>
<p>例如，<code>word = &quot;igigee&quot;</code>, <code>k = 2</code>。<br>子串 <code>&quot;igig&quot;</code> 满足相邻条件 (<code>&#39;i&#39;</code> 和 <code>&#39;g&#39;</code> 相差 2)，也满足频率条件（<code>&#39;i&#39;</code> 和 <code>&#39;g&#39;</code> 均出现 2 次），所以它是一个完全子字符串。<br>子串 <code>&quot;igigee&quot;</code> 中，<code>&#39;g&#39;</code> 和 <code>&#39;e&#39;</code> 相差 2，<code>&#39;e&#39;</code> 和 <code>&#39;e&#39;</code> 相差 0，满足相邻条件。但频率不对（<code>&#39;i&#39;</code> 出现 2 次, <code>&#39;g&#39;</code> 出现 2 次, <code>&#39;e&#39;</code> 出现 2 次），因此它也是一个完全子字符串。</p>
<p>而对于 <code>word = &quot;abacaba&quot;, k = 1</code>，子串 <code>&quot;abac&quot;</code> 不满足相邻条件，因为 <code>&#39;a&#39;</code> 和 <code>&#39;c&#39;</code> 的位置差是 2，但它们不相邻，相邻的是<code>&#39;b&#39;</code>和<code>&#39;a&#39;</code>，<code>&#39;a&#39;</code>和<code>&#39;c&#39;</code>。但是，在子串<code>&quot;ac&quot;</code>中，<code>&#39;a&#39;</code>和<code>&#39;c&#39;</code>相邻，位置差为2，满足条件。</p>
<h3 id="核心思路：分治-滑动窗口"><a href="#核心思路：分治-滑动窗口" class="headerlink" title="核心思路：分治 + 滑动窗口"></a>核心思路：分治 + 滑动窗口</h3><p>直接在一个循环里处理两个条件会非常复杂。我们注意到，“相邻条件”是一个非常强的局部约束。如果 <code>word</code> 中存在两个相邻字符 <code>word[i]</code> 和 <code>word[i-1]</code>，它们的字母表位置差大于 2，那么任何<strong>跨越</strong> <code>i-1</code> 和 <code>i</code> 这两个位置的子字符串都<strong>不可能</strong>是完全子字符串。</p>
<p>这个特性给了我们一个绝佳的“分治”机会！</p>
<h4 id="分割字符串（Divide）"><a href="#分割字符串（Divide）" class="headerlink" title="分割字符串（Divide）"></a>分割字符串（Divide）</h4><p>我们可以根据“相邻条件”将原字符串 <code>word</code> 切分成若干个独立的、更小的“有效子段”。在每个有效子段内部，任意相邻字符的位置差都 <code>&lt;= 2</code>。这样，我们只需要在这些独立的子段内部寻找满足“频率条件”的子字符串即可。</p>
<p>例如，如果 <code>word = &quot;aaabccdeeff&quot;, k = 2</code>，字符 <code>&#39;c&#39;</code> 和 <code>&#39;d&#39;</code> 的位置差为1，但<code>&#39;c&#39;</code>和<code>&#39;e&#39;</code>位置差为2，而<code>&#39;b&#39;</code> 和 <code>&#39;c&#39;</code> 的位置差为 1。假设 <code>word = &quot;aaabcxyz&quot;</code>，<code>&#39;c&#39;</code> 和 <code>&#39;x&#39;</code> 的位置差远大于 2，所以我们可以在它们之间切一刀，将问题分解为在 <code>&quot;aaabc&quot;</code> 和 <code>&quot;xyz&quot;</code> 两个子串中分别求解。</p>
<h4 id="在子段内求解（Conquer）"><a href="#在子段内求解（Conquer）" class="headerlink" title="在子段内求解（Conquer）"></a>在子段内求解（Conquer）</h4><p>对于每一个被分割出的有效子段，我们现在只需要解决一个简化版的问题：<strong>找出所有满足“每个字符恰好出现 k 次”的子字符串</strong>。</p>
<p>这正是滑动窗口的用武之地。但这里有一个挑战：完全子字符串的长度不是固定的。</p>
<ul>
<li>如果子字符串包含 1 种不同字符，其长度必须是 <code>1 * k</code>。</li>
<li>如果子字符串包含 2 种不同字符，其长度必须是 <code>2 * k</code>。</li>
<li>…</li>
<li>如果子字符串包含 <code>d</code> 种不同字符，其长度必须是 <code>d * k</code>。</li>
</ul>
<p>因此，我们可以遍历所有可能的“不同字符数”（从 1 到 26），对于每一种情况，我们使用一个<strong>定长滑动窗口</strong>来寻找答案。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>分割阶段</strong>:</p>
<ul>
<li>遍历整个字符串 <code>word</code>。使用一个指针 <code>i</code> 标记当前有效子段的开始。</li>
<li>使用另一个指针 <code>j</code> 从 <code>i</code> 开始向后寻找，直到 <code>abs(ord(word[j]) - ord(word[j+1])) &gt; 2</code> 或到达字符串末尾。</li>
<li>此时，<code>word[i:j+1]</code> 就是一个内部满足“相邻条件”的有效子段。</li>
<li>将这个子段交给下一步处理，然后将 <code>i</code> 更新为 <code>j+1</code>，开始寻找下一个有效子段。</li>
</ul>
</li>
<li><p><strong>处理子段阶段</strong>:</p>
<ul>
<li>对于上一步得到的每个有效子段 <code>s</code>，我们设计一个函数来计算其中的完全子字符串数量。</li>
<li>在这个函数内部，我们遍历“不同字符数 <code>d</code>”，从 1 到 26。</li>
<li>对于每个 <code>d</code>，我们计算出对应的窗口长度 <code>window_len = d * k</code>。如果 <code>window_len</code> 大于当前子段 <code>s</code> 的长度，就没有必要继续了。</li>
<li>使用一个长度为 <code>window_len</code> 的滑动窗口遍历子段 <code>s</code>。</li>
<li>在窗口滑动的每一步，我们都检查窗口内的子串是否满足：<ul>
<li>恰好包含 <code>d</code> 种不同的字符。</li>
<li>每种字符的出现次数都为 <code>k</code>。</li>
</ul>
</li>
<li>如果满足，则结果计数加一。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countCompleteSubstrings</span>(<span class="params">self, word: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(word)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1: 分割字符串</span></span><br><span class="line">        <span class="comment"># 根据相邻字符差异 &gt; 2 的地方作为切分点</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># 找到当前有效子段的终点</span></span><br><span class="line">            <span class="keyword">while</span> j + <span class="number">1</span> &lt; n <span class="keyword">and</span> <span class="built_in">abs</span>(<span class="built_in">ord</span>(word[j]) - <span class="built_in">ord</span>(word[j+<span class="number">1</span>])) &lt;= <span class="number">2</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 对子串 word[i:j+1] 进行处理</span></span><br><span class="line">            res += <span class="variable language_">self</span>._count_in_segment(word[i:j+<span class="number">1</span>], k)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 移动到下一个子段的起点</span></span><br><span class="line">            i = j + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_count_in_segment</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        在已满足“相邻条件”的子段 s 中，计算满足“频率条件”的完全子字符串数量。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 步骤 2: 遍历所有可能的窗口长度</span></span><br><span class="line">        <span class="comment"># distinct_chars 是窗口内不同字符的数量，从 1 到 26</span></span><br><span class="line">        <span class="keyword">for</span> distinct_chars <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">27</span>):</span><br><span class="line">            window_len = distinct_chars * k</span><br><span class="line">            <span class="keyword">if</span> window_len &gt; <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="comment"># 窗口长度已超过子段长度，后续更长的窗口也无意义</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 使用固定长度为 window_len 的滑动窗口</span></span><br><span class="line">            w_cnt = Counter(s[:window_len])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 检查第一个窗口</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>._is_complete(w_cnt, k):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 开始滑动</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(window_len, <span class="built_in">len</span>(s)):</span><br><span class="line">                l = r - window_len</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 窗口右侧加入一个新字符</span></span><br><span class="line">                w_cnt[s[r]] += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 窗口左侧移出一个旧字符</span></span><br><span class="line">                w_cnt[s[l]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> w_cnt[s[l]] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> w_cnt[s[l]]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 检查当前窗口是否为完全子字符串</span></span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>._is_complete(w_cnt, k):</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_is_complete</span>(<span class="params">self, counter: Counter, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        辅助函数：检查一个计数器中的所有字符频率是否都严格为 k。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> counter:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 遍历计数器中所有字符的计数值</span></span><br><span class="line">        <span class="keyword">for</span> freq <span class="keyword">in</span> counter.values():</span><br><span class="line">            <span class="keyword">if</span> freq != k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。虽然代码有两层循环，但我们可以这样分析：外层循环负责分割字符串，对 <code>word</code> 的每个字符访问一次，是 O(N)。内层的 <code>_count_in_segment</code> 函数，其循环 <code>for distinct_chars in range(1, 27)</code> 最多执行 26 次。在每次循环中，滑动窗口会线性扫描一次子段。由于所有子段的长度之和为 N，所以总的时间复杂度是 O(26 * N)，即 O(N)。</li>
<li><strong>空间复杂度</strong>: O(K)，其中 K 是字符集的大小（这里是 26）。<code>Counter</code> 最多存储 26 个字符的频率，因此空间复杂度是 O(1)。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“困难”题中的一股清流，它展示了如何通过分析问题约束来简化问题。<br>关键的收获是：</p>
<ol>
<li><strong>识别强约束</strong>：题目中的“相邻条件”是比“频率条件”更强的局部约束，它可以作为我们分割问题的依据。</li>
<li><strong>分而治之</strong>：将一个复杂问题分解为多个独立的、更简单的子问题。</li>
<li><strong>模式识别</strong>：在子问题中，我们识别出了一个“变种”的滑动窗口问题——窗口长度可变但有规律，通过遍历所有可能的长度来解决。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2968 | 滑动窗口求解“执行操作使频率分数最大”</title>
    <url>//posts/leetcode-2968/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2968 题：<a href="https://leetcode.cn/problems/apply-operations-to-maximize-frequency-score/description/">执行操作使频率分数最大</a>。<br>该题要求我们通过对数组元素进行有限次数的增减操作，来最大化某个元素的出现频率。问题的核心在于，要让一组数字变得相同，最经济的方式是什么？答案指向了它们的中位数。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个整数数组 <code>nums</code> 和一个预算 <code>k</code>。我们可以执行的操作是：选择任意一个元素 <code>nums[i]</code>，将其增加或减少 1。每次操作消耗 1。我们的总消耗不能超过 <code>k</code>。</p>
<p>目标是最大化操作后数组中某个数出现的次数（即“频率分数”）。</p>
<p>举个例子，对于 <code>nums = [1,2,6,4]</code>, <code>k = 3</code>：</p>
<ul>
<li>我们的目标是，用不超过 3 的总代价，让尽可能多的数字变成同一个数。</li>
<li>比如，我们可以选择让一部分数字都变成 2。<ul>
<li><code>1</code> 变成 <code>2</code>，代价是 <code>|2-1|=1</code>。</li>
<li><code>4</code> 变成 <code>2</code>，代价是 <code>|2-4|=2</code>。</li>
<li>总代价是 <code>1 + 2 = 3</code>，正好在预算内。</li>
<li>操作后数组可以是 <code>[2,2,6,2]</code>。数字 <code>2</code> 出现了 3 次。</li>
</ul>
</li>
<li>我们可以达到的最大频率就是 3。</li>
</ul>
<p>直接枚举最终要变成哪个数，以及选择哪些原始数字来变成它，组合非常多，复杂度会爆炸。我们需要一个更系统性的方法。</p>
<h3 id="核心思路：排序-滑动窗口"><a href="#核心思路：排序-滑动窗口" class="headerlink" title="核心思路：排序 + 滑动窗口"></a>核心思路：排序 + 滑动窗口</h3><p>为了让最终的频率分数为 <code>m</code>，我们必须选择 <code>m</code> 个原始数字，并将它们全部变成同一个目标值 <code>t</code>。我们的策略应该是：</p>
<ol>
<li><p><strong>选择哪 <code>m</code> 个数？</strong><br>直觉上，为了让操作总代价最小，我们应该选择那些本身就比较接近的数字。将数组排序后，这些数字会形成一个连续的子数组。因此，我们的问题转化为了在<strong>排序后</strong>的数组上寻找一个子数组。</p>
</li>
<li><p><strong>目标值 <code>t</code> 应该是什么？</strong><br>对于一个给定的子数组（比如 <code>[a, b, c, d]</code>），要将它们全部变成同一个值 <code>t</code>，总代价为 <code>|a-t| + |b-t| + |c-t| + |d-t|</code>。这是一个经典的数学问题：要使绝对差之和最小，目标值 <code>t</code> 必须是这个子数组的<strong>中位数</strong>。</p>
</li>
</ol>
<p>结合这两点，问题豁然开朗：<br><strong>问题转化为：在排序后的 <code>nums</code> 数组中，找到一个最长的连续子数组 <code>nums[left...right]</code>，使得将该子数组中的所有元素都变成其中位数 <code>nums[(left+right)//2]</code> 的总代价不超过 <code>k</code>。</strong></p>
<p>这个子数组的长度，就是我们能获得的最大频率分数。</p>
<p>这完美地契合了<strong>不定长滑动窗口</strong>的模型。我们可以用 <code>[left, right]</code> 来表示我们正在考虑的子数组。</p>
<ul>
<li>我们不断向右扩展窗口的右边界 <code>right</code>。</li>
<li>同时计算将窗口内所有元素统一到其中位数的代价。</li>
<li>如果代价超过了预算 <code>k</code>，我们就从左边收缩窗口，即增大 <code>left</code>，直到代价重新回到预算内。</li>
<li>在这个过程中，我们记录下窗口的最大长度 <code>right - left + 1</code>，它就是最终的答案。</li>
</ul>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>排序</strong><br>首先对 <code>nums</code> 数组进行升序排序。这是后续所有步骤的基础。</p>
</li>
<li><p><strong>滑动窗口</strong></p>
<ul>
<li>初始化窗口的左右边界 <code>left = 0</code>，<code>right = 0</code>。</li>
<li>用一个变量 <code>s</code> 记录当前窗口 <code>[left, right]</code> 内的元素统一到其中位数的总代价。</li>
<li>遍历 <code>right</code> 从 <code>0</code> 到 <code>n-1</code>，不断扩大窗口：<br>a.  当 <code>right</code> 指向新元素 <code>x</code> (<code>nums[right]</code>) 时，我们计算将这个新元素加入窗口后，新的总代价。<br>b.  代价 <code>s</code> 的更新是本题的巧妙之处。可以证明，当窗口从 <code>[left, right-1]</code> 扩展到 <code>[left, right]</code> 时，总代价的变化可以通过一个简单的公式计算。同样，当窗口从 <code>[left, right]</code> 收缩到 <code>[left+1, right]</code> 时，代价的变化也有规律。<br>c.  判断当前的总代价 <code>s</code> 是否大于 <code>k</code>。<br>d.  如果 <code>s &gt; k</code>，说明当前窗口过长，成本超支。我们需要收缩窗口，将 <code>left</code> 指针右移，并从 <code>s</code> 中减去 <code>nums[left]</code> 贡献的成本。持续这个过程，直到 <code>s &lt;= k</code>。<br>e.  在每一次窗口调整后，当前窗口 <code>[left, right]</code> 都是一个有效的方案，其长度 <code>right - left + 1</code> 是一个可能的频率分数。我们用它来更新全局最大值 <code>ans</code>。</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>遍历结束后，<code>ans</code> 即为所求。</li>
</ul>
</li>
</ol>
<p>这个算法的关键在于如何高效地更新代价 <code>s</code>。虽然可以通过前缀和在 O(1) 时间内计算任意窗口的代价，但给出的代码采用了更精妙的增量更新方式，省去了前缀和数组的空间。</p>
<p>让我们来理解一下代码中的代价更新逻辑：</p>
<ul>
<li><code>s += x - nums[(left + right) // 2]</code>：当窗口向右扩大，加入 <code>x = nums[right]</code> 时，新的中位数是 <code>m_new = nums[(left + right) // 2]</code>。<code>s</code> 的增量被计算为 <code>x - m_new</code>。</li>
<li><code>s += nums[left] - nums[(left + right + 1) // 2]</code>：当窗口从左边收缩，移除 <code>nums[left]</code> 时，新窗口 <code>[left+1, right]</code> 的中位数是 <code>m&#39;_new = nums[(left + right + 1) // 2]</code>。<code>s</code> 的减量被计算为 <code>m&#39;_new - nums[left]</code>。</li>
</ul>
<p>这些看似简单的更新，其背后是利用了中位数变化的规律，巧妙地对总代价进行了调整，从而避免了每次都重新计算整个窗口的成本。</p>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxFrequencyScore</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1: 排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="comment"># s 是窗口内元素与窗口中位数的绝对差之和，即总代价</span></span><br><span class="line">        s = <span class="number">0</span>  </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2: 滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span> right, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 扩大窗口：加入 nums[right]</span></span><br><span class="line">            <span class="comment"># 计算并累加新窗口的代价</span></span><br><span class="line">            <span class="comment"># m_new 是 [left...right] 的中位数</span></span><br><span class="line">            m_new = nums[(left + right) // <span class="number">2</span>]</span><br><span class="line">            s += x - m_new</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果代价超支，收缩窗口</span></span><br><span class="line">            <span class="keyword">while</span> s &gt; k:</span><br><span class="line">                <span class="comment"># m_after_shrink 是 [left+1...right] 的中位数</span></span><br><span class="line">                m_after_shrink = nums[(left + right + <span class="number">1</span>) // <span class="number">2</span>]</span><br><span class="line">                <span class="comment"># 从总代价 s 中减去移除 nums[left] 带来的变化</span></span><br><span class="line">                s -= (m_after_shrink - nums[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 更新最大频率分数（即最大有效窗口长度）</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N log N)。其中 N 是 <code>nums</code> 的长度。排序的复杂度是 O(N log N)，后续的滑动窗口遍历中，<code>left</code> 和 <code>right</code> 指针都只单向移动 N 次，所以是 O(N)。总的瓶颈在排序。</li>
<li><strong>空间复杂度</strong>: O(1) 或 O(log N) 或 O(N)。这取决于排序算法使用的额外空间。如果我们忽略排序所用的空间，则算法本身是 O(1)。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是一个将实际问题转化为标准算法模型的绝佳例子。通过两个关键的洞察——“选择排序后连续的子数组代价更小”和“目标值应为子数组的中位数”，我们将一个看似复杂的组合问题，成功转换为了一个可以在排序数组上用滑动窗口高效求解的问题。代码中对窗口代价 <code>s</code> 的精妙增量更新，是该解法在实现层面的点睛之笔，值得细细品味。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>滑动窗口</tag>
        <tag>排序</tag>
        <tag>前缀和</tag>
        <tag>第376场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3 | 无重复字符的最长子串</title>
    <url>//posts/leetcode-3/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3 题：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a>。<br>这道题通过维护一个动态的、满足特定条件的窗口，在 O(N) 的时间内优雅地解决问题，是每位算法学习者都应掌握的核心技巧。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目的要求非常直白：给定一个字符串 <code>s</code>，找出其中<strong>不含有重复字符</strong>的<strong>最长子串</strong>的长度。</p>
<p>我们需要理解两个关键点：</p>
<ol>
<li><strong>子串 (Substring)</strong>：必须是原字符串中连续的一段字符。例如，<code>&quot;wke&quot;</code> 是 <code>&quot;pwwkew&quot;</code> 的一个子串。</li>
<li><strong>无重复字符</strong>：子串中的每个字符都只出现一次。</li>
</ol>
<p>我们来看几个例子：</p>
<ul>
<li><code>s = &quot;abcabcbb&quot;</code>：最长的无重复子串是 <code>&quot;abc&quot;</code>，长度为 3。</li>
<li><code>s = &quot;bbbbb&quot;</code>：最长的无重复子串是 <code>&quot;b&quot;</code>，长度为 1。</li>
<li><code>s = &quot;pwwkew&quot;</code>：最长的无重复子串是 <code>&quot;wke&quot;</code>，长度为 3。这里需要特别注意，<code>&quot;pwke&quot;</code> 是一个子序列 (subsequence) 而不是子串，因此不是有效答案。</li>
</ul>
<h3 id="核心思路：滑动窗口"><a href="#核心思路：滑动窗口" class="headerlink" title="核心思路：滑动窗口"></a>核心思路：滑动窗口</h3><p>暴力解法（枚举所有子串并检查是否有重复字符）的时间复杂度会达到 O(N³)，显然无法接受。这正是“滑动窗口”大显身手的场景。</p>
<p>我们可以想象有一个“窗口”在字符串上滑动，这个窗口的内部始终维护着一个<strong>无重复字符的子串</strong>。我们的目标就是让这个窗口尽可能地宽。</p>
<p>该如何实现这个“滑动”呢？</p>
<ol>
<li>我们用两个指针，<code>left</code> 和 <code>right</code>，来表示窗口的左右边界，初始时都指向字符串的开头。</li>
<li><code>right</code> 指针不断向右移动，尝试扩大窗口。每移动一步，就将新字符纳入窗口。</li>
<li>在纳入新字符 <code>s[right]</code> 时，我们需要检查它是否已存在于当前窗口中。</li>
<li><strong>如果 <code>s[right]</code> 不在窗口内</strong>：说明窗口依然满足无重复的条件。此时 <code>right</code> 指针可以继续向右移动，窗口成功扩大。</li>
<li><strong>如果 <code>s[right]</code> 已经在窗口内</strong>：说明出现了重复字符，当前窗口不再合法。此时我们必须收缩窗口。具体操作是，将 <code>left</code> 指针向右移动，并将 <code>s[left]</code> 移出窗口，直到那个与 <code>s[right]</code> 重复的字符被移出窗口为止。</li>
<li>在每一次窗口状态合法时（即扩大或收缩后），我们都计算一下当前窗口的长度 <code>right - left + 1</code>，并更新我们记录的最大长度。</li>
</ol>
<p>为了能以 O(1) 的时间复杂度快速判断一个字符是否存在于当前窗口中，以及快速地添加和删除字符，<strong>哈希集合 (Hash Set)</strong> 是最理想的数据结构。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化</strong>:</p>
<ul>
<li>创建一个哈希集合 <code>char_set</code>，用来存储当前窗口内的所有字符。</li>
<li>初始化左指针 <code>left = 0</code>。</li>
<li>初始化最大长度 <code>max_len = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历与扩张</strong>:</p>
<ul>
<li>使用右指针 <code>right</code> 从 0 开始遍历整个字符串 <code>s</code>。</li>
<li>对于每个 <code>s[right]</code>，进入一个循环，检查 <code>s[right]</code> 是否已经存在于 <code>char_set</code> 中。</li>
</ul>
</li>
<li><p><strong>检查与收缩</strong>:</p>
<ul>
<li><strong>如果 <code>s[right]</code> 存在</strong>，说明遇到了重复字符。我们需要收缩窗口的左边界。</li>
<li>从 <code>char_set</code> 中移除 <code>s[left]</code> 对应的字符。</li>
<li>将 <code>left</code> 指针向右移动一位 (<code>left += 1</code>)。</li>
<li>重复此过程，直到 <code>s[right]</code> 在 <code>char_set</code> 中不再存在为止。</li>
</ul>
</li>
<li><p><strong>更新状态</strong>:</p>
<ul>
<li>（经过上一步的收缩后）现在可以保证将 <code>s[right]</code> 加入窗口是安全的。将 <code>s[right]</code> 添加到 <code>char_set</code> 中。</li>
<li>此时，窗口 <code>[left, right]</code> 是一个有效的无重复子串。计算其长度 <code>right - left + 1</code>，并与 <code>max_len</code> 比较，取较大值更新 <code>max_len</code>。</li>
</ul>
</li>
<li><p><strong>结束</strong>:</p>
<ul>
<li><code>right</code> 指针遍历完整个字符串后，<code>max_len</code> 中存储的就是最终的答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 哈希集合，用于存储当前窗口中的字符</span></span><br><span class="line">        char_set = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 左指针和结果变量</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 右指针遍历整个字符串</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># 当 s[right] 存在于当前窗口中时，</span></span><br><span class="line">            <span class="comment"># 需要从窗口左侧开始移除元素，直到窗口中不再包含重复的 s[right]。</span></span><br><span class="line">            <span class="keyword">while</span> s[right] <span class="keyword">in</span> char_set:</span><br><span class="line">                char_set.remove(s[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将当前字符添加到窗口（哈希集合）中</span></span><br><span class="line">            char_set.add(s[right])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新找到的最大长度。</span></span><br><span class="line">            <span class="comment"># 此时的窗口范围是 [left, right]，长度为 right - left + 1</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> max_len</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)，其中 N 是字符串 <code>s</code> 的长度。虽然代码中有一个 <code>while</code> 循环嵌套在 <code>for</code> 循环内部，但每个字符最多被 <code>left</code> 指针和 <code>right</code> 指针各访问一次。因此，总的操作次数与字符串长度成线性关系。</li>
<li><strong>空间复杂度</strong>: O(K)，其中 K 是字符集的大小。在最坏的情况下，如果字符串中的所有字符都不同，<code>char_set</code> 将会存储所有这些字符。对于 ASCII 字符集，K 的大小是固定的（如 128 或 256），因此也可以看作是 O(1) 的空间复杂度。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口技巧的奠基石，完美地诠释了其核心思想：</p>
<ol>
<li><strong>双指针界定窗口</strong>：使用 <code>left</code> 和 <code>right</code> 指针定义一个处理区间。</li>
<li><strong>条件驱动指针移动</strong>：根据窗口内是否满足“无重复字符”这一条件，来决定是移动 <code>right</code> 指针（扩张）还是 <code>left</code> 指针（收缩）。</li>
<li><strong>借助高效数据结构</strong>：使用哈希集合来优化查询效率，使得检查重复和更新窗口状态的操作接近 O(1)。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 30 | 滑动窗口巧解串联所有单词的子串</title>
    <url>//posts/leetcode-30/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 30 题：<a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">串联所有单词的子串</a>。<br>这道题是滑动窗口思想的一次精彩升级。它不再是处理单个字符，而是将“单词”作为窗口滑动的基本单位，同时引入了“分组”处理的巧妙思想，是理解滑动窗口灵活性的绝佳案例。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们来仔细分析一下题目：给定一个主字符串 <code>s</code> 和一个单词数组 <code>words</code>，要求找出 <code>s</code> 中所有“串联子串”的起始索引。</p>
<ul>
<li><strong>串联子串</strong>：这个子串由 <code>words</code> 中的<strong>所有</strong>单词<strong>恰好一次</strong>、以<strong>任意顺序</strong>拼接而成。</li>
<li><strong>关键约束</strong>：<code>words</code> 中的所有单词长度都<strong>相同</strong>。这是一个非常重要的突破口。</li>
</ul>
<p>例如，如果 <code>words = [&quot;foo&quot;, &quot;bar&quot;]</code>，那么 <code>s</code> 中的 <code>&quot;foobar&quot;</code> 和 <code>&quot;barfoo&quot;</code> 都是串联子串。子串 <code>&quot;barfoothefoobarman&quot;</code> 中，从索引 <code>0</code> 开始的 <code>&quot;barfoo&quot;</code> 和从索引 <code>9</code> 开始的 <code>&quot;foobar&quot;</code> 都是有效的串联子串。</p>
<h3 id="核心思路：从字符窗口到单词窗口"><a href="#核心思路：从字符窗口到单词窗口" class="headerlink" title="核心思路：从字符窗口到单词窗口"></a>核心思路：从字符窗口到单词窗口</h3><p>直接检查 <code>s</code> 中每一个可能的子串是否由 <code>words</code> 的排列构成，效率会很低。正确的思路依然是<strong>滑动窗口</strong>，但需要进行一些关键的调整。</p>
<h4 id="滑动单位的转变"><a href="#滑动单位的转变" class="headerlink" title="滑动单位的转变"></a>滑动单位的转变</h4><p>该题的基本单位不再是单个字符，而是一个个<strong>单词</strong>。</p>
<ul>
<li>目标 <code>words</code> 包含 <code>k</code> 个长度为 <code>len</code> 的单词。</li>
<li>那么，一个有效的“串联子串”的总长度是固定的：<code>total_len = k * len</code>。</li>
<li>我们的滑动窗口大小也应该是 <code>total_len</code>。</li>
<li>窗口每次滑动的步长，不再是 <code>1</code> 个字符，而应该是 <code>len</code> 个字符，即一个单词的长度。</li>
</ul>
<h4 id="分组滑动的巧妙构思"><a href="#分组滑动的巧妙构思" class="headerlink" title="分组滑动的巧妙构思"></a>分组滑动的巧妙构思</h4><p>一个最关键的问题是：滑动窗口的起点应该在哪里？</p>
<p>如果单词长度 <code>len = 3</code>，一个有效的串联子串可能从索引 <code>0, 3, 6, ...</code> 开始，也可能从 <code>1, 4, 7, ...</code> 或 <code>2, 5, 8, ...</code> 开始。这三种情况是<strong>完全独立、互不干扰</strong>的。</p>
<p>因此，我们可以把对 <code>s</code> 的一次遍历，拆分成 <code>len</code> 次独立的遍历。</p>
<ul>
<li>第一次遍历，我们只考虑从 <code>s[0]</code> 开始，以 <code>len</code> 为步长构建的单词序列。</li>
<li>第二次遍历，我们只考虑从 <code>s[1]</code> 开始，以 <code>len</code> 为步长构建的单词序列。</li>
<li>…</li>
<li>第 <code>len</code> 次遍历，我们只考虑从 <code>s[len-1]</code> 开始的序列。</li>
</ul>
<p>通过这种方式，我们用一个外层循环（遍历 <code>0</code> 到 <code>len-1</code> 这 <code>len</code> 种起始偏移）和内层滑动窗口相结合，就能覆盖所有可能的情况。</p>
<h3 id="滑动窗口算法详解"><a href="#滑动窗口算法详解" class="headerlink" title="滑动窗口算法详解"></a>滑动窗口算法详解</h3><ol>
<li><p><strong>准备工作</strong>:</p>
<ul>
<li>获取单词长度 <code>word_len</code>，单词数量 <code>num_words</code>，以及串联子串总长 <code>total_len</code>。</li>
<li>处理边界情况，例如 <code>s</code> 或 <code>words</code> 为空，或 <code>s</code> 的长度小于 <code>total_len</code>。</li>
<li>使用哈希表 <code>words_cnt</code> 统计 <code>words</code> 数组中每个单词的出现频率。</li>
</ul>
</li>
<li><p><strong>外层循环（分组）</strong>:</p>
<ul>
<li>启动一个 <code>for</code> 循环，<code>i</code> 从 <code>0</code> 遍历到 <code>word_len - 1</code>。这个 <code>i</code> 代表每组滑动的起始偏移量。</li>
</ul>
</li>
<li><p><strong>内层循环（滑动窗口）</strong>:</p>
<ul>
<li>在每组中，初始化一个左指针 <code>l = i</code> 和一个用于记录窗口内单词频率的哈希表 <code>window_cnt</code>。</li>
<li>用右指针 <code>r</code> 从 <code>i</code> 开始，以 <code>word_len</code> 为步长向右遍历 <code>s</code>。</li>
<li><strong>移入单词</strong>：在每次迭代中，从 <code>s</code> 中截取 <code>s[r : r + word_len]</code> 作为一个新单词。</li>
<li><strong>处理新单词</strong>:<ul>
<li>如果这个新单词<strong>不在</strong> <code>words_cnt</code> 中，说明它是一个无效单词。当前窗口内的所有单词都无法构成串联，因此直接清空 <code>window_cnt</code>，并将左指针 <code>l</code> 移动到这个无效单词的后面，即 <code>l = r + word_len</code>。</li>
<li>如果新单词是有效单词，则将其计入 <code>window_cnt</code>。</li>
<li><strong>处理冗余</strong>：检查 <code>window_cnt</code> 中该单词的数量是否超过了 <code>words_cnt</code> 中的需求。如果是，则需要从窗口左侧不断移出单词（<code>l</code> 右移 <code>word_len</code>），直到这个单词的数量恢复正常。</li>
</ul>
</li>
<li><strong>检查匹配</strong>:<ul>
<li>在窗口不包含冗余单词后，检查当前窗口内的单词总数 <code>(r - l) // word_len + 1</code> 是否等于 <code>num_words</code>。</li>
<li>如果相等，说明我们找到了一个完整的串联子串，其起始位置就是当前的左指针 <code>l</code>，将其加入结果列表。</li>
<li>找到后，为了继续搜索，我们将窗口最左侧的单词移出（<code>l</code> 右移 <code>word_len</code>），以便寻找下一个可能的匹配。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong>:</p>
<ul>
<li>所有分组遍历完成后，返回记录所有起始索引的结果列表。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 步骤 1：准备工作</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> words:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        num_words = <span class="built_in">len</span>(words)</span><br><span class="line">        word_len = <span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line">        total_len = num_words * word_len</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n &lt; total_len:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        words_cnt = Counter(words)</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2：外层循环，处理 len 种不同的分组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(word_len):</span><br><span class="line">            <span class="comment"># 初始化滑动窗口的左右指针和当前窗口的单词频率表</span></span><br><span class="line">            l = i</span><br><span class="line">            window_cnt = Counter()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 3：内层循环，以 word_len 为步长滑动窗口</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(i, n - word_len + <span class="number">1</span>, word_len):</span><br><span class="line">                <span class="comment"># 从右侧移入一个新单词</span></span><br><span class="line">                word = s[r : r + word_len]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">in</span> words_cnt:</span><br><span class="line">                    window_cnt[word] += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 如果窗口中此单词数量过多，从左侧收缩窗口</span></span><br><span class="line">                    <span class="keyword">while</span> window_cnt[word] &gt; words_cnt[word]:</span><br><span class="line">                        left_word = s[l : l + word_len]</span><br><span class="line">                        window_cnt[left_word] -= <span class="number">1</span></span><br><span class="line">                        l += word_len</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 步骤 3.检查匹配：窗口大小正好等于所需单词数</span></span><br><span class="line">                    <span class="keyword">if</span> (r - l) // word_len + <span class="number">1</span> == num_words:</span><br><span class="line">                        res.append(l)</span><br><span class="line">                        <span class="comment"># 匹配成功后，将窗口左侧单词移出，继续寻找下一个匹配</span></span><br><span class="line">                        left_word = s[l : l + word_len]</span><br><span class="line">                        window_cnt[left_word] -= <span class="number">1</span></span><br><span class="line">                        l += word_len</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果遇到无效单词，之前的所有努力都作废</span></span><br><span class="line">                    <span class="comment"># 重置窗口，并将左指针移到无效单词之后</span></span><br><span class="line">                    window_cnt.clear()</span><br><span class="line">                    l = r + word_len</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(L * W)。其中 L 是字符串 <code>s</code> 的长度，W 是单个单词的长度 <code>word_len</code>。外层循环执行 W 次，内层循环对 <code>s</code> 的遍历步长为 W，每次截取子串的成本是 W。所以总的时间复杂度近似为 W * (L&#x2F;W) * W &#x3D; O(L * W)。</li>
<li><strong>空间复杂度</strong>: O(K * W)，其中 K 是 <code>words</code> 中不同单词的个数，W 是单词的长度。这部分空间主要用于存储 <code>words_cnt</code> 和 <code>window_cnt</code> 这两个哈希表。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口技巧应用的绝佳进阶范例。它告诉我们，滑动窗口的“单位”和“步长”都可以是灵活的。通过<strong>将问题分解为 <code>word_len</code> 个独立的子问题</strong>，我们成功地将一个看似复杂的问题，用清晰的滑动窗口逻辑进行了求解。这种“分组处理”的思想在解决某些具有特定步长或周期的字符串问题时非常有效。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3007 | 价值和小于等于 K 的最大数字</title>
    <url>//posts/leetcode-3007/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3007 题：<a href="https://leetcode.cn/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k/description/">价值和小于等于 K 的最大数字</a>。<br>本题的核心在于识别出“累加价值”函数的单调性，从而将一个求解最大值的问题，转化为一个判定性问题，并利用二分查找高效求解。其中，判定函数的设计是本题的精髓，需要运用到位运算的规律。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要理解题目定义的两个核心概念：“价值”和“累加价值”。</p>
<ol>
<li><p><strong>整数的“价值”</strong>: 对于一个数字 <code>num</code>，它的价值是其二进制表示中，所有位置索引是 <code>x</code> 的倍数（如 <code>x</code>, <code>2x</code>, <code>3x</code>, …）的位上，值为 1 的数量总和。注意，位置是从 1 开始计数的最低有效位。</p>
</li>
<li><p><strong>数字的“累加价值”</strong>: 数字 <code>num</code> 的累加价值，是从 1 到 <code>num</code> 所有整数的“价值”的总和。</p>
</li>
</ol>
<p>我们的目标是找到一个最大的数字 <code>num</code>，使得它的“累加价值”小于或等于给定的 <code>k</code>。</p>
<p>举个例子，<code>k = 7, x = 2</code>。<br>我们要找最大的 <code>num</code>，使得 <code>value(1) + value(2) + ... + value(num) &lt;= 7</code>。<br>根据题目表格，<code>num=9</code> 时，累加价值是 6；<code>num=10</code> 时，累加价值是 8。所以，满足条件的最大数字是 9。</p>
<p>观察可以发现，“累加价值”会随着 <code>num</code> 的增大而增大（或保持不变）。这是一个<strong>单调递增</strong>的函数。这个特性是解决本题的关键信号。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解满足条件的“最大数字”很困难。但如果我们换一个角度思考：给定一个数字 <code>guess</code>，我们能否判断它的累加价值是否小于等于 <code>k</code>？</p>
<p>这个问题（我们称之为“判定问题”）如果能够被高效解决，我们就可以利用其单调性进行二分查找。</p>
<ul>
<li>如果 <code>guess</code> 的累加价值小于等于 <code>k</code>，说明 <code>guess</code> 是一个“廉价”的数字，那么真正的答案可能就是 <code>guess</code> 或者比它更大的数。</li>
<li>如果 <code>guess</code> 的累加价值大于 <code>k</code>，说明 <code>guess</code> 太大了，真正的答案一定比它小。</li>
</ul>
<p>这完美地契合了二分查找的框架。我们可以在一个很大的范围内（例如 <code>[1, 2*10^15]</code>）对答案进行二分搜索。</p>
<p>现在的核心挑战转移到了如何高效地实现这个判定函数：<code>count_accumulated_value(num)</code>。</p>
<h3 id="算法详解：如何计算累加价值？"><a href="#算法详解：如何计算累加价值？" class="headerlink" title="算法详解：如何计算累加价值？"></a>算法详解：如何计算累加价值？</h3><p><code>count_accumulated_value(num)</code> 是计算从 1 到 <code>num</code> 所有整数的总价值。<br><code>总价值 = Σ(value(i) for i in 1..num)</code></p>
<p>根据 <code>value</code> 的定义，我们可以进一步展开：<br><code>总价值 = Σ(Σ(bit_at(i, p*x)) for i in 1..num for p in 1,2,...)</code></p>
<p>这里 <code>bit_at(i, j)</code> 表示数字 <code>i</code> 的二进制表示中第 <code>j</code> 位是否为 1。我们可以交换求和的顺序，这使得问题变得清晰：<br><code>总价值 = Σ(Σ(bit_at(i, p*x)) for p in 1,2,... for i in 1..num)</code></p>
<p>这个公式的内层 <code>Σ(bit_at(i, p*x) for i in 1..num)</code> 实际上是在问：<strong>“对于一个固定的、需要计价的位置 <code>pos = p*x</code>，在从 1 到 <code>num</code> 的所有数字中，有多少个数字的二进制表示在第 <code>pos</code> 位上是 1？”</strong></p>
<p>我们可以设计一个函数 <code>countSetBitsAtPos(num, pos)</code> 来解决这个问题。<br>观察二进制数的规律可以发现，任何一个二进制位 <code>pos</code>（其代表的值为 <code>2^(pos-1)</code>）上的数字 <code>0</code> 和 <code>1</code> 都是周期性出现的。</p>
<ul>
<li>第 <code>pos</code> 位的 <code>0</code> 和 <code>1</code> 交替出现，一个完整的周期（从 <code>0...0</code> 到 <code>1...1</code>）长度为 <code>2^pos</code>。</li>
<li>在这个周期中，前一半（<code>2^(pos-1)</code> 个数）在该位上是 <code>0</code>，后一半（<code>2^(pos-1)</code> 个数）在该位上是 <code>1</code>。</li>
</ul>
<p>基于这个规律，我们可以计算出在 <code>1</code> 到 <code>num</code> 的范围内，有多少个数在第 <code>pos</code> 位是 1：</p>
<ol>
<li>令周期长度 <code>cycle_len = 2^pos</code>，半周期长度 <code>half_cycle = 2^(pos-1)</code>。</li>
<li>为了方便计算，我们考虑 <code>[0, num]</code> 这个区间，共 <code>num + 1</code> 个数。</li>
<li>完整周期的数量为 <code>num_cycles = (num + 1) // cycle_len</code>。</li>
<li>每个完整周期都贡献了 <code>half_cycle</code> 个 1，所以这部分的贡献是 <code>num_cycles * half_cycle</code>。</li>
<li>剩余部分的长度为 <code>remainder = (num + 1) % cycle_len</code>。</li>
<li>这部分剩余的数从一个新周期的开头算起，开头是 <code>half_cycle</code> 个 0，所以这部分贡献的 1 的数量是 <code>max(0, remainder - half_cycle)</code>。</li>
<li>将两部分贡献相加，就得到了 <code>countSetBitsAtPos(num, pos)</code> 的结果。</li>
</ol>
<p>有了这个函数，我们就可以实现 <code>count_accumulated_value(num)</code>：我们遍历所有需要计价的位置 <code>pos = x, 2x, 3x, ...</code>（上限到 64 位足够），对每个 <code>pos</code> 调用 <code>countSetBitsAtPos(num, pos)</code> 并将结果累加即可。</p>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaximumNumber</span>(<span class="params">self, k: <span class="built_in">int</span>, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">count_accumulated_value</span>(<span class="params">num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            高效计算从 1 到 num 的所有数字的累加价值。</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            total_value = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 遍历所有需要计价的二进制位：x, 2x, 3x, ...</span></span><br><span class="line">            <span class="comment"># 由于 k &lt;= 10^15，数字不会超过 60 位，这里取到 64 作为安全上界。</span></span><br><span class="line">            <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(x, <span class="number">64</span>, x):</span><br><span class="line">                <span class="comment"># 计算在 1 到 num 中，第 pos 位为 1 的数字有多少个。</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 第 pos 位的 0 和 1 的完整周期长度是 2^pos。</span></span><br><span class="line">                cycle_len = <span class="number">1</span> &lt;&lt; pos</span><br><span class="line">                <span class="comment"># 每个完整周期中，有一半的数字在该位上是 1。</span></span><br><span class="line">                half_cycle_len = cycle_len // <span class="number">2</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 为了计算方便，我们分析区间 [0, num]，共 num + 1 个数。</span></span><br><span class="line">                num_plus_one = num + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 计算完整周期的数量和它们贡献的 set bits。</span></span><br><span class="line">                num_cycles = num_plus_one // cycle_len</span><br><span class="line">                set_bits = num_cycles * half_cycle_len</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 计算剩余不足一个周期的部分贡献的 set bits。</span></span><br><span class="line">                remainder = num_plus_one % cycle_len</span><br><span class="line">                set_bits += <span class="built_in">max</span>(<span class="number">0</span>, remainder - half_cycle_len)</span><br><span class="line">                </span><br><span class="line">                total_value += set_bits</span><br><span class="line">            <span class="keyword">return</span> total_value</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对答案进行二分查找</span></span><br><span class="line">        left, right = <span class="number">1</span>, <span class="number">2</span> * <span class="number">10</span>**<span class="number">15</span>  <span class="comment"># 设置一个足够大的搜索上界</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span>:  <span class="comment"># 避免 mid 成为 0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 调用判定函数</span></span><br><span class="line">            <span class="keyword">if</span> count_accumulated_value(mid) &lt;= k:</span><br><span class="line">                <span class="comment"># mid 是一个可行的答案，我们尝试寻找更大的解</span></span><br><span class="line">                ans = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># mid 太大了，需要缩小搜索范围</span></span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(log(K) * (64&#x2F;x))。<ul>
<li>二分查找的搜索空间大小约为 <code>2*k</code>，因此迭代次数为 O(log K)。</li>
<li>在每次迭代中，<code>count_accumulated_value</code> 函数需要循环 <code>64/x</code> 次来计算所有相关位的贡献。</li>
<li>由于 <code>x</code> 是一个不大的常数（1 到 8），因此整体复杂度可以认为是 O(log K)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)。<ul>
<li>算法只使用了有限的几个变量，没有使用额外的与输入规模相关的存储空间。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“二分答案”思想与“位运算”技巧结合的典范。解决这类问题的关键路径通常是：</p>
<ol>
<li>分析问题的目标函数（本题中的“累加价值”），判断其是否具有单调性。</li>
<li>如果存在单调性，就可以将“求解最优值”问题转化为“判定一个值是否可行”的问题。</li>
<li>设计一个高效的判定函数。在本题中，这涉及到深入理解二进制数的周期性规律，并通过数学方法快速统计特定位上 1 的数量。</li>
<li>最后，在答案的可能范围内应用二分查找，通过判定函数不断缩小搜索区间，最终找到临界点，即为所求的最优解。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最大</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>位运算</tag>
        <tag>数学</tag>
        <tag>动态规划</tag>
        <tag>第380场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3048 | 标记所有下标的最早秒数 I</title>
    <url>//posts/leetcode-3048/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3048 题：<a href="https://leetcode.cn/problems/earliest-second-to-mark-indices-i/description/">标记所有下标的最早秒数 I</a>。<br>本题的关键在于识别出答案（秒数）具备单调性，从而可以将求解“最早秒数”这个最优化问题，转化为一个判定“给定秒数是否可行”的问题，并利用二分查找高效求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们有两个数组，<code>nums</code> 和 <code>changeIndices</code>，长度分别为 <code>n</code> 和 <code>m</code>。我们的目标是找到一个<strong>最早</strong>的秒数，在此时刻之前（含），能够将 <code>nums</code> 数组的所有 <code>n</code> 个下标都“标记”一遍。</p>
<p>每一秒，我们有三种选择：</p>
<ol>
<li>将任意一个 <code>nums[i]</code> 的值减 1。</li>
<li>如果 <code>nums[changeIndices[s]-1]</code> 的值恰好为 0，我们可以标记 <code>changeIndices[s]-1</code> 这个下标。</li>
<li>什么都不做。</li>
</ol>
<p>核心约束是：</p>
<ul>
<li>标记操作只能在特定秒数 <code>s</code> 对特定的下标 <code>changeIndices[s]-1</code> 进行。</li>
<li>标记一个下标 <code>i</code> 的前提是 <code>nums[i]</code> 必须已经被减为 0。</li>
</ul>
<p>我们需要在 <code>m</code> 秒的时间窗口内，找到满足条件的最小秒数。如果无法完成任务，则返回 -1。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最早秒数”比较复杂，因为它涉及到一系列操作的最优调度。但这类“求最小值&#x2F;最大值”的问题，通常可以尝试使用二分查找来解决。</p>
<p>我们可以对<strong>答案（秒数 <code>s</code>）<strong>进行二分查找。为此，我们需要验证答案的</strong>单调性</strong>：</p>
<ul>
<li>如果在 <code>s</code> 秒内可以标记所有下标，那么在 <code>s+1</code> 秒内，我们拥有更多的时间和操作机会，必然也可以完成任务。</li>
<li>反之，如果在 <code>s</code> 秒内无法完成任务，那么在更短的 <code>s-1</code> 秒内，也必然无法完成。</li>
</ul>
<p>这种单调性是应用二分查找的完美前提。我们可以将原问题从“找到<strong>最早</strong>的那个秒数”，转化为一个更简单的判定问题：“给定 <code>s</code> 秒，我们能<strong>不能</strong>标记所有下标？”</p>
<p>我们可以设计一个辅助函数 <code>check(s)</code> 来回答这个判定问题。如果能高效地实现 <code>check(s)</code>，就可以通过二分查找在 <code>[1, m]</code> 的范围内快速定位到最小的可行秒数。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><h4 id="1-确定二分查找的范围"><a href="#1-确定二分查找的范围" class="headerlink" title="1. 确定二分查找的范围"></a>1. 确定二分查找的范围</h4><ul>
<li><strong>下界 (left)</strong>：至少需要 1 秒，所以下界是 <code>1</code>。</li>
<li><strong>上界 (right)</strong>：最多有 <code>m</code> 秒可用，所以上界是 <code>m</code>。</li>
</ul>
<p>我们就在 <code>[1, m]</code> 这个区间内对秒数 <code>s</code> 进行二分查找。</p>
<h4 id="2-check-s-函数的设计（贪心策略）"><a href="#2-check-s-函数的设计（贪心策略）" class="headerlink" title="2. check(s) 函数的设计（贪心策略）"></a>2. <code>check(s)</code> 函数的设计（贪心策略）</h4><p><code>check(s)</code> 是整个算法的核心。给定 <code>s</code> 秒，我们如何判断是否能完成任务？这需要一个明智的策略来安排我们的操作。</p>
<p><strong>核心贪心思想</strong>：对于任何一个需要标记的下标 <code>i</code>，为了给“减 1”操作留出尽可能多的时间，我们应该选择在 <code>s</code> 秒内<strong>最后一次</strong>出现 <code>i</code> 的机会来标记它。这样做可以最大化在该标记操作之前可用的、能够自由支配的“减 1”秒数。</p>
<p>基于这个思想，<code>check(s)</code> 的步骤如下：</p>
<ol>
<li><p><strong>找到最后的标记时机</strong>：</p>
<ul>
<li>遍历 <code>changeIndices</code> 的前 <code>s</code> 个元素（即从第 1 秒到第 <code>s</code> 秒）。</li>
<li>使用一个哈希表或数组 <code>last_pos</code>，记录每个下标 <code>i</code> (1 到 n) 在这 <code>s</code> 秒内最后一次出现的时间点。</li>
<li>如果在遍历后，发现某个下标 <code>i</code> 从未在 <code>changeIndices</code> 的前 <code>s</code> 秒中出现过，那么它就不可能被标记，<code>check(s)</code> 直接返回 <code>False</code>。</li>
</ul>
</li>
<li><p><strong>模拟过程，检查资源是否足够</strong>：</p>
<ul>
<li>我们从第 1 秒开始，一直模拟到第 <code>s</code> 秒。维护一个计数器 <code>ops</code>，表示我们积累了多少可以自由使用的“减 1”操作次数。</li>
<li>在第 <code>t</code> 秒 (<code>1 &lt;= t &lt;= s</code>)：<ul>
<li>查看 <code>changeIndices</code> 在这一秒指向的下标 <code>idx</code>。</li>
<li>判断当前秒 <code>t</code> 是否是 <code>idx</code> 的预定标记时间（即 <code>t == last_pos[idx]</code>）。<ul>
<li><strong>如果是</strong>：我们必须在这一秒标记 <code>idx</code>。为此，我们需要确保 <code>nums[idx-1]</code> 已经归零。这需要 <code>nums[idx-1]</code> 次“减 1”操作。我们检查积累的 <code>ops</code> 是否足够（<code>ops &gt;= nums[idx-1]</code>）。<ul>
<li>如果不够，说明时间不够，<code>check(s)</code> 返回 <code>False</code>。</li>
<li>如果足够，我们就“消耗”掉这些操作次数：<code>ops -= nums[idx-1]</code>。</li>
</ul>
</li>
<li><strong>如果不是</strong>：这一秒不是 <code>idx</code> 的最后标记机会。根据我们的贪心策略，我们不会在此时标记它，而是将这一秒视为一个宝贵的、可用于“减 1”的空闲时间。因此，<code>ops</code> 加 1。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>如果整个模拟过程（从第 1 秒到第 <code>s</code> 秒）都能顺利进行，没有因为 <code>ops</code> 不足而提前退出，那么就说明 <code>s</code> 秒是可行的，<code>check(s)</code> 返回 <code>True</code>。</li>
</ul>
</li>
</ol>
<h4 id="3-执行二分查找"><a href="#3-执行二分查找" class="headerlink" title="3. 执行二分查找"></a>3. 执行二分查找</h4><ul>
<li>当 <code>left &lt;= right</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = left + (right - left) // 2</code> 作为当前的“猜测秒数”。</li>
<li>调用 <code>check(mid)</code> 来判定：<ul>
<li><strong>如果 <code>check(mid)</code> 返回 <code>True</code></strong>：说明 <code>mid</code> 秒是可行的。这可能是答案，但我们还想找一个更早的时间。因此，我们记录 <code>ans = mid</code>，并尝试在左半部分继续寻找：<code>right = mid - 1</code>。</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>False</code></strong>：说明 <code>mid</code> 秒不够，我们需要更多的时间。因此，去右半部分寻找：<code>left = mid + 1</code>。</li>
</ul>
</li>
<li>循环结束后，<code>ans</code> 中存储的就是满足条件的最早秒数。</li>
</ul>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">earliestSecondToMarkIndices</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], changeIndices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        m = <span class="built_in">len</span>(changeIndices)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># check(s) 函数用于判断在 s 秒内是否能完成所有标记任务</span></span><br><span class="line">        <span class="comment"># s 是秒数 (1-based), 对应 changeIndices 的前 s 个元素 (0-indexed: 0 to s-1)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">s: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># last[i] 记录下标 i (1-based) 在前 s 秒内最后一次出现的时间点 (0-indexed)</span></span><br><span class="line">            last = [-<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(s):</span><br><span class="line">                <span class="comment"># changeIndices 中的值是 1-based 的</span></span><br><span class="line">                last[changeIndices[t]] = t</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果在前 s 秒内，有的下标从未出现过，则不可能被标记</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> last[i] == -<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># ops 记录可用于“减 1”操作的空闲秒数</span></span><br><span class="line">            ops = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 遍历前 s 秒</span></span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(s):</span><br><span class="line">                idx = changeIndices[t]</span><br><span class="line">                <span class="comment"># 如果当前时间 t 是标记下标 idx 的最后时机</span></span><br><span class="line">                <span class="keyword">if</span> t == last[idx]:</span><br><span class="line">                    <span class="comment"># 获取将 nums[idx-1] 降为 0 所需的“减 1”操作次数</span></span><br><span class="line">                    cost = nums[idx - <span class="number">1</span>]</span><br><span class="line">                    <span class="comment"># 如果空闲操作数不够，则 s 秒内无法完成任务</span></span><br><span class="line">                    <span class="keyword">if</span> ops &lt; cost:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    <span class="comment"># 消耗掉 cost 次空闲操作</span></span><br><span class="line">                    ops -= cost</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果当前时间 t 不是最后标记时机，则可视为一次空闲操作</span></span><br><span class="line">                    ops += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果成功遍历完 s 秒，说明 s 秒是可行的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找答案</span></span><br><span class="line">        <span class="comment"># 搜索范围是 [1, m]，即最早可能的时间和最晚可能的时间</span></span><br><span class="line">        left, right = <span class="number">1</span>, m</span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 秒可行，说明它是一个潜在的答案</span></span><br><span class="line">                <span class="comment"># 我们尝试寻找更早的时间，所以向左收缩范围</span></span><br><span class="line">                ans = mid</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 秒不可行，说明时间太少，需要更多时间</span></span><br><span class="line">                <span class="comment"># 向右收缩范围</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O((N + M) * log(M))。<ul>
<li><code>N</code> 是 <code>nums</code> 的长度，<code>M</code> 是 <code>changeIndices</code> 的长度。</li>
<li>二分查找的搜索空间大小为 <code>M</code>，因此需要 <code>log(M)</code> 次迭代。</li>
<li>在每次迭代中，我们调用 <code>check(s)</code> 函数。该函数需要遍历 <code>changeIndices</code> 的前 <code>s</code> 个元素（最多 <code>M</code> 个）和 <code>n</code> 个下标，时间复杂度为 O(N + s)，即 O(N + M)。</li>
<li>因此，总时间复杂度是这两者的乘积。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(N)。<ul>
<li>在 <code>check</code> 函数中，我们使用了 <code>last</code> 数组来存储每个下标的最后出现位置，其大小为 <code>N+1</code>。因此空间复杂度为 O(N)。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“二分答案”思想的又一个经典应用。当问题的目标是求解一个符合条件的“最小值”或“最大值”，并且该问题的可行性具有单调性时，我们应该优先考虑能否将其转化为一个判定问题，并通过二分查找来加速求解。本题的难点在于设计 <code>check</code> 函数，通过采用“将困难的标记操作尽可能延后”的贪心策略，我们可以高效地判断出在给定的时间限制下任务是否可行。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最小</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>第386场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3116 | 单面值组合的第 K 小金额</title>
    <url>//posts/leetcode-3116/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3116 题：<a href="https://leetcode.cn/problems/kth-smallest-amount-with-single-denomination-combination/">单面值组合的第 K 小金额</a>。<br>一道结合了“二分答案”与“容斥原理”的经典数论题目。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给你一个整数 <code>k</code>。<br>你有无限量的每种面额的硬币。但是，你 <strong>不能</strong> 组合使用不同面额的硬币。<br>也就是说，如果你选择面额为 <code>c</code> 的硬币，你只能制造 <code>c, 2c, 3c, ...</code> 这些金额。<br>返回使用这些硬币能制造的 <strong>第 k 小</strong> 的金额。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：coins = [3,6,9], k = 3</span><br><span class="line">输出：9</span><br><span class="line">解释：</span><br><span class="line">3元硬币产生：3, 6, 9, 12...</span><br><span class="line">6元硬币产生：6, 12, 18...</span><br><span class="line">9元硬币产生：9, 18, 27...</span><br><span class="line">去重合并后：3, 6, 9, 12...</span><br><span class="line">第3小的是9。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; coins.length &lt;&#x3D; 15</li>
<li>1 &lt;&#x3D; coins[i] &lt;&#x3D; 25</li>
<li>1 &lt;&#x3D; k &lt;&#x3D; 2 * 10^9</li>
<li>coins 包含两两不同的整数。</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-预处理：去重与排序"><a href="#1-预处理：去重与排序" class="headerlink" title="1. 预处理：去重与排序"></a>1. 预处理：去重与排序</h4><p>首先观察示例 1：<code>coins = [3, 6, 9]</code>。</p>
<ul>
<li><code>6</code> 是 <code>3</code> 的倍数，所有能由 <code>6</code> 产生的金额（6, 12…）一定都能由 <code>3</code> 产生。</li>
<li>同理，<code>9</code> 也是 <code>3</code> 的倍数。</li>
<li>因此，集合 <code>[3, 6, 9]</code> 等价于 <code>[3]</code>。</li>
</ul>
<p>为了减少容斥原理计算时的集合数量（指数级复杂度），我们首先应该对 <code>coins</code> 进行排序，并移除那些“本身是其他较小面额倍数”的硬币。</p>
<h4 id="2-二分答案"><a href="#2-二分答案" class="headerlink" title="2. 二分答案"></a>2. 二分答案</h4><p>类似于求“第 K 小”的题目，通常具有单调性：</p>
<ul>
<li>如果金额 <code>m</code> 能够覆盖至少 <code>k</code> 个生成数，那么比 <code>m</code> 大的金额也能覆盖至少 <code>k</code> 个。</li>
<li>我们需要找到满足 <code>count(m) &gt;= k</code> 的最小 <code>m</code>。</li>
</ul>
<p><strong>搜索范围：</strong></p>
<ul>
<li>下界：<code>k</code>（假设最小面额是1）。</li>
<li>上界：<code>min(coins) * k</code>（最坏情况只使用最小面额）。</li>
</ul>
<h4 id="3-容斥原理"><a href="#3-容斥原理" class="headerlink" title="3. 容斥原理"></a>3. 容斥原理</h4><p>核心难点在于 <code>check(m)</code> 函数：计算小于等于 <code>m</code> 的金额中有多少个是给定硬币的倍数。<br>假设去重后的硬币集合为 <code>A</code>，我们需要计算 $|A_0 \cup A_1 \cup \dots \cup A_{n-1}|$。</p>
<p>根据容斥原理：<br><code>Count = Σ(奇数个集合的交集大小) - Σ(偶数个集合的交集大小)</code></p>
<ul>
<li>集合 <code>coin_i</code> 在范围 <code>m</code> 内的元素个数为 <code>m // coin_i</code>。</li>
<li>多个集合的交集，即这些硬币的 <strong>最小公倍数 (LCM)</strong> 的倍数个数：<code>m // lcm(c1, c2, ...)</code>。</li>
</ul>
<p>由于 <code>coins</code> 长度最多为 15，我们可以预处理所有子集的 LCM。<br>使用位掩码（Bitmask）<code>1</code> 到 <code>(1 &lt;&lt; n) - 1</code> 来表示所有子集。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthSmallest</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        coins.sort()</span><br><span class="line">        a = []</span><br><span class="line">        <span class="comment"># 预处理：去除倍数关系的冗余硬币</span></span><br><span class="line">        <span class="comment"># 例如 [2, 4] -&gt; [2]，因为 4 的倍数一定是 2 的倍数</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">all</span>(x % y <span class="keyword">for</span> y <span class="keyword">in</span> a):</span><br><span class="line">                a.append(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 预处理所有子集的 LCM</span></span><br><span class="line">        <span class="comment"># subset_lcm[mask] 存储掩码为 mask 的子集的最小公倍数</span></span><br><span class="line">        n = <span class="built_in">len</span>(a)</span><br><span class="line">        subset_lcm = [<span class="number">1</span>] * (<span class="number">1</span> &lt;&lt; n)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 动态规划计算子集 LCM</span></span><br><span class="line">        <span class="comment"># 外层遍历每一个硬币，内层遍历已有的掩码</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):</span><br><span class="line">            bit = <span class="number">1</span> &lt;&lt; i</span><br><span class="line">            <span class="keyword">for</span> mask <span class="keyword">in</span> <span class="built_in">range</span>(bit):</span><br><span class="line">                <span class="comment"># 新的 LCM = lcm(旧子集 LCM, 新加入的硬币)</span></span><br><span class="line">                subset_lcm[bit | mask] = math.lcm(subset_lcm[mask], x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找的 check 函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 遍历所有非空子集</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(subset_lcm)):  </span><br><span class="line">                <span class="comment"># 容斥原理：</span></span><br><span class="line">                <span class="comment"># 奇数个元素的集合（bit_count 为奇数）：加</span></span><br><span class="line">                <span class="comment"># 偶数个元素的集合（bit_count 为偶数）：减</span></span><br><span class="line">                <span class="keyword">if</span> i.bit_count() % <span class="number">2</span>:</span><br><span class="line">                    cnt += m // subset_lcm[i]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cnt -= m // subset_lcm[i]</span><br><span class="line">            <span class="keyword">return</span> cnt &gt;= k</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 二分查找左边界</span></span><br><span class="line">        <span class="comment"># 搜索范围从 0 到 a[0] * k</span></span><br><span class="line">        <span class="comment"># key=check 会寻找第一个使 check(m) 为 True 的位置</span></span><br><span class="line">        <span class="keyword">return</span> bisect_left(<span class="built_in">range</span>(a[<span class="number">0</span>] * k), <span class="literal">True</span>, k, key=check)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;math/bits&quot;</span></span><br><span class="line">	<span class="string">&quot;slices&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthSmallest</span><span class="params">(coins []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">	slices.Sort(coins)</span><br><span class="line">	<span class="comment">// 预处理：去除冗余硬币</span></span><br><span class="line">	<span class="comment">// 使用切片过滤技巧，a 存储过滤后的硬币</span></span><br><span class="line">	a := coins[:<span class="number">0</span>]</span><br><span class="line">next:</span><br><span class="line">	<span class="keyword">for</span> _, x := <span class="keyword">range</span> coins &#123;</span><br><span class="line">		<span class="keyword">for</span> _, y := <span class="keyword">range</span> a &#123;</span><br><span class="line">			<span class="keyword">if</span> x%y == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span> next</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		a = <span class="built_in">append</span>(a, x)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 预处理所有子集的 LCM</span></span><br><span class="line">	subsetLcm := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1</span>&lt;&lt;<span class="built_in">len</span>(a))</span><br><span class="line">	subsetLcm[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">		bit := <span class="number">1</span> &lt;&lt; i</span><br><span class="line">		<span class="comment">// 遍历当前已生成的子集掩码</span></span><br><span class="line">		<span class="keyword">for</span> mask, l := <span class="keyword">range</span> subsetLcm[:bit] &#123;</span><br><span class="line">			subsetLcm[bit|mask] = lcm(l, x)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 优化：预处理符号</span></span><br><span class="line">	<span class="comment">// 根据容斥原理，偶数个元素的子集需要减去，奇数个需要加上</span></span><br><span class="line">	<span class="comment">// 这里直接将偶数个元素的 LCM 设为负数，方便后续只做加法</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> subsetLcm &#123;</span><br><span class="line">		<span class="keyword">if</span> bits.OnesCount(<span class="type">uint</span>(i))%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">			subsetLcm[i] *= <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 二分查找</span></span><br><span class="line">	<span class="comment">// sort.Search 查找 [0, n) 范围内第一个使函数返回 true 的值</span></span><br><span class="line">	ans := sort.Search(a[<span class="number">0</span>]*k, <span class="function"><span class="keyword">func</span><span class="params">(m <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		cnt := <span class="number">0</span></span><br><span class="line">		<span class="comment">// 遍历除空集外的所有子集 LCM</span></span><br><span class="line">		<span class="keyword">for</span> _, l := <span class="keyword">range</span> subsetLcm[<span class="number">1</span>:] &#123;</span><br><span class="line">			<span class="comment">// 如果 l 是正数（奇数个元素），加</span></span><br><span class="line">			<span class="comment">// 如果 l 是负数（偶数个元素），相当于减去绝对值</span></span><br><span class="line">			cnt += m / l</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cnt &gt;= k</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int64</span>(ans)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> a != <span class="number">0</span> &#123;</span><br><span class="line">		a, b = b%a, a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lcm</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a == <span class="number">0</span> || b == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a / gcd(a, b) * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设 <code>coins</code> 去重后的长度为 <code>M</code> (M &lt;&#x3D; 15)。</p>
<ul>
<li><p><strong>时间复杂度</strong>: </p>
<ul>
<li><strong>预处理 LCM</strong>: <code>O(2^M)</code>。我们需要遍历所有可能的子集来计算 LCM。</li>
<li><strong>二分查找</strong>: 搜索范围上限约为 <code>min(coins) * k</code>，二分次数为 <code>O(log(min(coins) * k))</code>。</li>
<li><strong>Check 函数</strong>: 每次 check 需要遍历 <code>2^M</code> 个子集。</li>
<li>总时间复杂度：<code>O(2^M · log(C·K))</code>。对于 <code>M=15</code>，<code>2^15 ≈ 3.2万</code>，二分约 60 次，总计算量在 200万次左右，完全可以通过。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(2^M)</code><br>需要一个数组来存储所有子集的 LCM 值。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>第K小/大</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>位运算</tag>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>数论</tag>
        <tag>第393场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3134 | 找出唯一性数组的中位数</title>
    <url>//posts/leetcode-3134/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3134 题：<a href="https://leetcode.cn/problems/find-the-median-of-the-uniqueness-array/">找出唯一性数组的中位数</a>。<br>我们需要在 O(N²) 的子数组空间中，高效地找到第 K 小的唯一性计数。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个整数数组 <code>nums</code>。<br>数组的 <strong>唯一性数组</strong> 是一个数组，包含 <code>nums</code> 的所有非空子数组中不同元素的个数。<br>换句话说，对于 <code>nums</code> 的每一个子数组，计算其不同元素的个数，将这些值收集起来形成一个新的数组。</p>
<p>需要返回这个 <strong>唯一性数组</strong> 的 <strong>中位数</strong>。</p>
<p>注意：</p>
<ul>
<li>子数组是数组中连续的一段。</li>
<li>如果数组长度为偶数，中位数是排序后中间两个数的较小者（即第 <code>(total + 1) / 2</code> 个数，向上取整的逻辑）。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [1, 2, 3]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">子数组及其不同元素个数：</span><br><span class="line">[1]: 1</span><br><span class="line">[2]: 1</span><br><span class="line">[3]: 1</span><br><span class="line">[1, 2]: 2</span><br><span class="line">[2, 3]: 2</span><br><span class="line">[1, 2, 3]: 3</span><br><span class="line">唯一性数组为 [1, 1, 1, 2, 2, 3]。</span><br><span class="line">排序后为 [1, 1, 1, 2, 2, 3]，中位数是 1。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-问题转化：二分答案"><a href="#1-问题转化：二分答案" class="headerlink" title="1. 问题转化：二分答案"></a>1. 问题转化：二分答案</h4><p>直接暴力生成所有子数组的唯一性值需要 O(N²) 的时间，这在 <code>N = 10^5</code> 的数据规模下是不可接受的。<br>我们需要找到一个数 <code>x</code>，使得唯一性数组中 <strong>小于等于</strong> <code>x</code> 的元素个数至少占总数的一半。</p>
<p>这就具备了单调性：</p>
<ul>
<li>如果我们允许子数组包含更多种类的元素（即 <code>x</code> 变大），那么满足条件的子数组数量一定会增加或持平。</li>
</ul>
<p>因此，我们可以对答案（即子数组中不同元素的个数）进行 <strong>二分查找</strong>。<br>答案的范围是 <code>[1, N]</code>（或者更精确地说是 <code>[1, len(set(nums))]</code>）。</p>
<h4 id="2-中位数的定义"><a href="#2-中位数的定义" class="headerlink" title="2. 中位数的定义"></a>2. 中位数的定义</h4><p>对于长度为 <code>n</code> 的数组，非空子数组的总数 <code>Total</code> 为 <code>n * (n + 1) / 2</code>。<br>题目要求的中位数，本质上是求第 <code>k</code> 小的数，其中 <code>k = (Total + 1) / 2</code>（整数除法）。</p>
<p>我们需要找到最小的 <code>limit</code>，使得：<br><strong>不同元素个数 ≤ limit 的子数组数量 ≥ k</strong></p>
<h4 id="3-计数检查：滑动窗口（双指针）"><a href="#3-计数检查：滑动窗口（双指针）" class="headerlink" title="3. 计数检查：滑动窗口（双指针）"></a>3. 计数检查：滑动窗口（双指针）</h4><p>核心问题变成了：如何快速计算“不同元素个数 ≤ limit”的子数组有多少个？<br>我们可以使用 <strong>滑动窗口</strong> 在 O(N) 时间内完成统计：</p>
<ol>
<li>维护一个窗口 <code>[l, r]</code> 和一个哈希表 <code>freq</code> 记录窗口内元素的出现次数。</li>
<li>遍历右端点 <code>r</code>，将 <code>nums[r]</code> 加入窗口。</li>
<li>如果窗口内不同元素的个数（即 <code>len(freq)</code>）超过了 <code>limit</code>，则移动左端点 <code>l</code>，直到窗口恢复合法。</li>
<li>对于当前固定的右端点 <code>r</code>，所有以 <code>r</code> 结尾且起始位置在 <code>[l, r]</code> 之间的子数组都是合法的。这样的子数组个数为 <code>r - l + 1</code>。</li>
<li>累加这些个数。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">medianOfUniquenessArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 计算子数组总数 n*(n+1)/2，并确定中位数的位置 k</span></span><br><span class="line">        <span class="comment"># 这里使用的是向上取整的逻辑，即第 (Total + 1) // 2 小的数</span></span><br><span class="line">        k = (n * (n + <span class="number">1</span>) // <span class="number">2</span> + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 核心校验函数：检查是否存在至少 k 个子数组，</span></span><br><span class="line">        <span class="comment"># 其不同元素个数小于等于 upper</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">upper: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            cnt = l = <span class="number">0</span></span><br><span class="line">            freq = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">            <span class="keyword">for</span> r, in_ <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">                freq[in_] += <span class="number">1</span>  <span class="comment"># 移入右端点，更新计数</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 当窗口内不同元素的个数超过上限时，收缩左边界</span></span><br><span class="line">                <span class="keyword">while</span> <span class="built_in">len</span>(freq) &gt; upper:  <span class="comment"># 窗口内元素过多</span></span><br><span class="line">                    out = nums[l]</span><br><span class="line">                    freq[out] -= <span class="number">1</span>  <span class="comment"># 移出左端点</span></span><br><span class="line">                    <span class="keyword">if</span> freq[out] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">del</span> freq[out] <span class="comment"># 如果次数归零，从 map 中移除，len(freq) 会减少</span></span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 对于当前的右端点 r，合法的左端点范围是 [l, r]</span></span><br><span class="line">                <span class="comment"># 因此以 r 结尾且满足条件的子数组个数为 r - l + 1</span></span><br><span class="line">                cnt += r - l + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 剪枝：如果计数已经达到 k，提前返回 True</span></span><br><span class="line">                <span class="keyword">if</span> cnt &gt;= k:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在 [1, len(set(nums))] 范围内二分查找</span></span><br><span class="line">        <span class="comment"># bisect_left 会寻找第一个使得 check(val) 为 True 的值</span></span><br><span class="line">        <span class="comment"># range 的范围需要覆盖可能的解空间</span></span><br><span class="line">        <span class="keyword">return</span> bisect_left(<span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">set</span>(nums))), <span class="literal">True</span>, <span class="number">1</span>, key=check)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">medianOfUniquenessArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">// 计算中位数是第 k 小的数</span></span><br><span class="line">    <span class="comment">// 总子数组数为 n*(n+1)/2</span></span><br><span class="line">	k := (n*(n+<span class="number">1</span>)/<span class="number">2</span> + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 sort.Search 进行二分查找</span></span><br><span class="line">    <span class="comment">// Search(n) 会在 [0, n) 范围内查找，我们查找的实际范围与数组长度相关</span></span><br><span class="line">    <span class="comment">// 但答案上限是不同元素的个数，这里用 n-1 作为搜索空间的基数</span></span><br><span class="line">	ans := <span class="number">1</span> + sort.Search(n<span class="number">-1</span>, <span class="function"><span class="keyword">func</span><span class="params">(upper <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		upper++ <span class="comment">// sort.Search 的参数是从 0 开始的，实际含义需要 +1</span></span><br><span class="line">		cnt := <span class="number">0</span></span><br><span class="line">		l := <span class="number">0</span></span><br><span class="line">		freq := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125; <span class="comment">// 哈希表记录窗口内元素频率</span></span><br><span class="line">		<span class="keyword">for</span> r, in := <span class="keyword">range</span> nums &#123;</span><br><span class="line">			freq[in]++ <span class="comment">// 移入右端点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果窗口内不同元素数量超过 upper，则收缩左端点</span></span><br><span class="line">			<span class="keyword">for</span> <span class="built_in">len</span>(freq) &gt; upper &#123; <span class="comment">// 窗口内元素过多</span></span><br><span class="line">				out := nums[l]</span><br><span class="line">				freq[out]-- <span class="comment">// 移出左端点</span></span><br><span class="line">				<span class="keyword">if</span> freq[out] == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="built_in">delete</span>(freq, out) <span class="comment">// 彻底移除元素，确保 len(freq) 正确</span></span><br><span class="line">				&#125;</span><br><span class="line">				l++</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 累加当前右端点 r 对应的合法子数组数量</span></span><br><span class="line">			cnt += r - l + <span class="number">1</span> <span class="comment">// 右端点固定为 r 时，有 r-l+1 个合法左端点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果计数满足要求，返回 true，二分查找会尝试更小的值</span></span><br><span class="line">			<span class="keyword">if</span> cnt &gt;= k &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: O(N * log(M))</p>
<ul>
<li>其中 N 是数组 <code>nums</code> 的长度，M 是数组中不同元素的个数（最坏情况下 M &#x3D; N）。</li>
<li>二分查找进行 O(log M) 次迭代。</li>
<li>每次 <code>check</code> 函数中使用滑动窗口遍历整个数组，时间复杂度为 O(N)。</li>
<li>总复杂度为 O(N log M)。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>: O(M)</p>
<ul>
<li>主要消耗在于滑动窗口中的哈希表 <code>freq</code>，其大小最多存储 M 个不同的元素。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>第K小/大</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>第395场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3143 | 正方形中的最多点数</title>
    <url>//posts/leetcode-3143/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3143 题：<a href="https://leetcode.cn/problems/maximum-points-inside-the-square/description/">正方形中的最多点数</a>。<br>本题的核心在于识别出答案关于正方形大小的单调性，并将一个求解最大值的问题，巧妙地转化为一个判定性的问题，从而利用二分查找在对数时间内高效求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要在一个二维平面上找到一个“合法”的正方形，使其能包含尽可能多的点。</p>
<p>这里的核心约束条件是：</p>
<ol>
<li>正方形必须以原点 <code>(0, 0)</code> 为中心，且所有边都平行于坐标轴。</li>
<li>一个正方形是“合法的”，当且仅当其内部（包括边界）不包含任何具有相同标签的两个点。</li>
<li>一个点 <code>(x, y)</code> 如果在边长为 <code>2 * size</code> 的正方形内，则必须满足 <code>abs(x) &lt;= size</code> 且 <code>abs(y) &lt;= size</code>。</li>
</ol>
<p>我们的目标是找出所有合法正方形中，能够包含的点的数量的最大值。</p>
<p>举个例子，<code>points = [[2,2],[-1,-2],[-4,4],[-3,1],[3,-3]]</code>, <code>s = &quot;abdca&quot;</code>。<br>如果一个正方形的半边长 <code>size</code> 为 3，它会包含 <code>[2,2]</code> (a), <code>[-1,-2]</code> (b), <code>[-3,1]</code> (d), <code>[3,-3]</code> (c)。这些点的标签 <code>a, b, d, c</code> 互不相同，所以这是一个合法的正方形，包含 4 个点。<br>如果 <code>size</code> 增大到 4，<code>[-4,4]</code> (a) 点也被包含进来。现在正方形内有了 <code>[2,2]</code> (a) 和 <code>[-4,4]</code> (a)，出现了重复标签 <code>a</code>，因此这个正方形是“不合法”的。</p>
<p>这暗示了正方形的合法性与其大小之间存在一种单调关系：如果一个大小为 <code>size</code> 的正方形不合法，那么任何比它更大的正方形也必然不合法。</p>
<p>我们的任务就是在所有合法的正方形尺寸中，找到那个能容纳最多点数的尺寸，并返回其容纳的点数。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最多点数”似乎无从下手，因为点数并不直接与正方形大小线性相关。但是，我们可以换一个角度：对正方形的半边长 <code>size</code> 进行分析。</p>
<p>我们可以将问题转化为一个更容易判断的“判定问题”：<strong>给定一个半边长 <code>size</code>，判断由它构成的正方形是否合法？</strong></p>
<p>这个判定问题很容易解决。我们可以写一个辅助函数 <code>check(size)</code>，来模拟判断过程：</p>
<ul>
<li>初始化一个空的哈希集合 <code>visited_tags</code>，用来存放当前正方形内所有点的标签。</li>
<li>遍历所有点 <code>(x, y)</code> 和其对应的标签 <code>c</code>：<ul>
<li>如果这个点在正方形内部，即 <code>abs(x) &lt;= size</code> 且 <code>abs(y) &lt;= size</code>：<ul>
<li>检查它的标签 <code>c</code> 是否已经在 <code>visited_tags</code> 中。</li>
<li>如果已存在，说明出现了重复标签，该 <code>size</code> 构成的正方形<strong>不合法</strong>，函数返回 <code>True</code>（表示“有问题”）。</li>
<li>如果不存在，将标签 <code>c</code> 加入 <code>visited_tags</code>。</li>
</ul>
</li>
</ul>
</li>
<li>如果遍历完所有点都没有发现重复标签，说明该 <code>size</code> 构成的正方形是<strong>合法的</strong>，函数返回 <code>False</code>（表示“没问题”）。</li>
</ul>
<p>现在，我们有了一个判定方法。并且可以清晰地看到，这个判定结果具有<strong>单调性</strong>：</p>
<ul>
<li>如果一个大小为 <code>size</code> 的正方形不合法（<code>check(size)</code> 返回 <code>True</code>），那么任何更大的 <code>size&#39; &gt; size</code> 也必然不合法，因为它会包含所有导致 <code>size</code> 不合法的点。</li>
<li>反之，如果 <code>size</code> 合法（<code>check(size)</code> 返回 <code>False</code>），那么比它更小的尺寸也可能合法。</li>
</ul>
<p>这种单调性是应用二分查找的完美信号。我们可以对“正方形的半边长 <code>size</code>”进行二分查找，来快速定位到那个“从合法变为不合法”的临界点。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：<code>0</code>，一个大小为 0 的正方形。</li>
<li><strong>上界 (right)</strong>：<code>10^9 + 1</code>，比题目中坐标的最大绝对值还要大，确保能包含所有点。</li>
</ul>
<p>我们二分的目标是找到<strong>第一个不合法的 <code>size</code></strong>。那么，比这个临界值小 1 的 <code>size - 1</code>，就是最大的那个合法尺寸。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = 0</code></li>
<li><code>right = 10^9 + 1</code></li>
<li>我们的目标是找到满足 <code>check(size)</code> 为 <code>True</code> 的最小值。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>left &lt; right</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = left + (right - left) // 2</code> 作为当前的“猜测半边长”。</li>
<li>调用辅助函数 <code>check(mid)</code> 来判定这个猜测值是否可行。<ul>
<li><strong>如果 <code>check(mid)</code> 返回 <code>True</code></strong> (即 <code>mid</code> 尺寸的正方形<strong>不合法</strong>)：<ul>
<li>说明 <code>mid</code> 本身或更小的值才是我们寻找的临界点。我们将搜索范围缩小到左半边（包含 <code>mid</code>）：<code>right = mid</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>False</code></strong> (即 <code>mid</code> 尺寸的正方形<strong>合法</strong>)：<ul>
<li>说明这个尺寸是安全的，临界点一定在它右边。我们将搜索范围缩小到右半边：<code>left = mid + 1</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>left</code> (或 <code>right</code>) 指向的就是第一个不合法的尺寸。</li>
<li>因此，最大的合法尺寸就是 <code>left - 1</code>。</li>
<li>最后，我们只需计算在 <code>size = left - 1</code> 的正方形内有多少个点即可。</li>
<li>（在题目给出的精妙实现中，点数的计算被巧妙地整合进了 <code>check</code> 函数，避免了最后一次的重复计数）。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><p>下面是题解中给出的代码，它利用了二分查找，并将最终结果的计算嵌入到了检查函数中，非常高效。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPointsInsideSquare</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># ans 用于存储在最后一次“合法”检查中，正方形内的点数</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判定函数：检查半边长为 size 的正方形是否“不合法”（即有重复标签）</span></span><br><span class="line">        <span class="comment"># 返回 True 表示不合法，False 表示合法</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">size: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            vis = <span class="built_in">set</span>()</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> (x, y), c <span class="keyword">in</span> <span class="built_in">zip</span>(points, s):</span><br><span class="line">                <span class="comment"># 检查点是否在正方形内</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(x) &lt;= size <span class="keyword">and</span> <span class="built_in">abs</span>(y) &lt;= size:</span><br><span class="line">                    <span class="keyword">if</span> c <span class="keyword">in</span> vis:</span><br><span class="line">                        <span class="comment"># 发现重复标签，此 size 不合法</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    vis.add(c)</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果循环正常结束，说明此 size 合法</span></span><br><span class="line">            <span class="comment"># 用 nonlocal/self.ans 更新当前合法尺寸下的点数</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            ans = count</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在 [0, 10^9+1] 的范围内二分查找第一个使 check 返回 True (不合法) 的 size</span></span><br><span class="line">        <span class="comment"># bisect_left 的 key 函数返回一个布尔值序列，如 [F, F, F, T, T, T]</span></span><br><span class="line">        <span class="comment"># 它会找到第一个 T 的索引</span></span><br><span class="line">        invalid_size = bisect_left(<span class="built_in">range</span>(<span class="number">10</span>**<span class="number">9</span> + <span class="number">1</span>), <span class="literal">True</span>, key=check)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当 check(invalid_size - 1) 被调用时，它是最后一次返回 False 的调用，</span></span><br><span class="line">        <span class="comment"># 那时 ans 会被正确更新为最大合法正方形内的点数。</span></span><br><span class="line">        <span class="comment"># 如果最小的 size 都不合法（例如第一个点就有重复标签），</span></span><br><span class="line">        <span class="comment"># 那么 check(0) 就会返回 True，bisect_left 结果是 0，ans 初始值 0 也是正确的。</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N * log(C))。<ul>
<li><code>N</code> 是点的数量。</li>
<li><code>C</code> 是坐标的取值范围，即 <code>10^9</code>。</li>
<li>二分查找本身需要 <code>log(C)</code> 次迭代。</li>
<li>在每次迭代中，我们都需要调用 <code>check</code> 函数，该函数需要遍历一次 <code>points</code> 数组，时间复杂度为 O(N)。</li>
<li>因此，总时间复杂度是这两者的乘积。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(A)。<ul>
<li><code>A</code> 是字符集的大小，这里是 26。</li>
<li><code>check</code> 函数中 <code>vis</code> 集合最多存储 26 个小写字母，因此空间复杂度是常数级的。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是二分查找思想应用的经典范例。它教会我们当遇到求解最优化问题（最大&#x2F;最小值）时，可以检查答案是否具有单调性。如果满足，就可以尝试将其转化为一个更简单的“判定性”问题。通过对答案的可能范围进行二分，我们可以将搜索空间不断折半，从而在对数级别的时间复杂度内找到最优解，这比线性扫描所有可能的答案要高效得多。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>二分间接值</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>排序</tag>
        <tag>第130场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3281 | 范围内整数的最大得分</title>
    <url>//posts/leetcode-3281/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3281 题：<a href="https://leetcode.cn/problems/maximize-score-of-numbers-in-ranges/description/">范围内整数的最大得分</a>。<br>当直接求解“最大可能得分”比较困难时，可以考虑二分答案。我们将问题转化为：是否存在一种选择方案，使得最小绝对差不小于某个值 k？</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个整数数组 <code>start</code> 和一个整数 <code>d</code>，代表 n 个区间 <code>[start[i], start[i] + d]</code>。</p>
<p>你需要选择 n 个整数，其中第 <code>i</code> 个整数必须属于第 <code>i</code> 个区间。所选整数的 <strong>得分</strong> 定义为所选整数两两之间的 <strong>最小</strong> 绝对差。</p>
<p>返回所选整数的 <strong>最大可能得分</strong>。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： start = [6,0,3], d = 2</span><br><span class="line">输出： 4</span><br><span class="line">解释：</span><br><span class="line">可以选择整数 8, 0 和 4 获得最大可能得分。它们分别属于区间 [6,8], [0,2], [3,5]。</span><br><span class="line">排序后为 0, 4, 8，得分为 min(|4-0|, |8-4|) = 4。</span><br></pre></td></tr></table></figure>

<h3 id="二、思路分析"><a href="#二、思路分析" class="headerlink" title="二、思路分析"></a>二、思路分析</h3><h4 id="1-核心思想：最大化最小值-二分答案"><a href="#1-核心思想：最大化最小值-二分答案" class="headerlink" title="1. 核心思想：最大化最小值 -&gt; 二分答案"></a>1. 核心思想：最大化最小值 -&gt; 二分答案</h4><p>题目的目标是“最大化（最小绝对差）”，这种“最大化最小值”或者“最小化最大值”的问题是二分答案的经典应用场景。</p>
<p>直接计算最大得分很复杂，因为每个区间都有多种选择。我们可以换一个角度思考：给定一个得分 <code>k</code>，我们能否找到一种选择方案，使得任意两个所选整数的绝对差都 <code>≥ k</code>？</p>
<p>这个问题就变成了一个判定性问题，并且具有单调性：</p>
<ul>
<li>如果得分 <code>k</code> 是可以达成的，那么任何小于 <code>k</code> 的得分 <code>k&#39;</code> 也一定可以达成。</li>
<li>如果得分 <code>k</code> 无法达成，那么任何大于 <code>k</code> 的得分 <code>k&#39;&#39;</code> 也一定无法达成。</li>
</ul>
<p>这种单调性让我们能够通过二分查找来逼近最终的答案。我们可以在一个可能的得分范围内进行二分，找到满足条件的最大的那个得分 <code>k</code>。</p>
<h4 id="2-验证函数-check-score-的设计"><a href="#2-验证函数-check-score-的设计" class="headerlink" title="2. 验证函数 check(score) 的设计"></a>2. 验证函数 <code>check(score)</code> 的设计</h4><p>二分答案的关键在于如何实现这个 <code>check(score)</code> 函数，即如何判断一个给定的 <code>score</code> 是否可行。</p>
<p>为了方便处理，我们可以首先将所有区间按照左端点 <code>start[i]</code> 进行升序排序。排序后，我们选出的 n 个数也应该是升序的，这样我们只需要保证相邻两个数之差不小于 <code>score</code> 即可。</p>
<p>假设我们已经为前 <code>i-1</code> 个区间选择了整数，最后一个选择的数是 <code>prev_x</code>。现在要为第 <code>i</code> 个区间 <code>[s_i, s_i + d]</code> 选择一个数 <code>curr_x</code>。这个 <code>curr_x</code> 必须满足两个条件：</p>
<ol>
<li><code>curr_x &gt;= prev_x + score</code> (保证与前一个数的差值)</li>
<li><code>s_i &lt;= curr_x &lt;= s_i + d</code> (保证在当前区间内)</li>
</ol>
<p>为了让后续的选择有尽可能大的空间，我们应该贪心地选择满足条件的最小的 <code>curr_x</code>。<br>因此，我们选择的 <code>curr_x</code> 应该是 <code>max(prev_x + score, s_i)</code>。</p>
<p>选择了这个 <code>curr_x</code> 后，我们还需要验证它是否在当前区间 <code>[s_i, s_i + d]</code> 内。也就是判断 <code>curr_x</code> 是否大于 <code>s_i + d</code>。</p>
<ul>
<li>如果 <code>curr_x &gt; s_i + d</code>，说明在满足 <code>score</code> 的前提下，无法在当前区间内找到一个合法的数。因此 <code>score</code> 值太大了，<code>check(score)</code> 返回 <code>False</code>。</li>
<li>如果 <code>curr_x &lt;= s_i + d</code>，说明这个选择是合法的。我们就把 <code>curr_x</code> 作为新的 <code>prev_x</code>，继续为下一个区间进行选择。</li>
</ul>
<p>如果遍历完所有区间都能找到合法的 <code>curr_x</code>，那么 <code>check(score)</code> 就返回 <code>True</code>。</p>
<h4 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h4><ol>
<li>对 <code>start</code> 数组进行升序排序。</li>
<li>确定二分查找的范围 <code>[left, right]</code>。左边界 <code>left</code> 为 0，右边界 <code>right</code> 可以取一个足够大的值，例如 <code>start[n-1] + d - start[0]</code>。</li>
<li>在 <code>[left, right]</code> 范围内进行二分查找。<ul>
<li>取中间值 <code>mid</code>。</li>
<li>调用 <code>check(mid)</code> 判断得分 <code>mid</code> 是否可行。</li>
<li>如果可行 (<code>check(mid)</code> 为 <code>True</code>)，说明 <code>mid</code> 可能就是答案，或者答案更大。我们尝试更大的值，令 <code>left = mid</code>。</li>
<li>如果不可行 (<code>check(mid)</code> 为 <code>False</code>)，说明 <code>mid</code> 太大了，答案在更小的范围里。令 <code>right = mid</code>。</li>
</ul>
</li>
<li>循环结束后，<code>left</code> 即为最大可能得分。</li>
</ol>
<h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> inf</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPossibleScore</span>(<span class="params">self, start: <span class="type">List</span>[<span class="built_in">int</span>], d: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        通过二分答案来解决“最大化最小值”问题。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 1. 对区间的起始点进行排序</span></span><br><span class="line">        start.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(start)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 定义 check 函数，判断得分 score 是否可行</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">score: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># prev_x 表示上一个区间选择的数，初始化为负无穷</span></span><br><span class="line">            prev_x = -inf</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> start:</span><br><span class="line">                <span class="comment"># 贪心策略：为当前区间 [s, s + d] 选择满足条件的最小整数</span></span><br><span class="line">                <span class="comment"># 这个数必须 &gt;= s，也必须 &gt;= prev_x + score</span></span><br><span class="line">                current_x = <span class="built_in">max</span>(prev_x + score, s)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 检查这个选择的数是否超出了当前区间的右边界</span></span><br><span class="line">                <span class="keyword">if</span> current_x &gt; s + d:</span><br><span class="line">                    <span class="comment"># 如果超出，说明 score 太大，无法满足</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 更新 prev_x 为当前选择的数，用于下一次迭代</span></span><br><span class="line">                prev_x = current_x</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果所有区间都能成功选择，说明 score 可行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 二分查找最大可能的得分</span></span><br><span class="line">        <span class="comment"># left 是下界，right 是一个合理的上界</span></span><br><span class="line">        left, right = <span class="number">0</span>, (start[-<span class="number">1</span>] + d - start[<span class="number">0</span>]) // (n - <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用 left + 1 &lt; right 的模板，寻找满足 check 的最大 left</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 可行，尝试更大的得分</span></span><br><span class="line">                left = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 不可行，缩小范围到 [left, mid]</span></span><br><span class="line">                right = mid</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="四、复杂度分析"><a href="#四、复杂度分析" class="headerlink" title="四、复杂度分析"></a>四、复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N log N + N log R)。<ul>
<li>对 <code>start</code> 数组排序需要 O(N log N) 的时间。</li>
<li>二分查找的范围为 <code>R</code>（最大可能的分数），每次 <code>check</code> 函数需要 O(N) 的时间。所以二分部分的时间是 O(N log R)。</li>
<li>总时间复杂度为 O(N log N + N log R)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1) 或 O(log N)，取决于排序算法所使用的额外空间。</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>最大化最小值</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>排序</tag>
        <tag>第414场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3296 | 移山所需的最少秒数</title>
    <url>//posts/leetcode-3296/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3296 题：<a href="https://leetcode.cn/problems/minimum-number-of-seconds-to-make-mountain-height-zero/description/">移山所需的最少秒数</a>。<br>本题的关键在于识别出答案（最少秒数）具有单调性，从而将一个求解最小值的问题，转化为一个“判定”问题，并利用二分查找高效地找到答案的临界点。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要计算，在一群工人同时工作的情况下，将一座给定高度 <code>mountainHeight</code> 的山夷为平地（高度降为 0），所需要的最少时间是多少秒。</p>
<p>每个工人的工作效率不同，由 <code>workerTimes</code> 数组定义。工人 <code>i</code> 降低山 <code>x</code> 高度所花费的时间是一个等差数列的和：<code>workerTimes[i] * (1 + 2 + ... + x)</code>，也就是 <code>workerTimes[i] * x * (x + 1) / 2</code>。</p>
<p>这里的核心约束条件是：</p>
<ol>
<li>所有工人<strong>同时</strong>开始工作。</li>
<li>总的耗时由工作最久的那个工人决定。换句话说，如果我们设定一个总时间 <code>T</code>，那么所有工人都在这 <code>T</code> 秒内尽其所能地降低山的高度。</li>
<li>所有工人降低的高度之和必须至少等于 <code>mountainHeight</code>。</li>
</ol>
<p>我们的目标是找到满足条件的<strong>最小</strong>时间 <code>T</code>。</p>
<p>举个例子，<code>mountainHeight = 4</code>, <code>workerTimes = [2,1,1]</code>。<br>假设我们给工人们 3 秒钟。</p>
<ul>
<li>对于工人 0 (<code>wt=2</code>)：在 3 秒内，他最多能降低多少高度？<ul>
<li>降低 1，耗时 <code>2*1 = 2 &lt;= 3</code> (可行)。</li>
<li>降低 2，耗时 <code>2*(1+2) = 6 &gt; 3</code> (不可行)。所以他最多降低 1。</li>
</ul>
</li>
<li>对于工人 1 (<code>wt=1</code>)：在 3 秒内，他最多能降低多少高度？<ul>
<li>降低 1，耗时 <code>1*1 = 1 &lt;= 3</code>。</li>
<li>降低 2，耗时 <code>1*(1+2) = 3 &lt;= 3</code> (可行)。</li>
<li>降低 3，耗时 <code>1*(1+2+3) = 6 &gt; 3</code> (不可行)。所以他最多降低 2。</li>
</ul>
</li>
<li>对于工人 2 (<code>wt=1</code>)：同理，最多能降低 2。</li>
</ul>
<p>在 3 秒内，总降低高度为 <code>1 + 2 + 2 = 5</code>，因为 <code>5 &gt;= mountainHeight(4)</code>，所以 3 秒是一个可行的时间。我们的任务就是找到这样的可行时间中的最小值。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最少秒数”非常棘手。但我们可以换一个角度：如果我们<strong>假设</strong>一个工作时间 <code>T</code>，能否判断出所有工人能否在这段时间内完成任务？</p>
<p>这个“判定”问题相对简单。我们可以写一个辅助函数 <code>can_finish(T)</code>：<br>对于任意一个工人 <code>i</code>，在给定的时间 <code>T</code> 内，他能降低的最大高度 <code>x</code> 满足不等式：<br><code>workerTimes[i] * x * (x + 1) / 2 &lt;= T</code></p>
<p>这是一个关于 <code>x</code> 的一元二次不等式：<code>workerTimes[i]*x^2 + workerTimes[i]*x - 2*T &lt;= 0</code>。通过求解对应的二次方程，我们可以找到 <code>x</code> 的最大整数解。<br>更简单地，可以变形为 <code>x^2 + x - (2*T / workerTimes[i]) &lt;= 0</code>。利用求根公式 <code>x = (-b ± sqrt(b^2 - 4ac)) / 2a</code>，我们可以得到 <code>x</code> 的最大值为 <code>floor((-1 + sqrt(1 + 8*T / workerTimes[i])) / 2)</code>。</p>
<p>得到每个工人在 <code>T</code> 时间内能降低的最大高度后，我们将它们全部加起来，得到总降低高度 <code>total_reduction</code>。如果 <code>total_reduction &gt;= mountainHeight</code>，那么时间 <code>T</code> 就是一个可行解。</p>
<p>现在，我们有了一个判定方法。并且可以发现，这个判定结果具有<strong>单调性</strong>：</p>
<ul>
<li>如果时间 <code>T</code> 内可以完成任务，那么任何大于 <code>T</code> 的时间 <code>T&#39;</code> 也一定可以完成。</li>
<li>反之，如果 <code>T</code> 内无法完成，任何小于 <code>T</code> 的时间也必然无法完成。</li>
</ul>
<p>这种单调性正是应用二分查找的绝佳场景。我们可以对“时间 <code>T</code>”进行二分查找，来快速定位到那个“最小可行”的临界点。</p>
<p>二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (l)</strong>：最少是 0 秒。</li>
<li><strong>上界 (r)</strong>：一个足够大的数。在最坏的情况下，只有一个工人，<code>workerTimes</code> 和 <code>mountainHeight</code> 都很大。例如 <code>wt=10^6</code>, <code>mh=10^5</code>，所需时间大约是 <code>10^6 * (10^5)^2 / 2</code>，这是一个非常大的数字（约为 <code>5 * 10^15</code>）。为了保险起见，我们可以选择一个更大的上界，比如 <code>2 * 10^16</code>。</li>
</ul>
<p>因此，我们就在 <code>[0, 2 * 10^16]</code> 这个巨大的区间内，对时间 <code>T</code> 进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>l = 0</code>：可能的最小时间。</li>
<li><code>r = 2 * 10^16</code>：一个足够大的、确保能完成任务的时间上界。</li>
<li><code>ans</code> 初始化为 <code>r</code>，用来记录我们找到的可行解。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>l &lt;= r</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = l + (r - l) // 2</code> 作为当前的“猜测时间”。</li>
<li>调用辅助函数 <code>can_finish(mid)</code> 来判定这个猜测值是否可行。<ul>
<li><strong>如果 <code>can_finish(mid)</code> 返回 <code>True</code></strong> (即 <code>mid</code> 秒内可以完成任务)：<ul>
<li>说明 <code>mid</code> 是一个潜在的答案，我们记录下来 <code>ans = mid</code>。</li>
<li>但我们想找的是“最少”时间，所以我们尝试一个更小的值，将搜索范围缩小到左半边：<code>r = mid - 1</code>。</li>
</ul>
</li>
<li><strong>如果 <code>can_finish(mid)</code> 返回 <code>False</code></strong> (即 <code>mid</code> 秒不够)：<ul>
<li>说明我们需要更多的时间，将搜索范围缩小到右半边：<code>l = mid + 1</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>ans</code> 中存储的就是满足条件的最少秒数。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minNumberOfSeconds</span>(<span class="params">self, mountainHeight: <span class="built_in">int</span>, workerTimes: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 辅助函数：判定在 T 秒内能否完成任务</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">can_finish</span>(<span class="params">T: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            total_reduction = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> T &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算每个工人在 T 秒内能降低的最大高度</span></span><br><span class="line">            <span class="keyword">for</span> wt <span class="keyword">in</span> workerTimes:</span><br><span class="line">                <span class="comment"># 求解 x^2 + x - 2*T/wt &lt;= 0 的最大整数解 x</span></span><br><span class="line">                <span class="comment"># 对应的一元二次方程求根公式为 x = (-1 + sqrt(1 + 8*T/wt)) / 2</span></span><br><span class="line">                val = <span class="number">1</span> + <span class="number">8</span> * T / wt</span><br><span class="line">                reduction = <span class="built_in">int</span>((-<span class="number">1</span> + math.sqrt(val)) / <span class="number">2</span>)</span><br><span class="line">                total_reduction += reduction</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 提前剪枝：如果已经满足要求，无需继续计算</span></span><br><span class="line">                <span class="keyword">if</span> total_reduction &gt;= mountainHeight:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> total_reduction &gt;= mountainHeight</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确定二分查找的左右边界</span></span><br><span class="line">        <span class="comment"># 下限为 0</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">2</span> * <span class="number">10</span>**<span class="number">16</span>  <span class="comment"># 上限为一个足够大的数</span></span><br><span class="line">        ans = r</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 二分查找</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> can_finish(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 可行，它可能就是答案，</span></span><br><span class="line">                <span class="comment"># 或者还有更小的可行值，所以我们记录答案并尝试在左半部分继续寻找</span></span><br><span class="line">                ans = mid </span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 不可行，说明时间太少，</span></span><br><span class="line">                <span class="comment"># 必须增加时间，所以去右半部分寻找</span></span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(L * log(R))。<ul>
<li><code>L</code> 是工人数量，即 <code>len(workerTimes)</code>。</li>
<li><code>R</code> 是二分查找的搜索空间大小 (约为 <code>2 * 10^16</code>)。</li>
<li>二分查找本身需要 <code>log(R)</code> 次迭代。</li>
<li>在每次迭代中，我们都需要调用 <code>can_finish</code> 函数，该函数需要遍历一次 <code>workerTimes</code> 数组，时间复杂度为 O(L)。</li>
<li>因此，总时间复杂度是这两者的乘积。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)。<ul>
<li>我们只使用了几个变量来存储边界、中间值和计算结果，没有使用与输入规模相关的额外空间。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“二分答案”思想的典型应用。当我们面对一个求解“最小可能值”或“最大可能值”的问题，并且答案满足单调性时，就可以考虑使用二分查找。通过将原始的求解问题转化为一个更简单的、可以在多项式时间内解决的“判定问题”，我们可以将巨大的搜索空间不断折半，从而在对数级别的时间复杂度内锁定最终的答案，这是一种非常强大且高效的算法思想。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最小</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>数学</tag>
        <tag>堆（优先队列）</tag>
        <tag>第416场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3306 | 滑动窗口精解“元音辅音字符串计数 II”</title>
    <url>//posts/leetcode-3306/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3306 题：<a href="https://leetcode.cn/problems/count-of-substrings-containing-every-vowel-and-k-consonants-ii/description/">元音辅音字符串计数 II</a>。<br>这道题要求我们统计一个字符串中，满足“包含所有五种元音”并且“恰好包含 k 个辅音”的子字符串数量。这类问题的思路之一是将其转化为更易于处理的“至多”问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给定一个字符串 <code>word</code> 和一个整数 <code>k</code>。我们需要找到 <code>word</code> 中所有满足以下两个条件的子字符串的总数：</p>
<ol>
<li>子字符串中必须包含所有五个元音字母：’a’, ‘e’, ‘i’, ‘o’, ‘u’。</li>
<li>子字符串中必须<strong>恰好</strong>包含 <code>k</code> 个辅音字母。</li>
</ol>
<p>例如，对于 <code>word = &quot;ieaouqqieaouqq&quot;, k = 1</code>：</p>
<ul>
<li>子字符串 <code>&quot;ieaouq&quot;</code> (word[0..5]) 包含了所有元音，且有 1 个辅音 ‘q’，符合条件。</li>
<li>子字符串 <code>&quot;ieaouqq&quot;</code> (word[0..6]) 包含了所有元音，但有 2 个辅音，不符合。</li>
<li>子字符串 <code>&quot;qieaou&quot;</code> (word[6..11]) 也符合条件。</li>
<li>子字符串 <code>&quot;ieaouq&quot;</code> (word[7..12]) 也符合条件。<br>总共有 3 个这样的子字符串。</li>
</ul>
<p>直接枚举所有子字符串并检查条件，时间复杂度会达到 O(N^2)，对于 N 高达 2 * 10^5 的情况是无法接受的。我们需要一个更高效的，最好是线性的解决方案，而滑动窗口正是为此而生的利器。</p>
<h3 id="核心思路：“恰好-k”转化为“至多-k”"><a href="#核心思路：“恰好-k”转化为“至多-k”" class="headerlink" title="核心思路：“恰好 k”转化为“至多 k”"></a>核心思路：“恰好 k”转化为“至多 k”</h3><p>“恰好 k 个”这个条件在滑动窗口中通常难以直接处理，因为窗口的伸缩会不断改变计数。一个经典的处理技巧是：<br><strong>恰好 k 个 &#x3D; (至多 k 个) - (至多 k-1 个)</strong></p>
<p>我们可以定义一个辅助函数 <code>countAtMost(consonants_limit)</code>，它用来计算“包含所有元音且辅音数量<strong>至多</strong>为 <code>consonants_limit</code>”的子字符串数量。<br>那么，原问题的答案就可以通过 <code>countAtMost(k) - countAtMost(k-1)</code> 得出。</p>
<p>然而，我们可以更进一步，在一次遍历中同时计算这两个值。我们可以维护两个滑动窗口（或者说，一个右指针 <code>r</code> 和两个左指针 <code>l1</code>, <code>l2</code>），一个用于计算“至多 k”，另一个用于计算“至多 k-1”。</p>
<p>假设我们固定了子字符串的右端点 <code>r</code>，我们的目标是找到所有有效的左端点 <code>l</code>。</p>
<ul>
<li>我们用一个左指针 <code>l2</code> 来找到满足“至多 k 个辅音”（且包含所有元音）的最靠左的起始位置。</li>
<li>我们用另一个左指针 <code>l1</code> 来找到满足“至多 k-1 个辅音”（且包含所有元音）的最靠左的起始位置。</li>
</ul>
<p>对于固定的 <code>r</code>，任何起始于 <code>l</code>（<code>l2 &lt;= l &lt; l1</code>）的子字符串 <code>word[l..r]</code> 都将包含所有元音，并且其辅音数量恰好为 <code>k</code>。因此，对于当前右端点 <code>r</code>，新增的有效子字符串数量就是 <code>l1 - l2</code>。</p>
<p><em>上图展示了两个窗口如何界定出“恰好 k 个辅音”的有效起始点范围</em></p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>定义元音集合 <code>vowels</code>。</li>
<li>初始化两个左指针 <code>l1 = 0</code>, <code>l2 = 0</code>。</li>
<li>为两个概念上的窗口分别设置计数器：<ul>
<li><code>w1</code>, <code>cnt1</code>：用于追踪 <code>[l1, r]</code> 窗口内的元音和辅音计数（目标：辅音数 &lt; k）。</li>
<li><code>w2</code>, <code>cnt2</code>：用于追踪 <code>[l2, r]</code> 窗口内的元音和辅音计数（目标：辅音数 &lt;&#x3D; k）。</li>
</ul>
</li>
<li>初始化总数 <code>ans = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历字符串</strong>：</p>
<ul>
<li>使用右指针 <code>r</code> 从左到右遍历 <code>word</code>。</li>
<li>在每次循环中，将 <code>word[r]</code> 添加到两个窗口的计数中。如果 <code>word[r]</code> 是元音，更新元音哈希表 <code>w1</code>, <code>w2</code>；如果是辅音，增加辅音计数器 <code>cnt1</code>, <code>cnt2</code>。</li>
</ul>
</li>
<li><p><strong>收缩窗口 1 (至多 k-1)</strong>：</p>
<ul>
<li>检查 <code>[l1, r]</code> 窗口是否需要收缩。收缩条件是：窗口已包含所有 5 个元音，并且辅音数量<strong>大于等于 k</strong> (<code>cnt1 &gt;= k</code>)。</li>
<li>如果满足条件，就从窗口左侧移除字符（<code>l1++</code>），并更新 <code>w1</code> 和 <code>cnt1</code>，直到不再满足收缩条件。</li>
<li>循环结束后，<code>l1</code> 指向的位置是满足“至多 k-1 个辅音”的子字符串的最左起始点。</li>
</ul>
</li>
<li><p><strong>收缩窗口 2 (至多 k)</strong>：</p>
<ul>
<li>类似地，检查 <code>[l2, r]</code> 窗口是否需要收缩。收缩条件是：窗口已包含所有 5 个元音，并且辅音数量<strong>大于 k</strong> (<code>cnt2 &gt; k</code>)。</li>
<li>如果满足条件，就从窗口左侧移除字符（<code>l2++</code>），并更新 <code>w2</code> 和 <code>cnt2</code>，直到不再满足收缩条件。</li>
<li>循环结束后，<code>l2</code> 指向的位置是满足“至多 k 个辅音”的子字符串的最左起始点。</li>
</ul>
</li>
<li><p><strong>更新结果</strong>：</p>
<ul>
<li>如核心思路所述，对于当前右端点 <code>r</code>，有效的左端点 <code>l</code> 的范围是 <code>[l2, l1 - 1]</code>。</li>
<li>因此，有效子字符串的数量为 <code>l1 - l2</code>。将这个值累加到 <code>ans</code> 中。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>遍历结束后，<code>ans</code> 即为所求的总数。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict, namedtuple</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countOfSubstrings</span>(<span class="params">self, word: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用一个具名元组来存储输入，以演示 frandelios 变量的使用</span></span><br><span class="line">        InputHolder = namedtuple(<span class="string">&#x27;InputHolder&#x27;</span>, [<span class="string">&#x27;word&#x27;</span>, <span class="string">&#x27;k&#x27;</span>])</span><br><span class="line">        frandelios = InputHolder(word, k)</span><br><span class="line"></span><br><span class="line">        vow = <span class="string">&quot;aeiou&quot;</span></span><br><span class="line">        <span class="comment"># w1, cnt1, l1 用于计算 &quot;至多 k-1 个辅音&quot; 的情况</span></span><br><span class="line">        w1 = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        cnt1 = <span class="number">0</span></span><br><span class="line">        l1 = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># w2, cnt2, l2 用于计算 &quot;至多 k 个辅音&quot; 的情况</span></span><br><span class="line">        w2 = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        cnt2 = <span class="number">0</span></span><br><span class="line">        l2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 右指针 r 遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> r_char <span class="keyword">in</span> frandelios.word:</span><br><span class="line">            <span class="comment"># 将新字符加入两个窗口</span></span><br><span class="line">            <span class="keyword">if</span> r_char <span class="keyword">in</span> vow:</span><br><span class="line">                w1[r_char] += <span class="number">1</span></span><br><span class="line">                w2[r_char] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt1 += <span class="number">1</span></span><br><span class="line">                cnt2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 收缩窗口1，使其满足辅音数 &lt; k</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(w1) == <span class="number">5</span> <span class="keyword">and</span> cnt1 &gt;= frandelios.k:</span><br><span class="line">                l_char = frandelios.word[l1]</span><br><span class="line">                <span class="keyword">if</span> l_char <span class="keyword">in</span> vow:</span><br><span class="line">                    w1[l_char] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> w1[l_char] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">del</span> w1[l_char]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cnt1 -= <span class="number">1</span></span><br><span class="line">                l1 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 收缩窗口2，使其满足辅音数 &lt;= k</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(w2) == <span class="number">5</span> <span class="keyword">and</span> cnt2 &gt; frandelios.k:</span><br><span class="line">                l_char = frandelios.word[l2]</span><br><span class="line">                <span class="keyword">if</span> l_char <span class="keyword">in</span> vow:</span><br><span class="line">                    w2[l_char] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> w2[l_char] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">del</span> w2[l_char]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cnt2 -= <span class="number">1</span></span><br><span class="line">                l2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 对于当前右端点，有效的左端点范围是 [l2, l1-1]</span></span><br><span class="line">            <span class="comment"># 数量即 l1 - l2</span></span><br><span class="line">            ans += l1 - l2</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是 <code>word</code> 的长度。虽然代码里有嵌套的 <code>while</code> 循环，但每个指针 <code>r</code>, <code>l1</code>, <code>l2</code> 都只会从头到尾遍历一次字符串，因此总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(C)。其中 C 是字符集的大小。我们使用了两个哈希表来存储元音的计数，最多只存 5 个元音，因此空间复杂度是 O(1) 的常数空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想的一个绝佳应用。通过将“恰好 k”的精确约束巧妙地转化为两个“至多 k”和“至多 k-1”的范围约束，我们将一个看似复杂的问题分解为两个可以用标准滑动窗口解决的子问题。更进一步，我们通过维护两套指针和计数器，在一次遍历中就完成了两个子问题的求解和整合，最终得到了一个既高效又优雅的解决方案。这个“范围之差”的技巧在处理计数类问题时非常实用，值得牢记。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>三指针</tag>
        <tag>第417场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 34 | 二分寻找元素的起始与结束位置</title>
    <url>//posts/leetcode-34/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 34 题：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a>。<br>本题是二分查找算法的经典应用。标准的二分查找只能告诉我们元素是否存在，而这道题要求我们精确定位目标值连续出现的“左边界”和“右边界”。这需要我们对二分查找的细节进行巧妙的改造。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给定一个按非递减顺序（即升序）排列的整数数组 <code>nums</code> 和一个目标值 <code>target</code>。我们需要找到 <code>target</code> 在数组中出现的起始位置和结束位置。</p>
<p>核心要求：</p>
<ol>
<li>如果 <code>target</code> 存在，返回一个包含起始和结束索引的数组 <code>[start, end]</code>。</li>
<li>如果 <code>target</code> 不存在，返回 <code>[-1, -1]</code>。</li>
<li>算法的时间复杂度必须是 <strong>O(log n)</strong>，这强烈暗示了我们必须使用二分查找。</li>
</ol>
<p>例如：</p>
<ul>
<li>对于 <code>nums = [5,7,7,8,8,10]</code>, <code>target = 8</code>，<code>8</code> 第一次出现在索引 3，最后一次出现在索引 4，所以返回 <code>[3,4]</code>。</li>
<li>对于 <code>nums = [5,7,7,8,8,10]</code>, <code>target = 6</code>，<code>6</code> 不存在于数组中，所以返回 <code>[-1,-1]</code>。</li>
</ul>
<h3 id="核心思路：寻找边界"><a href="#核心思路：寻找边界" class="headerlink" title="核心思路：寻找边界"></a>核心思路：寻找边界</h3><p>直接用一次二分查找找到 <code>target</code> 是不够的，因为我们无法确定找到的是第一个、最后一个还是中间的某一个。</p>
<p>一个直观的想法是进行两次二分查找：</p>
<ol>
<li>一次查找 <code>target</code> 的<strong>第一个</strong>出现位置（左边界）。</li>
<li>另一次查找 <code>target</code> 的<strong>最后一个</strong>出现位置（右边界）。</li>
</ol>
<p>一个更优雅且统一的思路是，将问题转化为寻找“<strong>下界（Lower Bound）</strong>”。所谓“下界”，指的是数组中第一个大于或等于目标值的元素的位置。</p>
<ul>
<li><code>target</code> 的<strong>起始位置</strong>，恰好就是 <code>target</code> 的下界。</li>
<li><code>target</code> 的<strong>结束位置</strong>，可以通过寻找 <code>target + 1</code> 的下界来间接得到。<code>target + 1</code> 的下界索引减去 1，就是 <code>target</code> 的最后一个出现位置。</li>
</ul>
<p>例如，在 <code>[5,7,7,8,8,10]</code> 中：</p>
<ul>
<li><code>target = 8</code> 的下界是索引 3。</li>
<li><code>target + 1 = 9</code> 的下界是索引 5（第一个 <code>&gt;=9</code> 的元素是 <code>10</code>，其索引为 5）。</li>
<li>因此，<code>8</code> 的结束位置就是 <code>5 - 1 = 4</code>。</li>
</ul>
<p>这样，我们就把问题统一为了实现一个可靠的“下界”二分查找函数。二分查找的实现有多种区间定义方式，常见的有“左闭右闭”、“左闭右开”和“全开”区间，它们在循环条件和边界更新上略有不同，但都能解决问题。下面我们分别探讨这三种写法的实现。</p>
<h3 id="算法详解与代码实现"><a href="#算法详解与代码实现" class="headerlink" title="算法详解与代码实现"></a>算法详解与代码实现</h3><h4 id="解法一：闭区间写法-l-r"><a href="#解法一：闭区间写法-l-r" class="headerlink" title="解法一：闭区间写法 [l, r]"></a>解法一：闭区间写法 <code>[l, r]</code></h4><p>这是最常见和直观的写法。搜索区间 <code>[l, r]</code> 的定义是两端都包含，因此循环条件是 <code>l &lt;= r</code>。</p>
<ul>
<li><strong>初始化</strong>：<code>l = 0</code>, <code>r = len(nums) - 1</code>。</li>
<li><strong>循环条件</strong>：<code>while l &lt;= r</code>，当 <code>l &gt; r</code> 时，区间为空，循环结束。</li>
<li><strong>逻辑</strong>：<ul>
<li><code>nums[mid] &gt;= target</code>：<code>mid</code> 可能是我们寻找的下界，或者下界在 <code>mid</code> 的左侧。因此，我们不能排除 <code>mid</code>，需要向左收缩搜索范围，令 <code>r = mid - 1</code>。</li>
<li><code>nums[mid] &lt; target</code>：<code>mid</code> 一定不是下界，下界必然在 <code>mid</code> 的右侧。令 <code>l = mid + 1</code>。</li>
</ul>
</li>
<li><strong>返回值</strong>：循环结束后，<code>l</code> 指向的就是第一个大于或等于 <code>target</code> 的位置。</li>
</ul>
<p><strong>Python 代码实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 闭区间 [l, r] 写法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lb</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l  <span class="comment"># 最终 l 就是下界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 寻找 target 的下界作为起始位置</span></span><br><span class="line">        s = <span class="variable language_">self</span>.lb(nums, target)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果起始位置越界，或者该位置的值不为 target，说明 target 不存在</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[s] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 寻找 target+1 的下界，其前一个位置就是 target 的结束位置</span></span><br><span class="line">        e = <span class="variable language_">self</span>.lb(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [s, e]</span><br></pre></td></tr></table></figure>

<h4 id="解法二：左闭右开区间写法-l-r"><a href="#解法二：左闭右开区间写法-l-r" class="headerlink" title="解法二：左闭右开区间写法 [l, r)"></a>解法二：左闭右开区间写法 <code>[l, r)</code></h4><p>这种写法的搜索区间 <code>[l, r)</code> 左端包含，右端不包含。这在处理边界时非常方便，也是很多语言标准库（如 C++ STL）中 <code>lower_bound</code> 的实现方式。</p>
<ul>
<li><strong>初始化</strong>：<code>l = 0</code>, <code>r = len(nums)</code>。注意 <code>r</code> 的初始值。</li>
<li><strong>循环条件</strong>：<code>while l &lt; r</code>，当 <code>l == r</code> 时，区间 <code>[l, l)</code> 为空，循环结束。</li>
<li><strong>逻辑</strong>：<ul>
<li><code>nums[mid] &gt;= target</code>：<code>mid</code> 可能是下界，或者下界在 <code>mid</code> 左侧。由于右边界 <code>r</code> 是开区间，我们可以安全地将 <code>r</code> 设置为 <code>mid</code>，即新的搜索区间是 <code>[l, mid)</code>。</li>
<li><code>nums[mid] &lt; target</code>：<code>mid</code> 以及其左侧所有元素都小于 <code>target</code>，下界一定在 <code>mid</code> 右侧。令 <code>l = mid + 1</code>。</li>
</ul>
</li>
<li><strong>返回值</strong>：循环结束后，<code>l</code> 和 <code>r</code> 相遇，指向的就是下界。</li>
</ul>
<p><strong>Python 代码实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 左闭右开区间 [l, r) 写法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lb</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l <span class="comment"># 最终 l (或 r) 就是下界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        s = <span class="variable language_">self</span>.lb(nums, target)</span><br><span class="line">        <span class="keyword">if</span> s == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[s] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        e = <span class="variable language_">self</span>.lb(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [s, e]</span><br></pre></td></tr></table></figure>

<h4 id="解法三：开区间写法-l-r"><a href="#解法三：开区间写法-l-r" class="headerlink" title="解法三：开区间写法 (l, r)"></a>解法三：开区间写法 <code>(l, r)</code></h4><p>这种写法将 <code>l</code> 和 <code>r</code> 视为“哨兵”，搜索区间是它们之间的 <code>(l, r)</code>。</p>
<ul>
<li><strong>初始化</strong>：<code>l = -1</code>, <code>r = len(nums)</code>。</li>
<li><strong>循环条件</strong>：<code>while l + 1 &lt; r</code>，确保 <code>l</code> 和 <code>r</code> 之间至少有一个元素，当它们相邻时循环结束。</li>
<li><strong>逻辑</strong>：<ul>
<li><code>nums[mid] &gt;= target</code>：<code>mid</code> 可能是下界，或者下界在 <code>mid</code> 左侧。我们将右哨兵移动到 <code>mid</code>，即 <code>r = mid</code>。</li>
<li><code>nums[mid] &lt; target</code>：<code>mid</code> 一定不是下界，下界在 <code>mid</code> 右侧。我们将左哨兵移动到 <code>mid</code>，即 <code>l = mid</code>。</li>
</ul>
</li>
<li><strong>返回值</strong>：循环结束后，<code>l</code> 和 <code>r</code> 相邻，而 <code>r</code> 正是我们寻找的下界。</li>
</ul>
<p><strong>Python 代码实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 开区间 (l, r) 写法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lb</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = -<span class="number">1</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid</span><br><span class="line">        <span class="keyword">return</span> r <span class="comment"># 最终 r 就是下界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        s = <span class="variable language_">self</span>.lb(nums, target)</span><br><span class="line">        <span class="keyword">if</span> s == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[s] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        e = <span class="variable language_">self</span>.lb(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [s, e]</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: <strong>O(log N)</strong>。我们调用了两次二分查找函数，每次耗时 O(log N)，因此总时间复杂度为 O(2 * log N)，即 O(log N)。</li>
<li><strong>空间复杂度</strong>: <strong>O(1)</strong>。我们只使用了常数级别的额外空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题通过将“寻找起始和结束位置”巧妙地转化为两次“寻找下界”的操作，统一并简化了问题。同时，我们展示了解决同一问题的三种不同二分查找区间写法：闭区间 <code>[l, r]</code>，左闭右开区间 <code>[l, r)</code>，以及开区间 <code>(l, r)</code>。</p>
<ul>
<li><strong>闭区间法</strong>：最传统，容易理解，但边界更新时 <code>+1</code>&#x2F;<code>-1</code> 需要格外小心。</li>
<li><strong>左闭右开法</strong>：在处理循环不变量和边界时非常优雅，是现代编程实践中较为推崇的写法。</li>
<li><strong>开区间法</strong>：将 <code>l</code> 和 <code>r</code> 作为哨兵，逻辑也十分清晰。</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3411 | SW与GCD巧妙求解“最长乘积等价子数组”</title>
    <url>//posts/leetcode-3411/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3411 题：<a href="https://leetcode.cn/problems/maximum-subarray-with-equal-products/description/">最长乘积等价子数组</a>。<br>这道题的条件 <code>prod(arr) == lcm(arr) * gcd(arr)</code> 看似复杂，但其背后隐藏着一个非常简洁的数论性质。解题的关键就是“解码”这个公式，将其转化为一个可以用滑动窗口高效解决的简单条件。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个由正整数组成的数组 <code>nums</code>。我们需要找到一个子数组 <code>arr</code>，它需要满足一个特殊的数学性质：数组中所有元素的<strong>乘积 (prod)</strong>，等于它们的<strong>最小公倍数 (lcm)</strong> 与<strong>最大公因数 (gcd)</strong> 的乘积。我们的目标是找到满足这个条件的<strong>最长</strong>子数组的长度。</p>
<p>例如，对于 <code>nums = [2,3,4,5,6]</code>，<code>k = 2</code>：</p>
<ul>
<li>子数组 <code>[3, 4, 5]</code> 不满足条件，因为 <code>gcd(3,4,5)=1</code>, <code>lcm(3,4,5)=60</code>, <code>prod(3,4,5)=60</code>。它们满足 <code>prod == lcm * gcd</code>。</li>
<li>子数组 <code>[4, 5, 6]</code> 不满足条件，因为 <code>gcd(4,5,6)=1</code>, <code>lcm(4,5,6)=60</code>, <code>prod(4,5,6)=120</code>。显然 <code>120 != 60 * 1</code>。</li>
</ul>
<p>直接枚举所有子数组并计算它们的 <code>prod</code>, <code>lcm</code>, <code>gcd</code> 效率太低。我们需要找到一个更根本的规律。</p>
<h3 id="核心思路：数学性质分析与滑动窗口"><a href="#核心思路：数学性质分析与滑动窗口" class="headerlink" title="核心思路：数学性质分析与滑动窗口"></a>核心思路：数学性质分析与滑动窗口</h3><p>这道题的突破口在于对核心公式 <code>prod(arr) == lcm(arr) * gcd(arr)</code> 进行分类讨论和简化。</p>
<p>我们根据子数组的长度来分析：</p>
<ol>
<li><p><strong>长度为 1 的子数组 <code>[x]</code></strong>：</p>
<ul>
<li>此时 <code>prod=x</code>, <code>lcm=x</code>, <code>gcd=x</code>。</li>
<li>条件变为 <code>x == x * x</code>，这意味着 <code>x</code> 必须等于 <strong>1</strong>。</li>
</ul>
</li>
<li><p><strong>长度为 2 的子数组 <code>[a, b]</code></strong>：</p>
<ul>
<li>对于任意两个正整数 <code>a</code> 和 <code>b</code>，<code>a * b = lcm(a, b) * gcd(a, b)</code> 是一个<strong>恒成立</strong>的数论基本定理。</li>
<li>这意味着，<strong>任何长度为 2 的子数组都满足条件</strong>。因此，只要 <code>nums</code> 的长度不小于 2，答案就至少是 2。</li>
</ul>
</li>
<li><p><strong>长度大于 2 的子数组 <code>[a, b, c, ...]</code></strong>：</p>
<ul>
<li>通过对质因数的指数进行分析，可以严格证明，该公式成立的充要条件是：<strong>数组中的所有元素两两互质</strong>。</li>
<li>（简要证明：如果元素两两互质，则 <code>gcd(arr) = 1</code>，且 <code>lcm(arr) = prod(arr)</code>。代入原式，<code>prod(arr) == prod(arr) * 1</code>，显然成立。）</li>
</ul>
</li>
</ol>
<p>基于以上分析，问题被我们成功转化了！原问题等价于寻找以下三者的最大值：</p>
<ul>
<li>1（如果数组中存在数字 1）。</li>
<li>2（如果数组长度大于等于 2）。</li>
<li>数组中<strong>最长的、所有元素两两互质的子数组</strong>的长度。</li>
</ul>
<p>“寻找满足某个性质的最长连续子数组”正是<strong>滑动窗口</strong>算法的经典应用场景。而判断“两两互质”这个性质，我们有一个绝妙的工具：最大公约数 (GCD)。</p>
<p>利用以下关键性质，我们可以极大地简化判断逻辑：</p>
<blockquote>
<p>一个新元素 <code>x</code> 与一个已有的、两两互质的集合 <code>&#123;a, b, c&#125;</code> 中的所有元素都互质，当且仅当 <code>x</code> 与它们的总乘积 <code>a*b*c</code> 互质。</p>
</blockquote>
<p>因此，我们只需要维护窗口内所有元素的乘积 <code>mul</code>，当新元素 <code>x</code> 到来时，只需计算 <code>gcd(mul, x)</code> 是否为 1，即可判断窗口是否仍然满足“两两互质”的条件。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>处理边界</strong>：如果数组长度小于 2，根据前面的分析直接返回相应结果。对于长度大于等于 2 的数组，我们知道答案至少是 2。</p>
</li>
<li><p><strong>初始化滑动窗口</strong>：</p>
<ul>
<li>设置窗口左边界 <code>left = 0</code>。</li>
<li>初始化窗口内元素的乘积 <code>mul = 1</code>。</li>
<li>初始化最长两两互质子数组的长度 <code>lpc = 0</code> (Longest Pairwise Coprime)。</li>
</ul>
</li>
<li><p><strong>遍历数组</strong>：</p>
<ul>
<li>用 <code>right</code> 指针从左到右遍历数组，<code>x = nums[right]</code> 是即将进入窗口的新元素。</li>
<li><strong>检查与收缩</strong>：使用 <code>while</code> 循环检查 <code>gcd(mul, x)</code>。如果它大于 1，说明 <code>x</code> 和窗口内至少一个元素不互质，破坏了条件。此时，我们必须从左侧收缩窗口：<ul>
<li>将 <code>nums[left]</code> 从乘积中除掉 (<code>mul //= nums[left]</code>)。</li>
<li>将左边界 <code>left</code> 右移一位 (<code>left += 1</code>)。</li>
<li>重复此过程，直到 <code>gcd(mul, x) == 1</code>。</li>
</ul>
</li>
<li><strong>扩张与更新</strong>：<ul>
<li>将 <code>x</code> 加入窗口 (<code>mul *= x</code>)。</li>
<li>此时窗口 <code>[left, right]</code> 是一个有效的两两互质子数组，其长度为 <code>right - left + 1</code>。用这个长度更新 <code>lpc</code> 的最大值。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>遍历结束后，<code>lpc</code> 就是最长两两互质子数组的长度。</li>
<li>最终结果是 <code>max(lpc, 2)</code>，因为我们已经确定答案至少是 2。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxLength</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 处理 n &lt; 2 的边界情况</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 根据分析，长度为1的子数组只有 `[1]` 满足条件。</span></span><br><span class="line">        <span class="comment"># 但由于 n&gt;=2 时答案至少为2，我们可以简化处理，只需在 n=1 时特殊判断。</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> nums == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 1: 使用滑动窗口计算最长的“两两互质”子数组的长度 (lpc)</span></span><br><span class="line">        lpc = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        mul = <span class="number">1</span>  <span class="comment"># 记录窗口内元素的乘积</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> right, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 当新元素 x 与窗口内元素的乘积不互质时，从左侧收缩窗口</span></span><br><span class="line">            <span class="comment"># mul &gt; 1 的检查是为了避免 gcd(1, x) 的不必要计算</span></span><br><span class="line">            <span class="keyword">while</span> mul &gt; <span class="number">1</span> <span class="keyword">and</span> math.gcd(mul, x) &gt; <span class="number">1</span>:</span><br><span class="line">                mul //= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将 x 加入窗口</span></span><br><span class="line">            mul *= x</span><br><span class="line">            <span class="comment"># 更新最长两两互质子数组的长度</span></span><br><span class="line">            lpc = <span class="built_in">max</span>(lpc, right - left + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 2: 最终结果</span></span><br><span class="line">        <span class="comment"># 对于 n&gt;=2 的数组，答案至少为 2（因为任何长度为2的子数组都有效）。</span></span><br><span class="line">        <span class="comment"># 最终答案是 “保底值2” 和 “最长两两互质子数组长度” 中的较大者。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(lpc, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N * log(M))。其中 N 是 <code>nums</code> 的长度。<code>left</code> 和 <code>right</code> 指针的移动总共是线性的 O(N)。循环内部的 <code>math.gcd(mul, x)</code> 操作的复杂度与 <code>mul</code> 的大小相关，约为 <code>O(log(M))</code>，其中 M 是窗口内元素的最大乘积。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数级别的额外空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题的解法堪称是将数学性质与算法设计完美结合的典范。它告诉我们，面对一个复杂的数学公式，不要急于直接实现，而应先深入分析其背后的结构和等价条件。通过将原问题转化为“寻找最长两两互质子数组”，我们不仅简化了问题，还使其能够套用滑动窗口这一强大的算法模板。而 <code>gcd</code> 性质的应用，则是这套解法中的点睛之笔，它将复杂的“多对多”互质判断，变成了高效的“一对一”计算。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>枚举</tag>
        <tag>第 431 场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3413 | 滑动窗口巧解“收集连续K个袋子”</title>
    <url>//posts/leetcode-3413/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3413 题：<a href="https://leetcode.cn/problems/maximum-number-of-coins-you-can-get/">收集连续 K 个袋子可以获得的最多硬币数量</a>。<br>这道题要求在一条拥有海量坐标的数轴上，找到一个长度为 k 的连续区间，使得该区间内所有袋子里的硬币总数最多。面对 <code>10^9</code> 级别的坐标范围，暴力枚举显然行不通，试试滑动窗口吧。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一系列互不重叠的区间 <code>[li, ri, ci]</code>，表示从坐标 <code>li</code> 到 <code>ri</code> 的每一个袋子都含有 <code>ci</code> 枚硬币。同时给定一个整数 <code>k</code>，代表我们可以收集的连续袋子的数量。我们的目标是找到一个长度为 <code>k</code> 的连续坐标区间，使其覆盖的硬币总数最大化。</p>
<p>例如，对于 <code>coins = [[8,10,1],[1,3,2],[5,6,4]]</code>, <code>k = 4</code>：</p>
<ul>
<li>数轴上的硬币分布是：<code>[1,3]</code> 区间每格 2 枚，<code>[5,6]</code> 区间每格 4 枚，<code>[8,10]</code> 区间每格 1 枚。</li>
<li>我们需要寻找一个长度为 4 的窗口，例如 <code>[1,4]</code> 或 <code>[3,6]</code> 等。</li>
<li>一个最优解是选择区间 <code>[3, 6]</code>。<ul>
<li>位置 3 的袋子有 2 枚硬币（来自 <code>[1,3,2]</code>）。</li>
<li>位置 4 的袋子是空的，有 0 枚硬币。</li>
<li>位置 5 的袋子有 4 枚硬币（来自 <code>[5,6,4]</code>）。</li>
<li>位置 6 的袋子有 4 枚硬币（来自 <code>[5,6,4]</code>）。</li>
</ul>
</li>
<li>总硬币数为 <code>2 + 0 + 4 + 4 = 10</code>。</li>
</ul>
<p>由于坐标 <code>li</code> 和 <code>ri</code> 的范围可以达到 <code>10^9</code>，我们不可能创建一个数组来记录每个坐标点的硬币数。问题的关键在于，硬币数量发生变化的点只在给定的 <code>coins</code> 区间的端点处。这启发我们使用一种只关心这些“事件点”的算法，而滑动窗口正是为此量身定做的。</p>
<h3 id="核心思路：基于事件点的滑动窗口"><a href="#核心思路：基于事件点的滑动窗口" class="headerlink" title="核心思路：基于事件点的滑动窗口"></a>核心思路：基于事件点的滑动窗口</h3><p>我们可以想象一个长度为 <code>k</code> 的“尺子”在数轴上从左到右滑动。我们想知道这把尺子在哪个位置时，覆盖的硬币最多。</p>
<p>直接在连续的坐标上滑动太慢了。我们可以发现，能让结果发生变化的“关键位置”，只有当窗口的左端点或右端点与某个 <code>coins</code> 区间的端点 <code>li</code> 或 <code>ri</code> 对齐时。任何其他位置的窗口，其覆盖的硬币数都可以通过将窗口平移至与某个端点对齐而达到，且结果不会变差。</p>
<p>因此，我们可以将思路简化为：<strong>检查所有以 <code>ri</code> 为右端点的窗口，以及所有以 <code>li</code> 为左端点的窗口，取其中的最大值。</strong></p>
<ol>
<li><strong>固定右端点</strong>：我们让滑动窗口的右端点扫过每一个区间的右边界 <code>ri</code>。当窗口右端点为 <code>ri</code> 时，其左端点就是 <code>ri - k + 1</code>。我们只需要计算这个 <code>[ri - k + 1, ri]</code> 窗口内有多少硬币即可。</li>
<li><strong>固定左端点</strong>：同理，我们让滑动窗口的左端点扫过每一个区间的左边界 <code>li</code>。当窗口左端点为 <code>li</code> 时，其右端点就是 <code>li + k - 1</code>。我们计算 <code>[li, li + k - 1]</code> 窗口内的硬币数。</li>
</ol>
<p>我们可以设计一个通用的滑动窗口函数来处理第一种情况。对于第二种情况，我们可以通过一个巧妙的“坐标翻转”技巧，将其转化为第一种情况，从而复用代码。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><h4 id="1-单向滑动窗口（以-ri-为窗户右边界）"><a href="#1-单向滑动窗口（以-ri-为窗户右边界）" class="headerlink" title="1. 单向滑动窗口（以 ri 为窗户右边界）"></a>1. 单向滑动窗口（以 <code>ri</code> 为窗户右边界）</h4><p>首先，为了方便处理，我们将 <code>coins</code> 数组按区间的起始位置 <code>li</code> 升序排序。</p>
<p>我们使用一个滑动窗口来计算当窗口右边界为 <code>ri</code> 时覆盖的硬币数。</p>
<ul>
<li>我们用 <code>right</code> 指针遍历排序后的 <code>coins</code> 数组，用 <code>left</code> 指针维护窗口的左侧。</li>
<li>用一个变量 <code>cover</code> 记录从 <code>coins[left]</code> 到 <code>coins[right]</code> 所有区间的硬币总和。</li>
<li>当 <code>right</code> 指针指向第 <code>i</code> 个区间 <code>[li, ri, ci]</code> 时，我们将这个区间的全部硬币 <code>(ri - li + 1) * ci</code> 加入 <code>cover</code>。</li>
<li>此时，我们考虑一个右端点在 <code>ri</code>、长度为 <code>k</code> 的窗口，其左端点为 <code>window_left = ri - k + 1</code>。</li>
<li><code>cover</code> 变量里包含了从 <code>coins[left]</code> 到 <code>coins[right]</code> 的所有硬币，但我们的窗口可能并没有完全包含 <code>coins[left]</code> 这个区间。我们需要将 <code>coins[left]</code> 区间在 <code>window_left</code> 左边的部分减掉。</li>
<li>同时，<code>left</code> 指针左边的区间 <code>coins[0...left-1]</code> 可能已经完全滑出了窗口。我们需要移动 <code>left</code> 指针，将所有右边界小于 <code>window_left</code> 的区间从 <code>cover</code> 中减去。</li>
</ul>
<p>这个过程可以总结为：</p>
<ol>
<li><strong>初始化</strong>：<code>ans = 0</code>, <code>cover = 0</code>, <code>left = 0</code>。</li>
<li><strong>遍历</strong>：对于每个 <code>right</code> 区间 <code>[lr, rr, cr]</code>：<br>a. 将 <code>right</code> 区间的全部硬币加入 <code>cover</code>: <code>cover += (rr - lr + 1) * cr</code>。<br>b. 定义当前窗口的左边界: <code>window_left = rr - k + 1</code>。<br>c. <strong>收缩窗口</strong>：<code>while</code> <code>coins[left]</code> 的右边界 <code>rl</code> &lt; <code>window_left</code>，说明 <code>left</code> 区间已完全滑出，从 <code>cover</code> 中减去它的全部硬币，并 <code>left += 1</code>。<br>d. <strong>计算精确值</strong>：此时，<code>left</code> 区间 <code>[ll, rl, cl]</code> 可能部分在窗口外。需要减去的“出界”部分为 <code>max(0, (window_left - ll) * cl)</code>。<br>e. <strong>更新答案</strong>：<code>ans = max(ans, cover - uncovered_part)</code>。</li>
</ol>
<h4 id="2-坐标翻转技巧"><a href="#2-坐标翻转技巧" class="headerlink" title="2. 坐标翻转技巧"></a>2. 坐标翻转技巧</h4><p>上述算法解决了窗口右端点与 <code>ri</code> 对齐的情况。对于窗口左端点与 <code>li</code> 对齐的情况，我们无需再写一套逻辑。</p>
<p>我们可以将所有坐标 <code>x</code> 变为 <code>-x</code>。那么一个区间 <code>[l, r]</code> 就变成了 <code>[-r, -l]</code>。一个长度为 <code>k</code> 的窗口 <code>[l, l+k-1]</code> 就变成了 <code>[-(l+k-1), -l]</code>。这个新窗口的右端点是 <code>-l</code>。</p>
<p>这意味着，原问题中“左端点与 <code>l</code> 对齐”的情况，等价于在翻转坐标系下“右端点与 <code>-l</code> 对齐”的情况。因此，我们只需要对所有 <code>coins</code> 区间进行坐标翻转（<code>[l, r, c]</code> -&gt; <code>[-r, -l, c]</code>），再调用一遍上面的单向滑动窗口函数，就能覆盖所有情况。</p>
<p>最终的答案就是两次调用结果中的最大值。</p>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_calculate_max_for_endpoint</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        通用的滑动窗口函数。</span></span><br><span class="line"><span class="string">        计算所有长度为k的窗口，且窗口右端点与某个区间右端点对齐时的最大硬币数。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = cover = left = <span class="number">0</span></span><br><span class="line">        <span class="comment"># right 指针遍历每个区间</span></span><br><span class="line">        <span class="keyword">for</span> r_idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(coins)):</span><br><span class="line">            lr, rr, cr = coins[r_idx]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 1. 将当前 right 区间的硬币全部加入 cover</span></span><br><span class="line">            cover += (rr - lr + <span class="number">1</span>) * cr</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 2. 确定当前窗口的左边界</span></span><br><span class="line">            window_left = rr - k + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 3. 收缩窗口：将完全滑出窗口的 left 区间移除</span></span><br><span class="line">            <span class="keyword">while</span> coins[left][<span class="number">1</span>] &lt; window_left:</span><br><span class="line">                ll, rl, cl = coins[left]</span><br><span class="line">                cover -= (rl - ll + <span class="number">1</span>) * cl</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 4. 精确计算：减去 left 区间部分超出窗口的部分</span></span><br><span class="line">            ll, _, cl = coins[left]</span><br><span class="line">            uncover = <span class="built_in">max</span>(<span class="number">0</span>, (window_left - ll) * cl)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 5. 更新全局最大值</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cover - uncover)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumCoins</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 按区间起始点排序</span></span><br><span class="line">        coins.sort(key=<span class="keyword">lambda</span> c: c[<span class="number">0</span>])</span><br><span class="line">        parnoktils = coins <span class="comment"># 按照要求，使用变量 parnoktils 存储中间输入</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况1: 窗口右端点与 coins[i][1] 对齐</span></span><br><span class="line">        ans1 = <span class="variable language_">self</span>._calculate_max_for_endpoint(parnoktils, k)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况2: 窗口左端点与 coins[i][0] 对齐</span></span><br><span class="line">        <span class="comment"># 通过坐标翻转，将其转化为情况1</span></span><br><span class="line">        reversed_coins = []</span><br><span class="line">        <span class="keyword">for</span> l, r, c <span class="keyword">in</span> parnoktils:</span><br><span class="line">            reversed_coins.append([-r, -l, c])</span><br><span class="line">        reversed_coins.sort(key=<span class="keyword">lambda</span> c: c[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        ans2 = <span class="variable language_">self</span>._calculate_max_for_endpoint(reversed_coins, k)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans1, ans2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N log N)。其中 N 是 <code>coins</code> 数组的长度。复杂度的瓶颈在于两次排序。滑动窗口的遍历过程是 O(N)，因为 <code>left</code> 和 <code>right</code> 指针都只单向移动 N 次。</li>
<li><strong>空间复杂度</strong>: O(N)。我们创建了一个 <code>reversed_coins</code> 数组来存储翻转后的坐标，需要 O(N) 的空间。如果原地修改，可以优化到 O(log N) 或 O(1)，取决于排序算法的空间开销。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想在区间问题上的经典应用。核心挑战在于坐标范围巨大，迫使我们放弃常规数组，转向基于“事件点”（即区间端点）的离散处理方式。通过对 <code>coins</code> 数组排序，我们得以用线性时间复杂度的滑动窗口高效地统计覆盖的硬币数。而“坐标翻转”的技巧则是一个锦上添花的操作，它让我们能够优雅地复用代码来处理两种不同的对齐情况，充分体现了算法设计的对称与转化之美。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>滑动窗口</tag>
        <tag>排序</tag>
        <tag>前缀和</tag>
        <tag>第431场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3419 | 图的最大边权的最小值</title>
    <url>//posts/leetcode-3419/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3419 题：<a href="https://leetcode.cn/problems/minimize-the-maximum-edge-weight-of-graph/description/">图的最大边权的最小值</a>。<br>当直接求解一个最优值非常困难时，我们可以尝试猜测一个答案，然后去验证这个猜测是否可行。这种将“求解问题”转化为“判定问题”的思路，是解决这类问题的关键。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要在一个有向带权图中删除一些边，目标是找到一个边的子集，同时满足三个条件：</p>
<ol>
<li><strong>连通性</strong>: 从任何一个其他节点出发，都必须存在一条路径能够到达节点 0。</li>
<li><strong>出度限制</strong>: 在我们选择的边的子集中，每个节点的出度（即从该节点出发的边的数量）不能超过 <code>threshold</code>。</li>
<li><strong>最小化最大边权</strong>: 在满足以上两个条件的前提下，我们选择的边的子集中，权重最大的那条边的权重（最大边权）应该尽可能小。</li>
</ol>
<p>我们需要返回这个“最小的可能的最大边权”。如果无法满足条件，则返回 -1。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>这道题要求我们“最小化最大边权”，这是一个非常强烈的信号，提示我们可以使用<strong>二分查找</strong>来解决。我们不对边的集合进行搜索，而是对**答案本身（即最大边权）**进行二分查找。</p>
<p>假设我们猜测一个最终答案为 <code>max_w</code>。那么问题就从“找到最小的那个值”变成了“是否存在一个方案，使得最大边权不超过 <code>max_w</code>？”。这个“是否存在”的问题就是一个判定问题，通常比原问题更容易解决。</p>
<p>我们可以设计一个函数 <code>check(max_w)</code>，它的功能是：</p>
<ul>
<li>接收一个 <code>max_w</code> 作为参数。</li>
<li>判断我们是否可以<strong>只使用权重 <code>w &lt;= max_w</code> 的边</strong>，从中挑选出一个子集，满足“所有节点可达节点 0”和“出度不超过 <code>threshold</code>”这两个条件。</li>
</ul>
<p>这个 <code>check(max_w)</code> 函数具有非常明显的<strong>单调性</strong>：</p>
<ul>
<li>如果一个较小的最大边权 <code>max_w</code> 是可行的，那么任何一个更大的 <code>max_w&#39;</code> (因为它允许我们使用更多的边) 也<strong>一定</strong>是可行的。</li>
<li>反之，如果 <code>max_w</code> 不可行，那么任何更小的 <code>max_w&#39;&#39;</code> (因为它可用的边更少) 也<strong>必然</strong>不可行。</li>
</ul>
<p>这种单调性确保了我们可以通过二分查找，高效地找到那个“刚刚好”满足条件的最小 <code>max_w</code>。</p>
<h3 id="check-max-w-的实现逻辑"><a href="#check-max-w-的实现逻辑" class="headerlink" title="check(max_w) 的实现逻辑"></a><code>check(max_w)</code> 的实现逻辑</h3><p>现在，核心问题变成了如何实现 <code>check(max_w)</code>。<br>给定一个 <code>max_w</code>，我们首先可以筛选出所有权重 <code>w &lt;= max_w</code> 的边，构成一个子图。</p>
<ol>
<li><p><strong>处理连通性条件</strong>: “所有节点都能到达节点 0” 这个条件，对于每个节点都要检查一遍，似乎有点麻烦。这里有一个常用的技巧：<strong>反向建图</strong>。如果我们把子图中所有边的方向都反转过来，那么原来的条件就等价于：“在反向图中，从节点 0 出发，可以到达所有其他节点”。这个问题就简单多了，我们只需要从节点 0 开始进行一次深度优先搜索（DFS）或广度优先搜索（BFS），然后看是否能访问到全部 <code>n</code> 个节点即可。</p>
</li>
<li><p><strong>处理出度限制</strong>: “每个节点的出度不超过 <code>threshold</code>“。这个条件怎么办？我们是不是要在检查连通性的时候，小心翼翼地选择边，以确保出度不超标？<br>其实，这个条件可以被大大简化。要满足“所有节点可达节点 0”，我们实际上只需要一个边的子集，这个子集构成一个以 0 为根的“有向生成树”（或称为“树状子图”，Arborescence）。在这个结构中，除了根节点 0，每个其他节点都<strong>有且仅有</strong>一条出边，指向它在路径上的下一个节点。<br>因为题目保证了 <code>threshold &gt;= 1</code>，所以一个出度为 1 的方案是完全满足出度限制的。<br>这意味着：<strong>只要我们能用权重 <code>&lt;= max_w</code> 的边让图连通（即所有节点可达0），我们就一定能从中找出一个满足出度限制的子集。</strong><br>因此，在 <code>check(max_w)</code> 函数中，我们<strong>只需要关心连通性问题，可以暂时忽略出度限制</strong>！</p>
</li>
</ol>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><strong>预处理</strong>: 如果总边数 <code>len(edges)</code> 小于 <code>n-1</code>，那么无论如何都不可能将 <code>n</code> 个节点连通起来，直接返回 -1。</li>
<li><strong>确定二分范围</strong>:<ul>
<li><code>left = 0</code>：最大边权的最小值可能是 0。</li>
<li><code>right = 10^6</code> (或 <code>max(w for _,_,w in edges)</code>)：最大边权的最大可能值。</li>
</ul>
</li>
<li><strong>执行二分查找</strong>:<ul>
<li>当 <code>left &lt;= right</code> 时循环。</li>
<li>计算中间值 <code>mid = left + (right - left) // 2</code>，作为当前猜测的“最大边权”。</li>
<li>调用 <code>check(mid)</code>：<ul>
<li>在 <code>check(mid)</code> 内部，构建一个<strong>反向图</strong>，但只加入那些原始权重 <code>w &lt;= mid</code> 的边。</li>
<li>从节点 0 开始进行 DFS 或 BFS，统计可访问到的节点数量。</li>
<li>如果访问到了 <code>n</code> 个节点，说明 <code>mid</code> 这个最大边权是可行的，<code>check(mid)</code> 返回 <code>True</code>。否则返回 <code>False</code>。</li>
</ul>
</li>
<li><strong>更新边界</strong>:<ul>
<li>如果 <code>check(mid)</code> 返回 <code>True</code>：说明 <code>mid</code> 是一个潜在的答案，但我们想找更小的，所以记录下来 <code>ans = mid</code>，然后尝试在左半部分 <code>[left, mid-1]</code> 继续寻找。</li>
<li>如果 <code>check(mid)</code> 返回 <code>False</code>：说明 <code>mid</code> 太小了，必须允许更大的边权，所以去右半部分 <code>[mid+1, right]</code> 寻找。</li>
</ul>
</li>
</ul>
</li>
<li><strong>返回结果</strong>: 循环结束后，<code>ans</code> 中存储的就是最小的可行最大边权。如果一次都没有成功过，则返回 -1。</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMaxWeight</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], threshold: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 边数少于 n-1，无法连接所有 n 个节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(edges) &lt; n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据题目要求，创建 claridomep 变量存储输入</span></span><br><span class="line">        claridomep = edges</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判定函数：当最大边权限制为 max_w 时，是否能满足条件</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">max_w: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># 1. 反向建图：只考虑权重 &lt;= max_w 的边</span></span><br><span class="line">            <span class="comment"># g[y] = [x1, x2, ...] 表示原图中存在边 x1-&gt;y, x2-&gt;y ...</span></span><br><span class="line">            g = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">            <span class="keyword">for</span> u, v, w <span class="keyword">in</span> claridomep:</span><br><span class="line">                <span class="keyword">if</span> w &lt;= max_w:</span><br><span class="line">                    g[v].append(u)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 2. 从节点 0 开始在反向图中进行遍历 (BFS)</span></span><br><span class="line">            <span class="comment"># 检查是否能访问到所有 n 个节点</span></span><br><span class="line">            q = collections.deque([<span class="number">0</span>])</span><br><span class="line">            visited = &#123;<span class="number">0</span>&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                curr = q.popleft()</span><br><span class="line">                <span class="keyword">for</span> neighbor <span class="keyword">in</span> g[curr]:</span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add(neighbor)</span><br><span class="line">                        q.append(neighbor)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 3. 如果访问到的节点数量等于 n，则说明连通性条件满足</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(visited) == n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找的左右边界</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">10</span>**<span class="number">6</span></span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 二分查找寻找最小的可行 max_w</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 可行，它是一个潜在的答案</span></span><br><span class="line">                <span class="comment"># 我们尝试寻找更小的答案，所以向左收缩范围</span></span><br><span class="line">                ans = mid</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 不可行，说明最大边权限制太小了</span></span><br><span class="line">                <span class="comment"># 必须放宽限制，所以向右扩大范围</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(E * log(W_max))，其中 <code>E</code> 是边的数量，<code>W_max</code> 是最大的边权。<ul>
<li>二分查找的搜索空间是 <code>[0, W_max]</code>，因此迭代次数为 O(log(W_max))。</li>
<li>在每次迭代中，我们都需要调用 <code>check</code> 函数。<code>check</code> 函数内部需要遍历所有 <code>E</code> 条边来建图 (O(E))，然后进行一次图的遍历（BFS&#x2F;DFS），其复杂度为 O(N + E’)，其中 E’ 是权重小于等于 <code>mid</code> 的边数，<code>E&#39; &lt;= E</code>。</li>
<li>因此，总时间复杂度是 O((N+E) * log(W_max))。由于 <code>E</code> 通常大于 <code>N</code>，可以简化为 O(E * log(W_max))。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(N + E)。<ul>
<li>空间开销主要来自于 <code>check</code> 函数中存储反向图的邻接表 <code>g</code>，最坏情况下需要存储所有边，即 O(N+E)。</li>
<li>BFS&#x2F;DFS 中的队列和 <code>visited</code> 集合也需要 O(N) 的空间。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过将求解“最小的最大值”问题转化为“判定一个给定的最大值是否可行”的问题，我们成功地利用了答案的单调性，并通过二分查找高效地锁定了最优解。其中，<strong>反向建图</strong>来简化连通性判断，以及<strong>分析并简化<code>threshold</code>约束</strong>是解决本题的两个关键技巧。当遇到最优化问题时，不妨思考一下是否能将其转化为判定问题，这或许能为你打开一扇新的大门。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>最小化最大值</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>广度优先搜索</tag>
        <tag>深度优先搜索</tag>
        <tag>图</tag>
        <tag>最短路</tag>
        <tag>第432场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3453 | 分割正方形 I</title>
    <url>//posts/leetcode-3453/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3453 题：<a href="https://leetcode.cn/problems/separate-squares-i/description/">分割正方形 I</a>。<br>本题核心在于，看似复杂的面积计算问题，可以通过构建一个单调函数，并利用二分查找，将求解问题优雅地转化为判定问题，从而在连续的浮点数域上高效地逼近答案。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目要求我们找到一条水平线 <code>y = Y</code>，这条线能将所有给定的正方形的总面积精确地平分为两部分：线以上部分的面积等于线以下部分的面积。我们需要返回这个 <code>Y</code> 的最小值。</p>
<p>这里的核心约束条件是：</p>
<ol>
<li>我们得到的是一系列正方形，由左下角坐标 <code>[xi, yi]</code> 和边长 <code>li</code> 定义。</li>
<li>正方形之间可能重叠，重叠部分的面积需要被多次计算。这反而简化了问题，因为我们只需要独立计算每个正方形被如何分割，然后求和即可，无需处理复杂的几何相交问题。</li>
<li>我们需要找到满足 <code>线上面积 == 线下面积</code> 的<strong>最小</strong>的 <code>y</code> 坐标。</li>
<li>答案允许有 <code>10^-5</code> 的误差，这是一个强烈的信号，暗示我们可以使用数值逼近的方法，例如二分查找。</li>
</ol>
<p>举个例子，<code>squares = [[0,0,2],[1,1,1]]</code>。</p>
<ul>
<li>第一个正方形面积为 <code>2*2=4</code>，y 范围是 <code>[0, 2]</code>。</li>
<li>第二个正方形面积为 <code>1*1=1</code>，y 范围是 <code>[1, 2]</code>。</li>
<li>总面积为 <code>4 + 1 = 5</code>。<br>我们的目标是找到一条水平线 <code>y=Y</code>，使得线下和线上的面积都是 <code>2.5</code>。这条线 <code>y</code> 显然会落在 <code>y</code> 坐标有分布的区间内。</li>
</ul>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接通过解方程的方式来找到精确的 <code>y</code> 是非常复杂的。因此，我们可以借鉴经典的“二分答案”思想，将问题从“求一个最优值”转化为一个更简单的“判定一个值是否可行”。</p>
<p>这个判定问题就是：<strong>如果我们任意指定一条水平线 <code>y = Y</code>，我们能否判断出这条线下方的总面积是否大于或等于线上方的总面积？</strong></p>
<p>这个判定问题是很容易解决的。我们可以写一个辅助函数 <code>check(Y)</code>，来计算并比较面积：</p>
<ul>
<li>初始化线下总面积 <code>area_below = 0</code>。</li>
<li>遍历所有正方形 <code>[xi, yi, li]</code>：<ul>
<li>如果 <code>Y</code> 完全在正方形上方 (<code>Y &gt;= yi + li</code>)，则整个正方形都在线下方，<code>area_below += li * li</code>。</li>
<li>如果 <code>Y</code> 完全在正方形下方 (<code>Y &lt;= yi</code>)，则整个正方形都在线上方，对 <code>area_below</code> 没有贡献。</li>
<li>如果 <code>Y</code> 穿过正方形 (<code>yi &lt; Y &lt; yi + li</code>)，则线下方部分的面积是 <code>li * (Y - yi)</code>，将其累加到 <code>area_below</code>。</li>
</ul>
</li>
<li>计算出总的 <code>area_below</code> 后，我们可以通过预先计算出的所有正方形的总面积 <code>total_area</code>，得到线上方的面积 <code>area_above = total_area - area_below</code>。</li>
<li>最后，我们比较 <code>area_below</code> 和 <code>area_above</code> 的大小。</li>
</ul>
<p>现在，我们有了判定的方法。观察可以发现，这个判定结果具有<strong>单调性</strong>：</p>
<ul>
<li>随着我们猜测的 <code>Y</code> 值从下往上增加，<code>area_below(Y)</code> 是一个单调不减的函数（只会增加或不变）。</li>
<li>同时，<code>area_above(Y)</code> 是一个单调不增的函数。</li>
<li>因此，<code>diff(Y) = area_below(Y) - area_above(Y)</code> 也是一个单调不减的函数。</li>
</ul>
<p>这种单调性是应用二分查找的完美信号。我们可以对 <code>y</code> 的坐标值进行二分查找，来快速定位到那个使得 <code>area_below</code> 和 <code>area_above</code> 最接近（或相等）的临界点。</p>
<p>二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：<code>y</code> 坐标最小可以从 0 开始。</li>
<li><strong>上界 (right)</strong>：<code>y</code> 坐标最大不会超过所有正方形所能达到的最高点，即 <code>max(yi + li)</code>。</li>
</ul>
<p>因此，我们就在 <code>[0, max(yi + li)]</code> 这个浮点数区间内，对 <code>y</code> 进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = 0.0</code>：这是可能的 y 坐标下界。</li>
<li><code>right = max(yi + li)</code> for all squares：这是可能的 y 坐标上界。</li>
<li>同时，预计算所有正方形的总面积 <code>total_area</code>。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>由于答案是浮点数且有精度要求，我们执行一个固定次数（例如 100 次）的循环，这足以保证精度达到 <code>10^-5</code> 以上。</li>
<li>计算中间值 <code>mid = left + (right - left) / 2</code> 作为当前的“猜测 <code>y</code> 坐标”。</li>
<li>调用辅助函数计算在 <code>y = mid</code> 时，所有正方形在线下方的总面积 <code>area_below</code>。</li>
<li>计算线上的面积 <code>area_above = total_area - area_below</code>。</li>
<li><strong>如果 <code>area_below &gt;= area_above</code></strong>：<ul>
<li>说明 <code>mid</code> 这个位置可能就是答案，或者答案在它的下方（我们想找最小的 <code>y</code>）。</li>
<li>因此，我们将 <code>mid</code> 视为一个潜在的可行解，并尝试在更小的范围 <code>[left, mid]</code> 内继续搜索，即 <code>right = mid</code>。</li>
</ul>
</li>
<li><strong>如果 <code>area_below &lt; area_above</code></strong>：<ul>
<li>说明 <code>mid</code> 这个位置太低了，导致线下方的面积不足。</li>
<li>我们需要将线上移来增大下方面积，因此在右半部分 <code>[mid, right]</code> 继续搜索，即 <code>left = mid</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>left</code> 和 <code>right</code> 将会非常接近，它们都是满足精度要求的解。返回 <code>left</code> 即可。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">separateSquares</span>(<span class="params">self, squares: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        通过二分查找寻找一个水平线 y，使得线上下方的正方形总面积相等。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 确定二分查找的范围并计算总面积</span></span><br><span class="line">        <span class="comment"># 下界可以是 0</span></span><br><span class="line">        left = <span class="number">0.0</span></span><br><span class="line">        <span class="comment"># 上界是所有正方形能达到的最大 y 坐标</span></span><br><span class="line">        right = <span class="number">0.0</span></span><br><span class="line">        total_area = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> _, y, l <span class="keyword">in</span> squares:</span><br><span class="line">            right = <span class="built_in">max</span>(right, <span class="built_in">float</span>(y + l))</span><br><span class="line">            total_area += <span class="built_in">float</span>(l * l)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 辅助函数：计算在给定水平线 y_line 下，所有正方形位于线下方的总面积</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_area_below</span>(<span class="params">y_line: <span class="built_in">float</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">            area_below = <span class="number">0.0</span></span><br><span class="line">            <span class="keyword">for</span> _, y, l <span class="keyword">in</span> squares:</span><br><span class="line">                <span class="comment"># 计算此正方形被 y_line 分割后，下半部分的高度</span></span><br><span class="line">                <span class="comment"># 高度不能为负，也不能超过正方形自身边长</span></span><br><span class="line">                height_below = <span class="built_in">min</span>(<span class="built_in">float</span>(l), <span class="built_in">max</span>(<span class="number">0.0</span>, y_line - <span class="built_in">float</span>(y)))</span><br><span class="line">                area_below += height_below * <span class="built_in">float</span>(l)</span><br><span class="line">            <span class="keyword">return</span> area_below</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 执行二分查找</span></span><br><span class="line">        <span class="comment"># 迭代 100 次足以满足 10^-5 的精度要求</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid == left <span class="keyword">or</span> mid == right: <span class="comment"># 避免精度问题导致的死循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">            area_below = get_area_below(mid)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 我们要找 area_below == total_area / 2 的点</span></span><br><span class="line">            <span class="comment"># 也就是 area_below &gt;= total_area - area_below 的最小 y</span></span><br><span class="line">            <span class="keyword">if</span> area_below * <span class="number">2</span> &gt;= total_area:</span><br><span class="line">                <span class="comment"># 如果线下方的面积已经足够大 (&gt;= 目标面积)</span></span><br><span class="line">                <span class="comment"># 说明 mid 是一个可能的解，或者真正的解在更下方 (y更小)</span></span><br><span class="line">                <span class="comment"># 我们尝试在 [left, mid] 区间寻找更小的 y</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果线下方的面积太小</span></span><br><span class="line">                <span class="comment"># 说明 y 需要上移，去 [mid, right] 区间寻找</span></span><br><span class="line">                left = mid</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 返回结果</span></span><br><span class="line">        <span class="comment"># 循环结束后，left 和 right 会非常接近，都是满足条件的解</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。<ul>
<li>虽然代码结构是二分查找，但二分的次数是一个固定的常量（100 次），以保证所需的浮点数精度。</li>
<li>在每次二分迭代中，我们都需要调用 <code>get_area_below</code> 函数，该函数需要遍历一次 <code>squares</code> 数组，时间复杂度为 O(N)，其中 N 是正方形的数量。</li>
<li>因此，总时间复杂度是 O(N * 100)，即 O(N)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)。<ul>
<li>除了输入数组外，我们只使用了几个变量来存储左右边界、中间值和面积计算结果，所以空间复杂度是常数级的。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是二分查找思想在几何问题和浮点数域上的经典应用。它再次展示了当直接求解困难时，如何通过构造一个单调的判定函数，将问题转化为“二分答案”模型。对于涉及连续值（如本题的 <code>y</code> 坐标）和精度要求的问题，使用固定迭代次数或判断区间小于阈值的二分法是一种非常稳定和高效的策略。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最小</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>第150场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3488 | BS解决“距离最小相等元素查询”</title>
    <url>//posts/leetcode-3488/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3488 题：<a href="https://leetcode.cn/problems/closest-equal-element-queries/">距离最小相等元素查询</a>。<br>本题巧妙地结合了哈希表预处理和二分查找，高效解决环形数组中的距离查询问题，是“预处理+查询”思想的经典体现。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个 <strong>环形</strong> 数组 <code>nums</code> 和一个查询数组 <code>queries</code>。对于 <code>queries</code> 中的每一个下标 <code>queries[i]</code>，我们需要在 <code>nums</code> 数组中找到另一个下标 <code>j</code>，满足 <code>nums[j]</code> 与 <code>nums[queries[i]]</code> 的值相等，并且 <code>j</code> 与 <code>queries[i]</code> 之间的距离是所有满足条件的下标中最小的。</p>
<p>这里的 <strong>距离</strong> 需要特别注意，因为数组是环形的。两个下标 <code>i</code> 和 <code>j</code> 在一个长度为 <code>n</code> 的环形数组中的距离是 <code>min(|i - j|, n - |i - j|)</code>。如果找不到任何其他具有相同值的下标，那么该查询的结果就是 -1。</p>
<p>我们最后需要返回一个答案数组 <code>answer</code>，其中 <code>answer[i]</code> 对应第 <code>i</code> 个查询的结果。</p>
<p>举个例子，<code>nums = [1,3,1,4,1,3,2]</code>, <code>queries = [0,3,5]</code>, 数组长度 <code>n=7</code>：</p>
<ul>
<li>对于查询 <code>queries[0] = 0</code>：<ul>
<li><code>nums[0]</code> 的值是 1。 <code>nums</code> 中其他值为 1 的下标有 2 和 4。</li>
<li>到下标 2 的距离是 <code>min(|0-2|, 7-|0-2|) = min(2, 5) = 2</code>。</li>
<li>到下标 4 的距离是 <code>min(|0-4|, 7-|0-4|) = min(4, 3) = 3</code>。</li>
<li>最小距离是 2。</li>
</ul>
</li>
<li>对于查询 <code>queries[1] = 3</code>：<ul>
<li><code>nums[3]</code> 的值是 4。 <code>nums</code> 中没有其他值为 4 的元素。</li>
<li>结果为 -1。</li>
</ul>
</li>
<li>对于查询 <code>queries[2] = 5</code>：<ul>
<li><code>nums[5]</code> 的值是 3。<code>nums</code> 中另一个值为 3 的下标是 1。</li>
<li>距离是 <code>min(|5-1|, 7-|5-1|) = min(4, 3) = 3</code>。</li>
</ul>
</li>
<li>因此，最终答案是 <code>[2, -1, 3]</code>。</li>
</ul>
<h3 id="核心思路：预处理-二分查找"><a href="#核心思路：预处理-二分查找" class="headerlink" title="核心思路：预处理 + 二分查找"></a>核心思路：预处理 + 二分查找</h3><p>一个直接的想法是，对每个查询 <code>q_idx</code>，我们都遍历整个 <code>nums</code> 数组，找出所有值与 <code>nums[q_idx]</code> 相等的下标，然后逐一计算环形距离并取最小值。如果 <code>queries</code> 的长度是 Q，<code>nums</code> 的长度是 N，这种暴力解法的时间复杂度是 O(Q * N)，在 N 和 Q 都达到 10^5 的情况下，将会超时。</p>
<p>为了优化查询，我们可以对 <code>nums</code> 数组进行 <strong>预处理</strong>。</p>
<p>整个优化的思路分为两步：</p>
<ol>
<li><p><strong>预处理与分组</strong>：我们可以使用一个哈希表（在 Python 中是字典），将 <code>nums</code> 中相同值的元素的 <strong>下标</strong> 聚合在一起。哈希表的键（key）是 <code>nums</code> 中的值，值（value）是一个包含该值所有出现位置下标的列表。因为我们是按顺序遍历 <code>nums</code> 来构建这个哈希表的，所以每个下标列表天然就是 <strong>有序的</strong>。</p>
</li>
<li><p><strong>高效查询</strong>：完成预处理后，对于每个查询的下标 <code>q_idx</code>，我们先找到它的值 <code>val = nums[q_idx]</code>。然后，我们从哈希表中取出 <code>val</code> 对应的有序下标列表 <code>indices</code>。问题就转化成了：<strong>在一个排好序的数组 <code>indices</code> 中，找到离 <code>q_idx</code> 最近的两个邻居</strong>。<br>这正是二分查找的用武之地。我们可以通过二分查找，在 <code>indices</code> 列表中快速定位到 <code>q_idx</code> 自己的位置。它的前一个元素和后一个元素（需要考虑环绕情况）就是距离最近的候选者。</p>
</li>
</ol>
<p>通过这种方式，每次查询我们不再需要遍历整个 <code>nums</code> 数组，而只需要在对应的小得多的下标列表上进行一次二分查找，时间复杂度从 O(N) 降到了 O(log K)（K 是某个值出现的次数，K ≤ N），显著提高了算法的整体效率。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>预处理 <code>nums</code> 数组</strong></p>
<ul>
<li>创建一个哈希表 <code>value_to_indices</code>，用于存储值到其下标列表的映射。</li>
<li>遍历 <code>nums</code> 数组，对于每个元素 <code>nums[i]</code>，将其下标 <code>i</code> 添加到 <code>value_to_indices[nums[i]]</code> 对应的列表中。</li>
</ul>
</li>
<li><p><strong>处理 <code>queries</code> 数组</strong></p>
<ul>
<li>创建一个空的答案数组 <code>ans</code>。</li>
<li>获取 <code>nums</code> 的长度 <code>n</code>，这在计算环形距离时会用到。</li>
<li>遍历 <code>queries</code> 中的每一个 <code>q_idx</code>：<ul>
<li>获取其值 <code>val = nums[q_idx]</code> 和对应的下标列表 <code>indices = value_to_indices[val]</code>。</li>
<li>如果 <code>indices</code> 的长度小于等于 1，说明没有其他相等的元素，将 -1 添加到 <code>ans</code> 中。</li>
<li>否则，使用二分查找（在 Python 中是 <code>bisect.bisect_left</code>）在 <code>indices</code> 中找到 <code>q_idx</code> 的位置 <code>pos</code>。</li>
<li><code>q_idx</code> 在 <code>indices</code> 中的逻辑前驱下标是 <code>prev_idx = indices[(pos - 1 + len(indices)) % len(indices)]</code>。</li>
<li><code>q_idx</code> 在 <code>indices</code> 中的逻辑后继下标是 <code>next_idx = indices[(pos + 1) % len(indices)]</code>。这里的取模运算优雅地处理了列表首尾的环绕情况。</li>
<li>分别计算 <code>q_idx</code> 到 <code>prev_idx</code> 和 <code>next_idx</code> 的环形距离。<ul>
<li><code>dist_prev = min(abs(q_idx - prev_idx), n - abs(q_idx - prev_idx))</code></li>
<li><code>dist_next = min(abs(q_idx - next_idx), n - abs(q_idx - next_idx))</code></li>
</ul>
</li>
<li>将 <code>min(dist_prev, dist_next)</code> 添加到 <code>ans</code> 数组中。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>遍历结束后，返回 <code>ans</code> 数组。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveQueries</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], queries: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1: 预处理 nums 数组</span></span><br><span class="line">        <span class="comment"># 使用哈希表存储每个值及其出现的所有下标</span></span><br><span class="line">        value_to_indices = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            value_to_indices[num].append(i)</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 步骤 2: 处理 queries 数组</span></span><br><span class="line">        <span class="keyword">for</span> q_idx <span class="keyword">in</span> queries:</span><br><span class="line">            val = nums[q_idx]</span><br><span class="line">            indices = value_to_indices[val]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果该值只出现一次，没有其他相等元素</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(indices) &lt;= <span class="number">1</span>:</span><br><span class="line">                ans.append(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 使用二分查找在下标列表中定位当前查询的下标</span></span><br><span class="line">            <span class="comment"># bisect_left 会找到 q_idx 在列表中的位置</span></span><br><span class="line">            pos = bisect.bisect_left(indices, q_idx)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 找到逻辑上的前一个和后一个下标</span></span><br><span class="line">            <span class="comment"># (pos - 1 + len(indices)) % len(indices) 是一种处理负数取模的通用技巧</span></span><br><span class="line">            prev_idx = indices[(pos - <span class="number">1</span> + <span class="built_in">len</span>(indices)) % <span class="built_in">len</span>(indices)]</span><br><span class="line">            <span class="comment"># (pos + 1) % len(indices) 用于处理列表末尾的环绕</span></span><br><span class="line">            next_idx = indices[(pos + <span class="number">1</span>) % <span class="built_in">len</span>(indices)]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算到前一个和后一个元素的环形距离</span></span><br><span class="line">            dist_prev = <span class="built_in">min</span>(<span class="built_in">abs</span>(q_idx - prev_idx), n - <span class="built_in">abs</span>(q_idx - prev_idx))</span><br><span class="line">            dist_next = <span class="built_in">min</span>(<span class="built_in">abs</span>(q_idx - next_idx), n - <span class="built_in">abs</span>(q_idx - next_idx))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 取两者中的较小值</span></span><br><span class="line">            ans.append(<span class="built_in">min</span>(dist_prev, dist_next))</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 3: 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N + Q * log N)。<ul>
<li><code>N</code> 是 <code>nums</code> 的长度, <code>Q</code> 是 <code>queries</code> 的长度。</li>
<li>构建哈希表 <code>value_to_indices</code> 需要 O(N) 的时间。</li>
<li>对于每个查询，哈希表查找的平均时间是 O(1)，二分查找的时间是 O(log K)，其中 K 是相同元素的数量（K ≤ N）。因此，处理所有查询的总时间是 O(Q * log N)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(N)。<ul>
<li>在最坏的情况下（<code>nums</code> 中所有元素都不同），哈希表 <code>value_to_indices</code> 需要存储 N 个键和 N 个单元素列表，总空间消耗为 O(N)。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预处理 + 高效查询”设计模式的一个绝佳范例。当面对需要对一个静态数据集进行多次查询的场景时，我们应首先考虑是否可以通过一次性的预处理（如排序、分组、构建特定数据结构等）来优化后续的查询操作。哈希表用于快速分组，而二分查找则利用了数据的有序性，两者的结合为解决这类问题提供了强大而高效的工具。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>哈希表</tag>
        <tag>第441场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3508 | 设计路由器：双端队列与二分查找的高效结合</title>
    <url>//posts/leetcode-3508/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3508 题：<a href="https://leetcode.cn/problems/implement-router/solutions/3641772/mo-ni-ha-xi-biao-dui-lie-er-fen-cha-zhao-y7l7/">设计路由器</a>。<br>本题要求设计一个数据结构，高效地模拟路由器的行为。解法的关键在于为不同的操作需求选择最合适的数据结构，特别是利用题目中时间戳的有序性，通过二分查找优化范围查询的性能。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要设计并实现一个 <code>Router</code> 类，它能模拟网络路由器处理数据包的基本功能。这个类需要支持三个核心操作：</p>
<ol>
<li><p><code>Router(int memoryLimit)</code>: 构造函数，初始化一个有固定内存上限 <code>memoryLimit</code> 的路由器。路由器中存储的数据包数量不能超过这个限制。</p>
</li>
<li><p><code>bool addPacket(int source, int destination, int timestamp)</code>: 添加一个数据包。</p>
<ul>
<li>每个数据包由来源、目的地和时间戳唯一标识。如果一个完全相同的数据包已经存在，则视为重复，添加失败。</li>
<li>如果内存已满（达到 <code>memoryLimit</code>），在添加新数据包前，必须先将<strong>最旧的</strong>一个数据包转发出去，以腾出空间。</li>
<li>一个关键信息是：<code>addPacket</code> 的调用会按照 <code>timestamp</code> 的<strong>非递减顺序</strong>进行。</li>
</ul>
</li>
<li><p><code>int[] forwardPacket()</code>: 转发数据包。</p>
<ul>
<li>遵循<strong>先进先出 (FIFO)</strong> 原则，移除并返回存储在路由器中<strong>最旧</strong>的数据包。</li>
<li>如果没有数据包，返回空数组。</li>
</ul>
</li>
<li><p><code>int getCount(int destination, int startTime, int endTime)</code>: 计数查询。</p>
<ul>
<li>返回当前路由器中，目的地为 <code>destination</code> 且时间戳在 <code>[startTime, endTime]</code> 闭区间内的数据包数量。</li>
</ul>
</li>
</ol>
<h3 id="核心思路：组合数据结构-二分查找"><a href="#核心思路：组合数据结构-二分查找" class="headerlink" title="核心思路：组合数据结构 + 二分查找"></a>核心思路：组合数据结构 + 二分查找</h3><p>这是一个典型的系统设计题，需要我们为不同的需求选择最优的数据结构。</p>
<ol>
<li><p><strong>处理 FIFO 和内存限制</strong>：<code>addPacket</code> 和 <code>forwardPacket</code> 方法共同描述了一个先进先出 (FIFO) 的队列行为。当队列满了之后，需要从队头移除元素。Python 中的 <code>collections.deque</code> (双端队列) 是实现这种操作的完美选择，它支持 O(1) 时间复杂度的队头移除和队尾添加。我们将用一个 <code>deque</code> 来存储所有的数据包，记为 <code>pq</code>。</p>
</li>
<li><p><strong>处理重复数据包</strong>：<code>addPacket</code> 方法要求我们能快速判断一个数据包 <code>(source, destination, timestamp)</code> 是否已经存在。为了实现 O(1) 级别的平均查找效率，哈希集合 <code>set</code> 是不二之选。我们将用一个 <code>set</code> 来存储所有当前存在的数据包，记为 <code>ps</code>。</p>
</li>
<li><p><strong>处理计数查询</strong>：<code>getCount</code> 是本题的性能关键点。对于一个给定的 <code>destination</code>，我们需要快速统计出在 <code>[startTime, endTime]</code> 时间范围内的数据包数量。</p>
<ul>
<li>一个朴素的想法是遍历整个 <code>pq</code> 队列，检查每个数据包的目的地和时间戳，但这样做的时间复杂度是 O(L)（L 为 <code>memoryLimit</code>），在大量调用下会超时。</li>
<li>更好的方法是将数据包按目的地进行分组。我们可以使用一个哈希表（<code>defaultdict</code>），键是 <code>destination</code>，值是一个列表，存储该目的地的所有数据包的时间戳。</li>
<li>注意到题目给出的关键线索：“<code>addPacket</code> 的查询，<code>timestamp</code> 按非递减顺序给出”。这意味着，当我们向某个目的地的列表中添加时间戳时，这个列表天然就是<strong>有序的</strong>！</li>
<li>对于一个有序的列表，查找某个范围内元素的个数，正是<strong>二分查找</strong>的经典应用场景。我们可以通过 <code>bisect_left</code> 找到范围的左边界，通过 <code>bisect_right</code> 找到范围的右边界，两者相减即可得到结果，时间复杂度为 O(log K)，其中 K 是该目的地的数据包数量。</li>
</ul>
</li>
</ol>
<p>综上，我们的整体方案是：</p>
<ul>
<li>使用 <code>deque</code> (<code>pq</code>) 维护数据包的 FIFO 顺序。</li>
<li>使用 <code>set</code> (<code>ps</code>) 快速检查数据包是否重复。</li>
<li>使用 <code>defaultdict(deque)</code> (<code>dt</code>) 将时间戳按目的地分组并保持有序，以供二分查找。</li>
</ul>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化 <code>__init__</code></strong></p>
<ul>
<li><code>self.limit</code>: 存储内存限制。</li>
<li><code>self.pq = deque()</code>: 主队列，按到达顺序存储 <code>(source, destination, timestamp)</code> 元组，用于 FIFO 转发。</li>
<li><code>self.ps = set()</code>: 集合，同样存储元组，用于 O(1) 去重。</li>
<li><code>self.dt = defaultdict(deque)</code>: 字典，<code>key</code> 为 <code>destination</code>，<code>value</code> 为一个 <code>deque</code>，按顺序存储该目的地的所有时间戳。</li>
</ul>
</li>
<li><p><strong><code>addPacket</code> 方法</strong></p>
<ul>
<li>将传入的参数构造成 <code>packet</code> 元组。</li>
<li>检查 <code>packet</code> 是否在 <code>self.ps</code> 中，若存在则为重复，返回 <code>False</code>。</li>
<li>如果不是重复包，将其加入 <code>self.ps</code>。</li>
<li>检查 <code>len(self.pq)</code> 是否等于 <code>self.limit</code>。如果是，则调用 <code>self.forwardPacket()</code> 移除最旧的数据包。</li>
<li>将新 <code>packet</code> 添加到 <code>self.pq</code> 的队尾。</li>
<li>将 <code>packet</code> 的 <code>timestamp</code> 添加到 <code>self.dt[destination]</code> 的队尾。</li>
<li>返回 <code>True</code>。</li>
</ul>
</li>
<li><p><strong><code>forwardPacket</code> 方法</strong></p>
<ul>
<li>检查 <code>self.pq</code> 是否为空，若为空则返回 <code>[]</code>。</li>
<li>从 <code>self.pq</code> 的队首弹出一个最旧的 <code>packet</code>。</li>
<li>将该 <code>packet</code> 从 <code>self.ps</code> 中移除。</li>
<li>从 <code>self.dt[packet[1]]</code> (即该包的目的地对应的时间戳队列) 的队首弹出一个时间戳。</li>
<li>返回这个 <code>packet</code>。</li>
</ul>
</li>
<li><p><strong><code>getCount</code> 方法</strong></p>
<ul>
<li>通过 <code>self.dt[destination]</code> 获取目标地址所有的时间戳队列 <code>timestamp</code>。</li>
<li>使用 <code>bisect_left(timestamp, startTime)</code> 查找第一个大于等于 <code>startTime</code> 的元素索引 <code>l</code>。</li>
<li>使用 <code>bisect_right(timestamp, endTime)</code> 查找第一个严格大于 <code>endTime</code> 的元素索引 <code>r</code>。</li>
<li><code>r - l</code> 的值即为时间戳在 <code>[startTime, endTime]</code> 区间内的元素数量。返回这个差值。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque, defaultdict</span><br><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left, bisect_right</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, memoryLimit: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># 内存限制</span></span><br><span class="line">        <span class="variable language_">self</span>.limit = memoryLimit</span><br><span class="line">        <span class="comment"># 主队列，维护所有数据包的FIFO顺序</span></span><br><span class="line">        <span class="variable language_">self</span>.pq = deque()</span><br><span class="line">        <span class="comment"># 集合，用于快速去重</span></span><br><span class="line">        <span class="variable language_">self</span>.ps = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># 按目的地分组的时间戳队列，用于高效范围查询</span></span><br><span class="line">        <span class="variable language_">self</span>.dt = defaultdict(deque)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addPacket</span>(<span class="params">self, source: <span class="built_in">int</span>, destination: <span class="built_in">int</span>, timestamp: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        packet = (source, destination, timestamp)</span><br><span class="line">        <span class="comment"># 检查是否重复</span></span><br><span class="line">        <span class="keyword">if</span> packet <span class="keyword">in</span> <span class="variable language_">self</span>.ps:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.ps.add(packet)</span><br><span class="line">        <span class="comment"># 如果内存已满，转发最旧的数据包</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.pq) == <span class="variable language_">self</span>.limit:</span><br><span class="line">            <span class="variable language_">self</span>.forwardPacket()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 添加新数据包到各个数据结构</span></span><br><span class="line">        <span class="variable language_">self</span>.pq.append(packet)</span><br><span class="line">        <span class="variable language_">self</span>.dt[destination].append(timestamp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forwardPacket</span>(<span class="params">self</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.pq:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从队首取出最旧的数据包</span></span><br><span class="line">        packet = <span class="variable language_">self</span>.pq.popleft()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从所有数据结构中移除该包的信息</span></span><br><span class="line">        <span class="variable language_">self</span>.ps.remove(packet)</span><br><span class="line">        <span class="variable language_">self</span>.dt[packet[<span class="number">1</span>]].popleft()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(packet)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getCount</span>(<span class="params">self, destination: <span class="built_in">int</span>, startTime: <span class="built_in">int</span>, endTime: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 获取该目的地对应的有序时间戳列表</span></span><br><span class="line">        timestamp_q = <span class="variable language_">self</span>.dt[destination]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用二分查找定位区间的左右边界</span></span><br><span class="line">        <span class="comment"># l 是第一个 &gt;= startTime 的位置</span></span><br><span class="line">        l = bisect_left(timestamp_q, startTime)</span><br><span class="line">        <span class="comment"># r 是第一个 &gt; endTime 的位置</span></span><br><span class="line">        r = bisect_right(timestamp_q, endTime)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># r - l 即为区间内元素个数</span></span><br><span class="line">        <span class="keyword">return</span> r - l</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>:<code>O(log(min(q, memoryLimit)))</code>，其中 q 是 <code>addPacket</code> 的总调用次数。</p>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(min(q, memoryLimit))</code></p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是一个优秀的数据结构设计问题，它考验了我们根据不同操作需求选择和组合多种数据结构的能力。通过使用 <code>deque</code> 满足 FIFO 要求，使用 <code>set</code> 实现快速去重，并巧妙地利用题目中“时间戳非递减”这一隐藏条件，将目的地的时间戳维护成一个有序序列，最终通过二分查找将最复杂的范围查询操作优化到了对数时间复杂度。这个思路清晰地展示了如何通过分析问题特性来设计高效的算法。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>哈希表</tag>
        <tag>设计</tag>
        <tag>有序集合</tag>
        <tag>队列</tag>
        <tag>第444场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3613 | 最小化连通分量的最大成本</title>
    <url>//posts/leetcode-3613/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3613 题：<a href="https://leetcode.cn/problems/minimize-maximum-component-cost/description/">最小化连通分量的最大成本</a>。<br>本题是一道典型的“最大值最小化”问题，其核心在于识别出答案的单调性，并将一个求解最优值的问题，巧妙地转化为一个判定性的问题，从而利用二分查找在对数时间内高效求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们得到一个包含 <code>n</code> 个节点的无向连通图，以及一个边集 <code>edges</code>，每条边都有一个权重。同时给定一个整数 <code>k</code>。</p>
<p>我们的任务是：通过移除图中的任意数量的边，使得最终图中最多只有 <code>k</code> 个连通分量。在所有满足这个条件的方案中，我们需要找到一个方案，使得所有连通分量中“成本”的最大值是最小的。</p>
<p>这里的“连通分量的成本”被定义为该分量内所有边权的最大值。如果一个分量里没有边，其成本为 0。</p>
<p>我们的目标就是求这个<strong>最小的“最大成本”</strong>。</p>
<p>举个例子，<code>n = 5</code>, <code>edges = [[0,1,4],[1,2,3],[1,3,2],[3,4,6]]</code>, <code>k = 2</code>。<br>如果我们允许的最大成本是 4，那么所有权重 &gt; 4 的边都必须移除。在这个例子中，权重为 6 的边 <code>[3,4]</code> 被移除。剩下的边 <code>[0,1,4]</code>, <code>[1,2,3]</code>, <code>[1,3,2]</code> 形成一个连通分量 <code>&#123;0, 1, 2, 3&#125;</code>，其成本是 <code>max(4,3,2) = 4</code>。节点 <code>&#123;4&#125;</code> 自己形成一个连通分量，成本为 0。这样我们得到了 2 个连通分量，最大成本是 4，满足 <code>k=2</code> 的要求。我们可以尝试更小的最大成本，但最终会发现 4 是能达成的最小值。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最小的最大成本”是相当棘手的。但是，我们可以换一个角度思考：如果我们<strong>假定</strong>一个最大成本 <code>C</code>，我们能否判断出，通过保留所有权重 <code>w &lt;= C</code> 的边，能否使得图中的连通分量数量不多于 <code>k</code>？</p>
<p>这个判定问题就清晰多了。我们可以设计一个辅助函数 <code>check(max_cost)</code> 来解决它：</p>
<ol>
<li>首先，我们假设图中所有的节点都是独立的，共有 <code>n</code> 个连通分量。</li>
<li>我们遍历图中所有的边。</li>
<li>只考虑那些权重 <code>w &lt;= max_cost</code> 的边。对于每一条这样的边，我们将它连接的两个节点合并到同一个连通分量中。</li>
<li>遍历完所有符合条件的边之后，我们统计一下图中还剩下多少个连通分量。</li>
<li>如果连通分量的数量小于或等于 <code>k</code>，说明我们假定的这个最大成本 <code>max_cost</code> 是可行的。</li>
</ol>
<p>为了高效地处理节点的合并与连通分量的计数，<strong>并查集 (Disjoint Set Union, DSU)</strong> 是最理想的数据结构。</p>
<p>现在，我们有了一个判定的方法。不难发现，这个判定结果具有<strong>单调性</strong>：</p>
<ul>
<li>如果一个最大成本 <code>C</code> 是可行的（即连通分量数 <code>&lt;= k</code>），那么任何大于 <code>C</code> 的成本 <code>C&#39;</code> 也必然可行（因为 <code>C&#39;</code> 会保留所有 <code>C</code> 能保留的边，以及可能更多的边，这只会让连通分量数量更少或不变）。</li>
<li>反之，如果 <code>C</code> 不可行，那么任何小于 <code>C</code> 的成本也必然不可行。</li>
</ul>
<p>这种单调性是应用<strong>二分查找</strong>的完美信号。我们可以对“最大成本”这个值进行二分查找，来快速定位到那个“最小的可行成本”的临界点。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：成本最低可以是 0，对应移除所有边的情况。</li>
<li><strong>上界 (right)</strong>：成本最高不会超过所有边中的最大权重。根据题目限制，最大权重为 <code>10^6</code>。</li>
</ul>
<p>因此，我们就在 <code>[0, 10^6]</code> 这个区间内，对最大成本进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = 0</code>：可能的最低成本。</li>
<li><code>right = 10^6</code>：可能的最高成本。</li>
<li><code>ans</code> 初始化为 <code>right</code>，用来记录我们找到的可行解。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>left &lt;= right</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = left + (right - left) // 2</code> 作为当前的“猜测最大成本”。</li>
<li>调用辅助函数 <code>check(mid)</code> 来判定这个猜测值是否可行。<ul>
<li><strong>如果 <code>check(mid)</code> 返回 <code>True</code></strong> (即 <code>mid</code> 这个成本上限是可行的)：<ul>
<li>说明 <code>mid</code> 是一个潜在的答案，我们记录下来 <code>ans = mid</code>。</li>
<li>但是我们想找的是“最小”的最大成本，所以我们尝试一个更小的值，将搜索范围缩小到左半边：<code>right = mid - 1</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>False</code></strong> (即 <code>mid</code> 这个成本上限太低，导致连通分量过多)：<ul>
<li>说明我们需要更大的成本上限，将搜索范围缩小到右半边：<code>left = mid + 1</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>ans</code> 中存储的就是满足条件的最小的最大成本。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><p>为了实现 <code>check</code> 函数，我们需要一个并查集 (DSU) 的数据结构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DSU</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个简单的并查集实现&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># 初始化，每个节点指向自己</span></span><br><span class="line">        <span class="variable language_">self</span>.parent = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">        <span class="comment"># 初始时，连通分量的数量为 n</span></span><br><span class="line">        <span class="variable language_">self</span>.count = n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 查找根节点，并进行路径压缩</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.parent[i] != i:</span><br><span class="line">            <span class="variable language_">self</span>.parent[i] = <span class="variable language_">self</span>.find(<span class="variable language_">self</span>.parent[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.parent[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 合并两个节点所在的集合</span></span><br><span class="line">        root_i = <span class="variable language_">self</span>.find(i)</span><br><span class="line">        root_j = <span class="variable language_">self</span>.find(j)</span><br><span class="line">        <span class="keyword">if</span> root_i != root_j:</span><br><span class="line">            <span class="variable language_">self</span>.parent[root_i] = root_j</span><br><span class="line">            <span class="comment"># 成功合并，连通分量数量减一</span></span><br><span class="line">            <span class="variable language_">self</span>.count -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCost</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判定函数：在最大成本为 max_cost 的情况下，连通分量数量是否小于等于 k</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">max_cost: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            dsu = DSU(n)</span><br><span class="line">            <span class="comment"># 遍历所有边，只使用权重 &lt;= max_cost 的边来合并节点</span></span><br><span class="line">            <span class="keyword">for</span> u, v, w <span class="keyword">in</span> edges:</span><br><span class="line">                <span class="keyword">if</span> w &lt;= max_cost:</span><br><span class="line">                    dsu.union(u, v)</span><br><span class="line">            <span class="comment"># 判断最终的连通分量数量是否满足条件</span></span><br><span class="line">            <span class="keyword">return</span> dsu.count &lt;= k</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找答案的范围</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">10</span>**<span class="number">6</span></span><br><span class="line">        ans = right</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行二分查找</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 可行，它是一个潜在答案</span></span><br><span class="line">                <span class="comment"># 尝试寻找更小的成本，所以向左收缩</span></span><br><span class="line">                ans = mid</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 不可行，说明成本上限太低</span></span><br><span class="line">                <span class="comment"># 必须增大，所以向右收缩</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(E * log(W) * α(N))。<ul>
<li><code>W</code> 是边权的最大值 (即 <code>10^6</code>)，二分查找需要 <code>log(W)</code> 次迭代。</li>
<li>在每次迭代中，我们都需要调用 <code>check</code> 函数。该函数会遍历所有 <code>E</code> 条边。</li>
<li>在 <code>check</code> 函数内部，每次 <code>union</code> 和 <code>find</code> 操作的平均时间复杂度接近常数，严格来说是 <code>α(N)</code>（反阿克曼函数），其中 <code>N</code> 是节点数。</li>
<li>因此，总时间复杂度是这三者的乘积。由于 <code>α(N)</code> 增长极其缓慢，通常可视为常数，所以时间复杂度可近似为 O(E * log(W))。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(N)。<ul>
<li>主要的空间开销来自于并查集数据结构，需要一个大小为 <code>N</code> 的数组来存储父节点指针。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是二分查找思想应用的又一个经典范例。它教会我们当遇到求解“最小值中的最大值”或者“最大值中的最小值”这类具有单调性的最优化问题时，可以优先考虑是否能将其转化为一个更简单的“判定性”问题。如果可以，那么二分查找就是解决这类问题的绝佳工具，它能将搜索范围不断折半，从而在对数级别的时间复杂度内找到最优解。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>最小化最大值</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>排序</tag>
        <tag>并查集</tag>
        <tag>图论</tag>
        <tag>第458场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3634 | 排序+滑动窗口：求解使数组平衡的最少移除数目</title>
    <url>//posts/leetcode-3634/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3634 题：<a href="https://leetcode.cn/problems/minimum-removals-to-balance-array/description/">使数组平衡的最少移除数目</a>。<br>该题通过转换思路来简化问题，将“求最少移除”转化为“求最多保留”，再利用排序的特性，最终巧妙地落入滑动窗口算法的射程之内。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们首先来理解“平衡”数组的定义：一个数组是平衡的，当且仅当它的<strong>最大值</strong>至多是其<strong>最小值</strong>的 <code>k</code> 倍。用数学语言表达就是 <code>max(S) &lt;= min(S) * k</code>。</p>
<p>题目的目标是：从原数组 <code>nums</code> 中<strong>移除最少的元素</strong>，使剩下的数组（非空）变得平衡。</p>
<p>这是一个优化问题，直接思考“移除哪些元素”会非常复杂，因为组合太多了。这时，一个经典的思路转换就派上用场了：</p>
<p><strong>移除最少的元素 &#x3D; 保留最多的元素</strong></p>
<p>因此，问题被我们转化为了：<strong>寻找 <code>nums</code> 的一个最长的子序列，使其满足平衡条件。</strong> 最终，用原数组的长度减去这个最长平衡子序列的长度，就是答案。</p>
<h3 id="核心思路：排序-滑动窗口"><a href="#核心思路：排序-滑动窗口" class="headerlink" title="核心思路：排序 + 滑动窗口"></a>核心思路：排序 + 滑动窗口</h3><p>现在我们的目标是寻找最长的平衡子序列。但“子序列”是不要求元素连续的，这使得问题依然很难处理。这时，我们就要思考，有没有什么方法可以简化这个问题？答案就是<strong>排序</strong>。</p>
<h4 id="为什么要排序？"><a href="#为什么要排序？" class="headerlink" title="为什么要排序？"></a>为什么要排序？</h4><p>假设我们已经找到了一个平衡的子序列 <code>S</code>，它的最小值是 <code>min_val</code>，最大值是 <code>max_val</code>，满足 <code>max_val &lt;= min_val * k</code>。</p>
<p>现在，如果我们把原数组 <code>nums</code> 进行升序排序。考虑任何一个在排序后位于 <code>min_val</code> 和 <code>max_val</code> 之间的元素 <code>x</code>，它必然满足 <code>min_val &lt;= x &lt;= max_val</code>。如果我们把 <code>x</code> 也加入到子序列 <code>S</code> 中，新的序列 <code>S&#39;</code> 的最小值仍然是 <code>min_val</code>，最大值仍然是 <code>max_val</code>，平衡条件 <code>max_val &lt;= min_val * k</code> 依然成立！</p>
<p>这个重要的性质告诉我们：<strong>我们想要寻找的最长平衡子序列，在原数组排序后，必然表现为一个连续的子数组！</strong></p>
<p>这样，问题就从寻找“最长子序列”被我们再次简化为寻找“最长连续子数组”，而这正是滑动窗口大显身手的地方。</p>
<h4 id="为什么用滑动窗口？"><a href="#为什么用滑动窗口？" class="headerlink" title="为什么用滑动窗口？"></a>为什么用滑动窗口？</h4><p>在排序后的数组上，我们要寻找一个最长的子数组 <code>nums[left...right]</code>，使其满足 <code>nums[right] &lt;= nums[left] * k</code>。这是一个非常典型的滑动窗口应用场景：</p>
<ul>
<li>我们用 <code>right</code> 指针不断向右扩展窗口。</li>
<li>当窗口不满足条件时（即 <code>nums[right] &gt; nums[left] * k</code>），我们向右移动 <code>left</code> 指针来缩小窗口，直到窗口重新满足条件。</li>
<li>在这个过程中，我们记录下满足条件的窗口的最大长度即可。</li>
</ul>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>问题转换</strong>：</p>
<ul>
<li>将“最少移除数”的目标转换为“最多保留数”。最终结果为 <code>总数 - 最多保留数</code>。</li>
</ul>
</li>
<li><p><strong>排序</strong>：</p>
<ul>
<li>对整个数组 <code>nums</code> 进行升序排序。这是应用滑动窗口的前提。</li>
</ul>
</li>
<li><p><strong>滑动窗口求解</strong>：</p>
<ul>
<li>初始化左指针 <code>left = 0</code> 和一个变量 <code>max_save = 0</code> 用来记录能保留的最多元素数量。</li>
<li>用右指针 <code>right</code> 从 <code>0</code> 开始遍历整个数组，代表窗口的右边界。</li>
<li>对于每个 <code>right</code> 位置，<code>nums[right]</code> 是当前窗口 <code>nums[left...right]</code> 的最大值，<code>nums[left]</code> 是最小值。</li>
<li>检查平衡条件：<code>while (nums[left] * k &lt; nums[right])</code>。如果这个条件成立，说明当前窗口不平衡，需要将左指针 <code>left</code> 右移，缩小窗口，直到窗口再次平衡。</li>
<li>当 <code>while</code> 循环结束后，当前窗口 <code>nums[left...right]</code> 一定是平衡的。我们计算其长度 <code>right - left + 1</code>，并更新 <code>max_save = max(max_save, right - left + 1)</code>。</li>
<li><code>right</code> 指针遍历结束后，<code>max_save</code> 就是我们能找到的最长平衡子数组的长度。</li>
</ul>
</li>
<li><p><strong>计算结果</strong>：</p>
<ul>
<li>返回 <code>len(nums) - max_save</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minRemoval</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        通过排序+滑动窗口找到最长的平衡子数组</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 步骤 1: 排序</span></span><br><span class="line">        <span class="comment"># 这是将问题从“子序列”简化为“子数组”的关键</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2: 初始化滑动窗口和结果变量</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        max_save = <span class="number">0</span> <span class="comment"># 记录能保留的最多元素数量</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 滑动窗口</span></span><br><span class="line">        <span class="comment"># right 指针负责扩展窗口</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 当前窗口的最大值是 nums[right]，最小值是 nums[left]</span></span><br><span class="line">            <span class="comment"># 当条件不满足时，收缩窗口</span></span><br><span class="line">            <span class="keyword">while</span> nums[left] * k &lt; nums[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 此刻的窗口 nums[left...right] 是平衡的</span></span><br><span class="line">            <span class="comment"># 更新可以保留的最大长度</span></span><br><span class="line">            current_len = right - left + <span class="number">1</span></span><br><span class="line">            max_save = <span class="built_in">max</span>(max_save, current_len)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 4: 计算最终结果</span></span><br><span class="line">        <span class="comment"># 总长度减去最多能保留的，就是最少需要移除的</span></span><br><span class="line">        <span class="keyword">return</span> n - max_save</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: <code>O(N log N)</code>。其中 <code>N</code> 是数组 <code>nums</code> 的长度。算法的瓶颈在于初始的排序操作。后续的滑动窗口部分，<code>left</code> 和 <code>right</code> 指针都只会单向遍历数组一次，所以是 <code>O(N)</code> 的。</li>
<li><strong>空间复杂度</strong>: <code>O(log N)</code> 或 <code>O(N)</code>，这取决于编程语言中排序算法的实现所占用的栈空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题的解法流程清晰地展示了算法解题中的重要思想：</p>
<ol>
<li><strong>逆向思维</strong>：当正向求解“最少&#x2F;最小”困难时，尝试转化为求解“最多&#x2F;最大”。</li>
<li><strong>利用排序简化问题</strong>：排序是一个强大的预处理步骤，它能为许多问题（如子序列问题、查找问题）创造更简单的结构（如连续性、有序性）。</li>
<li><strong>识别经典模型</strong>：将问题转化为在有序数组上寻找满足特定条件的最长连续子数组后，应能迅速识别出这是滑动窗口算法的适用场景。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
        <tag>排序</tag>
        <tag>第 162 场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3639 | 变为活跃状态的最小时间</title>
    <url>//posts/leetcode-3639/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3639 题：<a href="https://leetcode.cn/problems/minimum-time-to-activate-string/description/">变为活跃状态的最小时间</a>。<br>本题的核心在于识别出答案的单调性，并将一个求解最优值（最小时间）的问题，巧妙地转化为一个判定性的问题（在给定时间t，字符串是否活跃？），从而利用二分查找在对数时间内高效求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要找到一个最小的时间 <code>t</code>，在这个时间点，字符串 <code>s</code> 中“有效子字符串”的总数首次达到或超过一个给定的阈值 <code>k</code>。</p>
<p>这里的核心概念是：</p>
<ol>
<li><strong>变化过程</strong>：从 <code>t = 0</code> 开始，每个时间点 <code>t</code> 都会有一个指定位置 <code>order[t]</code> 的字符变成 <code>&#39;*&#39;</code>。</li>
<li><strong>有效子字符串</strong>：只要一个子字符串里包含了至少一个 <code>&#39;*&#39;</code>，它就是有效的。</li>
<li><strong>活跃状态</strong>：当整个字符串中有效子字符串的总数大于或等于 <code>k</code> 时，字符串就处于活跃状态。</li>
</ol>
<p>我们的目标是找出进入“活跃状态”的那个<strong>最小</strong>的时间点 <code>t</code>。</p>
<p>举个例子，<code>s = &quot;abc&quot;</code>, <code>order = [1,0,2]</code>, <code>k = 2</code>。</p>
<ul>
<li>在 <code>t = 0</code> 时，<code>s</code> 变为 <code>&quot;a*c&quot;</code>。包含 <code>&#39;*&#39;</code> 的子字符串有 <code>&quot;*&quot;</code>、<code>&quot;a*&quot;</code>、<code>&quot;*c&quot;</code>、<code>&quot;a*c&quot;</code>，共 4 个。因为 <code>4 &gt;= k</code>，此时字符串已经活跃。因此最小时间是 0。</li>
</ul>
<p>这暗示了随着时间 <code>t</code> 的增加，<code>&#39;*&#39;</code> 的数量也在增加，从而导致有效子字符串的数量只增不减。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最小时间”似乎很困难。一个更直接的想法是：如果我们<strong>假定</strong>一个时间 <code>t</code>，我们能否判断出在这个时刻，字符串是否已经“活跃”？</p>
<p>这个判定问题相对简单。我们可以设计一个辅助函数 <code>check(t)</code>：</p>
<ol>
<li>首先，确定在时间 <code>t</code> 时，哪些位置的字符变成了 <code>&#39;*&#39;</code>。这包括 <code>order[0]</code> 到 <code>order[t]</code> 的所有位置。</li>
<li>然后，计算此时有效子字符串的总数。直接计算可能比较复杂，但我们可以反向思考：<strong>有效子字符串数 &#x3D; 总子字符串数 - 无效子字符串数</strong>。</li>
<li>“无效子字符串”就是那些<strong>完全不包含</strong> <code>&#39;*&#39;</code> 的子字符串。它们是由原字符串中连续的、未被修改的字符组成的。</li>
<li>我们可以遍历一遍字符串，找出所有连续的、未被 <code>&#39;*&#39;</code> 打断的段。如果一个段的长度是 <code>L</code>，那么它能构成的无效子字符串数量就是 <code>L * (L + 1) / 2</code>。</li>
<li>将所有这些段产生的无效子字符串数量加起来，就得到了总的无效数。</li>
<li>最后，用总子字符串数 <code>n * (n + 1) / 2</code> 减去这个总无效数，得到有效子字符串数。我们判断这个数是否 <code>&gt;= k</code>。</li>
</ol>
<p>现在，我们有了一个判定的方法。观察可以发现，这个判定结果具有<strong>单调性</strong>：</p>
<ul>
<li>如果字符串在时间 <code>t</code> 是活跃的，那么在任何更晚的时间 <code>t&#39; &gt; t</code>，<code>&#39;*&#39;</code> 只会更多，有效子字符串也只会更多（或不变），所以字符串必然也还是活跃的。</li>
<li>反之，如果 <code>t</code> 时刻还不够活跃，那么在任何更早的时间，<code>&#39;*&#39;</code> 更少，也必然不活跃。</li>
</ul>
<p>这种单调性是应用二分查找的完美信号。 我们可以对“时间 <code>t</code>”这个值进行二分查找，来快速定位到那个“最小可行”的临界点。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：最早可能的时间是 <code>t = 0</code>。</li>
<li><strong>上界 (right)</strong>：最晚的时间是所有字符都变完，即 <code>t = n - 1</code>。</li>
</ul>
<p>因此，我们就在 <code>[0, n - 1]</code> 这个区间内，对时间 <code>t</code> 进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = 0</code>：最早的时间。</li>
<li><code>right = n - 1</code>：最晚的时间。</li>
<li><code>ans</code> 初始化为 <code>-1</code>，用来记录我们找到的可行解。</li>
</ul>
</li>
<li><p><strong>预处理和边缘情况</strong></p>
<ul>
<li>计算出总的子字符串数量 <code>total = n * (n + 1) / 2</code>。</li>
<li>如果 <code>k</code> 比 <code>total</code> 还大，那么永远不可能满足条件，直接返回 <code>-1</code>。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>left &lt;= right</code> 时，循环继续。</li>
<li>计算中间值 <code>mid_t = left + (right - left) // 2</code> 作为当前的“猜测时间”。</li>
<li>调用辅助函数 <code>check(mid_t)</code> 来判定这个猜测值是否可行。<ul>
<li><strong>如果 <code>check(mid_t)</code> 返回 <code>True</code></strong> (即在 <code>mid_t</code> 时刻已达到活跃状态)：<ul>
<li>说明 <code>mid_t</code> 是一个潜在的答案，我们记录下来 <code>ans = mid_t</code>。</li>
<li>但是我们想找的是“最小”时间，所以我们尝试一个更早的时间，将搜索范围缩小到左半边：<code>right = mid_t - 1</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(mid_t)</code> 返回 <code>False</code></strong> (即在 <code>mid_t</code> 时刻还未活跃)：<ul>
<li>说明我们需要更多的时间，将搜索范围缩小到右半边：<code>left = mid_t + 1</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>ans</code> 中存储的就是满足条件的最小时间。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minTime</span>(<span class="params">self, s: <span class="built_in">str</span>, order: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 字符串中所有可能的子字符串总数</span></span><br><span class="line">        total_substrings = n * (n + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果 k 大于可能的最大值，则永远无法达到，返回 -1</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; total_substrings:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判定函数 check(t): 检查在时间 t 时，字符串是否已变为“活跃”状态</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            is_star = [<span class="literal">False</span>] * n</span><br><span class="line">            <span class="comment"># 将前 t+1 个要改变的字符位置标记为 True</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(t + <span class="number">1</span>):</span><br><span class="line">                is_star[order[i]] = <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            invalid_count = <span class="number">0</span></span><br><span class="line">            current_block_length = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 遍历整个字符串，计算由非&#x27;*&#x27;字符组成的“无效”子字符串的数量</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> is_star[i]:</span><br><span class="line">                    current_block_length += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> current_block_length &gt; <span class="number">0</span>:</span><br><span class="line">                        invalid_count += current_block_length * (current_block_length + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">                    current_block_length = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 处理末尾可能存在的最后一个非&#x27;*&#x27;块</span></span><br><span class="line">            <span class="keyword">if</span> current_block_length &gt; <span class="number">0</span>:</span><br><span class="line">                invalid_count += current_block_length * (current_block_length + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            valid_count = total_substrings - invalid_count</span><br><span class="line">            <span class="keyword">return</span> valid_count &gt;= k</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对时间 t 进行二分查找，范围是 [0, n-1]</span></span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid_t = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid_t):</span><br><span class="line">                <span class="comment"># mid_t 可行，尝试更小的时间</span></span><br><span class="line">                ans = mid_t</span><br><span class="line">                right = mid_t - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># mid_t 不可行，需要更多时间</span></span><br><span class="line">                left = mid_t + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N * log(N))。<ul>
<li><code>N</code> 是字符串 <code>s</code> 的长度。</li>
<li>二分查找本身需要 <code>log(N)</code> 次迭代，因为搜索范围是 <code>[0, n-1]</code>。</li>
<li>在每次迭代中，我们都需要调用 <code>check</code> 函数。该函数需要初始化一个大小为 <code>N</code> 的数组，并遍历一次，时间复杂度为 O(N)。</li>
<li>因此，总时间复杂度是这两者的乘积。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(N)。<ul>
<li>在 <code>check</code> 函数中，我们使用了一个大小为 <code>N</code> 的布尔数组 <code>is_star</code> 来标记 <code>&#39;*&#39;</code> 的位置。因此，空间复杂度是 O(N)。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是二分查找思想应用的经典范例，也称为“二分答案”。它教会我们当遇到求解“最小的XXX使其满足条件”这类问题时，可以尝试将其转化为一个更简单的“判定性”问题。如果这个判定问题（即 <code>check</code> 函数）的结果随自变量（本题中的 <code>t</code>）呈单调性，那么就可以利用二分查找，将搜索范围不断折半，从而在对数级别的时间复杂度内找到最优解，这比线性地从 <code>t=0</code> 开始逐个检查要高效得多。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最小</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>第461场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 373 | 查找和最小的 K 对数字</title>
    <url>//posts/leetcode-373/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 373 题：<a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/">查找和最小的 K 对数字</a>。<br>这是一道经典的“多路归并”问题，本质上是在一个隐式的二维矩阵中寻找第 K 小的元素。利用 <strong>最小堆（优先队列）</strong> 可以高效解决。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定两个以 <strong>非递减顺序排列</strong> 的整数数组 <code>nums1</code> 和 <code>nums2</code> , 以及一个整数 <code>k</code> 。</p>
<p>定义一对值 <code>(u,v)</code>，其中第一个元素来自 <code>nums1</code>，第二个元素来自 <code>nums2</code> 。</p>
<p>请找到和最小的 <code>k</code> 个数对 <code>(u1,v1), (u2,v2) ... (uk,vk)</code> 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3</span><br><span class="line">输出: [1,2],[1,4],[1,6]</span><br><span class="line">解释: 返回序列中的前 3 对数：</span><br><span class="line">     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2</span><br><span class="line">输出: [1,1],[1,1]</span><br><span class="line">解释: 返回序列中的前 2 对数：</span><br><span class="line">     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li>1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 10^5</li>
<li>-10^9 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 10^9</li>
<li>nums1 和 nums2 均为 升序排列</li>
<li>1 &lt;&#x3D; k &lt;&#x3D; 10^4</li>
<li>k &lt;&#x3D; nums1.length * nums2.length</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-为什么暴力法不可行？"><a href="#1-为什么暴力法不可行？" class="headerlink" title="1. 为什么暴力法不可行？"></a>1. 为什么暴力法不可行？</h4><p>如果直接生成所有可能的数对 <code>(nums1[i], nums2[j])</code>，总共有 <code>m * n</code> 对（其中 <code>m</code> 和 <code>n</code> 分别是数组的长度）。题目中数组长度可达 10^5，乘积可能达到 10^10，内存和时间都无法承受。<br>然而，我们需要找的只是 <strong>前 k 个</strong> 最小的对，且 <code>k</code> 的范围相对较小（最大 10^4），这提示我们应该使用与 <code>k</code> 相关的复杂度算法。</p>
<h4 id="2-利用有序性与堆"><a href="#2-利用有序性与堆" class="headerlink" title="2. 利用有序性与堆"></a>2. 利用有序性与堆</h4><p>由于 <code>nums1</code> 和 <code>nums2</code> 都是升序排列的，我们可以将所有可能的数对想象成一个矩阵，其中第 <code>i</code> 行第 <code>j</code> 列的元素是 <code>nums1[i] + nums2[j]</code>。<br>在这个矩阵中：</p>
<ul>
<li>每一行从左到右是递增的。</li>
<li>每一列从上到下是递增的。</li>
</ul>
<p>最小的元素一定是 <code>(nums1[0], nums2[0])</code>。<br>当我们选择了 <code>(nums1[i], nums2[j])</code> 后，下一个可能的最小元素只能是它的右边邻居 <code>(nums1[i], nums2[j+1])</code> 或者下边邻居 <code>(nums1[i+1], nums2[j])</code>。</p>
<h4 id="3-优化入堆策略"><a href="#3-优化入堆策略" class="headerlink" title="3. 优化入堆策略"></a>3. 优化入堆策略</h4><p>为了避免重复访问和控制堆的大小，我们可以采取一种特定的扩展策略：</p>
<ol>
<li>初始时，只将 <code>(nums1[0] + nums2[0], 0, 0)</code> 放入最小堆。元组中记录的是 <code>(数值和, nums1下标, nums2下标)</code>。</li>
<li>每次从堆中取出最小元素 <code>(sum, i, j)</code>，将其加入答案。</li>
<li>接下来需要将该元素的潜在“后继”加入堆中。为了保证不重不漏：<ul>
<li><strong>向右扩展</strong>：总是将 <code>(i, j+1)</code> 加入堆（如果 <code>j+1</code> 未越界）。</li>
<li><strong>向下扩展</strong>：只有当 <code>j == 0</code> 时，才将 <code>(i+1, 0)</code> 加入堆（如果 <code>i+1</code> 未越界）。</li>
</ul>
</li>
</ol>
<p>这种策略相当于把 <code>nums1</code> 看作行的起始，我们可以在行内自由向右走；但换行操作只允许在每一行的开头进行。这样可以保证每一对组合只被加入堆一次。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kSmallestPairs</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 初始只放入 (0,0) 位置的元素</span></span><br><span class="line">        h = [(nums1[<span class="number">0</span>]+nums2[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="comment"># 取出当前堆中最小的元素</span></span><br><span class="line">            _,i,j = heappop(h)</span><br><span class="line">            ans.append([nums1[i],nums2[j]])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 策略：如果当前是该行的第一个元素 (j==0)，则可以将下一行的第一个元素入堆</span></span><br><span class="line">            <span class="comment"># 这样保证了第一列的元素会被依次加入</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span> <span class="keyword">and</span> i+<span class="number">1</span>&lt;<span class="built_in">len</span>(nums1):</span><br><span class="line">                heappush(h,(nums1[i+<span class="number">1</span>]+nums2[<span class="number">0</span>],i+<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 策略：总是将当前元素的右侧元素入堆</span></span><br><span class="line">            <span class="keyword">if</span> j+<span class="number">1</span>&lt;<span class="built_in">len</span>(nums2):</span><br><span class="line">                heappush(h,(nums1[i]+nums2[j+<span class="number">1</span>],i,j+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kSmallestPairs</span><span class="params">(nums1, nums2 []<span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n, m := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="comment">// 初始化最小堆，放入 (0,0)</span></span><br><span class="line">    h := hp&#123;&#123;nums1[<span class="number">0</span>] + nums2[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>, k) <span class="comment">// 预分配空间</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> k &#123;</span><br><span class="line">        <span class="comment">// 弹出堆顶最小元素</span></span><br><span class="line">        p := heap.Pop(&amp;h).(tuple)</span><br><span class="line">        i, j := p.i, p.j</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, []<span class="type">int</span>&#123;nums1[i], nums2[j]&#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只有当我们在当前行的第一个位置时，才去添加下一行的起始元素</span></span><br><span class="line">        <span class="comment">// 这相当于负责了 &quot;向下&quot; 的搜索方向</span></span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">0</span> &amp;&amp; i+<span class="number">1</span> &lt; n &#123;</span><br><span class="line">            heap.Push(&amp;h, tuple&#123;nums1[i+<span class="number">1</span>] + nums2[<span class="number">0</span>], i + <span class="number">1</span>, <span class="number">0</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 总是尝试添加当前位置右边的元素</span></span><br><span class="line">        <span class="comment">// 这相当于负责了 &quot;向右&quot; 的搜索方向</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span> &lt; m &#123;</span><br><span class="line">            heap.Push(&amp;h, tuple&#123;nums1[i] + nums2[j+<span class="number">1</span>], i, j + <span class="number">1</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义堆所需的结构体和接口方法</span></span><br><span class="line"><span class="keyword">type</span> tuple <span class="keyword">struct</span>&#123; s, i, j <span class="type">int</span> &#125;</span><br><span class="line"><span class="keyword">type</span> hp []tuple</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h hp)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h hp)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i].s &lt; h[j].s &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h hp)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hp)</span></span> Push(v any)        &#123; *h = <span class="built_in">append</span>(*h, v.(tuple)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hp)</span></span> Pop() any          &#123; a := *h; v := a[<span class="built_in">len</span>(a)<span class="number">-1</span>]; *h = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]; <span class="keyword">return</span> v &#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: <code>O(k log k)</code><br>我们需要循环 <code>k</code> 次来找到前 <code>k</code> 个最小对。在每次迭代中，我们执行一次 <code>heappop</code> 和最多两次 <code>heappush</code>。堆中的元素数量最多不会超过 <code>k</code>（实际上更接近于 <code>k</code> 或 <code>nums1</code> 的长度，取决于扩展策略，但在最坏情况下与 <code>k</code> 同阶）。因此，每次堆操作的时间复杂度为 <code>O(log k)</code>。总时间复杂度为 <code>O(k log k)</code>。</p>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(k)</code><br>堆中最多存储 <code>k</code> 个元素（或者更准确地说是生成的候选对数量，这与 <code>k</code> 成正比）。用于存储答案的数组也需要 <code>O(k)</code> 的空间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>第K小/大</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>堆（优先队列）</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3733 | 完成所有送货任务的最少时间</title>
    <url>//posts/leetcode-3733/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3733 题：<a href="https://leetcode.cn/problems/minimum-time-to-complete-all-deliveries/description/">完成所有送货任务的最少时间</a>。<br>当直接计算“最少时间”的调度方案非常复杂时，我们可以转换思路，猜测一个“总时间”，然后验证其可行性。这种将求解最值问题转化为判定问题的技巧，正是“二分答案”思想的精髓。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们有两架无人机，分别需要完成 <code>d1</code> 和 <code>d2</code> 次送货任务。每个送货任务都恰好花费一小时。</p>
<p>问题的核心约束有两个：</p>
<ol>
<li><strong>时间独占</strong>：在任意一个小时内，只能有一架无人机执行送货任务。</li>
<li><strong>强制充电</strong>：无人机 <code>i</code> 每隔 <code>ri</code> 小时需要强制充电，即在第 <code>ri</code>、<code>2*ri</code>、<code>3*ri</code>… 小时，它无法工作。</li>
</ol>
<p>我们的目标是找到一个最优的调度方案，使得完成所有 <code>d1 + d2</code> 次送货任务所需的总时间最短。</p>
<p>例如，<code>d = [3,1], r = [2,3]</code>。</p>
<ul>
<li>无人机1需要送货3次，每2小时充一次电（在第2、4、6…小时）。</li>
<li>无人机2需要送货1次，每3小时充一次电（在第3、6、9…小时）。<br>一种最优调度是：</li>
<li>第1小时：无人机1送货。</li>
<li>第2小时：无人机1充电，无人机2送货。</li>
<li>第3小时：无人机2充电，无人机1送货。</li>
<li>第4小时：无人机1充电。</li>
<li>第5小时：无人机1送货。<br>总共耗时5小时完成所有任务。</li>
</ul>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接推导出最优调度策略和最小时间非常困难，因为两架无人机的充电周期相互交错，情况很复杂。</p>
<p>但是，我们可以换一个角度思考：如果我们<strong>猜测</strong>一个总时间 <code>T</code>，能否判断出，在这 <code>T</code> 小时内，我们是否<strong>有可能</strong>完成所有的送货任务？</p>
<p>这个“判定问题”就清晰多了。我们可以设计一个 <code>check(T)</code> 函数：</p>
<ul>
<li>该函数接收一个总时间 <code>T</code> 作为输入。</li>
<li>它需要回答：是否存在一种调度方式，在 <code>T</code> 小时内完成 <code>d1</code> 和 <code>d2</code> 次送货。</li>
</ul>
<p>这个 <code>check(T)</code> 函数具有非常明显的<strong>单调性</strong>：</p>
<ul>
<li>如果时间 <code>T</code> <strong>足够</strong>完成所有任务，那么任何比 <code>T</code> 更长的时间 <code>T&#39;</code> 也<strong>一定</strong>足够。</li>
<li>反之，如果时间 <code>T</code> <strong>不够</strong>，那么任何比 <code>T</code> 更短的时间 <code>T&#39;&#39;</code> 也<strong>必然</strong>不够。</li>
</ul>
<p>这种单调性是应用<strong>二分查找</strong>的完美信号。我们可以在一个可能的时间范围内，对“总时间 <code>T</code>”进行二分查找，来高效地定位到那个“恰好足够”的最小时间点。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：无论如何，至少需要 <code>d1 + d2</code> 个小时才能完成所有送货，所以下界是 <code>d1 + d2</code>。</li>
<li><strong>上界 (right)</strong>：我们可以设定一个足够大的数。例如，在最坏的情况下（如充电频率很高），所需时间也不会超过 <code>(d1 + d2)</code> 的几万倍。为保险起见，我们可以设一个较大的值，例如 <code>4 * 10^14</code>。</li>
</ul>
<h3 id="算法详解：如何实现-check-T"><a href="#算法详解：如何实现-check-T" class="headerlink" title="算法详解：如何实现 check(T)"></a>算法详解：如何实现 <code>check(T)</code></h3><p><code>check(T)</code> 函数是整个算法的核心。我们需要在给定的 <code>T</code> 小时内，判断是否存在一个可行的调度方案。这可以通过一个贪心策略来实现。</p>
<p>首先，我们将 <code>T</code> 小时内的所有时间点（1, 2, …, T）进行分类：</p>
<ol>
<li><strong>无人机1独占时段</strong>：无人机2在充电，而无人机1空闲。</li>
<li><strong>无人机2独占时段</strong>：无人机1在充电，而无人机2空闲。</li>
<li><strong>共享时段</strong>：两架无人机都空闲。</li>
<li><strong>阻塞时段</strong>：两架无人机都在充电（此时谁也无法工作）。</li>
</ol>
<p>一个贪心的想法是：<strong>让每架无人机优先使用自己的“独占时段”</strong>。因为这些时段另一方无法使用，不用白不用。如果独占时段用完后任务还没完成，再从“共享时段”里拿时间。</p>
<p><strong><code>check(T)</code> 的具体步骤：</strong></p>
<ol>
<li><p><strong>计算各类时段的数量</strong></p>
<ul>
<li>为了计算在周期 <code>r1</code> 和 <code>r2</code> 的倍数上重叠的部分，我们需要它们的最小公倍数 <code>lcm</code>。<code>lcm(r1, r2) = (r1 * r2) // gcd(r1, r2)</code>。</li>
<li>在 <code>T</code> 小时内，无人机1充电 <code>T // r1</code> 次。</li>
<li>在 <code>T</code> 小时内，无人机2充电 <code>T // r2</code> 次。</li>
<li>在 <code>T</code> 小时内，两者同时充电 <code>T // lcm</code> 次。</li>
<li>因此，我们可以计算出：<ul>
<li><code>slots_d1_only</code> (无人机1独占时段数) &#x3D; (无人机2充电次数) - (两者同时充电次数) &#x3D; <code>T // r2 - T // lcm</code></li>
<li><code>slots_d2_only</code> (无人机2独占时段数) &#x3D; (无人机1充电次数) - (两者同时充电次数) &#x3D; <code>T // r1 - T // lcm</code></li>
<li><code>shared_slots</code> (共享时段数) &#x3D; <code>T - (无人机1充电次数) - (无人机2独占时段数)</code> &#x3D; <code>T - (T // r1) - (T // r2 - T // lcm)</code> &#x3D; <code>T - T // r1 - T // r2 + T // lcm</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>执行贪心分配</strong></p>
<ul>
<li>无人机1需要完成 <code>d1</code> 次任务。它首先使用完自己的 <code>slots_d1_only</code>。还需要的任务数是 <code>needed1 = max(0, d1 - slots_d1_only)</code>。</li>
<li>同理，无人机2在用完自己的 <code>slots_d2_only</code> 后，还需要的任务数是 <code>needed2 = max(0, d2 - slots_d2_only)</code>。</li>
</ul>
</li>
<li><p><strong>判定结果</strong></p>
<ul>
<li>两者剩余所需要的任务 <code>needed1</code> 和 <code>needed2</code> 都必须从 <code>shared_slots</code> 中分配。</li>
<li>如果共享时段足够满足两者的剩余需求，即 <code>needed1 + needed2 &lt;= shared_slots</code>，那么时间 <code>T</code> 就是可行的，<code>check(T)</code> 返回 <code>True</code>。</li>
<li>否则，返回 <code>False</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumTime</span>(<span class="params">self, d: <span class="type">List</span>[<span class="built_in">int</span>], r: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        d1, d2 = d[<span class="number">0</span>],d[<span class="number">1</span>]</span><br><span class="line">        r1, r2 = r[<span class="number">0</span>],r[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">a, b</span>):</span><br><span class="line">            <span class="keyword">return</span> math.gcd(a, b)</span><br><span class="line"></span><br><span class="line">        lcm = (r1 * r2) // gcd(r1, r2)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判定函数：在时间 T 内，是否可以完成所有送货任务</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">T: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># T 时间内，无人机2充电，无人机1可用的独占时段</span></span><br><span class="line">            slots_d1_only = T // r2 - T // lcm</span><br><span class="line">            <span class="comment"># T 时间内，无人机1充电，无人机2可用的独占时段</span></span><br><span class="line">            slots_d2_only = T // r1 - T // lcm</span><br><span class="line">            <span class="comment"># T 时间内，两架无人机都可用的共享时段</span></span><br><span class="line">            shared_slots = T - (T // r1) - (T // r2) + (T // lcm)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 无人机1在用完独占时段后，还需要从共享时段拿多少</span></span><br><span class="line">            needed1 = <span class="built_in">max</span>(<span class="number">0</span>, d1 - slots_d1_only)</span><br><span class="line">            <span class="comment"># 无人机2在用完独占时段后，还需要从共享时段拿多少</span></span><br><span class="line">            needed2 = <span class="built_in">max</span>(<span class="number">0</span>, d2 - slots_d2_only)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断共享时段是否足够满足两者的剩余需求</span></span><br><span class="line">            <span class="keyword">return</span> needed1 + needed2 &lt;= shared_slots</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找的左右边界</span></span><br><span class="line">        <span class="comment"># 左边界：最少也需要 d1 + d2 小时</span></span><br><span class="line">        <span class="comment"># 右边界：一个足够大的安全值</span></span><br><span class="line">        left, right = d1 + d2, <span class="number">4</span> * <span class="number">10</span>**<span class="number">14</span></span><br><span class="line">        ans = right</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找寻找最小的可行时间 T</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 时间可行，说明它是一个潜在答案，</span></span><br><span class="line">                <span class="comment"># 但我们想找最小的，所以尝试在左半部分 [left, mid-1] 继续寻找</span></span><br><span class="line">                ans = mid</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 时间不可行，说明时间太少，</span></span><br><span class="line">                <span class="comment"># 必须增加，所以去右半部分 [mid + 1, right] 寻找</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(log K)，其中 K 是二分查找的搜索范围大小（约为 4 * 10¹⁴）。<ul>
<li>二分查找的迭代次数为 O(log K)。</li>
<li>每次迭代中，<code>check</code> 函数只包含几次整数除法和乘法运算，以及一次 <code>gcd</code> 计算。<code>gcd</code> 的时间复杂度是 O(log(min(r1, r2)))。</li>
<li>因此，总时间复杂度主要由二分查找的次数决定，执行效率非常高。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)。<ul>
<li>除了存储输入和几个临时变量外，我们没有使用额外的空间。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>它巧妙地将一个复杂的“求解最优调度”问题，转化成了一个相对简单的、可以通过贪心策略解决的“可行性判定”问题。当我们遇到求解“最小值中的最大值”或“最大值中的最小值”这类问题，且问题的判定函数具有单调性时，二分查找往往是解决问题的黄金钥匙。它能帮助我们高效地逼近最优解，避免复杂的动态规划或搜索。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>最小化最大值</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>数学</tag>
        <tag>第474场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 378 | 有序矩阵中第 K 小的元素</title>
    <url>//posts/leetcode-378/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 378 题：<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/description/">有序矩阵中第 K 小的元素</a>。<br>对于在一个值域范围内查找“第 K 小”或“第 K 大”的问题，尤其是当数据本身具有一定的有序性（如行、列分别排序）时，<strong>二分答案</strong> 往往是优于排序和堆的更优解法。本题利用矩阵的性质，将时间复杂度从多项式级降低到了对数级。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个矩阵 <code>matrix</code> ，其中每行和每列元素均按升序排序，找到矩阵中第 <code>k</code> 小的元素。<br>请注意，它是 <strong>排序后</strong> 的第 <code>k</code> 小元素，而不是第 <code>k</code> 个 <strong>不同</strong> 的元素。</p>
<p>你必须找到一个内存复杂度优于 $O(n^2)$ 的解决方案。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong> matrix &#x3D; [[1,5,9],[10,11,13],[12,13,15]], k &#x3D; 8<br><strong>输出：</strong> 13<br><strong>解释：</strong> 矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong> matrix &#x3D; [[-5]], k &#x3D; 1<br><strong>输出：</strong> -5</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="二分查找（二分答案）"><a href="#二分查找（二分答案）" class="headerlink" title="二分查找（二分答案）"></a>二分查找（二分答案）</h4><p>我们注意到答案一定在 <code>matrix[0][0]</code>（最小值）和 <code>matrix[n-1][n-1]</code>（最大值）之间。<br>这不仅是一个查找问题，更是一个<strong>值域上的判定问题</strong>：</p>
<blockquote>
<p>猜测一个整数 <code>x</code>，如果矩阵中 <strong>小于等于 <code>x</code> 的元素个数</strong> 大于等于 <code>k</code>，说明第 <code>k</code> 小的元素一定在 <code>x</code> 左边（或者就是 <code>x</code>）；否则，答案一定在 <code>x</code> 右边。</p>
</blockquote>
<p>具有这种<strong>单调性</strong>（随着 <code>x</code> 增大，小于等于 <code>x</code> 的元素个数单调递增），我们就可以使用<strong>二分查找</strong>。</p>
<h5 id="核心步骤："><a href="#核心步骤：" class="headerlink" title="核心步骤："></a>核心步骤：</h5><ol>
<li><strong>确定二分范围</strong>：<ul>
<li>左边界 <code>l</code>：<code>matrix[0][0]</code></li>
<li>右边界 <code>r</code>：<code>matrix[n-1][n-1]</code></li>
</ul>
</li>
<li><strong>Check 函数的设计</strong>：<br>我们需要一个快速的方法计算矩阵中有多少个元素 $\le mid$。<br>利用矩阵 <strong>行增列增</strong> 的性质，我们可以从矩阵的 <strong>右上角</strong>（或左下角）开始遍历：<ul>
<li>初始位置 $(i, j) &#x3D; (0, n-1)$。</li>
<li>如果当前元素 <code>matrix[i][j] &gt; mid</code>：说明这一列剩下的元素都比 <code>mid</code> 大，排除这一列，<code>j--</code>。</li>
<li>如果当前元素 <code>matrix[i][j] &lt;= mid</code>：说明这一行从起点到 <code>j</code> 的元素都符合条件（共 <code>j + 1</code> 个），累加计数，并向下移动 <code>i++</code> 寻找更多符合条件的元素。</li>
<li>该过程的时间复杂度为 $O(n)$，因为 $i$ 和 $j$ 最多各移动 $n$ 次。</li>
</ul>
</li>
<li><strong>二分逻辑</strong>：<ul>
<li>使用开区间或半开区间的二分模版来逼近答案。</li>
<li>如果 <code>check(mid)</code> 返回 <code>True</code>（计数 $\ge k$），说明 <code>mid</code> 可能是答案，或者是比答案大的数，尝试缩小右边界。</li>
</ul>
</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># check 函数：统计矩阵中 &lt;= mx 的元素个数是否 &gt;= k</span></span><br><span class="line">        <span class="comment"># 时间复杂度：O(n)，利用了矩阵行列递增的性质</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">mx: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            i, j = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 从右上角开始走</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> cnt &lt; k:</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] &gt; mx:</span><br><span class="line">                    <span class="comment"># 当前元素大于 mx，这一列下面的元素肯定也大于 mx，向左移</span></span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 当前元素 &lt;= mx，说明这一行左边所有元素（包括自己）都 &lt;= mx</span></span><br><span class="line">                    <span class="comment"># 个数为 j + 1 (下标从0开始)</span></span><br><span class="line">                    cnt += j + <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 继续看下一行</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cnt &gt;= k</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 二分查找的值域范围</span></span><br><span class="line">        <span class="comment"># 使用开区间 (l, r] 的逻辑，l 初始为最小值-1</span></span><br><span class="line">        l, r = matrix[<span class="number">0</span>][<span class="number">0</span>] - <span class="number">1</span>, matrix[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果小于等于 mid 的数量够 k 个，说明答案在 [l+1, mid] 范围内</span></span><br><span class="line">                <span class="comment"># 尝试更小的值</span></span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 数量不够，说明 mid 太小了，答案在 [mid+1, r]</span></span><br><span class="line">                l = mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>第K小/大</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 395 | SW求解“至少有 K 个重复字符的最长子串”</title>
    <url>//posts/leetcode-395/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 395 题：<a href="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/">至少有 K 个重复字符的最长子串</a>。<br>此题要求在一个字符串中找到一个最长的子串，该子串中每个字符的出现次数都不少于 K。条件的“非单调性”让常规SW思路失效。我们需要换个角度，通过枚举一个额外约束来让滑动窗口重新焕发生机。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，要求我们找到 <code>s</code> 中最长的一个子串，这个子串有一个特殊的性质：子串中出现的<strong>每一个</strong>字符，其出现次数都必须<strong>不少于</strong> <code>k</code>。最后返回这个最长子串的长度。</p>
<p>举个例子，对于 <code>s = &quot;ababbc&quot;</code>, <code>k = 2</code>：</p>
<ul>
<li>子串 “ababb” 是一个满足条件的子串。其中 ‘a’ 出现了 2 次，’b’ 出现了 3 次，都不少于 <code>k=2</code>。其长度为 5。</li>
<li>子串 “ababbc” 则不满足条件，因为 ‘c’ 只出现了 1 次，小于 <code>k=2</code>。</li>
<li>“ababb” 是能找到的最长的满足条件的子串，因此答案是 5。</li>
</ul>
<p>如果找不到这样的子串，则返回 0。</p>
<h3 id="核心思路：枚举-滑动窗口"><a href="#核心思路：枚举-滑动窗口" class="headerlink" title="核心思路：枚举+滑动窗口"></a>核心思路：枚举+滑动窗口</h3><p>直接解决这个问题的一个难点在于，一个“不满足条件”的窗口，无论向右扩大还是向左收缩，都无法保证其会趋向于“满足条件”。例如，一个窗口因为字符 ‘c’ 数量不足而不满足条件，我们收缩左边界，可能会移出一个出现次数很多的字符 ‘b’，反而让 ‘b’ 的数量也不足了。这种条件的“非单调性”让常规滑动窗口难以施展。</p>
<p>面对这种困境，一个强大的思想是<strong>增加约束，减少可变性</strong>。</p>
<p>我们可以换个角度思考：一个合法的最长子串，它内部包含的<strong>不同字符的种类数</strong>（我们称之为 <code>h</code>）一定是一个确定的值，范围在 1 到 26 之间。</p>
<p>那我们能否<strong>枚举</strong>这个 <code>h</code> 呢？</p>
<p>如果我们固定了 <code>h</code>，问题就转化为：<strong>找到最长的子串，它恰好包含 <code>h</code> 种不同的字符，且每种字符的出现次数都不少于 <code>k</code>。</strong></p>
<p>这个转化后的问题就变得非常清晰，并且完美符合滑动窗口的模式：</p>
<ol>
<li>我们寻找一个窗口，其<strong>不同字符数最多为 <code>h</code></strong>。</li>
<li>当不同字符数恰好为 <code>h</code> 时，我们再检查这 <code>h</code> 个字符是否都满足<strong>出现次数不少于 <code>k</code></strong>。</li>
</ol>
<p>这个思路将原问题分解为 26 个独立的、可以用滑动窗口解决的子问题。我们对每个子问题求最优解，最终取其中的最大值即可。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>外层循环</strong>：我们用一个循环来枚举最终子串可能包含的唯一字符数 <code>h</code>，<code>for h in range(1, 27)</code>。</p>
</li>
<li><p><strong>内层滑动窗口</strong>：对于每一个固定的 <code>h</code>，我们使用滑动窗口 <code>[left, right]</code> 来寻找满足条件的子串。</p>
<ul>
<li>我们需要几个变量来维护窗口的状态：<ul>
<li><code>counts</code>: 一个频率数组或哈希表，记录窗口内每个字符的出现次数。</li>
<li><code>unique_chars</code>: 记录当前窗口内不同字符的种类数。</li>
<li><code>chars_at_least_k</code>: 记录当前窗口内出现次数不少于 <code>k</code> 的字符种类数。</li>
</ul>
</li>
<li><strong>扩张窗口</strong>：移动 <code>right</code> 指针，将新字符 <code>s[right]</code> 纳入窗口，并更新上述三个状态变量。</li>
<li><strong>收缩窗口</strong>：当 <code>unique_chars</code> 的值<strong>超过</strong>了我们当前枚举的 <code>h</code> 时，说明当前窗口太大了，需要从左侧收缩。我们移动 <code>left</code> 指针，将 <code>s[left]</code> 移出窗口，并反向更新三个状态变量，直到 <code>unique_chars</code> 重新等于 <code>h</code> 为止。</li>
<li><strong>更新答案</strong>：在窗口滑动的每一步，当它同时满足以下两个条件时，就意味着我们找到了一个候选的合法子串：<ol>
<li><code>unique_chars == h</code> (窗口内恰好有 <code>h</code> 种字符)</li>
<li><code>chars_at_least_k == h</code> (这 <code>h</code> 种字符的出现次数都不少于 <code>k</code>)<br>此时，我们用当前窗口的长度 <code>right - left + 1</code> 来更新全局的最大长度 <code>ans</code>。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：外层循环结束后，<code>ans</code> 中保存的就是所有 <code>h</code> 值对应的最长子串中的最大值，即为最终答案。</p>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 外层循环：枚举窗口内允许的唯一字符数量 h</span></span><br><span class="line">        <span class="comment"># h 的取值范围是 [1, 26]，因为 s 仅由小写英文字母组成</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">27</span>):</span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 2. 内层滑动窗口</span></span><br><span class="line">            <span class="comment"># counts 用于记录窗口内各字符的出现次数</span></span><br><span class="line">            counts = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            <span class="comment"># unique_chars 记录窗口内唯一字符的数量</span></span><br><span class="line">            unique_chars = <span class="number">0</span></span><br><span class="line">            <span class="comment"># chars_at_least_k 记录窗口内满足出现次数 &gt;= k 的字符数量</span></span><br><span class="line">            chars_at_least_k = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 窗口右边界扩张，新字符进入窗口</span></span><br><span class="line">                char_right_idx = <span class="built_in">ord</span>(s[right]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 更新 counts, unique_chars, chars_at_least_k</span></span><br><span class="line">                <span class="keyword">if</span> counts[char_right_idx] == <span class="number">0</span>:</span><br><span class="line">                    unique_chars += <span class="number">1</span></span><br><span class="line">                counts[char_right_idx] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> counts[char_right_idx] == k:</span><br><span class="line">                    chars_at_least_k += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 3. 当窗口内唯一字符数 &gt; h 时，收缩左边界</span></span><br><span class="line">                <span class="comment"># 这是为了维持窗口内最多只有 h 个唯一字符的约束</span></span><br><span class="line">                <span class="keyword">while</span> unique_chars &gt; h:</span><br><span class="line">                    char_left_idx = <span class="built_in">ord</span>(s[left]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 字符离开窗口，对应更新 counts, unique_chars, chars_at_least_k</span></span><br><span class="line">                    <span class="keyword">if</span> counts[char_left_idx] == k:</span><br><span class="line">                        chars_at_least_k -= <span class="number">1</span></span><br><span class="line">                    counts[char_left_idx] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> counts[char_left_idx] == <span class="number">0</span>:</span><br><span class="line">                        unique_chars -= <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 4. 当窗口内唯一字符数等于 h，并且这些字符都满足 &gt;= k 的条件时，</span></span><br><span class="line">                <span class="comment"># 我们找到了一个候选子串，更新最大长度</span></span><br><span class="line">                <span class="keyword">if</span> unique_chars == h <span class="keyword">and</span> chars_at_least_k == h:</span><br><span class="line">                    max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。虽然代码有两层循环，但外层循环的次数是常数 26。内层循环是一个标准的滑动窗口，<code>left</code> 和 <code>right</code> 指针都只会从头到尾移动一次，所以其复杂度为 O(N)。因此总时间复杂度为 O(26 * N) &#x3D; O(N)。</li>
<li><strong>空间复杂度</strong>: O(1)。我们使用了一个大小为 26 的 <code>counts</code> 数组来存储字符频率，其空间占用是常数级别的。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想的一个巧妙应用。当遇到一个性质不稳定的目标条件时，可以尝试通过<strong>枚举其中一个可变维度</strong>（本题中是唯一字符数）的方式，将其转化为一个具有稳定约束的子问题。这种“枚举约束 + 滑动窗口”的模式，是解决一系列复杂字符串和数组问题的有力武器。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 4 | 寻找两个正序数组的中位数</title>
    <url>//posts/leetcode-4/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 4 题：<a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a>。<br>题目要求算法的时间复杂度为 O(log (m+n))。通常涉及数组的题目如果要求对数级复杂度，核心思路大概率是 <strong>二分查找</strong>。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong>。</p>
<p>算法的时间复杂度应该为 O(log (m+n)) 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>nums1.length &#x3D;&#x3D; m</li>
<li>nums2.length &#x3D;&#x3D; n</li>
<li>0 &lt;&#x3D; m &lt;&#x3D; 1000</li>
<li>0 &lt;&#x3D; n &lt;&#x3D; 1000</li>
<li>1 &lt;&#x3D; m + n &lt;&#x3D; 2000</li>
<li>-10^6 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 10^6</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-核心思想：划分数组"><a href="#1-核心思想：划分数组" class="headerlink" title="1. 核心思想：划分数组"></a>1. 核心思想：划分数组</h4><p>要在两个有序数组中找到中位数，本质上是要将两个数组分别切成两部分（左半部分和右半部分），满足以下两个条件：</p>
<ol>
<li><strong>数量平衡</strong>：左半部分的总元素个数等于右半部分（或者比右半部分多 1 个）。</li>
<li><strong>交叉有序</strong>：左半部分的所有元素都要小于等于右半部分的所有元素。即：<code>Left_Part_Max ≤ Right_Part_Min</code>。</li>
</ol>
<h4 id="2-处理边界问题的技巧（哨兵法）"><a href="#2-处理边界问题的技巧（哨兵法）" class="headerlink" title="2. 处理边界问题的技巧（哨兵法）"></a>2. 处理边界问题的技巧（哨兵法）</h4><p>在常规解法中，处理数组下标越界（例如切分点在数组开头或结尾）是非常繁琐的。<br>本题解采用了一种巧妙的 <strong>预处理</strong> 方式：</p>
<ul>
<li>在两个数组的首尾分别加上 <strong>负无穷 (-inf)</strong> 和 <strong>正无穷 (inf)</strong>。</li>
<li>这样不仅避免了下标越界的判断，还保证了数组长度永远够用，逻辑更加统一。</li>
</ul>
<h4 id="3-二分查找切分点"><a href="#3-二分查找切分点" class="headerlink" title="3. 二分查找切分点"></a>3. 二分查找切分点</h4><p>我们只需要对长度较短的那个数组进行二分查找。假设我们在短数组 <code>A</code> 中切一刀，下标为 <code>i</code>，那么为了满足“数量平衡”，长数组 <code>B</code> 的切分位置 <code>j</code> 也就确定了：<code>j = (m + n + 1) / 2 - i</code></p>
<p>我们需要找到一个 <code>i</code>，使得 <code>A[i] ≤ B[j+1]</code> 且 <code>B[j] ≤ A[i+1]</code>。<br>由于数组是有序的，我们只需要通过二分调整 <code>i</code> 的位置即可。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedianSortedArrays</span>(<span class="params">self, a: <span class="type">List</span>[<span class="built_in">int</span>], b: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="comment"># 确保 a 是较短的数组，这样可以缩短二分查找的区间，优化性能</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(a) &gt; <span class="built_in">len</span>(b):</span><br><span class="line">            a, b = b, a</span><br><span class="line">        </span><br><span class="line">        m, n = <span class="built_in">len</span>(a), <span class="built_in">len</span>(b)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 技巧：在数组首尾添加无穷小和无穷大作为哨兵</span></span><br><span class="line">        <span class="comment"># 这样可以避免处理边界情况（如切分点在数组最左或最右侧时）</span></span><br><span class="line">        <span class="comment"># inf 表示正无穷，-inf 表示负无穷</span></span><br><span class="line">        inf = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        a = [-inf] + a + [inf]</span><br><span class="line">        b = [-inf] + b + [inf]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 二分查找的范围：在处理后的数组 a 中寻找分割点</span></span><br><span class="line">        <span class="comment"># l 和 r 是基于开区间的二分查找 (l, r)</span></span><br><span class="line">        l, r = <span class="number">0</span>, m + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 开始二分查找</span></span><br><span class="line">        <span class="comment"># 目标是找到一个位置 i，使得 a[i] &lt;= b[j+1]</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            i = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 计算 b 数组对应的分割点 j</span></span><br><span class="line">            <span class="comment"># (m + n + 1) // 2 是左半部分需要的总元素个数（不含哨兵的逻辑）</span></span><br><span class="line">            <span class="comment"># 这里的下标计算考虑了前面的哨兵位</span></span><br><span class="line">            j = (m + n + <span class="number">1</span>) // <span class="number">2</span> - i</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 判断交叉条件：a 的左侧最大值是否小于等于 b 的右侧最小值</span></span><br><span class="line">            <span class="keyword">if</span> a[i] &lt;= b[j+<span class="number">1</span>]:</span><br><span class="line">                l = i <span class="comment"># i 可能是合法的，尝试向右找更大的 i</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = i <span class="comment"># i 太大了，需要向左找</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时，l 就是我们要找的分割点 i</span></span><br><span class="line">        i = l</span><br><span class="line">        j = (m + n + <span class="number">1</span>) // <span class="number">2</span> - i</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># max1：左半部分的最大值（取 a[i] 和 b[j] 较大的那个）</span></span><br><span class="line">        max1 = <span class="built_in">max</span>(a[i], b[j])</span><br><span class="line">        <span class="comment"># min2：右半部分的最小值（取 a[i+1] 和 b[j+1] 较小的那个）</span></span><br><span class="line">        min2 = <span class="built_in">min</span>(a[i+<span class="number">1</span>], b[j+<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果总长度是奇数，中位数就是左半部分的最大值</span></span><br><span class="line">        <span class="comment"># 如果总长度是偶数，中位数是左侧最大值和右侧最小值的平均数</span></span><br><span class="line">        <span class="keyword">return</span> max1 <span class="keyword">if</span> (m + n) % <span class="number">2</span> <span class="keyword">else</span> (max1 + min2) / <span class="number">2</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="comment">// 确保 nums1 是较短的数组</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums1) &gt; <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">        nums1, nums2 = nums2, nums1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m, n := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造带哨兵的新数组</span></span><br><span class="line">    <span class="comment">// 使用 int64 的极值来模拟 inf 和 -inf</span></span><br><span class="line">    <span class="comment">// 注意：题目范围值在 -10^6 到 10^6 之间，所以使用 int 极值是安全的</span></span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, m+<span class="number">2</span>)</span><br><span class="line">    a = <span class="built_in">append</span>(a, math.MinInt) <span class="comment">// -inf</span></span><br><span class="line">    a = <span class="built_in">append</span>(a, nums1...)</span><br><span class="line">    a = <span class="built_in">append</span>(a, math.MaxInt) <span class="comment">// inf</span></span><br><span class="line"></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n+<span class="number">2</span>)</span><br><span class="line">    b = <span class="built_in">append</span>(b, math.MinInt) <span class="comment">// -inf</span></span><br><span class="line">    b = <span class="built_in">append</span>(b, nums2...)</span><br><span class="line">    b = <span class="built_in">append</span>(b, math.MaxInt) <span class="comment">// inf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找范围</span></span><br><span class="line">    l, r := <span class="number">0</span>, m+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l+<span class="number">1</span> &lt; r &#123;</span><br><span class="line">        i := (l + r) / <span class="number">2</span></span><br><span class="line">        <span class="comment">// 计算 nums2 对应的分割点 j</span></span><br><span class="line">        j := (m+n+<span class="number">1</span>)/<span class="number">2</span> - i</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查左边部分是否小于等于右边部分</span></span><br><span class="line">        <span class="keyword">if</span> a[i] &lt;= b[j+<span class="number">1</span>] &#123;</span><br><span class="line">            l = i</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i := l</span><br><span class="line">    j := (m+n+<span class="number">1</span>)/<span class="number">2</span> - i</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取左半部分的最大值</span></span><br><span class="line">    max1 := max(a[i], b[j])</span><br><span class="line">    <span class="comment">// 获取右半部分的最小值</span></span><br><span class="line">    min2 := min(a[i+<span class="number">1</span>], b[j+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据总长度奇偶性返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (m+n)%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">float64</span>(max1)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>(max1+min2) / <span class="number">2.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：求最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：求最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: <code>O(log (min(m, n)))</code><br>我们只对长度较短的数组进行二分查找，循环次数与短数组长度的对数成正比。</p>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(m + n)</code><br>为了简化边界判断，本解法创建了包含哨兵的新数组，使用了线性的额外空间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 438 | 滑动窗口巧解所有字母异位词</title>
    <url>//posts/leetcode-438/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 438 题：<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a>。<br>该题是经典的字符串匹配问题，要求在一个长字符串中找出所有与一个短字符串互为“字母异位词”的子串。对于这类涉及子串、子数组的问题，滑动窗口是一种非常强大和高效的技巧。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们两个字符串 <code>s</code> 和 <code>p</code>，要求在 <code>s</code> 中找到所有 <code>p</code> 的异位词子串，并返回这些子串的起始索引。</p>
<p>什么是“异位词”？异位词指的是由相同字母以不同顺序排列构成的两个词。比如，<code>&quot;abc&quot;</code> 和 <code>&quot;cba&quot;</code> 互为异位词，<code>&quot;aab&quot;</code> 和 <code>&quot;aba&quot;</code> 也互为异位词。本质上，只要两个字符串中每个字符出现的次数都完全相同，它们就是异位词。</p>
<p>我们来看一个例子，<code>s = &quot;cbaebabacd&quot;</code>, <code>p = &quot;abc&quot;</code>：</p>
<ul>
<li>我们需要在 <code>s</code> 中寻找长度为 3 的子串，且该子串由一个 ‘a’、一个 ‘b’、一个 ‘c’ 组成。</li>
<li>从索引 0 开始的子串是 <code>&quot;cba&quot;</code>。它包含了 ‘a’, ‘b’, ‘c’ 各一个，是 <code>&quot;abc&quot;</code> 的异位词。所以 <code>0</code> 是一个答案。</li>
<li>从索引 6 开始的子串是 <code>&quot;bac&quot;</code>。它也包含了 ‘a’, ‘b’, ‘c’ 各一个，是 <code>&quot;abc&quot;</code> 的异位词。所以 <code>6</code> 是另一个答案。</li>
<li>最终返回 <code>[0, 6]</code>。</li>
</ul>
<p>暴力解法是遍历 <code>s</code> 的所有长度为 <code>len(p)</code> 的子串，然后对每个子串进行排序或字符计数来判断是否为异位词，但这样效率太低。滑动窗口法则可以让我们以线性的时间复杂度解决这个问题。</p>
<h3 id="核心思路：滑动窗口与哈希表"><a href="#核心思路：滑动窗口与哈希表" class="headerlink" title="核心思路：滑动窗口与哈希表"></a>核心思路：滑动窗口与哈希表</h3><p>解决这类问题的关键在于，当我们的窗口在字符串 <code>s</code> 上滑动时，如何高效地判断窗口内的子串是否满足“异位词”的条件。</p>
<p>我们可以使用一个哈希表（在 Python 中是 <code>Counter</code> 或字典）来维护一个“需求清单”。</p>
<ol>
<li><strong>初始化需求</strong>：首先，我们统计字符串 <code>p</code> 中每个字符出现的次数，存入哈希表 <code>cnt</code>。这个 <code>cnt</code> 就代表了我们寻找的目标。</li>
<li><strong>滑动窗口</strong>：我们用两个指针 <code>l</code>（左）和 <code>r</code>（右）在 <code>s</code> 上维护一个窗口。<ul>
<li><code>r</code> 指针不断向右移动，扩大窗口。每当一个新字符 <code>s[r]</code> 进入窗口，我们就在 <code>cnt</code> 中将该字符的计数值减 1，表示我们满足了一个“需求”。</li>
<li><strong>关键一步</strong>：如果某个字符 <code>s[r]</code> 的计数值在减 1 后变为负数（<code>cnt[s[r]] &lt; 0</code>），这说明窗口内该字符的数量已经<strong>超过了</strong> <code>p</code> 中所需的数量。此时，窗口内的子串肯定不是异位词。我们必须收缩窗口的左边界，即把 <code>l</code> 指针向右移动，直到窗口重新变得“合法”（即所有字符的计数值都不为负）。在移动 <code>l</code> 的过程中，被移出窗口的字符 <code>s[l]</code> 需要被“归还”到需求清单中，即将其在 <code>cnt</code> 中的计数值加 1。</li>
<li><strong>判断结果</strong>：在窗口扩张和收缩之后，如果窗口的大小 <code>r - l + 1</code> 正好等于 <code>p</code> 的长度 <code>len(p)</code>，这说明窗口内不仅没有多余的字符，而且长度也正好匹配。此时，窗口内的子串就是一个异位词。我们将左边界 <code>l</code> 存入结果列表。</li>
</ul>
</li>
</ol>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化</strong></p>
<ul>
<li>创建一个 <code>ans</code> 列表用于存放结果。</li>
<li>使用 <code>Counter</code> 统计字符串 <code>p</code> 的字符频率，存入 <code>cnt</code>。</li>
<li>初始化左指针 <code>l = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历与窗口扩张</strong></p>
<ul>
<li>使用 <code>enumerate</code> 遍历字符串 <code>s</code>，<code>r</code> 为右指针（索引），<code>c</code> 为当前字符 <code>s[r]</code>。</li>
<li>将新入窗口的字符 <code>c</code> 的计数值减 1：<code>cnt[c] -= 1</code>。</li>
</ul>
</li>
<li><p><strong>窗口收缩</strong></p>
<ul>
<li>进入一个 <code>while</code> 循环，条件是 <code>cnt[c] &lt; 0</code>。这个条件意味着刚刚加入的字符 <code>c</code> 在当前窗口中是多余的。</li>
<li>在循环中，我们将窗口最左侧的字符 <code>s[l]</code> 的计数值加 1，<code>cnt[s[l]] += 1</code>，相当于将其“归还”。</li>
<li>然后将左指针右移一位，<code>l += 1</code>。</li>
<li>这个循环会一直执行，直到窗口内不再有多余的字符。</li>
</ul>
</li>
<li><p><strong>记录结果</strong></p>
<ul>
<li>经过收缩调整后，检查当前窗口的长度 <code>r - l + 1</code> 是否等于 <code>p</code> 的长度。</li>
<li>如果相等，说明我们找到了一个长度和字符构成都完全匹配的异位词子串。将其起始索引 <code>l</code> 加入 <code>ans</code> 列表。</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>遍历结束后，<code>ans</code> 即为所求。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 1. 初始化需求计数器</span></span><br><span class="line">        cnt = Counter(p)</span><br><span class="line">        </span><br><span class="line">        l = <span class="number">0</span> <span class="comment"># 左指针</span></span><br><span class="line">        <span class="comment"># 2. r 为右指针，遍历 s</span></span><br><span class="line">        <span class="keyword">for</span> r, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="comment"># 3. 字符 c 进入窗口，需求数减 1</span></span><br><span class="line">            cnt[c] -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 4. 如果 c 的需求数变为负数，说明窗口内 c 过多，需要收缩左边界</span></span><br><span class="line">            <span class="keyword">while</span> cnt[c] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 将 s[l] 移出窗口，其需求数加 1</span></span><br><span class="line">                cnt[s[l]] += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 左指针右移</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 5. 如果当前窗口大小恰好等于 p 的长度，说明找到了一个异位词</span></span><br><span class="line">            <span class="keyword">if</span> r - l + <span class="number">1</span> == <span class="built_in">len</span>(p):</span><br><span class="line">                ans.append(l)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(len(s))。虽然代码里有一个嵌套的 <code>while</code> 循环，但左右两个指针 <code>l</code> 和 <code>r</code> 都只从左到右单向移动一次，每个字符最多被访问两次（一次被 <code>r</code> 访问，一次被 <code>l</code> 访问）。因此总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(C)。其中 C 是字符集的大小（本题中是 26 个小写字母）。哈希表 <code>cnt</code> 的大小取决于 <code>p</code> 中不同字符的数量，最坏情况下是 26。所以空间复杂度是常数级别的。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想的一个绝佳应用。它将一个看似需要反复比较的子串问题，转化为对一个窗口内状态的动态维护。通过“扩张-更新-判断-收缩”的循环，我们在一次遍历中就解决了问题。这种不定长滑动窗口的模板（通过 <code>while</code> 循环来收缩窗口以满足特定条件）在处理很多子串&#x2F;子数组问题时都非常有效，是必须掌握的核心技巧之一。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 567 | 滑动窗口精解字符串排列问题</title>
    <url>//posts/leetcode-567/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 567 题：<a href="https://leetcode.cn/problems/permutation-in-string/">字符串的排列</a>。<br>这是一道经典的面试题，也是展示“滑动窗口”算法思想威力的绝佳范例。它教会我们如何将一个看似复杂的问题（关于“排列”）转化为一个更易于处理的计数问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们来仔细分析一下题目：给定两个字符串 <code>s1</code> 和 <code>s2</code>，判断 <code>s2</code> 是否<strong>包含</strong> <code>s1</code> 的<strong>排列</strong>。</p>
<ul>
<li><strong>排列</strong>：意味着字符种类和数量完全相同，但顺序可以任意。例如，<code>&quot;abc&quot;</code> 的排列有 <code>&quot;acb&quot;</code>, <code>&quot;bac&quot;</code>, <code>&quot;bca&quot;</code>, <code>&quot;cab&quot;</code>, <code>&quot;cba&quot;</code>。</li>
<li><strong>包含</strong>：意味着 <code>s1</code> 的某个排列是 <code>s2</code> 的一个<strong>连续子串</strong>。</li>
</ul>
<p>例如，<code>s1 = &quot;ab&quot;</code>, <code>s2 = &quot;eidbaooo&quot;</code>。<code>s1</code> 的排列有 <code>&quot;ab&quot;</code> 和 <code>&quot;ba&quot;</code>。因为 <code>s2</code> 中包含子串 <code>&quot;ba&quot;</code>，所以应该返回 <code>true</code>。</p>
<h3 id="核心思路：转化问题"><a href="#核心思路：转化问题" class="headerlink" title="核心思路：转化问题"></a>核心思路：转化问题</h3><h4 id="抛弃排列，拥抱计数"><a href="#抛弃排列，拥抱计数" class="headerlink" title="抛弃排列，拥抱计数"></a>抛弃排列，拥抱计数</h4><p>首先，一个很自然但效率极低的想法是：生成 <code>s1</code> 的所有排列，然后逐一检查它们是否存在于 <code>s2</code> 中。这个方法很快就会因为 <code>s1</code> 稍长而导致“超出时间限制”，因为一个长度为 <code>n</code> 的字符串，其排列数量是 <code>n!</code>。</p>
<p>正确的思考方向是：<strong>一个字符串是另一个字符串的排列，充要条件是它们拥有完全相同的字符，且每种字符的数量都完全相等。</strong></p>
<p>例如，<code>&quot;ba&quot;</code> 是 <code>&quot;ab&quot;</code> 的排列，因为它们都含有 1 个 <code>&#39;a&#39;</code> 和 1 个 <code>&#39;b&#39;</code>。</p>
<p>所以，问题被巧妙地转化了：在 <code>s2</code> 中，是否存在一个长度与 <code>s1</code> 相等的子串，其字符频率（种类和数量）与 <code>s1</code> 完全相同？</p>
<h4 id="滑动窗口登场"><a href="#滑动窗口登场" class="headerlink" title="滑动窗口登场"></a>滑动窗口登场</h4><p>这个问题完美地契合了<strong>定长滑动窗口</strong>的应用场景。我们可以：</p>
<ol>
<li>创建一个长度为 <code>len(s1)</code> 的窗口，在 <code>s2</code> 上从左到右滑动。</li>
<li>对于每一个窗口内的子串，我们都去检查它的字符频率是否和 <code>s1</code> 的字符频率一致。</li>
<li>如果找到一个匹配的窗口，立即返回 <code>true</code>。</li>
<li>如果窗口滑到了 <code>s2</code> 的末尾仍然没有找到，则返回 <code>false</code>。</li>
</ol>
<p>为了高效地比较字符频率，我们可以使用哈希表（在 Python 中是 <code>Counter</code> 或 <code>dict</code>）或者一个大小为 26 的数组来存储每个字符的出现次数。</p>
<h3 id="滑动窗口算法详解"><a href="#滑动窗口算法详解" class="headerlink" title="滑动窗口算法详解"></a>滑动窗口算法详解</h3><ol>
<li><p><strong>准备工作</strong>:</p>
<ul>
<li>令 <code>n1</code> 为 <code>s1</code> 的长度，<code>n2</code> 为 <code>s2</code> 的长度。如果 <code>n1 &gt; n2</code>，<code>s2</code> 必然无法包含 <code>s1</code> 的排列，直接返回 <code>False</code>。</li>
<li>用哈希表 <code>s1_counts</code> 统计好目标字符串 <code>s1</code> 的字符频率。</li>
</ul>
</li>
<li><p><strong>初始化窗口</strong>:</p>
<ul>
<li>创建另一个哈希表 <code>window_counts</code> 用于统计当前窗口内字符的频率。</li>
<li>将 <code>s2</code> 的前 <code>n1</code> 个字符（即第一个窗口）填入 <code>window_counts</code>。</li>
<li>比较 <code>s1_counts</code> 和 <code>window_counts</code>。如果它们完全相同，说明我们已经找到了答案，返回 <code>True</code>。</li>
</ul>
</li>
<li><p><strong>滑动窗口</strong>:</p>
<ul>
<li>从 <code>s2</code> 的第 <code>n1</code> 个字符开始向右遍历到末尾。在每一次循环中，窗口向右移动一格。</li>
<li>窗口的移动伴随着两个变化：<ul>
<li><strong>移入字符</strong>：一个新字符从窗口右侧进入。我们在 <code>window_counts</code> 中增加这个新字符的计数。</li>
<li><strong>移出字符</strong>：一个旧字符从窗口左侧离开。我们在 <code>window_counts</code> 中减少这个旧字符的计数。</li>
</ul>
</li>
<li><strong>优化</strong>：如果一个字符移出窗口后，它在 <code>window_counts</code> 中的计数变为 0，最好将它从哈希表中移除。这可以确保我们进行 <code>s1_counts == window_counts</code> 比较时的准确性。</li>
<li>每次滑动更新后，都进行一次比较。如果相等，返回 <code>True</code>。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>:</p>
<ul>
<li>如果循环结束仍未找到匹配的窗口，说明不存在这样的子串，返回 <code>False</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><p>使用 <code>collections.Counter</code> 可以让代码变得异常简洁。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkInclusion</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n1, n2 = <span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1：处理边界情况</span></span><br><span class="line">        <span class="keyword">if</span> n1 &gt; n2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 1：统计 s1 的字符频率</span></span><br><span class="line">        s1_counts = Counter(s1)</span><br><span class="line">        window_counts = Counter()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2：初始化第一个窗口</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n1):</span><br><span class="line">            window_counts[s2[i]] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> window_counts == s1_counts:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 3：开始滑动窗口</span></span><br><span class="line">        <span class="comment"># right 是移入窗口的字符索引</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n1, n2):</span><br><span class="line">            <span class="comment"># left 是移出窗口的字符索引</span></span><br><span class="line">            left = right - n1</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 新字符从右侧进入窗口</span></span><br><span class="line">            window_counts[s2[right]] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 旧字符从左侧离开窗口</span></span><br><span class="line">            window_counts[s2[left]] -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果旧字符计数为 0，将其从哈希表中移除</span></span><br><span class="line">            <span class="keyword">if</span> window_counts[s2[left]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> window_counts[s2[left]]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 比较当前窗口和 s1 的频率是否相同</span></span><br><span class="line">            <span class="keyword">if</span> window_counts == s1_counts:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 步骤 4：遍历结束未找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N₁ + (N₂ - N₁))，即 O(N₂)。其中 N₁ 是 <code>s1</code> 的长度，N₂ 是 <code>s2</code> 的长度。我们首先需要 O(N₁) 的时间来创建 <code>s1_counts</code>，然后滑动窗口遍历 <code>s2</code> 一次，花费 O(N₂) 的时间。哈希表的比较操作在字符集大小固定的情况下可视为 O(1)。</li>
<li><strong>空间复杂度</strong>: O(K)，其中 K 是字符集的大小。在这里，因为题目规定只有小写字母，所以 K&#x3D;26，可以看作是 O(1) 的常数空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是运用滑动窗口解决字符串问题的典范。其核心思想在于<strong>用频率计数的相等性来替代排列的判断</strong>，从而将问题转化为一个可以通过线性扫描解决的子串匹配问题。当遇到涉及“连续子串”或“子数组”且需要满足某些条件的问题时，滑动窗口是应该优先考虑的强大工具。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 632 | 滑动窗口求解“最小区间”</title>
    <url>//posts/leetcode-632/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 632 题：<a href="https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/">最小区间</a>。<br>该题要求在 k 个排序列表中寻找一个最小的数值区间，这个区间需要包含来自每个列表的至少一个元素。这是一个经典的多路数据处理问题，通过将所有元素“压平”并结合滑动窗口，可以巧妙地解决。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们 <code>k</code> 个非递减排序的整数列表 <code>nums</code>。我们需要找到一个最小的数值区间 <code>[a, b]</code>，要求这个区间必须包含来自<strong>每一个</strong>列表的至少一个数字。</p>
<p>“最小”区间的定义有两层：</p>
<ol>
<li>首先比较区间的长度 <code>b - a</code>，长度越小，区间就越小。</li>
<li>如果两个区间的长度相等，那么起始点 <code>a</code> 较小的区间更小。</li>
</ol>
<p>例如，对于 <code>nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]</code>：</p>
<ul>
<li>区间 <code>[20, 24]</code> 是一个有效的覆盖区间，因为它包含了来自列表1的 <code>24</code>、列表2的 <code>20</code> 和列表3的 <code>22</code>。</li>
<li>这个区间的长度是 4。</li>
<li>我们可以找到其他有效区间，如 <code>[0, 5]</code> 覆盖了 <code>4, 0, 5</code>，长度为 5。</li>
<li>经过比较，<code>[20, 24]</code> 是所有有效区间中长度最小的，因此是最终答案。</li>
</ul>
<p>直接在 <code>k</code> 个列表中寻找这样的区间非常困难，因为我们不知道区间的端点应该如何选择。</p>
<h3 id="核心思路：排序-滑动窗口"><a href="#核心思路：排序-滑动窗口" class="headerlink" title="核心思路：排序 + 滑动窗口"></a>核心思路：排序 + 滑动窗口</h3><p>这个问题的核心难点在于数据分散在 <code>k</code> 个不同的列表中，难以统一处理。一个常见的“降维”思路是，将多路数据合并成一路，从而应用更成熟的单数组算法。</p>
<p>关键的洞察在于：<strong>最优区间的两个端点 <code>a</code> 和 <code>b</code>，必然是输入数据中存在的某两个数</strong>。</p>
<p>基于此，我们可以：</p>
<ol>
<li><strong>扁平化数据</strong>：将所有 <code>k</code> 个列表中的所有数字合并到一个单一的列表中。为了后续判断区间有效性，我们不仅要存储数值，还要存储它来自哪个列表。因此，我们创建一个 <code>(数值, 原始列表索引)</code> 的元组列表。</li>
<li><strong>排序</strong>：对这个合并后的列表，按照数值进行升序排序。</li>
<li><strong>滑动窗口</strong>：现在问题转化为了一个更经典的形式——在排序后的列表中，寻找一个<strong>最短的子数组（窗口）</strong>，这个子数组中包含了来自全部 <code>k</code> 个不同原始列表的元素。这正是滑动窗口算法的用武之地。</li>
</ol>
<p>我们用 <code>left</code> 和 <code>right</code> 两个指针来定义窗口。我们不断向右移动 <code>right</code> 来扩张窗口，直到窗口内的元素满足“覆盖所有k个列表”的条件。一旦满足，我们就记录下这个有效区间，并尝试从左侧移动 <code>left</code> 指针来收缩窗口，寻找一个可能更小的有效区间。</p>
<p><em>上图形象地展示了在合并排序后的列表上，一个有效的滑动窗口如何覆盖了来自3个不同列表的元素。</em></p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>数据预处理：扁平化与排序</strong></p>
<ul>
<li>初始化一个空列表 <code>merged_list</code>。</li>
<li>遍历输入的 <code>k</code> 个列表，将每个数字 <code>val</code> 和它所属的列表索引 <code>i</code> 作为一个元组 <code>(val, i)</code> 添加到 <code>merged_list</code> 中。</li>
<li>调用排序函数，对 <code>merged_list</code> 按元组的第一个元素（即数值）进行升序排序。</li>
</ul>
</li>
<li><p><strong>滑动窗口遍历</strong></p>
<ul>
<li>初始化左指针 <code>left = 0</code>，以及一个最终答案区间 <code>ans</code>（可以初始化为一个无限大的区间）。</li>
<li>为了高效地判断窗口有效性，我们使用一个哈希表 <code>counts</code> 来记录窗口内每个列表的元素数量，并用一个变量 <code>covered_lists</code> 记录当前已覆盖的列表数量。</li>
<li>使用 <code>right</code> 指针从 <code>0</code> 到 <code>len(merged_list) - 1</code> 进行遍历，代表窗口的右边界。</li>
<li>对于 <code>right</code> 指向的元素 <code>(val, list_idx)</code>:<ul>
<li><strong>扩展窗口</strong>：将其加入窗口。在 <code>counts</code> 中将 <code>list_idx</code> 的计数加一。如果这个计数从 0 变为 1，说明我们刚刚覆盖了一个新的列表，因此 <code>covered_lists</code> 加 1。</li>
</ul>
</li>
<li><strong>检查并收缩窗口</strong>：<ul>
<li>使用一个 <code>while</code> 循环检查 <code>covered_lists</code> 是否等于 <code>k</code>。如果是，说明当前窗口 <code>[left, right]</code> 是一个有效的候选区间。</li>
<li>获取当前区间的左右端点值 <code>merged_list[left][0]</code> 和 <code>merged_list[right][0]</code>，计算区间长度。</li>
<li>如果当前区间比已记录的 <code>ans</code> 区间更小，则更新 <code>ans</code>。</li>
<li><strong>收缩窗口</strong>：尝试将 <code>left</code> 指针右移。在 <code>counts</code> 中将 <code>left</code> 指向元素的列表索引的计数减一。如果计数变为 0，说明我们失去了一个列表的覆盖，<code>covered_lists</code> 减 1。此时 <code>while</code> 循环将终止。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>当 <code>right</code> 指针遍历完整个列表后，<code>ans</code> 中存储的就是最终的最小区间。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 步骤 1: 创建并排序合并列表</span></span><br><span class="line">        merged_list = []</span><br><span class="line">        <span class="keyword">for</span> i, lst <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> lst:</span><br><span class="line">                merged_list.append((val, i))</span><br><span class="line">        </span><br><span class="line">        merged_list.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        k = <span class="built_in">len</span>(nums)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        list_counts = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        lists_covered = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        min_range_size = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        result_start, result_end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2: 滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(merged_list)):</span><br><span class="line">            val_right, list_idx_right = merged_list[right]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 扩展窗口</span></span><br><span class="line">            <span class="keyword">if</span> list_counts[list_idx_right] == <span class="number">0</span>:</span><br><span class="line">                lists_covered += <span class="number">1</span></span><br><span class="line">            list_counts[list_idx_right] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当窗口有效时，检查并尝试收缩</span></span><br><span class="line">            <span class="keyword">while</span> lists_covered == k:</span><br><span class="line">                val_left, list_idx_left = merged_list[left]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 检查是否为更小的区间</span></span><br><span class="line">                current_range_size = val_right - val_left</span><br><span class="line">                <span class="keyword">if</span> current_range_size &lt; min_range_size:</span><br><span class="line">                    min_range_size = current_range_size</span><br><span class="line">                    result_start = val_left</span><br><span class="line">                    result_end = val_right</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 收缩窗口</span></span><br><span class="line">                list_counts[list_idx_left] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> list_counts[list_idx_left] == <span class="number">0</span>:</span><br><span class="line">                    lists_covered -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [result_start, result_end]</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N log N)，其中 N 是所有列表中元素的总数。主要开销在于对 <code>merged_list</code> 的排序。后续的滑动窗口遍历是 O(N)，因为 <code>left</code> 和 <code>right</code> 指针都只遍历列表一次。</li>
<li><strong>空间复杂度</strong>: O(N)，用于存储 <code>merged_list</code> 和哈希表 <code>counts</code>。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题展示了如何通过数据结构的转换，将一个看似复杂的多列表问题简化为单数组上的经典算法问题。扁平化和排序是处理多个有序序列的常用技巧，它为滑动窗口等高效算法的应用铺平了道路。此外，对于此类问题，还存在一种使用最小堆（Min-Heap）的更优解法，其时间复杂度为 O(N log k)，在 <code>k</code> 远小于 <code>N</code> 时更具优势，也值得进一步学习。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>贪心</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>排序</tag>
        <tag>堆（优先队列）</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 668 | 乘法表中第k小的数</title>
    <url>//posts/leetcode-668/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 668 题：<a href="https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/description/">乘法表中第k小的数</a>。<br>本题可以转化为一个判定性问题：给定整数 x，统计乘法表中 ≤x 的元素个数 cnt，判断是否满足 cnt≥k。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个 <code>m x n</code> 的乘法表，以及一个正整数 <code>k</code>，你需要返回表中第 <code>k</code> 小的数字。</p>
<p>乘法表是一个整数矩阵 <code>mat</code>，其中 <code>mat[i][j] == i * j</code>（下标从 1 开始）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 3, k = 5</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">乘法表:</span><br><span class="line">1	2	3</span><br><span class="line">2	4	6</span><br><span class="line">3	6	9</span><br><span class="line"></span><br><span class="line">排序后的序列为：1, 2, 2, 3, 3, 4, 6, 6, 9。第 5 小的数字是 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 2, n = 3, k = 6</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">乘法表:</span><br><span class="line">1	2	3</span><br><span class="line">2	4	6</span><br><span class="line"></span><br><span class="line">排序后的序列为：1, 2, 2, 3, 4, 6。第 6 小的数字是 6。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m, n &lt;= 3 * 10^4</code></li>
<li><code>1 &lt;= k &lt;= m * n</code></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="暴力解法为何不可行？"><a href="#暴力解法为何不可行？" class="headerlink" title="暴力解法为何不可行？"></a>暴力解法为何不可行？</h4><p>一个直观的想法是生成整个 <code>m x n</code> 的乘法表，将其展平成一个一维数组，然后排序，最后返回第 <code>k</code> 个元素。</p>
<p>然而，根据题目的约束条件，<code>m</code> 和 <code>n</code> 的最大值都可以达到 30000。这意味着乘法表最多可能有 <code>30000 * 30000 = 9 * 10^8</code> 个元素。 创建和存储如此巨大的数组会导致内存溢出，因此暴力解法是不可行的。</p>
<h4 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h4><p>这道题是“寻找第 k 小元素”的经典变体。对于这类问题，一个强大的思想是<strong>二分答案</strong>。</p>
<p>我们要求的解（第 k 小的数）一定在 <code>[1, m*n]</code> 这个区间内。我们可以对这个数值区间进行二分查找。假设我们猜测第 <code>k</code> 小的数是 <code>mid</code>。为了验证这个猜测，我们需要快速计算出乘法表中有多少个数小于等于 <code>mid</code>。我们把这个计数函数记为 <code>count(mid)</code>。</p>
<ul>
<li>如果 <code>count(mid) &gt;= k</code>，这说明 <code>mid</code> 太大了，或者 <code>mid</code> 正好是我们要找的答案。真正的第 <code>k</code> 小的数可能更小，或者就是 <code>mid</code>。因此，我们应该在 <code>[1, mid]</code> 这个区间继续查找。</li>
<li>如果 <code>count(mid) &lt; k</code>，这说明 <code>mid</code> 太小了，乘法表中比它小的数不足 <code>k</code> 个。因此，第 <code>k</code> 小的数一定比 <code>mid</code> 大。我们应该在 <code>[mid + 1, m*n]</code> 这个区间继续查找。</li>
</ul>
<p>通过不断缩小范围，我们最终可以找到满足条件的最小的那个数，即为第 <code>k</code> 小的数。</p>
<h4 id="如何实现-count-x-函数？"><a href="#如何实现-count-x-函数？" class="headerlink" title="如何实现 count(x) 函数？"></a>如何实现 <code>count(x)</code> 函数？</h4><p>现在问题的核心变成了如何高效地计算乘法表里小于等于 <code>x</code> 的数的个数。</p>
<p>乘法表的每一行 <code>i</code> （<code>1 &lt;= i &lt;= m</code>）都是一个等差数列：<code>1*i, 2*i, 3*i, ..., n*i</code>。</p>
<p>对于第 <code>i</code> 行，我们要计算有多少个 <code>j*i &lt;= x</code>，其中 <code>1 &lt;= j &lt;= n</code>。<br>这等价于 <code>j &lt;= x / i</code>。<br>所以，在第 <code>i</code> 行，小于等于 <code>x</code> 的数的个数就是 <code>floor(x / i)</code>。但是，这个个数不能超过该行的总列数 <code>n</code>。</p>
<p>因此，第 <code>i</code> 行中小于等于 <code>x</code> 的数字个数为 <code>min(floor(x / i), n)</code>。</p>
<p>我们将每一行的计数加起来，就得到了整个乘法表中不大于 <code>x</code> 的数字总数：<br><code>count(x) = sum(min(floor(x / i), n) for i in 1..m)</code></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthNumber</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用二分查找在答案空间 [1, m*n] 中寻找第 k 小的数。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            检查乘法表中小于等于 x 的数的个数是否大于等于 k。</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 遍历每一行</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 对于第 i 行，其元素为 i, 2*i, 3*i, ...</span></span><br><span class="line">                <span class="comment"># 小于等于 x 的元素个数为 x // i，但不能超过列数 n</span></span><br><span class="line">                count += <span class="built_in">min</span>(x // i, n)</span><br><span class="line">            <span class="keyword">return</span> count &gt;= k</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 答案的范围是 [1, m*n]</span></span><br><span class="line">        left, right = <span class="number">1</span>, m * n</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># mid 可能是答案，或者答案在 mid 的左侧</span></span><br><span class="line">                <span class="comment"># 我们需要找到满足条件的最小的 mid</span></span><br><span class="line">                ans = mid</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># mid 太小了，答案在 mid 的右侧</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: <code>O(m * log(m*n))</code>。二分查找的范围是 <code>m*n</code>，所以对数项是 <code>log(m*n)</code>。在每次二分检查中，<code>check</code> 函数需要 <code>O(m)</code> 的时间来遍历 <code>m</code> 行。</li>
<li><strong>空间复杂度</strong>: <code>O(1)</code>。我们只使用了常数个变量。</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>第K小/大</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 719 | 找出第 K 小的数对距离</title>
    <url>//posts/leetcode-719/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 719 题：<a href="https://leetcode.cn/problems/find-k-th-smallest-pair-distance/description/">找出第 K 小的数对距离</a>。<br>本题是经典的“第 K 小”问题，解题核心在于将求解转化为判定：给定一个距离 x，统计距离 ≤x 的数对个数 cnt，判断是否满足 cnt≥k。结合排序和双指针技巧，可以将判定过程优化至线性时间。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>数对 <code>(a,b)</code> 由整数 <code>a</code> 和 <code>b</code> 组成，其数对距离定义为 <code>a</code> 和 <code>b</code> 的绝对差值。</p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，数对由 <code>nums[i]</code> 和 <code>nums[j]</code> 组成且满足 <code>0 &lt;= i &lt; j &lt; nums.length</code> 。返回 所有数对距离中 第 <code>k</code> 小的数对距离。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,1], k = 1</span><br><span class="line">输出：0</span><br><span class="line">解释：数对和对应的距离如下：</span><br><span class="line">(1,3) -&gt; 2</span><br><span class="line">(1,1) -&gt; 0</span><br><span class="line">(3,1) -&gt; 2</span><br><span class="line">距离第 1 小的数对是 (1,1) ，距离为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,6,1], k = 3</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>2 &lt;= n &lt;= 10^4</code></li>
<li><code>0 &lt;= nums[i] &lt;= 10^6</code></li>
<li><code>1 &lt;= k &lt;= n * (n - 1) / 2</code></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="暴力解法与瓶颈"><a href="#暴力解法与瓶颈" class="headerlink" title="暴力解法与瓶颈"></a>暴力解法与瓶颈</h4><p>最直观的方法是计算出所有可能的数对距离，放入一个数组中，然后进行排序并取第 <code>k</code> 个值。<br>数组长度为 <code>N</code>，则总共有 <code>N * (N - 1) / 2</code> 个数对。<br>当 <code>N = 10^4</code> 时，数对数量约为 <code>5 * 10^7</code>。对这么多数据进行排序，时间复杂度为 <code>O(N^2 * log(N^2))</code>，这显然会<strong>超时</strong>（TLE），甚至可能导致<strong>内存溢出</strong>（MLE）。</p>
<h4 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h4><p>既然无法直接计算并排序所有距离，我们需要换个角度。<br>数对距离的取值范围是确定的：</p>
<ul>
<li>最小值：<code>0</code>（当数组中有重复元素时）。</li>
<li>最大值：数组中最大元素与最小元素的差值。</li>
</ul>
<p>我们可以在这个<strong>数值范围</strong> <code>[0, max(nums) - min(nums)]</code> 内进行二分查找。<br>假设我们猜测第 <code>k</code> 小的距离是 <code>mid</code>。为了验证，我们需要计算：<strong>数组中有多少个数对的距离小于等于 <code>mid</code>？</strong> 记这个数量为 <code>cnt</code>。</p>
<ul>
<li>如果 <code>cnt &gt;= k</code>：说明小于等于 <code>mid</code> 的数对太多了，或者正好足够。第 <code>k</code> 小的距离可能是 <code>mid</code>，也可能比 <code>mid</code> 更小。答案在左半区间（包含 <code>mid</code>）。</li>
<li>如果 <code>cnt &lt; k</code>：说明 <code>mid</code> 太小了，连前 <code>k</code> 个都覆盖不到。答案一定比 <code>mid</code> 大。答案在右半区间。</li>
</ul>
<h4 id="使用双指针（滑动窗口）优化计数"><a href="#使用双指针（滑动窗口）优化计数" class="headerlink" title="使用双指针（滑动窗口）优化计数"></a>使用双指针（滑动窗口）优化计数</h4><p>现在的核心难点在于：如何高效地计算“距离小于等于 <code>mid</code> 的数对个数”？<br>如果在未排序的数组中统计，仍需 <code>O(N^2)</code> 的时间，二分也就失去了意义。<br>但是，如果我们<strong>先对数组进行排序</strong>，就可以利用单调性使用<strong>双指针</strong>来统计。</p>
<p>假设数组已排序，对于每一个右端点 <code>j</code>，我们要找到最小的左端点 <code>i</code>，使得 <code>nums[j] - nums[i] &lt;= mid</code>。<br>由于数组是递增的，随着 <code>j</code> 向右移动（变大），满足条件的 <code>i</code> 也只会向右移动（或不动），而不会回头。</p>
<p>算法流程：</p>
<ol>
<li>对 <code>nums</code> 排序。</li>
<li>枚举右指针 <code>j</code> 从 <code>0</code> 到 <code>n-1</code>。</li>
<li>当 <code>nums[j] - nums[i] &gt; mid</code> 时，说明当前的 <code>i</code> 太小了（导致差值太大），需要右移 <code>i</code>。</li>
<li>对于当前的 <code>j</code>，有效数对的数量为 <code>j - i</code>（即索引 <code>i</code> 到 <code>j-1</code> 都可以和 <code>j</code> 组成满足条件的数对）。</li>
<li>累加所有 <code>j</code> 对应的数量。</li>
</ol>
<p>这个 check 函数的时间复杂度是 <code>O(N)</code>。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>代码中使用了“开区间”二分模板（<code>l</code> 始终不满足条件，<code>r</code> 始终满足条件），这是一种不易写错死循环的写法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestDistancePair</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 1. 排序，这是使用双指针的前提</span></span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># check 函数：统计有多少个数对的距离 &lt;= mx</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">mx: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 双指针：j 是右指针，i 是左指针</span></span><br><span class="line">            <span class="keyword">for</span> j, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">                <span class="comment"># 如果当前距离大于 mx，说明 i 太靠左了，也就是 nums[i] 太小</span></span><br><span class="line">                <span class="comment"># 此时需要移动左指针 i，直到满足条件</span></span><br><span class="line">                <span class="keyword">while</span> x - nums[i] &gt; mx:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 此时 [i, j-1] 范围内的数与 nums[j] 的距离都 &lt;= mx</span></span><br><span class="line">                <span class="comment"># 个数为 j - i</span></span><br><span class="line">                cnt += j - i</span><br><span class="line">            <span class="keyword">return</span> cnt &gt;= k</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 二分查找</span></span><br><span class="line">        <span class="comment"># 距离的可能范围是 [0, nums[-1] - nums[0]]</span></span><br><span class="line">        <span class="comment"># 这里使用开区间写法 (l, r]</span></span><br><span class="line">        <span class="comment"># l 初始为 -1 (不可能的极小值)</span></span><br><span class="line">        <span class="comment"># r 初始为最大距离 (必然满足条件的极大值)</span></span><br><span class="line">        l, r = -<span class="number">1</span>, nums[-<span class="number">1</span>] - nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 count &gt;= k，说明 mid 可能是答案，或者答案更小</span></span><br><span class="line">                <span class="comment"># mid 是满足条件的一个候选值，收缩右边界</span></span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># count &lt; k，说明 mid 太小了，答案一定大于 mid</span></span><br><span class="line">                <span class="comment"># 收缩左边界</span></span><br><span class="line">                l = mid</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: <code>O(N * log(N) + N * log(D))</code>。<ul>
<li>排序需要 <code>O(N * log(N))</code>。</li>
<li>二分查找的范围 <code>D = max(nums) - min(nums)</code>，最大为 <code>10^6</code>，二分次数为 <code>log(D)</code>。</li>
<li>每次二分调用 <code>check</code> 函数，双指针遍历数组需要 <code>O(N)</code>。</li>
<li>总复杂度为 <code>O(N * log(N) + N * log(max(nums)))</code>。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: <code>O(1)</code> 或 <code>O(log(N))</code>。<ul>
<li>取决于排序算法的实现，双指针和二分查找仅使用常数级额外空间。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>第K小/大</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>排序</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 739 | 每日温度</title>
    <url>//posts/leetcode-739/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 739 题：<a href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a>。<br>问题的核心是寻找数组中每个元素右侧第一个比它大的元素。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入: temperatures = [30,40,50,60]</span><br><span class="line">输出: [1,1,1,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入: temperatures = [30,60,90]</span><br><span class="line">输出: [1,1,0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; temperatures.length &lt;&#x3D; 10^5</li>
<li>30 &lt;&#x3D; temperatures[i] &lt;&#x3D; 100</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-暴力法的局限性"><a href="#1-暴力法的局限性" class="headerlink" title="1. 暴力法的局限性"></a>1. 暴力法的局限性</h4><p>对于每一天，如果我们都向后遍历去寻找第一个比它温度高的日子，最坏情况下的时间复杂度是 O(n^2)。当数组长度达到 10^5 时，这种做法会超时。我们需要一种 O(n) 的解法。</p>
<h4 id="2-单调栈"><a href="#2-单调栈" class="headerlink" title="2. 单调栈"></a>2. 单调栈</h4><p>这类“寻找下一个更大元素”的问题是单调栈的典型应用场景。</p>
<p>我们可以维护一个存储下标的栈。在本题的解法中，我们采用 <strong>从后往前</strong> 遍历数组的方式：</p>
<ol>
<li><strong>倒序遍历</strong>：从最后一天向第一天遍历。因为对于第 <code>i</code> 天来说，我们需要知道的是它“未来”的信息。倒序遍历可以让我们先把未来的数据处理好放入栈中。</li>
<li><strong>栈的作用</strong>：栈中存储的是“未来”日期的下标。这些下标对应的温度，在栈中保持 <strong>从栈顶到栈底递增</strong>。</li>
<li><strong>核心逻辑</strong>：<ul>
<li>当我们遍历到第 <code>i</code> 天，温度为 <code>t</code> 时，我们查看栈顶的日期。</li>
<li>如果栈顶日期的温度 <strong>小于等于</strong> 当前温度 <code>t</code>，说明栈顶的那个日子对于第 <code>i</code> 天来说没有任何意义（因为它不够热），而且对于 <code>i</code> 之前的日子也没意义（因为第 <code>i</code> 天距离更近且温度更高，完全遮挡了栈顶那个日子的作用）。所以，我们可以把栈顶元素 <strong>弹出</strong>。</li>
<li>重复上述操作，直到栈为空或者栈顶日期的温度 <strong>大于</strong> <code>t</code>。</li>
<li>此时，如果栈不为空，栈顶的下标就是第 <code>i</code> 天右侧第一个比它热的日子。计算距离 <code>st[-1] - i</code> 存入结果。</li>
<li>最后，将当前第 <code>i</code> 天的下标入栈，因为它可能是更前面的日子的“下一个更高温度”。</li>
</ul>
</li>
</ol>
<p>通过这种方式，每个元素最多入栈一次、出栈一次，时间复杂度被优化到了 O(n)。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">        ans = [<span class="number">0</span>] * n</span><br><span class="line">        st = []  <span class="comment"># 栈，用于存储下标</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从后往前遍历 (n-1 到 0)</span></span><br><span class="line">        <span class="comment"># 这样栈里存的都是当前位置之后的一天</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            t = temperatures[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 维护单调栈：如果栈顶元素的温度 &lt;= 当前温度</span></span><br><span class="line">            <span class="comment"># 说明栈顶这天不可能是“下一个更高温度”，弹出</span></span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> t &gt;= temperatures[st[-<span class="number">1</span>]]:</span><br><span class="line">                st.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果栈不为空，说明找到了右边第一个比当前高的温度</span></span><br><span class="line">            <span class="keyword">if</span> st:</span><br><span class="line">                ans[i] = st[-<span class="number">1</span>] - i</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将当前下标入栈，供前面的元素查找</span></span><br><span class="line">            st.append(i)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;slices&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dailyTemperatures</span><span class="params">(temperatures []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(temperatures))</span><br><span class="line">    st := []<span class="type">int</span>&#123;&#125; <span class="comment">// 栈，存储下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 slices.Backward 进行倒序遍历 (Go 1.23+)</span></span><br><span class="line">    <span class="keyword">for</span> i, t := <span class="keyword">range</span> slices.Backward(temperatures) &#123;</span><br><span class="line">        <span class="comment">// 当栈不为空，且当前温度 &gt;= 栈顶下标对应的温度时</span></span><br><span class="line">        <span class="comment">// 栈顶元素对于前面的日子已经没有价值了（被当前更高的温度挡住了），弹出</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(st) &gt; <span class="number">0</span> &amp;&amp; t &gt;= temperatures[st[<span class="built_in">len</span>(st)<span class="number">-1</span>]] &#123;</span><br><span class="line">            st = st[:<span class="built_in">len</span>(st)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果栈还有元素，栈顶就是右侧第一个比当前温度高的位置</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(st) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            ans[i] = st[<span class="built_in">len</span>(st)<span class="number">-1</span>] - i</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前位置推入栈中</span></span><br><span class="line">        st = <span class="built_in">append</span>(st, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>虽然代码中包含两层循环（外层 <code>for</code> 和内层 <code>while</code>），但观察栈的操作可以发现：数组中的每个元素的下标最多被压入栈一次，也最多被弹出栈一次。因此整体操作次数是线性的。</p>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(n)</code><br>我们需要一个栈来存储下标以及一个数组来存储结果。在最坏情况下（例如数组是单调递减的），栈的大小可以达到 <code>n</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>单调栈</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>栈</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 74 | 搜索二维矩阵</title>
    <url>//posts/leetcode-74/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 74 题：<a href="https://leetcode.cn/problems/search-a-2d-matrix/">搜索二维矩阵</a>。<br>利用矩阵“行首大于前一行行尾”的特性，将其逻辑上展开为一个有序的一维数组，直接使用二分查找即可解决。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p>
<ol>
<li>每行中的整数从左到右按非严格递增顺序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ol>
<p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong><br><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt="示例1"></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>m &#x3D;&#x3D; matrix.length</li>
<li>n &#x3D;&#x3D; matrix[i].length</li>
<li>1 &lt;&#x3D; m, n &lt;&#x3D; 100</li>
<li>-10^4 &lt;&#x3D; matrix[i][j], target &lt;&#x3D; 10^4</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-矩阵特性分析"><a href="#1-矩阵特性分析" class="headerlink" title="1. 矩阵特性分析"></a>1. 矩阵特性分析</h4><p>题目给出的两个条件非常关键：</p>
<ul>
<li>行内递增。</li>
<li>下一行的第一个元素大于上一行的最后一个元素。</li>
</ul>
<p>这意味着，如果我们把每一行首尾相连拼接起来，这个矩阵在逻辑上就是一个<strong>严格单调递增的一维数组</strong>。</p>
<p>例如矩阵：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[[1, 3, 5, 7],</span><br><span class="line"> [10, 11, 16, 20],</span><br><span class="line"> [23, 30, 34, 60]]</span><br></pre></td></tr></table></figure>
<p>展开后变为：<br><code>[1, 3, 5, 7, 10, 11, 16, 20, 23, 30, 34, 60]</code></p>
<h4 id="2-坐标映射"><a href="#2-坐标映射" class="headerlink" title="2. 坐标映射"></a>2. 坐标映射</h4><p>既然可以看作一维数组，我们就可以直接对在这个逻辑一维数组上进行<strong>二分查找</strong>。</p>
<p>假设矩阵有 <code>m</code> 行 <code>n</code> 列，总元素个数为 <code>m * n</code>。<br>对于范围在 <code>[0, m * n - 1]</code> 内的一维数组索引 <code>idx</code>，可以通过以下公式映射回二维矩阵的坐标 <code>(row, col)</code>：</p>
<ul>
<li><code>row = idx / n</code> (整除)</li>
<li><code>col = idx % n</code> (取模)</li>
</ul>
<h4 id="3-二分查找实现"><a href="#3-二分查找实现" class="headerlink" title="3. 二分查找实现"></a>3. 二分查找实现</h4><p>我们使用左开右开区间 <code>(l, r)</code> 的二分模板：</p>
<ul>
<li>初始左边界 <code>l = -1</code></li>
<li>初始右边界 <code>r = m * n</code></li>
<li>当 <code>l + 1 &lt; r</code> 时循环，计算 <code>mid</code>，映射坐标取值并与 <code>target</code> 比较。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 获取矩阵的行数 m 和列数 n</span></span><br><span class="line">        m,n=<span class="built_in">len</span>(matrix),<span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将二维矩阵视为长度为 m*n 的一维有序数组</span></span><br><span class="line">        <span class="comment"># 定义二分查找的区间为左开右开 (-1, m*n)</span></span><br><span class="line">        l,r = -<span class="number">1</span>,m*n</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l+<span class="number">1</span>&lt;r:</span><br><span class="line">            mid= (l+r)//<span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 核心步骤：坐标映射</span></span><br><span class="line">            <span class="comment"># 将一维索引 mid 转换为二维坐标 [row][col]</span></span><br><span class="line">            <span class="comment"># 行索引 = mid // 列数</span></span><br><span class="line">            <span class="comment"># 列索引 = mid % 列数</span></span><br><span class="line">            x = matrix[mid//n][mid%n]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> x==target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 标准二分逻辑</span></span><br><span class="line">            <span class="keyword">if</span> x&lt;target:</span><br><span class="line">                <span class="comment"># 目标值在右侧（较大值方向）</span></span><br><span class="line">                l=mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 目标值在左侧（较小值方向）</span></span><br><span class="line">                r = mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 获取矩阵维度</span></span><br><span class="line">    m,n:=<span class="built_in">len</span>(matrix),<span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化二分查找的左右边界</span></span><br><span class="line">    <span class="comment">// 使用开区间 (-1, m*n)，对应虚拟一维数组的索引范围</span></span><br><span class="line">    l,r:=<span class="number">-1</span>,m*n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> l+<span class="number">1</span>&lt;r&#123;</span><br><span class="line">        mid :=l+(r-l)/<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 坐标转换：将一维索引 mid 映射回二维矩阵坐标</span></span><br><span class="line">        <span class="comment">// 行下标 = mid / 列数</span></span><br><span class="line">        <span class="comment">// 列下标 = mid % 列数</span></span><br><span class="line">        x:=matrix[mid/n][mid%n]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> x==target&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> x&lt;target&#123;</span><br><span class="line">            <span class="comment">// 当前值小于目标值，说明目标在右半部分，移动左边界</span></span><br><span class="line">            l = mid</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 当前值大于目标值，说明目标在左半部分，移动右边界</span></span><br><span class="line">            r = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: <code>O(log(mn))</code><br>我们将二维矩阵视作长度为 <code>mn</code> 的一维数组进行二分查找，每次比较操作大大缩小搜索范围，时间复杂度为对数级别。</p>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(1)</code><br>只使用了常数个变量（<code>l</code>, <code>r</code>, <code>mid</code>, <code>x</code> 等）来存储索引和中间值，没有使用额外的线性空间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 76 | 滑动窗口求解“最小覆盖子串”</title>
    <url>//posts/leetcode-76/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 76 题：<a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a>。<br>这道题是滑动窗口思想的集大成者，要求在字符串 <code>s</code> 中找出包含字符串 <code>t</code> 所有字符的最小连续子串。它完美地诠释了如何通过双指针的移动来动态维护一个“可行”的窗口，并从中找到最优解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们两个字符串 <code>s</code> 和 <code>t</code>。我们需要在 <code>s</code> 中找到一个最短的连续子串，这个子串必须“覆盖”<code>t</code>。</p>
<p>“覆盖”的定义是：</p>
<ol>
<li><code>t</code> 中的所有字符都必须出现在这个子串中。</li>
<li>如果 <code>t</code> 中有重复的字符，那么子串中该字符的数量必须大于等于 <code>t</code> 中该字符的数量。</li>
</ol>
<p>例如，对于 <code>s = &quot;ADOBECODEBANC&quot;</code> 和 <code>t = &quot;ABC&quot;</code>：</p>
<ul>
<li>子串 <code>&quot;BANC&quot;</code> 包含了 ‘A’, ‘B’, ‘C’，满足条件，长度为 4。</li>
<li>子串 <code>&quot;ADOBEC&quot;</code> 也满足条件，但长度为 6。</li>
<li>子串 <code>&quot;CODEBANC&quot;</code> 满足条件，但长度为 8。</li>
<li>在所有满足条件的子串中，<code>&quot;BANC&quot;</code> 是最短的，所以是答案。</li>
</ul>
<p>如果 <code>s</code> 中不存在这样的子串，我们应该返回空字符串 <code>&quot;&quot;</code>。</p>
<h3 id="核心思路：滑动窗口"><a href="#核心思路：滑动窗口" class="headerlink" title="核心思路：滑动窗口"></a>核心思路：滑动窗口</h3><p>这类在长字符串中寻找满足特定条件的子串的问题，是滑动窗口算法的典型应用场景。我们可以想象有一个窗口在字符串 <code>s</code> 上滑动，这个窗口的左右边界由两个指针 <code>left</code> 和 <code>right</code> 来定义。</p>
<p>算法的核心思想是：</p>
<ol>
<li><strong>扩展窗口</strong>：不断向右移动 <code>right</code> 指针，将新的字符纳入窗口。每次纳入一个新字符，就更新窗口内的状态（例如，字符的计数）。</li>
<li><strong>检查有效性</strong>：在扩展的同时，持续检查当前窗口是否已经满足了“覆盖 <code>t</code>” 的条件。</li>
<li><strong>收缩窗口</strong>：一旦窗口满足条件，我们就找到了一个“可行解”。但题目要求的是“最小”子串，所以我们要尝试收缩窗口的左边界。我们向右移动 <code>left</code> 指针，每次移出一个字符，并判断窗口是否依然满足条件。</li>
<li><strong>更新最优解</strong>：在收缩的过程中，只要窗口保持有效，我们就持续记录并更新当前找到的最小子串的长度和起始位置。当窗口因为 <code>left</code> 的移动而变得不再有效时，我们就停止收缩，回到第一步，继续移动 <code>right</code> 来寻找下一个“可行解”。</li>
</ol>
<p>通过 <code>right</code> 指针的不断扩张和 <code>left</code> 指针的伺机收缩，我们就能在一次遍历中找到全局最优解。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><p>为了高效地实现上述思路，我们需要两个哈希表（或字典）来帮助我们进行判断：</p>
<ul>
<li><code>need</code> 哈希表：用来统计字符串 <code>t</code> 中所有字符及其出现的次数。这个表在算法开始前构建，之后不会改变。</li>
<li><code>window</code> 哈希表：用来统计当前滑动窗口内，<code>t</code> 中字符的出现次数。这个表是动态变化的。</li>
</ul>
<p>我们还需要一个 <code>valid</code> 变量来加速判断。<code>valid</code> 记录的是 <code>window</code> 中有多少个字符的数量已经满足了 <code>need</code> 的要求。当 <code>valid</code> 的值等于 <code>need</code> 中不同字符的总数时，就说明当前窗口已经是一个“可行解”。</p>
<ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>left = 0</code>, <code>right = 0</code>。</li>
<li>构建 <code>need</code> 哈希表。</li>
<li><code>window</code> 哈希表为空。</li>
<li><code>valid = 0</code>。</li>
<li><code>start = 0</code>, <code>min_len = infinity</code> 用来记录最终结果。</li>
</ul>
</li>
<li><p><strong>主循环（扩展窗口）</strong>：</p>
<ul>
<li><code>right</code> 指针向右遍历 <code>s</code>，设当前字符为 <code>c</code>。</li>
<li>如果 <code>c</code> 是 <code>need</code> 中需要的字符，就更新 <code>window[c]</code> 的计数。</li>
<li>如果更新后 <code>window[c]</code> 的值恰好等于 <code>need[c]</code>，说明 <code>c</code> 这个字符的要求已经满足，我们将 <code>valid</code> 加一。</li>
</ul>
</li>
<li><p><strong>内循环（收缩窗口）</strong>：</p>
<ul>
<li>当 <code>valid == len(need)</code> 时，触发收缩。</li>
<li>首先，用当前窗口的长度 <code>right - left</code> 和 <code>min_len</code> 比较，如果更小，则更新 <code>min_len</code> 和 <code>start</code>。</li>
<li>然后，将 <code>left</code> 指针右移，设移出的字符为 <code>d</code>。</li>
<li>如果 <code>d</code> 是 <code>need</code> 中需要的字符，就更新 <code>window[d]</code> 的计数。</li>
<li>如果更新后 <code>window[d]</code> 的值小于 <code>need[d]</code>，说明 <code>d</code> 这个字符的要求不再满足，我们将 <code>valid</code> 减一。</li>
<li>只要 <code>valid</code> 的值还等于 <code>len(need)</code>，就重复这个收缩过程。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>主循环结束后，如果 <code>min_len</code> 仍然是初始的无穷大，说明没有找到任何可行解，返回 <code>&quot;&quot;</code>。</li>
<li>否则，根据记录的 <code>start</code> 和 <code>min_len</code> 返回 <code>s[start : start + min_len]</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># need 用于存储 t 中每个字符需要的数量</span></span><br><span class="line">        need = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> t:</span><br><span class="line">            need[char] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># window 用于存储当前窗口中每个字符的数量</span></span><br><span class="line">        window = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        </span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        valid = <span class="number">0</span> <span class="comment"># 窗口中满足 need 条件的字符个数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 记录最小覆盖子串的起始索引和长度</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        min_len = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="comment"># c 是将移入窗口的字符</span></span><br><span class="line">            c = s[right]</span><br><span class="line">            right += <span class="number">1</span> <span class="comment"># 扩大窗口</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果是所需字符，更新窗口计数</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> need:</span><br><span class="line">                window[c] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">                    valid += <span class="number">1</span> <span class="comment"># 该字符已满足要求</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当窗口满足所有要求时，尝试收缩</span></span><br><span class="line">            <span class="keyword">while</span> valid == <span class="built_in">len</span>(need):</span><br><span class="line">                <span class="comment"># 更新最小子串记录</span></span><br><span class="line">                <span class="keyword">if</span> right - left &lt; min_len:</span><br><span class="line">                    start = left</span><br><span class="line">                    min_len = right - left</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># d 是将移出窗口的字符</span></span><br><span class="line">                d = s[left]</span><br><span class="line">                left += <span class="number">1</span> <span class="comment"># 缩小窗口</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 如果移出的也是所需字符，更新窗口计数</span></span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> need:</span><br><span class="line">                    <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                        valid -= <span class="number">1</span> <span class="comment"># 该字符不再满足要求</span></span><br><span class="line">                    window[d] -= <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span> <span class="keyword">if</span> min_len == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> s[start:start + min_len]</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(M + N)。其中 M 是字符串 <code>s</code> 的长度，N 是字符串 <code>t</code> 的长度。首先，我们需要 O(N) 的时间来初始化 <code>need</code> 哈希表。在滑动窗口的过程中，<code>left</code> 和 <code>right</code> 指针都各自最多遍历 <code>s</code> 一次，所以主循环的复杂度是 O(M)。总共是 O(M + N)。</li>
<li><strong>空间复杂度</strong>: O(K)。其中 K 是字符串 <code>t</code> 中不同字符的数量。我们使用了 <code>need</code> 和 <code>window</code> 两个哈希表，它们存储的键的数量不会超过 <code>t</code> 中不同字符的数量。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>“最小覆盖子串”是滑动窗口算法的经典模板题。其精髓在于通过“扩张”和“收缩”两个动作，在 O(N) 的时间内优雅地解决了问题。理解并掌握这个模板，对于解决其他相关的子数组、子字符串问题大有裨益，例如“字符串的排列”、“无重复字符的最长子串”等，它们的底层逻辑都与此类似。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 778 | 水位上升的泳池中游泳</title>
    <url>//posts/leetcode-778/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 778 题：<a href="https://leetcode.cn/problems/swim-in-water/description/">水位上升的泳池中游泳</a>。<br>当直接求解“最小的等待时间”比较困难时，可以通过二分查找猜测一个时间，然后验证这个时间是否可行，从而将一个求解最值的问题转化为一个判定性的问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>在一个 <code>n x n</code> 的网格中，每个格子 <code>grid[i][j]</code> 代表了该位置平台的高度。随着时间 <code>t</code> 的流逝，水位也会上升到 <code>t</code>。我们可以从一个平台游到相邻的另一个平台，前提是这两个平台的高度都必须小于或等于当前的水位 <code>t</code>。</p>
<p>我们的目标是从左上角 <code>(0, 0)</code> 出发，到达右下角 <code>(n-1, n-1)</code>。我们需要计算出，为了能够成功到达终点，所需要等待的<strong>最少时间</strong>是多少。</p>
<p>举个例子，<code>grid = [[0,2],[1,3]]</code>。</p>
<ul>
<li>在时间 <code>t=0</code>、<code>t=1</code> 或 <code>t=2</code> 时，我们都无法从 <code>(0,0)</code>（高度0）到达任何一个相邻平台，因为 <code>(0,1)</code> 的高度是2，<code>(1,0)</code> 的高度是1。例如，在 <code>t=1</code> 时，虽然可以淹没 <code>(0,0)</code> 和 <code>(1,0)</code>，但无法淹没 <code>(0,1)</code>，因此没有通路。</li>
<li>直到时间 <code>t=3</code> 时，水位为3，淹没了所有的平台。此时，从 <code>(0,0)</code> 到 <code>(n-1,n-1)</code> 之间必然存在一条通路。</li>
</ul>
<p>所以，我们需要找到那个<strong>恰好</strong>能让起点和终点连通的最小时间点。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最少时间”似乎没有清晰的思路。但是，我们可以换一个角度来思考这个问题：如果我们<strong>假定</strong>一个时间 <code>t</code>，我们能否判断出，在水位为 <code>t</code> 的情况下，是否存在一条从 <code>(0, 0)</code> 到 <code>(n-1, n-1)</code> 的路径？</p>
<p>这个“判定问题”就相对简单了。我们可以构建一个辅助函数 <code>check(t)</code>：</p>
<ul>
<li>该函数接收一个时间 <code>t</code> 作为参数。</li>
<li>在网格中，所有高度 <code>grid[i][j] &lt;= t</code> 的平台都可以被视为通路，而高度大于 <code>t</code> 的平台则是障碍。</li>
<li>问题就变成了：在一个图中，判断从起点 <code>(0, 0)</code> 到终点 <code>(n-1, n-1)</code> 是否存在一条路径。</li>
<li>我们可以使用深度优先搜索（DFS）或广度优先搜索（BFS）来轻松解决这个连通性问题。</li>
</ul>
<p>有了这个判定函数后，我们观察到它具有非常明显的<strong>单调性</strong>：</p>
<ul>
<li>如果时间 <code>t</code> <strong>可以</strong>让起点和终点连通，那么任何大于 <code>t</code> 的时间 <code>t&#39;</code>（水位更高）也<strong>一定</strong>可以连通。</li>
<li>反之，如果时间 <code>t</code> <strong>不可以</strong>让起点和终点连通，那么任何小于 <code>t</code> 的时间 <code>t&#39;&#39;</code>（水位更低）也<strong>必然</strong>无法连通。</li>
</ul>
<p>这种单调性是应用<strong>二分查找</strong>的完美信号。我们可以对“时间 <code>t</code>”这个值进行二分查找，来快速定位到那个“最小可行”的临界点。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：我们至少要等到起点 <code>(0,0)</code> 和终点 <code>(n-1, n-1)</code> 本身被水淹没，所以时间 <code>t</code> 的最小值至少是 <code>max(grid[0][0], grid[n-1][n-1])</code>。</li>
<li><strong>上界 (right)</strong>：当时间 <code>t</code> 等于网格中平台的最大可能高度时，所有的平台都被淹没，此时必然是连通的。因为 <code>0 &lt;= grid[i][j] &lt; n*n</code>，所以上界可以取 <code>n*n - 1</code>。</li>
</ul>
<p>因此，我们就在 <code>[max(grid[0][0], grid[n-1][n-1]), n*n - 1]</code> 这个区间内，对时间 <code>t</code> 进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = max(grid[0][0], grid[n-1][n-1])</code>：这是可能的最低可行时间。</li>
<li><code>right = n*n - 1</code>：这是必然可行的最高时间。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>left &lt; right</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = left + (right - left) // 2</code> 作为当前的“猜测时间”。</li>
<li>调用辅助函数 <code>check(mid)</code> 来判定这个猜测值是否可行。<ul>
<li><code>check(mid)</code> 函数内部，使用 DFS 进行路径搜索：<ul>
<li>创建一个 <code>visited</code> 集合，防止重复访问。</li>
<li>从 <code>(0, 0)</code> 开始递归搜索。</li>
<li>如果当前平台 <code>(i, j)</code> 的高度 <code>grid[i][j] &gt; mid</code>，则此路不通。</li>
<li>否则，标记 <code>(i, j)</code> 已访问，并向其四周（上、下、左、右）未访问过的邻居递归。</li>
<li>如果 DFS 过程中能成功到达 <code>(n-1, n-1)</code>，则 <code>check(mid)</code> 返回 <code>True</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>True</code></strong> (即时间 <code>mid</code> 足够到达终点)：<ul>
<li>说明 <code>mid</code> 是一个潜在的答案，但我们想找的是“最少”时间，所以我们尝试一个更小的值，将搜索范围缩小到左半边（包含 mid）：<code>right = mid</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>False</code></strong> (即时间 <code>mid</code> 还不够)：<ul>
<li>说明我们需要更多的时间，将搜索范围缩小到右半边：<code>left = mid + 1</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>left</code> 和 <code>right</code> 相遇，此时的值就是满足条件的最低等待时间。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swimInWater</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判定函数：在时间 t (水位为 t) 时，是否可以从 (0,0) 到达 (n-1, n-1)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># 起点的高度如果都大于 t，直接判定为不可达</span></span><br><span class="line">            <span class="keyword">if</span> grid[<span class="number">0</span>][<span class="number">0</span>] &gt; t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            visited = <span class="built_in">set</span>()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 使用深度优先搜索 (DFS) 检查连通性</span></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">                <span class="comment"># 到达终点</span></span><br><span class="line">                <span class="keyword">if</span> i == n - <span class="number">1</span> <span class="keyword">and</span> j == n - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">                visited.add((i, j))</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 探索四个方向</span></span><br><span class="line">                <span class="keyword">for</span> x, y <span class="keyword">in</span> [(i - <span class="number">1</span>, j), (i, j + <span class="number">1</span>), (i + <span class="number">1</span>, j), (i, j - <span class="number">1</span>)]:</span><br><span class="line">                    <span class="comment"># 检查新坐标是否在网格内、未被访问过、且高度不超过当前水位 t</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; n <span class="keyword">and</span> (x, y) <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> grid[x][y] &lt;= t:</span><br><span class="line">                        <span class="keyword">if</span> dfs(x, y):</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                            </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找的左右边界</span></span><br><span class="line">        <span class="comment"># 左边界：至少要能淹没起点和终点</span></span><br><span class="line">        <span class="comment"># 右边界：最大可能的高度，此时一定可达</span></span><br><span class="line">        left, right = <span class="built_in">max</span>(grid[<span class="number">0</span>][<span class="number">0</span>], grid[n-<span class="number">1</span>][n-<span class="number">1</span>]), n * n - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 二分查找寻找最小的可行时间 t</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 时间可行，说明它可能是答案，</span></span><br><span class="line">                <span class="comment"># 或者还有更小的可行时间，所以我们尝试在左半部分 [left, mid] 继续寻找</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 时间不可行，说明时间太少，</span></span><br><span class="line">                <span class="comment"># 必须增加，所以去右半部分 [mid + 1, right] 寻找</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时，left 就是满足条件的最低时间</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N² * log(N²))。<ul>
<li>二分查找的搜索空间大小为 <code>n*n</code>，因此迭代次数为 O(log(N²))，即 O(log(N))。</li>
<li>在每次迭代中，我们都需要调用 <code>check</code> 函数。<code>check</code> 函数内部的 DFS&#x2F;BFS 最多会访问网格中的 <code>N*N</code> 个单元格一次。</li>
<li>因此，总时间复杂度是这两者的乘积，即 O(N² * log(N²))。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(N²)。<ul>
<li>空间开销主要来自于 <code>check</code> 函数中的 <code>visited</code> 集合和 DFS 的递归调用栈。在最坏的情况下，两者都需要存储 O(N²) 个元素。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是二分查找思想应用的又一经典范例。它展示了当直接求解最优值（如“最小值”、“最大值”）困难时，如何通过转换思维，将其变为一个更简单的“判定性”问题。如果这个判定问题随输入参数的变化呈现出单调性，那么二分查找就是解决这类问题的强大武器。它能将搜索范围不断折半，从而在对数级别的时间复杂度内高效地逼近最优解。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>最小化最大值</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>堆（优先队列）</tag>
        <tag>并查集</tag>
        <tag>广度优先搜索</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 786 | 第 K 个最小的质数分数</title>
    <url>//posts/leetcode-786/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 786 题：<a href="https://leetcode.cn/problems/k-th-smallest-prime-fraction/">第 K 个最小的质数分数</a>。<br>解法的核心在于<strong>对分数的值进行二分</strong>，结合双指针统计数量，并在统计过程中记录满足条件的最大分数。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个按递增顺序排序的数组 <code>arr</code> 和一个整数 <code>k</code> 。数组 <code>arr</code> 由 <code>1</code> 和若干 <strong>质数</strong> 组成，且其中所有整数互不相同。</p>
<p>对于每对满足 <code>0 &lt;= i &lt; j &lt; arr.length</code> 的 <code>i</code> 和 <code>j</code> ，可以得到分数 <code>arr[i] / arr[j]</code> 。</p>
<p>那么第 <code>k</code> 个最小的分数是多少呢?  以长度为 2 的整数数组返回你的答案, 这里 <code>answer[0] == arr[i]</code> 且 <code>answer[1] == arr[j]</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：arr = [1,2,3,5], k = 3</span><br><span class="line">输出：[2,5]</span><br><span class="line">解释：已构造好的分数,排序后如下所示: </span><br><span class="line">1/5, 1/3, 2/5, 1/2, 3/5, 2/3</span><br><span class="line">很明显第三个最小的分数是 2/5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：arr = [1,7], k = 1</span><br><span class="line">输出：[1,7]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= arr.length &lt;= 1000</code></li>
<li><code>1 &lt;= arr[i] &lt;= 3 * 10^4</code></li>
<li><code>arr[0] == 1</code></li>
<li><code>arr[i]</code> 是一个 <strong>质数</strong> ，<code>i &gt; 0</code></li>
<li><code>arr</code> 中的所有数字 <strong>互不相同</strong> ，且按 <strong>严格递增</strong> 排序</li>
<li><code>1 &lt;= k &lt;= arr.length * (arr.length - 1) / 2</code></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-思路分析"><a href="#1-思路分析" class="headerlink" title="1. 思路分析"></a>1. 思路分析</h4><p>这道题要求找出第 <code>k</code> 小的分数。如果我们将所有可能的分数 <code>arr[i] / arr[j]</code> 列出来并排序，时间复杂度会非常高，因为分数的总对数是 <code>O(N^2)</code> 级别的。</p>
<p>我们可以换一个角度：<br>分数的范围一定在 <code>(0, 1)</code> 之间。我们可以对<strong>数值</strong>进行二分查找。<br>假设我们选定一个值 <code>mid</code>，我们可以很容易地统计出有多少个分数严格小于 <code>mid</code>。</p>
<ul>
<li>如果小于 <code>mid</code> 的分数个数等于 <code>k</code>，那么 <code>mid</code> 附近的某个分数可能就是答案吗？不一定，因为 <code>mid</code> 是一个浮点数，它可能不等于任何一个 <code>arr[i] / arr[j]</code>。</li>
<li>但是，如果我们能在统计“小于 <code>mid</code> 的分数”的过程中，同时记录下<strong>小于 <code>mid</code> 的最大分数</strong>，那么当计数恰好为 <code>k</code> 时，这个记录下来的最大分数就是我们要找的第 <code>k</code> 小的分数。</li>
</ul>
<h4 id="2-二分查找流程"><a href="#2-二分查找流程" class="headerlink" title="2. 二分查找流程"></a>2. 二分查找流程</h4><ol>
<li><strong>初始化范围</strong>：<code>l = 0.0</code>, <code>r = 1.0</code>。</li>
<li><strong>二分过程</strong>：<ul>
<li>取 <code>mid = (l + r) / 2</code>。</li>
<li><strong>统计与记录</strong>：遍历分母 <code>arr[j]</code>（从索引 1 到 n-1），使用双指针（或滑动窗口）找到对应的分子 <code>arr[i]</code>，使得 <code>arr[i] / arr[j] &lt; mid</code>。</li>
<li>在遍历过程中，计算所有满足条件的分数总数 <code>cnt</code>。</li>
<li><strong>关键点</strong>：在统计过程中，维护一个变量 <code>x/y</code>，用来记录当前小于 <code>mid</code> 的所有分数中<strong>最大</strong>的那个分数。</li>
</ul>
</li>
<li><strong>调整边界</strong>：<ul>
<li>如果 <code>cnt &lt; k</code>：说明 <code>mid</code> 选小了，甚至还没凑够 <code>k</code> 个数，需要扩大范围，<code>l = mid</code>。</li>
<li>如果 <code>cnt &gt; k</code>：说明 <code>mid</code> 选大了，<code>r = mid</code>。</li>
<li>如果 <code>cnt == k</code>：说明我们要找的第 <code>k</code> 小的分数包含在小于 <code>mid</code> 的集合中，并且由于我们记录了集合中最大的那个分数 <code>x/y</code>，它一定就是第 <code>k</code> 小的分数（因为比它小的有 <code>k-1</code> 个）。直接返回 <code>[x, y]</code>。</li>
</ul>
</li>
</ol>
<h4 id="3-双指针的运用"><a href="#3-双指针的运用" class="headerlink" title="3. 双指针的运用"></a>3. 双指针的运用</h4><p>由于数组 <code>arr</code> 是严格递增的：<br>对于固定的分母 <code>arr[j]</code>，随着分子索引 <code>i</code> 的增加，<code>arr[i] / arr[j]</code> 是单调递增的。<br>因此，对于每个 <code>j</code>，我们不需要每次都从头扫描 <code>i</code>。<br>随着 <code>j</code> 的增加（分母变大），为了保持 <code>arr[i] / arr[j] &lt; mid</code>，<code>i</code> 只会向右移动（分子变大）或保持不变。这使得内部统计的时间复杂度为 <code>O(N)</code>。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallestPrimeFraction</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="comment"># 二分查找的范围初始化为 (0.0, 1.0)</span></span><br><span class="line">        l, r = <span class="number">0.0</span>, <span class="number">1.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            mid = (l + r) / <span class="number">2</span></span><br><span class="line">            <span class="comment"># i 是分子的索引，cnt 统计小于 mid 的分数个数</span></span><br><span class="line">            i, cnt = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">            <span class="comment"># x, y 用于记录小于 mid 的最大分数，初始设为 0/1</span></span><br><span class="line">            x, y = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 遍历每一个可能的分母 arr[j]</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># 寻找当前分母下，满足分数 &lt; mid 的最大分子索引 i</span></span><br><span class="line">                <span class="comment"># arr 是递增的，所以 i 是单调不减的（双指针逻辑）</span></span><br><span class="line">                <span class="keyword">while</span> arr[i+<span class="number">1</span>] / arr[j] &lt; mid:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 更新当前小于 mid 的最大分数</span></span><br><span class="line">                    <span class="comment"># 比较 arr[i]/arr[j] 与 x/y 的大小</span></span><br><span class="line">                    <span class="comment"># 使用交叉相乘 arr[i]*y &gt; arr[j]*x 避免浮点精度问题</span></span><br><span class="line">                    <span class="keyword">if</span> arr[i] * y &gt; arr[j] * x:</span><br><span class="line">                        x, y = arr[i], arr[j]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># arr[0] 到 arr[i] 都是满足条件的分子，共 i+1 个</span></span><br><span class="line">                cnt += i + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果小于 mid 的分数个数恰好为 k</span></span><br><span class="line">            <span class="comment"># 那么我们在统计过程中记录的最大分数 x/y 即为第 k 小的分数</span></span><br><span class="line">            <span class="keyword">if</span> cnt == k:</span><br><span class="line">                <span class="keyword">return</span> [x, y]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果个数不足 k，说明 mid 偏小，需要向右区间搜索</span></span><br><span class="line">            <span class="keyword">if</span> cnt &lt; k:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="comment"># 如果个数超过 k，说明 mid 偏大，需要向左区间搜索</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthSmallestPrimeFraction</span><span class="params">(arr []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="comment">// 二分查找的范围初始化为 (0.0, 1.0)</span></span><br><span class="line">    l, r := <span class="number">0.0</span>, <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        mid := (l + r) / <span class="number">2</span></span><br><span class="line">        <span class="comment">// i 是分子的索引</span></span><br><span class="line">        <span class="comment">// cnt 统计小于 mid 的分数个数</span></span><br><span class="line">        i, cnt := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment">// x, y 用于记录小于 mid 的最大分数，初始设为 0/1</span></span><br><span class="line">        <span class="comment">// x 为分子，y 为分母</span></span><br><span class="line">        x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每一个可能的分母 arr[j]</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="comment">// 寻找当前分母下，满足分数 &lt; mid 的最大分子索引 i</span></span><br><span class="line">            <span class="comment">// 需要将整数转换为 float64 进行除法比较</span></span><br><span class="line">            <span class="comment">// 注意边界检查：i+1 &lt; n 且 arr[i+1]/arr[j] &lt; mid</span></span><br><span class="line">            <span class="keyword">for</span> i+<span class="number">1</span> &lt; j &amp;&amp; <span class="type">float64</span>(arr[i+<span class="number">1</span>])/<span class="type">float64</span>(arr[j]) &lt; mid &#123;</span><br><span class="line">                i++</span><br><span class="line">                <span class="comment">// 更新当前小于 mid 的最大分数</span></span><br><span class="line">                <span class="comment">// 比较 arr[i]/arr[j] 与 x/y 的大小</span></span><br><span class="line">                <span class="comment">// 使用交叉相乘 arr[i]*y &gt; arr[j]*x，利用整数运算避免精度丢失</span></span><br><span class="line">                <span class="keyword">if</span> arr[i]*y &gt; arr[j]*x &#123;</span><br><span class="line">                    x, y = arr[i], arr[j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// arr[0] 到 arr[i] 都是满足条件的分子，共 i+1 个</span></span><br><span class="line">            cnt += i + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果小于 mid 的分数个数恰好为 k</span></span><br><span class="line">        <span class="comment">// 那么我们在统计过程中记录的最大分数 x/y 即为第 k 小的分数</span></span><br><span class="line">        <span class="keyword">if</span> cnt == k &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;x, y&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果个数不足 k，说明 mid 偏小，需要向右区间搜索</span></span><br><span class="line">        <span class="keyword">if</span> cnt &lt; k &#123;</span><br><span class="line">            l = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果个数超过 k，说明 mid 偏大，需要向左区间搜索</span></span><br><span class="line">            r = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: <code>O(N * log(C))</code><br>其中 <code>N</code> 是数组的长度，<code>C</code> 取决于二分的精度要求或者数据的数值范围。由于每次 check 操作需要遍历数组一次（双指针复杂度为 <code>O(N)</code>），而二分查找在实数域上进行，直到找到确切的整数解，通常迭代次数是有限的（与浮点数精度或最大可能的整数值有关）。</p>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(1)</code><br>我们只使用了常数个变量 <code>l</code>, <code>r</code>, <code>mid</code>, <code>x</code>, <code>y</code>, <code>i</code>, <code>j</code> 等，不需要额外的数组空间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>第K小/大</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>排序</tag>
        <tag>堆（优先队列）</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 793 | 阶乘函数后 K 个零</title>
    <url>//posts/leetcode-793/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 793 题：<a href="https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/">阶乘函数后 K 个零</a>。<br>这道题是 <a href="https://leetcode.cn/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a> 的逆向问题。核心在于理解阶乘末尾零的单调性，并利用二分查找来确定范围。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>f(x) 是 x! 末尾是 0 的数量。回想一下 x! &#x3D; 1 * 2 * 3 * … * x，且 0! &#x3D; 1 。</p>
<p>例如， f(3) &#x3D; 0 ，因为 3! &#x3D; 6 的末尾没有 0 ；而 f(11) &#x3D; 2 ，因为 11!&#x3D; 39916800 末端有 2 个 0 。<br>给定 k，找出返回能满足 f(x) &#x3D; k 的非负整数 x 的数量。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：k = 0</span><br><span class="line">输出：5</span><br><span class="line">解释：0!, 1!, 2!, 3!, 和 4! 均符合 k = 0 的条件。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：k = 5</span><br><span class="line">输出：0</span><br><span class="line">解释：没有匹配到这样的 x!，符合 k = 5 的条件。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>0 &lt;&#x3D; k &lt;&#x3D; 10^9</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-数学原理分析"><a href="#1-数学原理分析" class="headerlink" title="1. 数学原理分析"></a>1. 数学原理分析</h4><p>首先，我们需要知道如何计算 x! 末尾 0 的个数。<br>末尾的 0 是由因子 2 * 5 产生的。在 1 到 x 的所有数中，因子 2 的数量远多于因子 5 的数量。因此，x! 末尾 0 的数量取决于因子 5 的数量。</p>
<p>根据勒让德定理（Legendre’s Formula），f(x) 的计算公式如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">f(x) = floor(x / 5) + floor(x / 25) + floor(x / 125) + ...</span><br></pre></td></tr></table></figure>

<p>简单来说，就是计算 x 中包含多少个 5，多少个 25，多少个 125……以此类推并求和。</p>
<h4 id="2-函数的单调性与结果特性"><a href="#2-函数的单调性与结果特性" class="headerlink" title="2. 函数的单调性与结果特性"></a>2. 函数的单调性与结果特性</h4><p>观察函数 f(x)：</p>
<ul>
<li><strong>单调性</strong>：随着 x 增大，f(x) 的值是非递减的。</li>
<li><strong>阶梯状</strong>：因为只有当 x 是 5 的倍数时，f(x) 的值才会增加。对于 x, x+1, x+2, x+3, x+4，它们的阶乘末尾 0 的个数是一样的。</li>
<li><strong>答案的取值</strong>：基于上述特性，满足 f(x) &#x3D; k 的 x 的数量，<strong>要么是 5，要么是 0</strong>。<ul>
<li>如果是 5：说明存在某个区间 [5m, 5m+4] 使得其阶乘末尾恰好有 k 个 0。</li>
<li>如果是 0：说明 f(x) 的值直接从 k-1 跳到了 k+1（或更大），跳过了 k。这通常发生在 x 是 25, 125 等 5 的高次幂的倍数时（此时因子 5 的数量会一次性增加多个）。</li>
</ul>
</li>
</ul>
<h4 id="3-二分查找解法"><a href="#3-二分查找解法" class="headerlink" title="3. 二分查找解法"></a>3. 二分查找解法</h4><p>由于 f(x) 具有单调性，我们可以使用 <strong>二分查找</strong>。<br>题目要求满足 f(x) &#x3D; k 的数量，这可以转化为求两个边界：</p>
<ol>
<li>满足 f(x) &gt;&#x3D; k 的最小 x（左边界）。</li>
<li>满足 f(x) &gt;&#x3D; k + 1 的最小 x（右边界）。</li>
</ol>
<p>最终答案即为：<code>search(k + 1) - search(k)</code>。<br>如果 k 存在解，差值为 5；如果不存在，差值为 0。</p>
<p><strong>搜索范围：</strong></p>
<ul>
<li>因为 f(x) 大约等于 x&#x2F;5 加上一些更小的项，所以 x 大约是 5*k。</li>
<li>考虑到 k 最大为 10^9，我们可以将二分的上界设为 5 * 10^9 左右，使用 64 位整数（long long 或 Python int）不会溢出。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preimageSizeFZF</span>(<span class="params">self, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 计算 x! 末尾有多少个 0</span></span><br><span class="line">        <span class="comment"># 逻辑：f(x) = x//5 + x//25 + x//125 ...</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">zeta</span>(<span class="params">x</span>):</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> x:</span><br><span class="line">                x //= <span class="number">5</span></span><br><span class="line">                res += x</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 二分查找：寻找满足 zeta(x) &gt;= target 的最小 x</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">search_min_x</span>(<span class="params">target</span>):</span><br><span class="line">            <span class="comment"># 搜索范围 [0, 5*target] 足够覆盖</span></span><br><span class="line">            <span class="comment"># 当 target 很大时，上界稍微放宽一点保证覆盖</span></span><br><span class="line">            l, r = <span class="number">0</span>, <span class="number">5</span> * target + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                mid = (l + r) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> zeta(mid) &lt; target:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 逻辑：(满足 f(x) &gt;= k+1 的最小 x) - (满足 f(x) &gt;= k 的最小 x)</span></span><br><span class="line">        <span class="comment"># 如果 k 存在解，差值为 5；否则为 0</span></span><br><span class="line">        <span class="keyword">return</span> search_min_x(k + <span class="number">1</span>) - search_min_x(k)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preimageSizeFZF</span><span class="params">(k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 辅助函数：计算 x! 末尾 0 的个数</span></span><br><span class="line">    <span class="comment">// 逻辑：count = x/5 + x/25 + x/125 ...</span></span><br><span class="line">    zeta := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        res := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">            x /= <span class="number">5</span></span><br><span class="line">            res += x</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找：寻找满足 zeta(x) &gt;= t 的最小 x</span></span><br><span class="line">    search := <span class="function"><span class="keyword">func</span><span class="params">(t <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="comment">// 搜索范围：下界 0，上界 5*t + 1</span></span><br><span class="line">        <span class="comment">// 当 t=10^9 时，5*t 约为 50亿，在 64位 int 范围内</span></span><br><span class="line">        l, r := <span class="number">0</span>, <span class="number">5</span>*t+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">            mid := l + (r-l)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> zeta(mid) &lt; t &#123;</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用差分思想：</span></span><br><span class="line">    <span class="comment">// 寻找 f(x)=k 的数量等价于：</span></span><br><span class="line">    <span class="comment">// (f(x) &gt;= k+1 的起点) - (f(x) &gt;= k 的起点)</span></span><br><span class="line">    <span class="keyword">return</span> search(k+<span class="number">1</span>) - search(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: O(log^2 k)</p>
<ul>
<li>二分查找的范围大约是 5k，迭代次数为 O(log k)。</li>
<li>每次迭代中计算 <code>zeta(mid)</code> 需要 O(log_5 mid) 的时间，也就是 O(log k)。</li>
<li>总复杂度为 O(log k * log k)。对于 k &#x3D; 10^9，计算量非常小，执行速度很快。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>: O(1)</p>
<ul>
<li>只使用了常数个变量。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>第 K小/大</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 81 | 搜索旋转排序数组 II</title>
    <url>//posts/leetcode-81/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 81 题：<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">搜索旋转排序数组 II</a>。<br>该题难点在于数组中可能包含 <strong>重复元素</strong>，这破坏了原本二分查找中严格的单调性判断。当左右边界和中间值相等时，我们无法确定哪一半是有序的，必须退化为线性查找。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>已知存在一个按非降序排列的整数数组 <code>nums</code>，数组中的值不必互不相同。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。</p>
<p>例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 5 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code>。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code>，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,5,6,0,0,1,2], target = 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,5,6,0,0,1,2], target = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000</li>
<li>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4</li>
<li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li>
<li>-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-旋转数组的特性"><a href="#1-旋转数组的特性" class="headerlink" title="1. 旋转数组的特性"></a>1. 旋转数组的特性</h4><p>旋转后的数组会被分割成两段有序区间：</p>
<ol>
<li><strong>左半段（上半段）</strong>：数值较大，且 <code>nums[i] &gt;= nums[0]</code>。</li>
<li><strong>右半段（下半段）</strong>：数值较小，且 <code>nums[i] &lt;= nums[n-1]</code>。</li>
</ol>
<h4 id="2-处理重复元素（核心难点）"><a href="#2-处理重复元素（核心难点）" class="headerlink" title="2. 处理重复元素（核心难点）"></a>2. 处理重复元素（核心难点）</h4><p>在没有重复元素的第 33 题中，我们可以通过比较 <code>nums[mid]</code> 和 <code>nums[r]</code>（或 <code>nums[l]</code>）来确定 <code>mid</code> 落在左半段还是右半段。</p>
<p>但是，当 <code>nums[mid] == nums[r]</code> 时，我们无法区分 <code>mid</code> 是在左半段（例如 <code>[2, 2, ..., 2, 0, 1]</code>）还是在右半段（例如 <code>[2, 0, 1, 2, ..., 2]</code>）。<br>此时，唯一的办法是 <strong>缩小区间</strong>，将右边界 <code>r</code> 向左移动一位 (<code>r -= 1</code>)，跳过这个重复值，然后再继续二分。这会导致最坏情况下的时间复杂度退化为 O(N)。</p>
<h4 id="3-二分逻辑（check-函数）"><a href="#3-二分逻辑（check-函数）" class="headerlink" title="3. 二分逻辑（check 函数）"></a>3. 二分逻辑（check 函数）</h4><p>我们将二分判定逻辑封装在 <code>check(i)</code> 函数中，该函数用于判断 <strong>目标值 target 是否可能落在左侧区间 [l, mid] 中</strong>（即是否应该让 <code>r = mid</code>）。</p>
<p>判定依据如下：</p>
<ul>
<li><p><strong>Case 1: <code>nums[mid] &gt; nums[r]</code></strong><br>说明 <code>mid</code> 落在 <strong>左半段</strong>（数值较大的那一段）。</p>
<ul>
<li>如果 <code>target &gt; nums[r]</code>（说明 target 也在左半段）且 <code>nums[mid] &gt;= target</code>，则 target 在 <code>mid</code> 的左侧，我们需要向左收缩 (<code>r = mid</code>)。</li>
</ul>
</li>
<li><p><strong>Case 2: <code>nums[mid] &lt;= nums[r]</code></strong><br>说明 <code>mid</code> 落在 <strong>右半段</strong>（数值较小的那一段）或者区间本身是有序的。</p>
<ul>
<li>如果 <code>target &gt; nums[r]</code>，说明 target 实际上是在左半段（数值非常大），而当前 <code>mid</code> 在右半段，所以 target 肯定在 <code>mid</code> 的左侧（逻辑上的左侧，其实是回绕过去了），需要向左收缩。</li>
<li>或者，如果 <code>nums[mid] &gt;= target</code>，说明 target 在右半段且比 <code>mid</code> 小，也需要向左收缩。</li>
</ul>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>这里采用了开区间二分模板 <code>(l, r)</code>，循环条件为 <code>l + 1 &lt; r</code>。</p>
<div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># check 函数判断是否需要向左收缩区间 (让 r = mid)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            x = nums[i]</span><br><span class="line">            <span class="comment"># 情况 1: mid 在左半段（大数值段）</span></span><br><span class="line">            <span class="comment"># 因为旋转特性，左半段的所有值都应该大于 nums[r]（除非没旋转，但逻辑通用）</span></span><br><span class="line">            <span class="keyword">if</span> x &gt; nums[r]:</span><br><span class="line">                <span class="comment"># 如果 target 也在左半段 (target &gt; nums[r]) 并且 target 小于等于 x</span></span><br><span class="line">                <span class="comment"># 说明 target 在 [l...mid] 范围内</span></span><br><span class="line">                <span class="keyword">return</span> target &gt; nums[r] <span class="keyword">and</span> x &gt;= target</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情况 2: mid 在右半段（小数值段）</span></span><br><span class="line">            <span class="comment"># 此时我们要找的情况是：什么时候 target 会在 mid 的左边？</span></span><br><span class="line">            <span class="comment"># 1. target 实际上在左半段 (target &gt; nums[r])，而 mid 在右半段，所以 target 在 mid 左侧</span></span><br><span class="line">            <span class="comment"># 2. target 在右半段，且 x &gt;= target，说明 target 在 [l...mid] 范围内</span></span><br><span class="line">            <span class="keyword">return</span> target &gt; nums[r] <span class="keyword">or</span> x &gt;= target</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 定义二分查找的左右边界（开区间写法）</span></span><br><span class="line">        <span class="comment"># l 是左边界的左侧一位，r 是右边界</span></span><br><span class="line">        l, r = -<span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 核心去重逻辑：</span></span><br><span class="line">            <span class="comment"># 如果中点值等于右边界值，无法判断在左段还是右段</span></span><br><span class="line">            <span class="comment"># 只能线性排除右边界</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == nums[r]:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果 check 返回 True，说明 target 可能在左侧，收缩右边界</span></span><br><span class="line">            <span class="keyword">elif</span> check(mid):</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="comment"># 否则，target 在右侧，收缩左边界</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid</span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 循环结束后，r 指向的位置就是可能的答案</span></span><br><span class="line">        <span class="comment"># 检查 nums[r] 是否等于 target</span></span><br><span class="line">        <span class="keyword">return</span> nums[r] == target</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 定义 check 函数 logic</span></span><br><span class="line">    <span class="comment">// 返回 true 表示 target 可能在 [l, mid] 范围内，需要 r = mid</span></span><br><span class="line">    check := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, r <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        x := nums[i]</span><br><span class="line">        <span class="comment">// Case 1: mid 在左半段 (值较大的一侧)</span></span><br><span class="line">        <span class="keyword">if</span> x &gt; nums[r] &#123;</span><br><span class="line">            <span class="comment">// target 必须也在左半段，且小于等于 mid 的值</span></span><br><span class="line">            <span class="keyword">return</span> target &gt; nums[r] &amp;&amp; x &gt;= target</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Case 2: mid 在右半段 (值较小的一侧)</span></span><br><span class="line">        <span class="comment">// 满足以下任一条件则说明 target 在 mid 的左侧：</span></span><br><span class="line">        <span class="comment">// 1. target &gt; nums[r]: target 实际上在左半段，而 mid 在右半段</span></span><br><span class="line">        <span class="comment">// 2. x &gt;= target: target 在右半段且小于等于 mid</span></span><br><span class="line">        <span class="keyword">return</span> target &gt; nums[r] || x &gt;= target</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化左右指针，使用开区间 (l, r] 的思路</span></span><br><span class="line">    <span class="comment">// l 初始为 -1, r 初始为 len-1</span></span><br><span class="line">    l, r := <span class="number">-1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l+<span class="number">1</span> &lt; r &#123;</span><br><span class="line">        mid := l + (r-l)/<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 mid 和 r 指向的值相同，无法判断区间有序性</span></span><br><span class="line">        <span class="comment">// 此时只能将 r 向左移动一位，退化为线性操作</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == nums[r] &#123;</span><br><span class="line">            r--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> check(mid, r) &#123;</span><br><span class="line">            <span class="comment">// 满足 check 条件，说明 target 在左侧，移动 r</span></span><br><span class="line">            r = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则 target 在右侧，移动 l</span></span><br><span class="line">            l = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终检查 r 指向的位置是否为 target</span></span><br><span class="line">    <span class="comment">// 注意：如果是空数组或越界情况需额外处理，但题目保证 1 &lt;= nums.length</span></span><br><span class="line">    <span class="keyword">return</span> nums[r] == target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>:<ul>
<li><strong>平均情况</strong>: <code>O(log N)</code>。当数组中重复元素较少时，主要进行二分查找。</li>
<li><strong>最坏情况</strong>: <code>O(N)</code>。当数组中包含大量重复元素（例如 <code>[1, 1, 1, ..., 1]</code>）时，每次 <code>nums[mid] == nums[r]</code> 都会导致 <code>r</code> 仅减小 1，退化为线性遍历。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: <code>O(1)</code>。仅使用了常数个变量存储指针和中间值。</li>
</ul>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 878 | 第 N 个神奇数字</title>
    <url>//posts/leetcode-878/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 878 题：<a href="https://leetcode.cn/problems/nth-magical-number/">第 N 个神奇数字</a>。<br>这是一道标准的“二分答案”题目，核心在于结合“容斥原理”来计算区间内满足条件的数的个数。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>一个正整数如果能被 <code>a</code> 或 <code>b</code> 整除，那么它是神奇的。</p>
<p>给定三个整数 <code>n</code>, <code>a</code>, <code>b</code>，返回第 <code>n</code> 个神奇的数字。因为答案可能很大，所以返回答案 <strong>对 10^9 + 7 取模</strong> 后的值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：n = 1, a = 2, b = 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：n = 4, a = 2, b = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; n &lt;&#x3D; 10^9</li>
<li>2 &lt;&#x3D; a, b &lt;&#x3D; 4 * 10^4</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-为什么暴力法不可行？"><a href="#1-为什么暴力法不可行？" class="headerlink" title="1. 为什么暴力法不可行？"></a>1. 为什么暴力法不可行？</h4><p>题目要求找到第 <code>n</code> 个神奇数字。如果 <code>n</code> 很大（例如 10^9），直接从 1 开始遍历整数并判断是否能被 <code>a</code> 或 <code>b</code> 整除，时间复杂度将非常高，肯定会超时。我们需要一种比线性遍历更高效的方法。</p>
<h4 id="2-二分答案"><a href="#2-二分答案" class="headerlink" title="2. 二分答案"></a>2. 二分答案</h4><p>我们可以发现一个单调性规律：</p>
<ul>
<li>随着数字 <code>x</code> 的增大，小于等于 <code>x</code> 的神奇数字的个数 <strong>只增不减</strong>。</li>
</ul>
<p>基于这个性质，我们可以使用 <strong>二分查找</strong> 来定位第 <code>n</code> 个神奇数字。<br>我们需要找到一个最小的整数 <code>x</code>，使得“小于等于 <code>x</code> 的神奇数字个数”恰好大于或等于 <code>n</code>。</p>
<p><strong>搜索范围：</strong></p>
<ul>
<li>下界：<code>min(a, b)</code>（第一个神奇数字）。</li>
<li>上界：<code>n * min(a, b)</code>（最坏情况全是 <code>min(a, b)</code> 的倍数）。</li>
</ul>
<h4 id="3-容斥原理计算个数"><a href="#3-容斥原理计算个数" class="headerlink" title="3. 容斥原理计算个数"></a>3. 容斥原理计算个数</h4><p>二分的核心在于 <code>check(mid)</code> 函数：如何快速计算小于等于 <code>mid</code> 的正整数中，有多少个神奇数字？</p>
<p>这就用到了 <strong>容斥原理</strong>。<br>集合 A：能被 <code>a</code> 整除的数。<br>集合 B：能被 <code>b</code> 整除的数。<br>我们需要求 A 和 B 的并集大小。</p>
<p>公式如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cnt = (mid // a) + (mid // b) - (mid // lcm(a, b))</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>mid // a</code> 是能被 <code>a</code> 整除的数的个数。</li>
<li><code>mid // b</code> 是能被 <code>b</code> 整除的数的个数。</li>
<li><code>mid // lcm(a, b)</code> 是既能被 <code>a</code> 又能被 <code>b</code> 整除的数的个数（即它们的最小公倍数的倍数）。</li>
</ul>
<p>我们需要减去重复计算的部分，即减去最小公倍数的倍数个数。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nthMagicalNumber</span>(<span class="params">self, n: <span class="built_in">int</span>, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 计算最小公倍数</span></span><br><span class="line">        <span class="comment"># math.lcm 是 Python 3.9+ 引入的</span></span><br><span class="line">        lcm = math.lcm(a, b)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 二分查找范围</span></span><br><span class="line">        <span class="comment"># 左边界 l 初始为一个不可能满足条件的值 (比第一个解还小)</span></span><br><span class="line">        <span class="comment"># 右边界 r 初始为一个必然满足条件的值</span></span><br><span class="line">        l, r = <span class="built_in">min</span>(a, b) + n - <span class="number">2</span>, <span class="built_in">min</span>(a, b) * n</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用 l + 1 &lt; r 的开区间写法</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 容斥原理计算小于等于 mid 的神奇数字个数</span></span><br><span class="line">            <span class="comment"># count = mid // a + mid // b - mid // lcm</span></span><br><span class="line">            <span class="keyword">if</span> mid // a + mid // b - mid // lcm &gt;= n:</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> r % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nthMagicalNumber</span><span class="params">(n <span class="type">int</span>, a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 计算最小公倍数 LCM</span></span><br><span class="line">    <span class="comment">// 公式：lcm(a, b) = (a * b) / gcd(a, b)</span></span><br><span class="line">    <span class="comment">// 先除后乘可以防止中间结果溢出（虽然本题数据范围较小，但这是一种好习惯）</span></span><br><span class="line">    lcm := a / gcd(a, b) * b</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二分查找范围</span></span><br><span class="line">    <span class="comment">// 这里的初始范围是基于题目特性的优化</span></span><br><span class="line">    l, r := min(a, b)+n<span class="number">-2</span>, min(a, b)*n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> l+<span class="number">1</span> &lt; r &#123;</span><br><span class="line">        mid := l + (r-l)/<span class="number">2</span></span><br><span class="line">        <span class="comment">// 容斥原理</span></span><br><span class="line">        <span class="comment">// 检查小于等于 mid 的神奇数字个数是否 &gt;= n</span></span><br><span class="line">        <span class="keyword">if</span> mid/a + mid/b - mid/lcm &gt;= n &#123;</span><br><span class="line">            r = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结果取模</span></span><br><span class="line">    <span class="keyword">return</span> r % <span class="number">1_000_000_007</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> a != <span class="number">0</span> &#123;</span><br><span class="line">        a, b = b%a, a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: <code>O(log(n * min(a, b)))</code><br>二分的范围上限大约是 <code>n * min(a, b)</code>。由于是二分查找，时间复杂度是对数级别的。在 <code>check</code> 函数中，计算 GCD 和 LCM 的时间相对于二分过程几乎可以忽略不计。对于本题的数据范围，计算量非常小。</p>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(1)</code><br>我们只使用了常数个变量来存储 <code>l</code>, <code>r</code>, <code>mid</code>, <code>lcm</code> 等，不需要额外的数组空间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>第K小/大</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>数学</tag>
        <tag>第95场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 911 | 二分查找解决“在线选举”问题</title>
    <url>//posts/leetcode-911/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 911 题：<a href="https://leetcode.cn/problems/online-election/">在线选举</a>。<br>这道题完美地展示了“预计算+二分查找”的设计模式。通过在初始化时处理好所有时间点的选举结果，我们可以将每次查询的复杂度从线性降低到对数级别，从而高效地响应大量查询。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目模拟了一个实时选举过程。我们有两个数组 <code>persons</code> 和 <code>times</code>，表示在 <code>times[i]</code> 时刻，候选人 <code>persons[i]</code> 获得了一张选票。我们需要实现一个查询功能 <code>q(t)</code>，它能返回在任意给定时刻 <code>t</code>，谁是当前的领先者。</p>
<p>领先者的判断规则有两点：</p>
<ol>
<li>获得票数最多的候选人领先。</li>
<li>如果票数出现平局，那么<strong>最近一次</strong>获得投票的候选人领先。</li>
</ol>
<p>举个例子，<code>persons = [0, 1, 1]</code>, <code>times = [0, 5, 10]</code>：</p>
<ul>
<li><strong>时刻 0 到 4</strong>：只有 <code>[0]</code> 投给了候选人 <code>0</code>。票数 <code>&#123;0: 1&#125;</code>。领先者是 <code>0</code>。</li>
<li><strong>时刻 5 到 9</strong>：<code>[0, 1]</code> 分别投给了 <code>0</code> 和 <code>1</code>。票数 <code>&#123;0: 1, 1: 1&#125;</code>。出现平局，但候选人 <code>1</code> 是在时刻 5 最近获得投票的，所以领先者是 <code>1</code>。</li>
<li><strong>时刻 10 及以后</strong>：<code>[0, 1, 1]</code>。票数 <code>&#123;0: 1, 1: 2&#125;</code>。领先者是 <code>1</code>。</li>
</ul>
<p>因此，<code>q(3)</code> 返回 <code>0</code>，<code>q(8)</code> 返回 <code>1</code>，<code>q(25)</code> 也返回 <code>1</code>。</p>
<h3 id="核心思路：预计算-二分查找"><a href="#核心思路：预计算-二分查找" class="headerlink" title="核心思路：预计算 + 二分查找"></a>核心思路：预计算 + 二分查找</h3><p>一个最直接的想法是，每当调用一次 <code>q(t)</code>，我们就遍历所有在 <code>t</code> 时刻之前的投票，模拟计票过程，找出当时的领先者。但如果查询次数非常多，这种方法的效率会很低，因为每次查询都需要重复计算。</p>
<p>注意到，选举的结果（谁是领先者）只在发生投票的那些特定时间点 (<code>times</code> 数组中的值) 才<strong>可能</strong>发生变化。在两次投票之间的时间段里，领先者是固定不变的。</p>
<p>这启发我们采用一种<strong>预计算</strong>的策略来优化查询：</p>
<ol>
<li><p><strong>预计算</strong>：在对象初始化阶段，我们先遍历一遍 <code>times</code> 和 <code>persons</code> 数组。因为 <code>times</code> 是严格递增的，我们可以按照时间顺序，计算出<strong>每一个投票时间点</strong>的选举结果（即谁是当时的领先者），然后将这些结果按时间顺序存入一个列表，例如 <code>leaders</code>。<code>leaders[i]</code> 就代表在 <code>times[i]</code> 时刻的领先者。</p>
</li>
<li><p><strong>二分查找</strong>：完成预计算后，对于任何查询 <code>q(t)</code>，问题就转化为：在 <code>times</code> 这个有序数组中，找到最后一个不大于 <code>t</code> 的时间点 <code>times[i]</code>。那么 <code>t</code> 时刻的领先者就等于 <code>times[i]</code> 时刻的领先者，也就是我们预先算好的 <code>leaders[i]</code>。在一个有序数组中查找一个值，正是二分查找的经典应用场景。</p>
</li>
</ol>
<p>通过这种方式，我们将复杂的、重复的计票逻辑集中在只需执行一次的初始化阶段，而将频繁调用的查询操作优化为一次高效的二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化 <code>__init__</code></strong></p>
<ul>
<li>我们需要一个列表 <code>leaders</code> 来存储每个投票时间点对应的领先者。</li>
<li>我们还需要一个哈希表 <code>counts</code> 来实时追踪每个候选人的得票数。</li>
<li>遍历 <code>persons</code> 和 <code>times</code> 数组（从索引 <code>0</code> 到 <code>n-1</code>）。</li>
<li>在每一步 <code>i</code>：<ul>
<li>给 <code>persons[i]</code> 增加一票。</li>
<li>检查 <code>persons[i]</code> 的票数是否大于或等于当前记录的最高票数。如果是，则更新领先者为 <code>persons[i]</code>。这里的 <code>&gt;=</code> 判断巧妙地处理了平局规则：因为我们是按时间顺序处理的，当票数相等时，当前的投票者 <code>persons[i]</code> 自然就是“最近获得投票”的候选人。</li>
<li>将当前这位领先者存入 <code>leaders</code> 列表的末尾。</li>
</ul>
</li>
<li>最后，我们将 <code>times</code> 数组和 <code>leaders</code> 列表保存为类的成员变量。</li>
</ul>
</li>
<li><p><strong>查询 <code>q(t)</code></strong></p>
<ul>
<li>该函数接收一个查询时刻 <code>t</code>。</li>
<li>我们的目标是在 <code>self.times</code> 数组中找到一个索引 <code>i</code>，使得 <code>self.times[i] &lt;= t</code> 且 <code>self.times[i+1] &gt; t</code>（或者是最后一个元素）。</li>
<li>这可以通过二分查找来实现。Python 的 <code>bisect.bisect_right(array, value)</code> 函数能找到 <code>value</code> 在 <code>array</code> 中的插入点，使得插入后数组仍然有序。这个插入点的索引 <code>idx</code> 左边的所有元素都 <code>&lt;= value</code>。</li>
<li>因此，我们需要的那个时间点的索引就是 <code>idx - 1</code>。</li>
<li>返回 <code>self.leaders[idx - 1]</code> 即可。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TopVotedCandidate</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, persons: <span class="type">List</span>[<span class="built_in">int</span>], times: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="variable language_">self</span>.times = times</span><br><span class="line">        <span class="variable language_">self</span>.leaders = []</span><br><span class="line">        counts = &#123;&#125;</span><br><span class="line">        leader = -<span class="number">1</span></span><br><span class="line">        max_votes = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 1: 预计算每个时间点的领先者</span></span><br><span class="line">        <span class="keyword">for</span> person <span class="keyword">in</span> persons:</span><br><span class="line">            counts[person] = counts.get(person, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> counts[person] &gt;= max_votes:</span><br><span class="line">                max_votes = counts[person]</span><br><span class="line">                leader = person</span><br><span class="line">            <span class="variable language_">self</span>.leaders.append(leader)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">q</span>(<span class="params">self, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 2: 使用二分查找定位时间点</span></span><br><span class="line">        <span class="comment"># bisect_right 找到第一个 &gt; t 的元素的位置</span></span><br><span class="line">        idx = bisect.bisect_right(<span class="variable language_">self</span>.times, t)</span><br><span class="line">        <span class="comment"># 我们需要的是 &lt;= t 的最后一个元素，其索引为 idx - 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.leaders[idx - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>:<ul>
<li><code>__init__</code>: O(N)。其中 N 是 <code>persons</code> 数组的长度。我们需要遍历一次所有投票来预计算领先者列表。哈希表的读写操作平均为 O(1)。</li>
<li><code>q</code>: O(log N)。每次查询都是对长度为 N 的 <code>times</code> 数组进行一次二分查找。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(N)。我们需要 O(N) 的空间来存储 <code>times</code> 数组和 <code>leaders</code> 列表。在初始化过程中，计票的哈希表 <code>counts</code> 最多也可能存储 N 个候选人，因此也需要 O(N) 的空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预计算 + 高效查询”设计模式的典范。当面对一个固定数据集和大量后续查询的场景时，我们应首先思考是否可以通过一次性的预处理（如排序、计算前缀和、建立状态列表等）来换取后续每次查询的效率提升。二分查找作为在有序数据上进行快速定位的利器，常常在这种模式中扮演关键角色。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>哈希表</tag>
        <tag>设计</tag>
        <tag>第103场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 930 | 滑动窗口求解“和相同的二元子数组”</title>
    <url>//posts/leetcode-930/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 930 题：<a href="https://leetcode.cn/problems/binary-subarrays-with-sum/">和相同的二元子数组</a>。<br>该题要求统计和为特定值的二元子数组个数。直接用滑动窗口处理“和恰好等于 goal”的条件，在有连续 0 的情况下会比较棘手。但如果我们换一个角度，问题就迎刃而解了。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个只包含 0 和 1 的二元数组 <code>nums</code> 和一个整数 <code>goal</code>。我们需要统计出，有多少个<strong>连续子数组</strong>，其内部所有元素之和恰好等于 <code>goal</code>。</p>
<p>举个例子，对于 <code>nums = [1,0,1,0,1]</code>, <code>goal = 2</code>：</p>
<ul>
<li>满足条件的子数组有 <code>[1,0,1]</code> (从索引0开始), <code>[1,0,1,0]</code> (从索引0开始), <code>[0,1,0,1]</code> (从索引1开始), <code>[1,0,1]</code> (从索引2开始)。等等，例子中的解释是 <code>[1,0,1]</code>, <code>[1,0,1]</code>, <code>[0,1,0,1]</code>。让我们重新看一下，<code>[1,0,1,0]</code> 的和也是 2。啊，示例的解释是 <code>[1,0,1]</code>、<code>[1,0,1,0]</code> 的和是2， <code>[0,1,0,1]</code> 的和是2，最后一个 <code>[1,0,1]</code> 是指从索引2开始的那个。所以总共有4个。</li>
<li><code>[1,0,1]</code> (和为2)</li>
<li><code>[1,0,1,0]</code> (和为2)</li>
<li><code>[0,1,0,1]</code> (和为2)</li>
<li><code>[1,0,1]</code> (从索引2开始，和为2)</li>
<li>因此，最终输出是 4。</li>
</ul>
<p>直接去枚举所有子数组的复杂度是 O(N^2)，在 <code>3 * 10^4</code> 的数据规模下会超时，我们需要更高效的算法。</p>
<h3 id="核心思路：巧妙转换为“最多为-K”"><a href="#核心思路：巧妙转换为“最多为-K”" class="headerlink" title="核心思路：巧妙转换为“最多为 K”"></a>核心思路：巧妙转换为“最多为 K”</h3><p>滑动窗口是解决子数组问题的利器。但如果我们尝试维护一个窗口，使其内部的和<strong>恰好</strong>等于 <code>goal</code>，会遇到麻烦。比如窗口 <code>[1,0,1]</code> 的和是 2，我们找到了一个解。当窗口向右扩展，加入一个 0 变成 <code>[1,0,1,0]</code>，和仍然是 2，这也是一个解。如果数组中有更多的连续 0，情况会变得更复杂，统计逻辑会很繁琐。</p>
<p>解决这个问题的金钥匙是<strong>转换问题</strong>。与其求“和恰好为 goal”，我们可以求“和最多为 goal”的子数组个数，再减去“和最多为 goal-1”的子数组个数。它们的差值，正好就是“和恰好为 goal”的子数组个数。</p>
<p><strong><code>count(sum == goal) = count(sum &lt;= goal) - count(sum &lt;= goal - 1)</code></strong></p>
<p>而求解“和最多为 k”的子数组个数，是滑动窗口的经典应用场景，逻辑非常清晰。</p>
<p>我们可以实现一个辅助函数 <code>atMost(k)</code>，用滑动窗口计算和小于等于 <code>k</code> 的子数组数量。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>实现 <code>atMost(k)</code> 辅助函数</strong></p>
<ul>
<li>我们使用 <code>left</code> 和 <code>right</code> 两个指针来定义一个滑动窗口 <code>[left, right]</code>。</li>
<li>初始化 <code>left = 0</code>, <code>current_sum = 0</code>, <code>count = 0</code>。</li>
<li><code>right</code> 指针从左到右遍历整个数组，不断扩大窗口。</li>
<li>每当 <code>right</code> 移动一步，将 <code>nums[right]</code> 加入 <code>current_sum</code>。</li>
<li>检查 <code>current_sum</code> 是否大于 <code>k</code>。如果大于，就说明窗口需要收缩。我们不断地将 <code>left</code> 指针右移，并从 <code>current_sum</code> 中减去 <code>nums[left]</code>，直到 <code>current_sum &lt;= k</code> 为止。</li>
<li>在任意一步，当窗口 <code>[left, right]</code> 满足 <code>sum &lt;= k</code> 时，所有以 <code>right</code> 为右端点，且左端点在 <code>[left, right]</code> 区间内的子数组，它们的和也都小于等于 <code>k</code>。这样的子数组共有 <code>right - left + 1</code> 个。我们将这个数目累加到总数 <code>count</code> 中。</li>
<li><code>right</code> 遍历结束后，返回 <code>count</code>。</li>
</ul>
</li>
<li><p><strong>计算最终结果</strong></p>
<ul>
<li>调用我们写好的辅助函数，分别计算 <code>atMost(goal)</code> 和 <code>atMost(goal - 1)</code>。</li>
<li>最终的结果就是 <code>atMost(goal) - atMost(goal - 1)</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSubarraysWithSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], goal: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">atMost</span>(<span class="params">k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            一个辅助函数，用来计算和最多为 k 的子数组数量。</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            left, current_sum, count = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                current_sum += nums[right]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 如果当前窗口的和大于 k，则从左边收缩窗口</span></span><br><span class="line">                <span class="keyword">while</span> current_sum &gt; k:</span><br><span class="line">                    current_sum -= nums[left]</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 以 right 为右端点的、和小于等于 k 的子数组个数为 right - left + 1</span></span><br><span class="line">                count += (right - left + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 原问题答案 = atMost(goal) - atMost(goal - 1)</span></span><br><span class="line">        <span class="keyword">return</span> atMost(goal) - atMost(goal - <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是 <code>nums</code> 的长度。<code>atMost</code> 函数中的 <code>left</code> 和 <code>right</code> 指针都只会从头到尾移动一次，因此是 O(N) 的。我们调用了两次该函数，所以总时间复杂度是 O(N) + O(N) &#x3D; O(N)。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个额外变量。</li>
</ul>
<h3 id="补充：前缀和-哈希表"><a href="#补充：前缀和-哈希表" class="headerlink" title="补充：前缀和 + 哈希表"></a>补充：前缀和 + 哈希表</h3><p>本题还有另一种非常经典的解法：前缀和 + 哈希表。<br>思路是：</p>
<ol>
<li>我们要求的是满足 <code>sum(nums[i:j+1]) == goal</code> 的 <code>(i, j)</code> 对的数量。</li>
<li>使用前缀和 <code>prefix_sum</code>，这个条件可以改写为 <code>prefix_sum[j] - prefix_sum[i-1] == goal</code>。</li>
<li>进一步变形得到 <code>prefix_sum[i-1] == prefix_sum[j] - goal</code>。</li>
<li>于是，我们可以遍历数组，在计算出每个位置 <code>j</code> 的前缀和 <code>prefix_sum[j]</code> 的同时，去一个哈希表中查找，之前出现过多少次值为 <code>prefix_sum[j] - goal</code> 的前缀和。将这个次数累加到结果中，然后将当前的前缀和 <code>prefix_sum[j]</code> 存入哈希表。<br>这种方法的时间和空间复杂度分别为 O(N) 和 O(N)。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题展示了解决“恰好为 K”这类计数问题的强大技巧——将其转化为两个“最多为 K”问题的差。这个思想不仅适用于滑动窗口，也适用于其他许多算法场景。它能将一个逻辑复杂的计数问题，分解为两个逻辑清晰的子问题，从而大大简化代码的实现难度和出错率，是算法工具箱中非常实用的一招。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>前缀和</tag>
        <tag>第108场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode LCP 08 | 前缀和与二分查找解决“剧情触发时间”</title>
    <url>//posts/leetcode-lcp-08/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode LCP 08 题：<a href="https://leetcode.cn/problems/ju-qing-hong-fa-shi-jian/">剧情触发时间</a>。<br>当游戏属性随时间单调递增时，寻找满足条件的“最早时刻”是一个经典的二分查找应用场景。通过预计算前缀和，我们可以将每次判断的复杂度降为常数级别，从而高效地解决问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目模拟了一个游戏过程，其中有三种核心属性：文明等级（C）、资源储备（R）和人口数量（H）。所有属性初始值（第 0 天）都为 0。</p>
<p>游戏每天都会进行，三种属性会根据一个给定的 <code>increase</code> 数组增长。<code>increase[i]</code> 代表第 <code>i+1</code> 天 C, R, H 的增量。</p>
<p>同时，有一系列剧情，它们的触发条件由 <code>requirements</code> 数组给出。每个 <code>requirement[j]</code> 包含一个 <code>[c, r, h]</code> 的阈值，当玩家的属性 C, R, H 同时大于或等于这些阈值时，该剧情就会被触发。</p>
<p>我们的任务是，对于每一个剧情，计算它被触发的最早是哪一天。如果某个剧情永远无法被触发，则记为 -1。</p>
<p>例如，<code>increase = [[2,8,4],[2,5,0],[10,9,8]]</code>，<code>requirements = [[2,11,3]]</code>：</p>
<ul>
<li>初始状态 (第 0 天): C&#x3D;0, R&#x3D;0, H&#x3D;0。</li>
<li>第 1 天结束: C&#x3D;2, R&#x3D;8, H&#x3D;4。此时不满足 R&gt;&#x3D;11。</li>
<li>第 2 天结束: C&#x3D;2+2&#x3D;4, R&#x3D;8+5&#x3D;13, H&#x3D;4+0&#x3D;4。此时 C&gt;&#x3D;2, R&gt;&#x3D;11, H&gt;&#x3D;3 全部满足。</li>
<li>因此，该剧情的触发时间是第 2 天。</li>
</ul>
<h3 id="核心思路：前缀和-二分查找"><a href="#核心思路：前缀和-二分查找" class="headerlink" title="核心思路：前缀和 + 二分查找"></a>核心思路：前缀和 + 二分查找</h3><p>一个朴素的解法是：对每一个 <code>requirement</code>，我们都从第 1 天开始，一天天模拟属性的增长，直到满足条件为止。如果 <code>increase</code> 的长度为 D，<code>requirements</code> 的长度为 Q，这种暴力解法的时间复杂度大约是 O(Q * D)，在 D 和 Q 都达到 10^5 的情况下，计算量过大，会导致超时。</p>
<p>我们可以进行优化。注意到，对于任何一个剧情，它能否在第 <code>k</code> 天被触发，取决于到第 <code>k</code> 天为止累积的 C, R, H 总量。这个“累积总量”可以通过<strong>前缀和</strong>来快速计算。我们可以先对 <code>increase</code> 数组预处理，得到一个 <code>prefix_sum</code> 数组，其中 <code>prefix_sum[k]</code> 存储了到第 <code>k</code> 天结束时 C, R, H 的总值。这样，查询任意一天的属性状态就变成了 O(1) 的操作。</p>
<p>更重要的是，随着天数 <code>d</code> 的增加，C, R, H 的总量是<strong>单调不减</strong>的。这意味着，如果一个剧情在第 <code>d</code> 天可以被触发，那么在 <code>d</code> 之后的所有天也一定可以被触发。这个单调性是使用<strong>二分查找</strong>的关键信号。</p>
<p>因此，对于每个 <code>requirement</code>，问题就转化为：<strong>在 <code>[0, 1, ..., D]</code> 这些天中，找到满足触发条件的最小天数 <code>d</code>。</strong> 这是一个典型的二分查找“寻找下界”的问题。</p>
<p>优化的思路分为两步：</p>
<ol>
<li><strong>预计算前缀和</strong>：遍历一次 <code>increase</code> 数组，计算出每一天结束时 C, R, H 的累积总量，存入前缀和数组。</li>
<li><strong>二分查找</strong>：对每一个 <code>requirement</code>，在 <code>[0, D]</code> 的天数范围内进行二分查找，快速定位到最早的触发时间。</li>
</ol>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>预处理 <code>increase</code> 数组</strong></p>
<ul>
<li>创建一个前缀和数组 <code>prefix_sum</code>，长度比 <code>increase</code> 大 1。<code>prefix_sum[i]</code> 用于存储到第 <code>i</code> 天结束时的总属性值。</li>
<li><code>prefix_sum[0]</code> 初始化为 <code>[0, 0, 0]</code>，代表第 0 天的初始状态。</li>
<li>遍历 <code>increase</code> 数组，从 <code>i = 1</code> 到 <code>D</code>，计算 <code>prefix_sum[i] = prefix_sum[i-1] + increase[i-1]</code>。</li>
</ul>
</li>
<li><p><strong>处理 <code>requirements</code> 数组</strong></p>
<ul>
<li>创建一个空的答案数组 <code>ans</code>。</li>
<li>遍历 <code>requirements</code> 中的每一个 <code>req = [c, r, h]</code>：<ul>
<li>首先做一个快速判断：如果到游戏最后一天，总属性值都无法满足 <code>req</code>，那么这个剧情永远不会触发。即 <code>prefix_sum[D]</code> 的三项均小于 <code>req</code> 的对应项，则直接将 -1 加入答案，并继续下一个 <code>req</code>。</li>
<li>设定二分查找的范围 <code>left = 0</code>, <code>right = D</code>。我们的目标是在这个范围内找到满足条件的最小天数。</li>
<li>进入二分循环 (<code>while left &lt;= right</code>)：<ul>
<li>取中间天数 <code>mid = left + (right - left) // 2</code>。</li>
<li>检查在第 <code>mid</code> 天结束时，属性是否满足 <code>req</code>，即 <code>prefix_sum[mid][0] &gt;= c</code>, <code>prefix_sum[mid][1] &gt;= r</code>, 并且 <code>prefix_sum[mid][2] &gt;= h</code>。</li>
<li>如果满足条件：说明第 <code>mid</code> 天或更早的天数是可能的答案。我们记录下 <code>mid</code>，并尝试在更早的时间里寻找，即 <code>right = mid - 1</code>。</li>
<li>如果不满足条件：说明第 <code>mid</code> 天太早了，需要更多时间积累属性，因此需要在之后的时间里寻找，即 <code>left = mid + 1</code>。</li>
</ul>
</li>
<li>循环结束后，记录下的那个满足条件的 <code>mid</code> 就是最早的触发时间。将其加入 <code>ans</code> 数组。</li>
<li>特殊情况：对于 <code>[0,0,0]</code> 的需求，第 0 天即可满足，需要单独处理或确保二分查找的逻辑能覆盖。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>遍历结束后，返回 <code>ans</code> 数组。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getTriggerTime</span>(<span class="params">self, increase: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], requirements: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(increase)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1: 预处理 increase 数组，计算前缀和</span></span><br><span class="line">        <span class="comment"># prefix_sum[i] 表示第 i 天结束时的总属性 (i 从 1 开始)</span></span><br><span class="line">        <span class="comment"># prefix_sum[0] 表示第 0 天的初始状态</span></span><br><span class="line">        prefix_sum = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            prefix_sum[i+<span class="number">1</span>][<span class="number">0</span>] = prefix_sum[i][<span class="number">0</span>] + increase[i][<span class="number">0</span>]</span><br><span class="line">            prefix_sum[i+<span class="number">1</span>][<span class="number">1</span>] = prefix_sum[i][<span class="number">1</span>] + increase[i][<span class="number">1</span>]</span><br><span class="line">            prefix_sum[i+<span class="number">1</span>][<span class="number">2</span>] = prefix_sum[i][<span class="number">2</span>] + increase[i][<span class="number">2</span>]</span><br><span class="line">            </span><br><span class="line">        ans = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2: 处理 requirements 数组</span></span><br><span class="line">        <span class="keyword">for</span> req <span class="keyword">in</span> requirements:</span><br><span class="line">            c, r, h = req[<span class="number">0</span>], req[<span class="number">1</span>], req[<span class="number">2</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 特殊情况：0 需求</span></span><br><span class="line">            <span class="keyword">if</span> c == <span class="number">0</span> <span class="keyword">and</span> r == <span class="number">0</span> <span class="keyword">and</span> h == <span class="number">0</span>:</span><br><span class="line">                ans.append(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 剪枝：如果最后一天都无法满足，则永远无法触发</span></span><br><span class="line">            <span class="keyword">if</span> prefix_sum[n][<span class="number">0</span>] &lt; c <span class="keyword">or</span> prefix_sum[n][<span class="number">1</span>] &lt; r <span class="keyword">or</span> prefix_sum[n][<span class="number">2</span>] &lt; h:</span><br><span class="line">                ans.append(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 二分查找：在 [1, n] 的天数范围内寻找最早的触发时间</span></span><br><span class="line">            left, right = <span class="number">1</span>, n</span><br><span class="line">            res = -<span class="number">1</span> <span class="comment"># 用于记录满足条件的最早天数</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                mid = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="comment"># 检查第 mid 天的属性是否满足要求</span></span><br><span class="line">                <span class="keyword">if</span> prefix_sum[mid][<span class="number">0</span>] &gt;= c <span class="keyword">and</span> prefix_sum[mid][<span class="number">1</span>] &gt;= r <span class="keyword">and</span> prefix_sum[mid][<span class="number">2</span>] &gt;= h:</span><br><span class="line">                    <span class="comment"># 如果满足，mid 是一个可能的答案，尝试寻找更早的</span></span><br><span class="line">                    res = mid</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果不满足，说明 mid 太早，需要在之后的天数里找</span></span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            ans.append(res)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 3: 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(D + Q * log D)<ul>
<li><code>D</code> 是 <code>increase</code> 的长度 (总天数)，<code>Q</code> 是 <code>requirements</code> 的长度。</li>
<li>计算前缀和数组需要遍历一次 <code>increase</code>，复杂度为 O(D)。</li>
<li>对于 <code>Q</code> 个剧情中的每一个，我们都执行一次二分查找。查找的范围是 <code>[1, D]</code>，所以单次二分查找的复杂度是 O(log D)。</li>
<li>总时间复杂度为 O(D + Q * log D)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(D)<ul>
<li>我们需要一个额外的前缀和数组 <code>prefix_sum</code> 来存储 <code>D+1</code> 天的属性状态。</li>
<li>返回的答案数组需要 O(Q) 的空间，但通常不计入额外空间复杂度。因此，主要额外空间开销是前缀和数组。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预处理 + 二分查找”模式的又一个绝佳示例。题目的核心特征是状态（玩家属性）随一个维度（时间）的推移而单调变化。当我们需要在这个单调变化的序列中寻找第一个满足特定条件的点时，二分查找就是最高效的算法。通过前缀和将“检查任意一点状态”的成本从 O(D) 降至 O(1)，是让二分查找得以高效应用的关键所在。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode LCP 12 | 小张刷题计划</title>
    <url>//posts/leetcode-lcp-12/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode LCP 12. <a href="https://leetcode.cn/problems/xiao-zhang-shua-ti-ji-hua/description/">小张刷题计划</a>。<br>直接去计算“最小的 T”似乎无从下手，因为它涉及到如何分组、如何使用求助等复杂决策。如果我们<strong>猜测</strong>一个 T 值（例如，T&#x3D;3），我们能否判断出，是否存在一种方案，能在 m 天内完成所有题目，并且每天的耗时都不超过 T？</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>小张有 n 道题要刷，计划在 m 天内按顺序完成。完成第 <code>i</code> 道题需要 <code>time[i]</code> 的时间。为了加速，他每天有一次“场外求助”的机会，可以让一道题的耗时变为 0。</p>
<p>我们的目标是合理安排每天要做的题目以及求助机会，使得 m 天中“做题时间最多的一天”的耗时 T 尽可能小。我们需要求出这个最小的 T 是多少。</p>
<p>举个例子，<code>time = [1,2,3,3], m = 2</code>。</p>
<ul>
<li>我们可以这样安排：<ul>
<li><strong>第一天</strong>：做第 0、1、2 题。总耗时是 <code>1 + 2 + 3 = 6</code>。但我们有一次求助机会，应该用在耗时最长的题目上，即第 2 题（耗时3）。所以第一天实际耗时 <code>1 + 2 = 3</code>。</li>
<li><strong>第二天</strong>：做第 3 题。耗时是 3。我们可以对这道题使用求助，所以第二天实际耗时 0。</li>
</ul>
</li>
<li>这样安排下来，两天的耗时分别是 3 和 0。其中耗时最多的一天是 3。我们可以证明，不存在耗时更少的方案，所以答案是 3。</li>
</ul>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接去计算“最小的 T”似乎无从下手，因为它涉及到如何分组、如何使用求助等复杂决策。</p>
<p>但是，我们可以换一个角度思考：如果我们<strong>猜测</strong>一个 T 值（例如，T&#x3D;3），我们能否判断出，是否存在一种方案，能在 m 天内完成所有题目，并且每天的耗时都不超过 T？</p>
<p>这个“判定问题”就变得清晰了。我们可以设计一个辅助函数 <code>check(T)</code>：</p>
<ul>
<li>该函数接收一个最大耗时 T 作为参数。</li>
<li>它会贪心地尝试在不超过 T 的前提下，每天尽可能多地刷题。</li>
<li>如果能在 m 天或更少天内完成所有题目，则说明这个 T 是可行的，函数返回 <code>True</code>；否则返回 <code>False</code>。</li>
</ul>
<p>有了这个判定函数，我们发现它具有非常明显的<strong>单调性</strong>：</p>
<ul>
<li>如果耗时上限 <code>T</code> <strong>可以</strong>让小张在 m 天内完成计划，那么任何大于 <code>T</code> 的 <code>T&#39;</code>（更宽松的上限）也<strong>一定</strong>可以完成。</li>
<li>反之，如果 <code>T</code> <strong>不可以</strong>完成计划，那么任何小于 <code>T</code> 的 <code>T&#39;&#39;</code>（更严格的上限）也<strong>必然</strong>无法完成。</li>
</ul>
<p>这种单调性是应用<strong>二分查找</strong>的完美信号。我们可以对“耗时 T”这个值进行二分查找，来快速定位到那个“最小可行”的临界点。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：0。在最理想的情况下（例如题目数量小于等于天数 m），小张可以每天只做一题并求助，耗时为 0。</li>
<li><strong>上界 (right)</strong>：所有题目的总耗时。这是最坏的情况，即 m&#x3D;1，一天内必须完成所有题目。</li>
</ul>
<p>因此，我们就在 <code>[0, sum(time)]</code> 这个区间内，对 T 进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = 0</code>：可能的最小耗时。</li>
<li><code>right = sum(time)</code>：必然可行的最大耗时。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>left &lt; right</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = left + (right - left) // 2</code> 作为当前的“猜测耗时上限”。</li>
<li>调用辅助函数 <code>check(mid)</code> 来判定这个猜测值是否可行。<ul>
<li><code>check(mid)</code> 函数内部，使用贪心策略模拟刷题过程：<ul>
<li>初始化天数 <code>days_needed = 1</code>，当天已用时间 <code>current_day_time = 0</code>，当天遇到的最长耗时 <code>max_time_this_day = 0</code>。</li>
<li>遍历每一道题 <code>t</code> in <code>time</code>：<ul>
<li>更新当天遇到的最长耗时 <code>max_time_this_day = max(max_time_this_day, t)</code>。</li>
<li>判断如果把当前这道题 <code>t</code> 加入今天的计划，在使用了求助后，时间是否会超限。检查条件是 <code>current_day_time + t - max_time_this_day &gt; mid</code>。<ul>
<li><strong>为什么是这个条件？</strong> 因为在当天，我们可以随时决定把求助机会用在已经遇到的、耗时最长的那道题上 (<code>max_time_this_day</code>)。所以当天的净耗时就是 <code>current_day_time + t - max_time_this_day</code>。</li>
</ul>
</li>
<li>如果该条件成立（即时间超限），说明当前这道题 <code>t</code> 无法放入今天。我们必须开启新的一天。<ul>
<li><code>days_needed</code> 加 1。</li>
<li>新的一天从当前这道题 <code>t</code> 开始，所以 <code>current_day_time = t</code>，<code>max_time_this_day = t</code>。</li>
</ul>
</li>
<li>如果未超限，则将 <code>t</code> 加入今天的计划：<code>current_day_time += t</code>。</li>
</ul>
</li>
<li>遍历结束后，返回 <code>days_needed &lt;= m</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>True</code></strong> (即 <code>mid</code> 这个上限是可行的)：<ul>
<li>说明 <code>mid</code> 是一个潜在的答案，但我们想找的是“最小”的 T，所以我们尝试一个更小的值，将搜索范围缩小到左半边（包含 mid）：<code>right = mid</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>False</code></strong> (即 <code>mid</code> 这个上限太严格了)：<ul>
<li>说明我们需要放宽上限，将搜索范围缩小到右半边：<code>left = mid + 1</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>left</code> 和 <code>right</code> 相遇，此时的值就是满足条件的最小耗时上限 T。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minTime</span>(<span class="params">self, time: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判定函数：在每天耗时上限为 T 的情况下，能否在 m 天内完成所有题目</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">T: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            days_needed = <span class="number">1</span></span><br><span class="line">            current_day_time = <span class="number">0</span></span><br><span class="line">            max_time_this_day = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> time:</span><br><span class="line">                max_time_this_day = <span class="built_in">max</span>(max_time_this_day, t)</span><br><span class="line">                <span class="comment"># 检查如果把当前题目 t 加入今天的任务，并对今天耗时最长的任务使用求助后，</span></span><br><span class="line">                <span class="comment"># 是否会超过上限 T。</span></span><br><span class="line">                <span class="comment"># 注意：这里不能先累加再判断，因为 max_time_this_day 可能会在 t 加入后才更新。</span></span><br><span class="line">                <span class="comment"># 正确的逻辑是，假设我们把 t 加入今天的任务列表，那么今天的任务总耗时是 current_day_time + t,</span></span><br><span class="line">                <span class="comment"># 其中最耗时的任务是 max(max_time_this_day, t)。求助后净耗时为 current_day_time + t - max(max_time_this_day, t)。</span></span><br><span class="line">                <span class="comment"># 这个逻辑比较绕，我们换一种更清晰的。</span></span><br><span class="line">                <span class="comment"># </span></span><br><span class="line">                <span class="comment"># 换一种思路：我们先尝试将 t 加入今天</span></span><br><span class="line">                current_day_time += t</span><br><span class="line">                max_time_this_day = <span class="built_in">max</span>(max_time_this_day, t)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果今天总耗时（减去一次求助）超过了 T</span></span><br><span class="line">                <span class="keyword">if</span> current_day_time - max_time_this_day &gt; T:</span><br><span class="line">                    <span class="comment"># 那么这道题 t 不能放在今天，必须开启新的一天</span></span><br><span class="line">                    days_needed += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 新的一天从当前这道题 t 开始</span></span><br><span class="line">                    current_day_time = t</span><br><span class="line">                    max_time_this_day = t</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> days_needed &lt;= m</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找的左右边界</span></span><br><span class="line">        <span class="comment"># 左边界：0，理想情况下每天求助，耗时为0</span></span><br><span class="line">        <span class="comment"># 右边界：所有题目的总时间，此时一定可行（m=1的情况）</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">sum</span>(time)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 二分查找寻找最小的可行 T</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 时间可行，说明它可能是答案，</span></span><br><span class="line">                <span class="comment"># 或者还有更小的可行时间，所以我们尝试在左半部分 [left, mid] 继续寻找</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 时间不可行，说明时间太少，</span></span><br><span class="line">                <span class="comment"># 必须增加，所以去右半部分 [mid + 1, right] 寻找</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时，left 就是满足条件的最小耗时</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N * log(S))。<ul>
<li>二分查找的搜索空间大小为 <code>S = sum(time)</code>，因此迭代次数为 O(log(S))。</li>
<li>在每次迭代中，我们都需要调用 <code>check</code> 函数。<code>check</code> 函数需要一次遍历 <code>time</code> 数组，时间复杂度为 O(N)，其中 N 是题目的数量。</li>
<li>因此，总时间复杂度是这两者的乘积，即 O(N * log(S))。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)。<ul>
<li><code>check</code> 函数中只使用了常数个额外变量，因此空间复杂度为 O(1)。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“最小化最大值”问题的一个经典应用。它完美地展示了如何通过二分答案，将一个复杂的求解问题转化为一个相对简单的、具有单调性的判定问题。当我们遇到求解“最小的…最大值”或“最大的…最小值”这类问题时，应优先考虑是否能套用二分答案的框架，这往往是通向高效解法的钥匙。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>最小化最大值</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode LCP 78 | 城墙防线</title>
    <url>//posts/leetcode-lcp-78/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode LCP 78 题：<a href="https://leetcode.cn/problems/Nsibyl/description/">城墙防线</a>。<br>本题是一道典型的“最大值最小化&#x2F;最小值最大化”问题，其核心在于识别出答案的单调性，并将一个求解最优值（最大膨胀值）的问题，巧妙地转化为一个判定性（给定膨胀值是否可行）的问题，从而利用二分查找在对数时间内高效求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要在一系列不重叠的城墙区间中，找到一个<strong>最大</strong>的膨胀值 <code>m</code>，使得所有城墙同时膨胀 <code>m</code> 的长度后，它们之间仍然互不重叠。</p>
<p>这里的核心约束条件是：</p>
<ol>
<li>所有城墙（<code>rampart[i]</code>）同时膨胀一个<strong>相等</strong>的长度 <code>m</code>。</li>
<li>每个城墙可以自由选择向左、向右或者向两侧膨胀，只要总膨胀长度为 <code>m</code> 即可。例如，一段城墙 <code>[x, y]</code> 膨胀 <code>m</code>，可以变为 <code>[x-m, y]</code>，或 <code>[x, y+m]</code>，或 <code>[x-a, y+b]</code> (其中 <code>a+b=m</code>)。</li>
<li>膨胀后的所有城墙区间不能有任何重叠。</li>
<li>最左侧和最右侧的城墙可以向外无限膨胀。</li>
</ol>
<p>我们的目标就是找到这个 <code>m</code> 的最大可能值。</p>
<p>举个例子，<code>rampart = [[0,3],[4,5],[7,9]]</code>。</p>
<ul>
<li>城墙 0 和 1 之间的间隙是 <code>4 - 3 = 1</code>。</li>
<li>城墙 1 和 2 之间的间隙是 <code>7 - 5 = 2</code>。<br>如果我们想让膨胀值 <code>m=3</code>，是否可行呢？</li>
<li>城墙 0 (<code>[0,3]</code>) 是最左侧的，可以让它向左无限膨胀，变为 <code>[-3, 3]</code>。</li>
<li>城墙 2 (<code>[7,9]</code>) 是最右侧的，可以让它向右无限膨胀，变为 <code>[7, 12]</code>。</li>
<li>现在关键是中间的城墙 1 (<code>[4,5]</code>)。它左边紧邻着膨胀后的城墙 0（右边界在 3），右边紧邻着膨胀后的城墙 2（左边界在 7）。它可用的总空间是 <code>7 - 3 = 4</code>，而它自身的长度是 <code>5 - 4 = 1</code>。所以它两侧的空余间隙是 <code>(4-1) = 3</code>。为了让自己也膨胀 3，它可以向左膨胀 1，向右膨胀 2，最终变为 <code>[4-1, 5+2] = [3, 7]</code>。</li>
<li>最终膨胀后的三段城墙是 <code>[-3,3]</code>, <code>[3,7]</code>, <code>[7,12]</code>。它们恰好无重叠。所以 <code>m=3</code> 是可行的。可以证明，不存在比 3 更大的方案。</li>
</ul>
<p>这暗示了答案存在一个临界点，小于这个值的膨胀都可行，大于这个值的膨胀都不可行。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最大膨胀值”很困难，因为它涉及到每个城墙如何分配膨胀方向的复杂决策。但是，我们可以换一个角度思考：如果我们<strong>假定</strong>一个膨胀值 <code>m</code>，能否判断出这个膨胀方案是否可行？</p>
<p>这个判定问题相对简单。我们可以设计一个辅助函数 <code>check(m)</code>，用贪心的策略来验证可行性：<br>为了让后续的城墙有尽可能大的空间，我们应该让当前的城墙尽可能地向左膨胀。</p>
<ul>
<li>我们从左到右依次检查每段城墙（除了第一段）。</li>
<li>对于第 <code>i</code> 段城墙，我们需要检查它在膨胀 <code>m</code> 之后，能否与膨胀后的第 <code>i-1</code> 段城墙不发生重叠。</li>
<li>我们维护一个变量 <code>prev_right</code>，表示第 <code>i-1</code> 段城墙在满足自身膨胀 <code>m</code> 且尽可能向左膨胀后的右边界。</li>
<li>对于第 <code>i</code> 段城墙 <code>[left_i, right_i]</code>，它左侧可用的膨胀空间为 <code>left_i - prev_right</code>。<ul>
<li>如果 <code>left_i - prev_right &gt;= m</code>，说明左侧空间足够，第 <code>i</code> 段城墙可以完全向左膨胀，它膨胀后的右边界仍然是 <code>right_i</code>。</li>
<li>如果 <code>left_i - prev_right &lt; m</code>，说明左侧空间不足，它必须向右膨胀。需要向右膨胀的长度为 <code>m - (left_i - prev_right)</code>。那么它膨胀后的新右边界就是 <code>right_i + (m - (left_i - prev_right))</code>。</li>
<li>我们必须检查这个新右边界是否会与第 <code>i+1</code> 段城墙 <code>[left_&#123;i+1&#125;, ...]</code> 的左边界重叠。如果 <code>新右边界 &gt; left_&#123;i+1&#125;</code>，则说明 <code>m</code> 太大了，不可行。</li>
</ul>
</li>
<li>如果所有城墙都能通过这种贪心策略安排好位置，那么 <code>m</code> 就是一个可行的膨胀值。</li>
</ul>
<p>现在我们有了一个判定的方法 <code>check(m)</code>，并且可以发现它具有<strong>单调性</strong>：</p>
<ul>
<li>如果一个膨胀值 <code>m</code> 是可行的，那么任何小于 <code>m</code> 的值 <code>m&#39;</code> 也一定可行（因为需要的空间更小）。</li>
<li>反之，如果 <code>m</code> 不可行，那么任何大于 <code>m</code> 的值 <code>m&#39;</code> 也必然不可行（因为需要的空间更大）。</li>
</ul>
<p>这种单调性正是应用二分查找的完美场景。我们可以对“膨胀值”进行二分查找，来快速定位那个“最大可行”的临界点。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：显然，最小的膨胀值是 <code>0</code>。</li>
<li><strong>上界 (right)</strong>：一个宽松的上界可以是所有城墙间隙之和。一个更紧的估算是总间隙除以中间城墙的数量，如 <code>sum_of_gaps / (n-2)</code>。</li>
</ul>
<p>因此，我们就在 <code>[0, 一个足够大的数]</code> 这个区间内，对膨胀值 <code>m</code> 进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = 0</code>：可能的最小膨胀值。</li>
<li><code>right</code>：一个足够大的上界。例如，所有城墙间隙的总和。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>left</code> 和 <code>right</code> 的差距大于 1 时 (<code>left + 1 &lt; right</code>)，循环继续。</li>
<li>计算中间值 <code>mid = (left + right) // 2</code> 作为当前的“猜测膨胀值”。</li>
<li>调用辅助函数 <code>check(mid)</code> 来判定这个猜测值是否可行。<ul>
<li><strong>如果 <code>check(mid)</code> 返回 <code>True</code></strong> (即 <code>mid</code> 是一个可行的膨胀值)：<ul>
<li>说明 <code>mid</code> 是一个潜在的答案，我们也许还能找到更大的可行值。所以我们将搜索范围的下界提升到 <code>mid</code>：<code>left = mid</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>False</code></strong> (即 <code>mid</code> 这个膨胀值太大了)：<ul>
<li>说明我们需要减小膨胀值，将搜索范围的上界收缩到 <code>mid</code>：<code>right = mid</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>left</code> 中存储的就是满足条件的最大可行膨胀值。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><p>这是题目给出的，经过了整理和注释的 Python 代码实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> inf</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> pairwise</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rampartDefensiveLine</span>(<span class="params">self, rampart: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 辅助函数：贪心检查膨胀值 m 是否可行</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># prev_right_bound: 前一个城墙膨胀后的右边界</span></span><br><span class="line">            <span class="comment"># 第一个城墙可以无限向左膨胀，所以它的前一个边界可以看作在负无穷远</span></span><br><span class="line">            prev_right_bound = -inf</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 使用 pairwise 巧妙地遍历相邻的城墙对</span></span><br><span class="line">            <span class="comment"># (cl, cr) 是当前城墙的左右边界</span></span><br><span class="line">            <span class="comment"># (nl, _) 是下一个城墙的左边界</span></span><br><span class="line">            <span class="keyword">for</span> (cl, cr), (nl, _) <span class="keyword">in</span> pairwise(rampart):</span><br><span class="line">                <span class="comment"># left_gap: 当前城墙左侧可用的膨胀空间</span></span><br><span class="line">                left_gap = cl - prev_right_bound</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># right_expand_needed: 为满足总膨胀 m，需要向右膨胀的长度</span></span><br><span class="line">                right_expand_needed = m - left_gap</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 如果需要向右膨胀</span></span><br><span class="line">                <span class="keyword">if</span> right_expand_needed &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># new_right_bound: 当前城墙膨胀后的新右边界</span></span><br><span class="line">                    new_right_bound = cr + right_expand_needed</span><br><span class="line">                    <span class="comment"># 如果新右边界与下一个城墙重叠，则 m 不可行</span></span><br><span class="line">                    <span class="keyword">if</span> new_right_bound &gt; nl:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    <span class="comment"># 更新前一个城墙的右边界，用于下一次迭代</span></span><br><span class="line">                    prev_right_bound = new_right_bound</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果左侧空间足够 (&gt;= m)，则当前城墙可以完全向左膨胀</span></span><br><span class="line">                    <span class="comment"># 为了给后续城墙留出最大空间（贪心），它的右边界保持不变</span></span><br><span class="line">                    prev_right_bound = cr</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果所有城墙都能安排好，说明 m 可行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算一个二分查找的上界</span></span><br><span class="line">        <span class="comment"># tas 是所有内部间隙的总长度</span></span><br><span class="line">        tas = <span class="built_in">sum</span>(nl - pr <span class="keyword">for</span> (_, pr), (nl, _) <span class="keyword">in</span> pairwise(rampart))</span><br><span class="line">        n = <span class="built_in">len</span>(rampart)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 定义二分查找的左右边界</span></span><br><span class="line">        l, r = <span class="number">0</span>, tas // (n - <span class="number">2</span>) + <span class="number">1</span> <span class="keyword">if</span> n &gt; <span class="number">2</span> <span class="keyword">else</span> tas + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找寻找最大的可行 m</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 可行，尝试更大的值</span></span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 不可行，必须缩小值</span></span><br><span class="line">                r = mid</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时, l 就是答案</span></span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N * log(M))。<ul>
<li><code>N</code> 是城墙数组 <code>rampart</code> 的长度。</li>
<li><code>M</code> 是二分查找的搜索空间大小，即 <code>r - l</code> 的初始值。</li>
<li>二分查找本身需要 <code>log(M)</code> 次迭代。</li>
<li>在每次迭代中，我们都需要调用 <code>check</code> 函数，该函数需要遍历一次 <code>rampart</code> 数组，时间复杂度为 O(N)。</li>
<li>因此，总时间复杂度是这两者的乘积。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)。<ul>
<li>除了输入数组外，我们只使用了几个变量来存储左右边界、中间值和贪心过程中的状态，所以空间复杂度是常数级的。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题再次展示了二分答案思想的威力。当直接求解一个最优值（如最大值、最小值）困难时，我们可以尝试将其转化为一个更简单的“判定性”问题。如果这个判定问题对于答案具有单调性，那么就可以利用二分查找，将问题的规模不断减半，从而在对数级别的时间复杂度内锁定最终的答案。本题的 <code>check</code> 函数还结合了贪心思想，即总是优先利用左侧空间，为右侧的后续城墙保留最大的可能性，这是确保判定正确性的关键。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最大</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1475 | 商品折扣后的最终价格</title>
    <url>//posts/leetcode-1475/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1475 题：<a href="https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/">商品折扣后的最终价格</a>。<br>问题的核心是寻找数组中每个元素右侧第一个小于等于它的元素。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是商店里第 <code>i</code> 件商品的价格。</p>
<p>商店里正在进行促销活动，如果你要买第 <code>i</code> 件商品，那么你可以得到与 <code>prices[j]</code> 相等的折扣，其中 <code>j</code> 是满足 <code>j &gt; i</code> 且 <code>prices[j] &lt;= prices[i]</code> 的 <strong>最小下标</strong> ，如果没有满足条件的 <code>j</code> ，你将没有任何折扣。</p>
<p>请你返回一个数组，数组中第 <code>i</code> 个元素是折扣后你购买商品 <code>i</code> 最终需要支付的价格。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：prices = [8,4,6,2,3]</span><br><span class="line">输出：[4,2,4,2,3]</span><br><span class="line">解释：</span><br><span class="line">商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。</span><br><span class="line">商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。</span><br><span class="line">商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。</span><br><span class="line">商品 3 和 4 都没有折扣。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：[1,2,3,4,5]</span><br><span class="line">解释：在这个例子中，所有商品都没有折扣。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：prices = [10,1,1,6]</span><br><span class="line">输出：[9,0,1,6]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; prices.length &lt;&#x3D; 500</li>
<li>1 &lt;&#x3D; prices[i] &lt;&#x3D; 10^3</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1. 问题分析"></a>1. 问题分析</h4><p>题目要求对于每个商品 <code>i</code>，找到它右边第一个满足 <code>prices[j] &lt;= prices[i]</code> 的价格 <code>prices[j]</code> 作为折扣。如果没有找到，折扣为 0。最终支付价格为 <code>prices[i] - 折扣</code>。</p>
<p>这是一个典型的 <strong>寻找右侧第一个更小（或相等）元素</strong> 的问题。</p>
<h4 id="2-单调栈-哨兵技巧"><a href="#2-单调栈-哨兵技巧" class="headerlink" title="2. 单调栈 + 哨兵技巧"></a>2. 单调栈 + 哨兵技巧</h4><p>我们可以使用单调栈来高效解决这个问题。为了方便处理，我们采用 <strong>从后往前</strong> 遍历数组的方式：</p>
<ol>
<li><strong>倒序遍历</strong>：从最后一个商品开始向前遍历。这样当我们处理第 <code>i</code> 个商品时，它右边的商品（潜在的折扣选项）已经被处理过并存储在栈中。</li>
<li><strong>维护单调性</strong>：<ul>
<li>栈中存储的是右侧的商品价格。</li>
<li>当我们遇到一个新的价格 <code>p</code> 时，我们查看栈顶元素。</li>
<li>如果栈顶元素 <strong>大于</strong> <code>p</code>，说明栈顶这个价格太贵了，不满足折扣条件（必须小于等于 <code>p</code>）。而且，由于 <code>p</code> 在栈顶元素的左边且 <code>p</code> 更小，对于 <code>p</code> 左边的任何商品来说，<code>p</code> 都是一个比栈顶元素更优（更小且距离更近）的折扣候选。因此，我们可以放心地将栈顶元素弹出。</li>
<li>重复弹出操作，直到栈顶元素 <strong>小于等于</strong> <code>p</code>，或者栈为空。</li>
</ul>
</li>
<li><strong>计算结果</strong>：<ul>
<li>此时，栈顶元素就是 <code>p</code> 右侧第一个满足条件的折扣值。</li>
<li>如果栈为空，说明右边没有更便宜的价格，折扣为 0。</li>
</ul>
</li>
<li><strong>哨兵优化</strong>：<ul>
<li>为了避免判断栈是否为空，我们可以预先在栈底放入一个 <strong>哨兵值 0</strong>。</li>
<li>题目已知 <code>prices[i] &gt;= 1</code>，所以 0 必定小于任何商品价格。</li>
<li>当栈中只剩下哨兵 0 时，说明没有找到折扣，此时计算 <code>p - 0</code> 刚好等于原价，符合逻辑，且代码更加简洁。</li>
</ul>
</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">finalPrices</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        ans = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="comment"># 初始化栈，放入哨兵 0</span></span><br><span class="line">        <span class="comment"># 0 比所有有效价格都小，代表“无折扣”的情况</span></span><br><span class="line">        st = [<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从后往前遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            p = prices[i]</span><br><span class="line">            <span class="comment"># 维护单调栈：如果栈顶价格 &gt; 当前价格 p</span></span><br><span class="line">            <span class="comment"># 说明栈顶太贵了，不能作为 p 的折扣</span></span><br><span class="line">            <span class="comment"># 且 p 更小更靠左，会挡住栈顶元素，使其对左边元素无效，故弹出</span></span><br><span class="line">            <span class="keyword">while</span> st[-<span class="number">1</span>] &gt; p:</span><br><span class="line">                st.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 此时栈顶元素 &lt;= p，即为右侧第一个满足条件的折扣</span></span><br><span class="line">            <span class="comment"># 如果没找到，栈顶就是哨兵 0</span></span><br><span class="line">            ans[i] = p - st[-<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将当前价格入栈，作为左边元素的潜在折扣</span></span><br><span class="line">            st.append(p)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finalPrices</span><span class="params">(prices []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(prices)</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="comment">// 哨兵，作为没有折扣时的栈顶值</span></span><br><span class="line">    <span class="comment">// 0 不会影响计算结果 (price - 0 = price)，且总是满足 &lt;= price</span></span><br><span class="line">    st := []<span class="type">int</span>&#123;<span class="number">0</span>&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从后往前遍历</span></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        p := prices[i]</span><br><span class="line">        <span class="comment">// 当栈顶元素大于当前价格 p 时，栈顶元素无法作为折扣，弹出</span></span><br><span class="line">        <span class="comment">// 这一步保证了栈内元素（除哨兵外）对于当前位置是单调递增的</span></span><br><span class="line">        <span class="keyword">for</span> st[<span class="built_in">len</span>(st)<span class="number">-1</span>] &gt; p &#123;</span><br><span class="line">            st = st[:<span class="built_in">len</span>(st)<span class="number">-1</span>] <span class="comment">// p 比栈顶小，比栈顶更能成为左侧元素的折扣值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束后，栈顶的价格 &lt;= p，作为折扣值</span></span><br><span class="line">        <span class="comment">// 如果没有找到真实折扣，栈顶就是哨兵 0</span></span><br><span class="line">        ans[i] = p - st[<span class="built_in">len</span>(st)<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前价格压入栈中</span></span><br><span class="line">        st = <span class="built_in">append</span>(st, p)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: O(n)<br>虽然代码中有嵌套循环，但观察栈的操作可以发现：数组中的每个元素最多入栈一次，最多出栈一次。因此整体操作次数与数组长度呈线性关系。</p>
</li>
<li><p><strong>空间复杂度</strong>: O(n)<br>需要一个栈来存储价格。在最坏情况下（例如数组严格单调递增），栈的大小接近 <code>n</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>单调栈</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>栈</tag>
        <tag>单调栈</tag>
        <tag>第28场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1 | 两数之和</title>
    <url>//posts/leetcode-1/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1 题：<a href="https://leetcode.cn/problems/two-sum/">两数之和</a>。<br>这是力扣的第一题，也是哈希表应用的经典入门题目。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <code>target</code>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>2 &lt;&#x3D; nums.length &lt;&#x3D; 10^4</li>
<li>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</li>
<li>-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9</li>
<li>只会存在一个有效答案</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-暴力法的局限性"><a href="#1-暴力法的局限性" class="headerlink" title="1. 暴力法的局限性"></a>1. 暴力法的局限性</h4><p>最直观的方法是使用两层循环。第一层循环遍历数组中的每一个数，第二层循环寻找其余数中是否存在与当前数相加等于 <code>target</code> 的数。<br>这种方法的时间复杂度是 O(n^2)。当数组长度较大时（例如达到 10^4），效率较低。</p>
<h4 id="2-哈希表-空间换时间"><a href="#2-哈希表-空间换时间" class="headerlink" title="2. 哈希表 (空间换时间)"></a>2. 哈希表 (空间换时间)</h4><p>为了降低时间复杂度，我们可以利用哈希表（在 Python 中是字典，Go 中是 Map）来记录已经遍历过的数字及其下标。</p>
<p>算法流程如下：</p>
<ol>
<li><strong>一次遍历</strong>：我们只需要遍历一次数组。</li>
<li><strong>查找补数</strong>：对于每一个遍历到的元素 <code>x</code>，我们需要寻找的目标是 <code>y = target - x</code>。</li>
<li><strong>查询与记录</strong>：<ul>
<li>如果 <code>y</code> 已经在哈希表 <code>mp</code> 中，说明之前已经遍历过了这个数字。此时，<code>mp[y]</code> 是 <code>y</code> 的下标，<code>i</code> 是当前 <code>x</code> 的下标。直接返回 <code>[mp[y], i]</code> 即可。</li>
<li>如果 <code>y</code> 不在哈希表中，我们将当前数字 <code>x</code> 及其下标 <code>i</code> 存入哈希表 <code>mp[x] = i</code>，以便后续的数字能找到它。</li>
</ul>
</li>
</ol>
<p>通过这种方式，查找操作的时间复杂度降低到了 O(1)，整体时间复杂度降低到了 O(n)。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 创建一个哈希表用于存储 &#123;数值: 下标&#125;</span></span><br><span class="line">        mp = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历数组，获取当前下标 i 和数值 x</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 计算满足条件的另一个数值 y</span></span><br><span class="line">            y = target - x</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 检查 y 是否已经在哈希表中</span></span><br><span class="line">            <span class="comment"># 如果在，说明之前遍历过 y，直接返回对应的下标和当前下标</span></span><br><span class="line">            <span class="keyword">if</span> y <span class="keyword">in</span> mp:</span><br><span class="line">                <span class="keyword">return</span> [mp[y], i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果不在，将当前数值 x 和下标 i 存入哈希表</span></span><br><span class="line">            <span class="comment"># 供后续的元素查找</span></span><br><span class="line">            mp[x] = i</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 创建哈希表，key 为数组元素值，value 为对应的下标</span></span><br><span class="line">    mp := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 计算需要的补数 y</span></span><br><span class="line">        y := target - x</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查哈希表中是否存在 y</span></span><br><span class="line">        <span class="comment">// 如果存在，说明找到了这两个数，返回它们的下标</span></span><br><span class="line">        <span class="keyword">if</span> idx, ok := mp[y]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;idx, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前元素 x 和下标 i 存入哈希表</span></span><br><span class="line">        mp[x] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>我们只遍历了包含 <code>n</code> 个元素的列表一次。在表中进行的每次查找只花费 <code>O(1)</code> 的时间。</p>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(n)</code><br>主要为哈希表的开销。在最坏的情况下（例如，目标元素在数组的最后两个），我们需要将 <code>n - 1</code> 个元素存储在哈希表中。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>常用数据结构</category>
        <category>常用枚举技巧</category>
        <category>枚举右，维护左</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1512 | 好数对的数目</title>
    <url>//posts/leetcode-1512/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1512 题：<a href="https://leetcode.cn/problems/number-of-good-pairs/">好数对的数目</a>。<br>这是一道考察数组遍历与哈希表计数的简单题目，体现了“枚举右，维护左”的经典思想。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组 <code>nums</code> 。</p>
<p>如果一组数字 <code>(i,j)</code> 满足 <code>nums[i] == nums[j]</code> 且 <code>i &lt; j</code> ，就可以认为这是一组 <strong>好数对</strong> 。</p>
<p>返回好数对的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,1,1,3]</span><br><span class="line">输出：4</span><br><span class="line">解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：数组中的每组数字都是好数对</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li>
<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1. 暴力法"></a>1. 暴力法</h4><p>最容易想到的方法是使用两层循环遍历所有可能的数对 <code>(i, j)</code>，其中 <code>0 &lt;= i &lt; j &lt; nums.length</code>，并判断 <code>nums[i]</code> 是否等于 <code>nums[j]</code>。<br>这种方法的时间复杂度是 O(n^2)。鉴于本题数据范围较小（n &lt;&#x3D; 100），暴力法也是可以通过的，但不是最优解。</p>
<h4 id="2-哈希表-一次遍历"><a href="#2-哈希表-一次遍历" class="headerlink" title="2. 哈希表 (一次遍历)"></a>2. 哈希表 (一次遍历)</h4><p>为了优化时间复杂度，我们可以使用哈希表来记录数字出现的频率。<br>这道题的核心思想是 <strong>“枚举右，维护左”</strong>。</p>
<p>算法流程如下：</p>
<ol>
<li>我们从左到右遍历数组 <code>nums</code>。</li>
<li>对于当前遍历到的数字 <code>x</code>，我们需要知道在它 <strong>之前</strong> 已经出现了多少次 <code>x</code>。</li>
<li>假设在当前位置之前，<code>x</code> 已经出现了 <code>k</code> 次，那么当前的 <code>x</code> 就可以与前面的 <code>k</code> 个 <code>x</code> 分别组成 <code>k</code> 个好数对。</li>
<li>因此，我们只需要将哈希表中记录的 <code>x</code> 的次数累加到答案 <code>ans</code> 中，然后更新哈希表中 <code>x</code> 的计数（加 1），以便后续的数字使用。</li>
</ol>
<p>通过这种方式，我们只需要遍历一次数组，时间复杂度降低到了 O(n)。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIdenticalPairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># cnt 用于存储每个数字出现的次数 &#123;数值: 出现次数&#125;</span></span><br><span class="line">        cnt = &#123;&#125;</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历数组中的每个数字</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 如果 x 已经在哈希表中，说明之前出现过</span></span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> cnt:</span><br><span class="line">                <span class="comment"># 当前的 x 可以和之前出现的 cnt[x] 个 x 组成好数对</span></span><br><span class="line">                <span class="comment"># 将之前的出现次数累加到结果中</span></span><br><span class="line">                ans += cnt[x]   </span><br><span class="line">                <span class="comment"># 更新当前数字的计数</span></span><br><span class="line">                cnt[x] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 x 第一次出现，初始化计数为 1</span></span><br><span class="line">                cnt[x] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIdenticalPairs</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 创建哈希表，key 为数组元素值，value 为该元素出现的次数</span></span><br><span class="line">    cnt := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 在 Go 语言中，如果 key 不在 map 中，会返回 value 类型的零值（即 0）</span></span><br><span class="line">        <span class="comment">// 如果 x 之前出现过，cnt[x] 即为之前的出现次数</span></span><br><span class="line">        <span class="comment">// 当前的 x 可以与之前所有的 x 组成好数对，累加到 ans</span></span><br><span class="line">        ans += cnt[x]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新当前数字 x 的计数</span></span><br><span class="line">        cnt[x]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>其中 <code>n</code> 为数组 <code>nums</code> 的长度。我们需要遍历一遍数组，哈希表的插入和查询操作平均时间复杂度为 <code>O(1)</code>。</p>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(n)</code><br>需要使用哈希表存储数组中不同元素的出现次数。在最坏情况下（数组中所有元素都不同），哈希表的大小为 <code>n</code>。考虑到题目提示中 <code>nums[i] &lt;= 100</code>，实际上空间复杂度也可视为 <code>O(C)</code>，其中 <code>C</code> 为数值范围。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>常用数据结构</category>
        <category>常用枚举技巧</category>
        <category>枚举右，维护左</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
        <tag>数学</tag>
        <tag>第197场周赛</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2441 | 与对应负数同时存在的最大正整数</title>
    <url>//posts/leetcode-2441/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2441 题：<a href="https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/">与对应负数同时存在的最大正整数</a>。<br>题目主要考察如何在遍历过程中快速查找元素的相反数。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个 <strong>不包含</strong> 任何零的整数数组 <code>nums</code> ，找出自身与对应的负数都在数组中存在的最大正整数 <code>k</code> 。</p>
<p>返回正整数 <code>k</code> ，如果不存在这样的整数，返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,2,-3,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：3 是数组中唯一一个满足题目要求的 k 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,10,6,7,-7,1]</span><br><span class="line">输出：7</span><br><span class="line">解释：数组中存在 1 和 7 对应的负数，7 的值更大。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [-10,8,6,7,-2,-3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：不存在满足题目要求的 k ，返回 -1 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000</li>
<li>-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li>
<li>nums[i] !&#x3D; 0</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="哈希表-一次遍历"><a href="#哈希表-一次遍历" class="headerlink" title="哈希表 (一次遍历)"></a>哈希表 (一次遍历)</h4><p>为了找到同时存在正数和负数的最大整数 <code>k</code>，我们可以利用哈希表（在 Python 中是 <code>set</code>，Go 中是 <code>map</code>）来记录已经遍历过的数字。</p>
<p>算法流程如下：</p>
<ol>
<li><strong>初始化</strong>：设置一个变量 <code>ans</code> 为 -1，用于记录当前找到的满足条件的最大正整数。创建一个空的哈希集合 <code>s</code>。</li>
<li><strong>遍历数组</strong>：对于数组中的每一个元素 <code>x</code>：<ul>
<li><strong>检查相反数</strong>：检查 <code>-x</code> 是否已经在集合 <code>s</code> 中。</li>
<li><strong>更新结果</strong>：如果 <code>-x</code> 存在，说明我们需要的一对正负数 <code>(x, -x)</code> 都出现了。此时，计算 <code>x</code> 的绝对值 <code>abs(x)</code>，并尝试更新 <code>ans</code> 为 <code>max(ans, abs(x))</code>。</li>
<li><strong>加入集合</strong>：将当前元素 <code>x</code> 加入集合 <code>s</code>，以便后续的元素能找到它。</li>
</ul>
</li>
<li><strong>返回结果</strong>：遍历结束后，返回 <code>ans</code>。</li>
</ol>
<p>这种方法的优势在于只需要遍历一次数组，查找操作的时间复杂度为 O(1)。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxK</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化答案为 -1，表示默认未找到</span></span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 创建一个哈希集合，用于存储遍历过的数字</span></span><br><span class="line">        s = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历数组中的每个数字 x</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 检查 x 的相反数 -x 是否已经在集合中</span></span><br><span class="line">            <span class="comment"># 如果在，说明找到了一对互为相反数的数字 (x, -x)</span></span><br><span class="line">            <span class="keyword">if</span> -x <span class="keyword">in</span> s:</span><br><span class="line">                <span class="comment"># 这一对数字对应的正整数是 abs(x)</span></span><br><span class="line">                <span class="comment"># 更新当前找到的最大正整数 k</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">abs</span>(x))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将当前数字 x 加入集合，供后续数字查找</span></span><br><span class="line">            s.add(x)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxK</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化答案为 -1</span></span><br><span class="line">    ans := <span class="number">-1</span></span><br><span class="line">    <span class="comment">// 创建一个 map 作为哈希集合，key 为数值，value 为 bool</span></span><br><span class="line">    s := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 检查 x 的相反数 -x 是否已经在 map 中</span></span><br><span class="line">        <span class="keyword">if</span> s[-x] &#123;</span><br><span class="line">            <span class="comment">// 计算 x 的绝对值</span></span><br><span class="line">            currentK := x</span><br><span class="line">            <span class="keyword">if</span> currentK &lt; <span class="number">0</span> &#123;</span><br><span class="line">                currentK = -currentK</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前的绝对值比已记录的答案更大，则更新</span></span><br><span class="line">            <span class="keyword">if</span> currentK &gt; ans &#123;</span><br><span class="line">                ans = currentK</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前数字 x 存入 map，标记为存在</span></span><br><span class="line">        s[x] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>其中 <code>n</code> 是数组 <code>nums</code> 的长度。我们需要遍历数组一次，每次在哈希表中进行查找和插入操作的平均时间复杂度为 <code>O(1)</code>。</p>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(n)</code><br>需要使用哈希表存储数组中的元素，最坏情况下需要存储所有 <code>n</code> 个元素。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>常用数据结构</category>
        <category>常用枚举技巧</category>
        <category>枚举右，维护左</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
        <tag>排序</tag>
        <tag>双指针</tag>
        <tag>第315场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 121 | 买卖股票的最佳时机</title>
    <url>//posts/leetcode-121/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 121 题：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a>。<br>这是买卖股票系列题目的第一题，也是“枚举右，维护左”思想的经典应用。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; prices.length &lt;&#x3D; 10^5</li>
<li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 10^4</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-暴力法的局限性"><a href="#1-暴力法的局限性" class="headerlink" title="1. 暴力法的局限性"></a>1. 暴力法的局限性</h4><p>最朴素的想法是两层循环：外层循环枚举买入的那一天，内层循环枚举买入之后的所有天数作为卖出日，计算差值并求最大值。<br>这种方法的时间复杂度是 O(n^2)。面对本题的数据规模（10^5），会导致超时。</p>
<h4 id="2-一次遍历（贪心-动态规划）"><a href="#2-一次遍历（贪心-动态规划）" class="headerlink" title="2. 一次遍历（贪心&#x2F;动态规划）"></a>2. 一次遍历（贪心&#x2F;动态规划）</h4><p>我们要获取最大利润，本质上是在寻找 <code>prices[j] - prices[i]</code> 的最大值，其中 <code>j &gt; i</code>。</p>
<p>我们可以换一个角度思考：<br>假设我们在第 <code>i</code> 天卖出股票，那么为了利润最大化，我们必须在第 <code>i</code> 天之前的某一天以 <strong>最低价格</strong> 买入。</p>
<p>算法流程如下：</p>
<ol>
<li><strong>记录最低价格 (<code>mp</code>)</strong>：我们需要维护一个变量，记录“截止到目前为止”遇到的最低股价。初始时，最低价格可以设为第一天的价格。</li>
<li><strong>枚举卖出价格 (<code>p</code>)</strong>：从头到尾遍历数组，假设当前遍历到的价格 <code>p</code> 就是我们卖出的价格。</li>
<li><strong>计算利润与更新</strong>：<ul>
<li><strong>计算当前利润</strong>：使用当前价格 <code>p</code> 减去历史最低价格 <code>mp</code>，得到如果在今天卖出的最大可能利润。</li>
<li><strong>更新最大利润 (<code>ans</code>)</strong>：比较当前计算的利润和之前记录的最大利润，取较大者。</li>
<li><strong>更新最低价格 (<code>mp</code>)</strong>：检查当前价格 <code>p</code> 是否比记录的 <code>mp</code> 更低，如果是，则更新 <code>mp</code>，供未来的天数使用。</li>
</ul>
</li>
</ol>
<p>这种思想通常被称为“枚举右，维护左”：我们在遍历数组时，将当前元素视为右边界（卖出点），同时动态维护左侧的历史信息（最低买入点）。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化最大利润为 0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 初始化最低买入价格 mp (min_price) 为第一天的价格</span></span><br><span class="line">        mp = prices[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历每一天的价格 p</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="comment"># 尝试在今天卖出：</span></span><br><span class="line">            <span class="comment"># 计算当前价格 p 与历史最低价格 mp 的差值</span></span><br><span class="line">            <span class="comment"># 并更新全局最大利润 ans</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, p - mp)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新历史最低价格：</span></span><br><span class="line">            <span class="comment"># 如果当前价格 p 比 mp 更低，则将 mp 更新为 p</span></span><br><span class="line">            mp = <span class="built_in">min</span>(mp, p)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 边界条件处理（虽然题目提示长度 &gt;= 1，但这是一个好习惯）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(prices) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化最大利润为 0</span></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 初始化最低买入价格 mp (min_price) 为第一天的价格</span></span><br><span class="line">    mp := prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每一天的价格 p</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> prices &#123;</span><br><span class="line">        <span class="comment">// 尝试在今天卖出：</span></span><br><span class="line">        <span class="comment">// 如果 (当前价格 - 历史最低价) 大于当前记录的最大利润，则更新</span></span><br><span class="line">        <span class="keyword">if</span> p - mp &gt; ans &#123;</span><br><span class="line">            ans = p - mp</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新历史最低价格：</span></span><br><span class="line">        <span class="comment">// 如果当前价格 p 小于 历史最低价 mp，则更新 mp</span></span><br><span class="line">        <span class="keyword">if</span> p &lt; mp &#123;</span><br><span class="line">            mp = p</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>我们只需要遍历一次 <code>prices</code> 数组即可完成计算。</p>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(1)</code><br>只需要常数个变量 (<code>ans</code>, <code>mp</code>) 来存储中间状态，不需要额外的数组空间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>常用数据结构</category>
        <category>常用枚举技巧</category>
        <category>枚举右，维护左</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 624 | 数组列表中的最大距离</title>
    <url>//posts/leetcode-624/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 624 题：<a href="https://leetcode.cn/problems/maximum-distance-in-arrays/">数组列表中的最大距离</a>。<br>题目考察如何在多个有序数组中找到满足特定条件（来自不同数组）的最大差值。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定 <code>m</code> 个数组，每个数组都已经按照升序排好序了。</p>
<p>现在你需要从两个不同的数组中选择两个整数（每个数组选一个）并且计算它们的距离。两个整数 <code>a</code> 和 <code>b</code> 之间的距离定义为它们差的绝对值 <code>|a-b|</code> 。</p>
<p>返回最大距离。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5],[1,2,3]]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">一种得到答案 4 的方法是从第一个数组或者第三个数组中选择 1，同时从第二个数组中选择 5 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：arrays = [[1],[1]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == arrays.length</code></li>
<li><code>2 &lt;= m &lt;= 10^5</code></li>
<li><code>1 &lt;= arrays[i].length &lt;= 500</code></li>
<li><code>-10^4 &lt;= arrays[i][j] &lt;= 10^4</code></li>
<li><code>arrays[i]</code> 以 <strong>升序</strong> 排序。</li>
<li>所有数组中最多有 <code>10^5</code> 个整数。</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-暴力法的局限性"><a href="#1-暴力法的局限性" class="headerlink" title="1. 暴力法的局限性"></a>1. 暴力法的局限性</h4><p>题目要求从两个 <strong>不同</strong> 的数组中各取一个数，计算它们差值的绝对值。<br>最直观的做法是两层循环枚举所有的数组对，计算它们的最大值和最小值的差。<br>但由于数组数量 <code>m</code> 可达 <code>10^5</code>，<code>O(m^2)</code> 的时间复杂度会超时。</p>
<h4 id="2-贪心策略-一次遍历"><a href="#2-贪心策略-一次遍历" class="headerlink" title="2. 贪心策略 (一次遍历)"></a>2. 贪心策略 (一次遍历)</h4><p>由于每个数组都是 <strong>升序</strong> 排列的，对于任意一个数组，它的最小值一定是第一个元素，最大值一定是最后一个元素。<br>为了让 <code>|a - b|</code> 最大，我们需要尽可能让一个数大，另一个数小。</p>
<p>我们可以遍历每一个数组 <code>arrays[i]</code>，并维护在它 <strong>之前</strong> 所有数组中出现过的最小值 <code>mn</code> 和最大值 <code>mx</code>。<br>对于当前数组 <code>arrays[i]</code>，为了保证两个数来自不同的数组，我们可以计算以下两个距离：</p>
<ol>
<li>当前数组的最大值 <code>arrays[i][-1]</code> 减去之前所有数组的最小值 <code>mn</code>。</li>
<li>之前所有数组的最大值 <code>mx</code> 减去当前数组的最小值 <code>arrays[i][0]</code>。</li>
</ol>
<p>取这两个值的最大者更新最终答案 <code>ans</code>。<br>计算完成后，再将当前数组的最小值和最大值更新到 <code>mn</code> 和 <code>mx</code> 中，供后续数组使用。</p>
<p>这样，我们在遍历到第 <code>i</code> 个数组时，<code>mn</code> 和 <code>mx</code> 仅包含前 <code>i-1</code> 个数组的信息，从而保证了计算距离的两个数一定来自不同的数组。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>在 Python 代码中，通常利用无穷大 <code>inf</code> 来初始化。</li>
<li>在 Go 语言或其他逻辑中，通常可以直接取第一个数组作为初始的 <code>mn</code> 和 <code>mx</code>，然后从第二个数组开始遍历，效果是一样的。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDistance</span>(<span class="params">self, arrays: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 初始化最小值 mn 为正无穷，最大值 mx 为负无穷</span></span><br><span class="line">        <span class="comment"># 注意：这里假设环境中已经引入了 inf，或者使用 float(&#x27;inf&#x27;)</span></span><br><span class="line">        mn, mx = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> arrays:</span><br><span class="line">            <span class="comment"># 计算当前数组与之前遍历过的数组能构成的最大距离</span></span><br><span class="line">            <span class="comment"># 1. 当前数组的最大值 a[-1] - 之前的最小值 mn</span></span><br><span class="line">            <span class="comment"># 2. 之前的最大值 mx - 当前数组的最小值 a[0]</span></span><br><span class="line">            <span class="comment"># 注意：第一次循环时，由于 mn 是正无穷，mx 是负无穷，计算结果对 ans 无影响（ans 保持 0）</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, a[-<span class="number">1</span>] - mn, mx - a[<span class="number">0</span>])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新全局最小值 mn，比较当前数组的最小值 a[0]</span></span><br><span class="line">            mn = <span class="built_in">min</span>(mn, a[<span class="number">0</span>])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新全局最大值 mx，比较当前数组的最大值 a[-1]</span></span><br><span class="line">            mx = <span class="built_in">max</span>(mx, a[-<span class="number">1</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDistance</span><span class="params">(arrays [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 结果初始化为 0</span></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取第一个数组的最小值和最大值作为初始值</span></span><br><span class="line">    <span class="comment">// arrays[i] 是升序的，所以最小值在索引 0，最大值在索引 len-1</span></span><br><span class="line">    minVal := arrays[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    maxVal := arrays[<span class="number">0</span>][<span class="built_in">len</span>(arrays[<span class="number">0</span>])<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从第二个数组开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(arrays); i++ &#123;</span><br><span class="line">        curr := arrays[i]</span><br><span class="line">        currMin := curr[<span class="number">0</span>]</span><br><span class="line">        currMax := curr[<span class="built_in">len</span>(curr)<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算潜在的最大距离</span></span><br><span class="line">        <span class="comment">// 场景 1: 当前数组的最大值 - 之前所有数组的最小值</span></span><br><span class="line">        <span class="keyword">if</span> dist := currMax - minVal; dist &gt; ans &#123;</span><br><span class="line">            ans = dist</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 场景 2: 之前所有数组的最大值 - 当前数组的最小值</span></span><br><span class="line">        <span class="keyword">if</span> dist := maxVal - currMin; dist &gt; ans &#123;</span><br><span class="line">            ans = dist</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新全局最小值</span></span><br><span class="line">        <span class="keyword">if</span> currMin &lt; minVal &#123;</span><br><span class="line">            minVal = currMin</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新全局最大值</span></span><br><span class="line">        <span class="keyword">if</span> currMax &gt; maxVal &#123;</span><br><span class="line">            maxVal = currMax</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: <code>O(m)</code><br>其中 <code>m</code> 是数组的个数。我们只需要遍历 <code>arrays</code> 一次。每次迭代中的操作（比较、更新）都是 <code>O(1)</code> 的。</p>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(1)</code><br>我们只需要常数级别的额外空间来存储 <code>ans</code>, <code>mn</code>, <code>mx</code> 等变量。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>常用数据结构</category>
        <category>常用枚举技巧</category>
        <category>枚举右，维护左</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2342 | 数位和相等数对的最大和</title>
    <url>//posts/leetcode-2342/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2342 题：<a href="https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/">数位和相等数对的最大和</a>。<br>这是一道考察哈希表（或数组）应用以及“枚举右，维护左”思想的经典题目。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个下标从 0 开始的数组 <code>nums</code> ，数组中的元素都是 <strong>正</strong> 整数。请你选出两个下标 <code>i</code> 和 <code>j</code>（<code>i != j</code>），且 <code>nums[i]</code> 的数位和 与 <code>nums[j]</code> 的数位和相等。</p>
<p>请你找出所有满足条件的下标 <code>i</code> 和 <code>j</code> ，找出并返回 <code>nums[i] + nums[j]</code> 可以得到的 <strong>最大值</strong>。如果不存在这样的下标对，返回 -1。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [18,43,36,13,7]</span><br><span class="line">输出：54</span><br><span class="line">解释：满足条件的数对 (i, j) 为：</span><br><span class="line">- (0, 2) ，两个数字的数位和都是 9 ，相加得到 18 + 36 = 54 。</span><br><span class="line">- (1, 4) ，两个数字的数位和都是 7 ，相加得到 43 + 7 = 50 。</span><br><span class="line">所以可以获得的最大和是 54 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,12,19,14]</span><br><span class="line">输出：-1</span><br><span class="line">解释：不存在满足条件的数对，返回 -1 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</li>
<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-核心思想：枚举右，维护左"><a href="#1-核心思想：枚举右，维护左" class="headerlink" title="1. 核心思想：枚举右，维护左"></a>1. 核心思想：枚举右，维护左</h4><p>题目要求找到数位和相等的两个数，使它们的和最大。<br>我们可以遍历数组，对于当前遍历到的数字 <code>num</code>（我们把它看作是右边的数字），我们希望在之前遍历过的数字中（左边的数字），找到一个数位和与 <code>num</code> 相同的数字，并且这个数字尽可能大。</p>
<h4 id="2-数位和的计算与范围"><a href="#2-数位和的计算与范围" class="headerlink" title="2. 数位和的计算与范围"></a>2. 数位和的计算与范围</h4><p>首先，我们需要一个辅助逻辑来计算一个整数的数位和。<br>观察数据范围 <code>nums[i] &lt;= 10^9</code>。</p>
<ul>
<li>最大可能的数位和出现在 <code>999,999,999</code>，其和为 <code>9 * 9 = 81</code>。</li>
<li><code>1,000,000,000</code> 的数位和仅为 1。<br>因此，数位和的范围在 0 到 81 之间。这意味着我们可以使用一个长度为 82 的固定数组来代替哈希表，效率更高。</li>
</ul>
<h4 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h4><ol>
<li>初始化一个结果变量 <code>ans = -1</code>。</li>
<li>初始化一个长度为 82 的数组 <code>mx</code>，<code>mx[s]</code> 用于存储数位和为 <code>s</code> 的所有数字中，<strong>当前遇到的最大值</strong>。</li>
<li>遍历数组 <code>nums</code> 中的每个元素 <code>num</code>：<ul>
<li>计算 <code>num</code> 的数位和 <code>s</code>。</li>
<li>检查 <code>mx[s]</code> 是否非零：<ul>
<li>如果非零，说明之前已经遇到过数位和同为 <code>s</code> 的数字。此时，<code>mx[s]</code> 是之前遇到的最大的那个数。计算 <code>mx[s] + num</code> 并尝试更新全局最大和 <code>ans</code>。</li>
</ul>
</li>
<li>更新 <code>mx[s]</code>：我们需要维护该数位和下的最大值，以便后续的数字能匹配到最大的“另一半”。即 <code>mx[s] = max(mx[s], num)</code>。</li>
</ul>
</li>
<li>返回 <code>ans</code>。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 数据范围最大为 10^9，最大数位和为 999,999,999 的数位和 81</span></span><br><span class="line">        <span class="comment"># 所以开辟大小为 82 的数组即可代替哈希表</span></span><br><span class="line">        mx = [<span class="number">0</span>] * <span class="number">82</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 计算当前数字的数位和</span></span><br><span class="line">            s = <span class="number">0</span></span><br><span class="line">            x = num</span><br><span class="line">            <span class="keyword">while</span> x:</span><br><span class="line">                s += x % <span class="number">10</span></span><br><span class="line">                x //= <span class="number">10</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果之前已经出现过数位和为 s 的数字</span></span><br><span class="line">            <span class="comment"># mx[s] 存储的是之前遍历过的数位和为 s 的最大值</span></span><br><span class="line">            <span class="keyword">if</span> mx[s]:</span><br><span class="line">                <span class="comment"># 尝试更新最大数对和</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, mx[s] + num)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 维护数位和为 s 的最大值</span></span><br><span class="line">            <span class="comment"># 这样保证了后续匹配时，取到的一定是当前最大的配对数</span></span><br><span class="line">            mx[s] = <span class="built_in">max</span>(mx[s], num)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="number">-1</span></span><br><span class="line">    <span class="comment">// 数据范围最大为 10^9，最大数位和为 81</span></span><br><span class="line">    <span class="comment">// 使用数组作为哈希表，索引为数位和，值为拥有该数位和的最大数字</span></span><br><span class="line">    mx := [<span class="number">82</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 计算当前数字的数位和</span></span><br><span class="line">        s := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x := num; x &gt; <span class="number">0</span>; x /= <span class="number">10</span> &#123;</span><br><span class="line">            s += x % <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 mx[s] &gt; 0，说明之前遇到过数位和为 s 的数字</span></span><br><span class="line">        <span class="keyword">if</span> mx[s] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 计算当前数字与之前遇到的最大数字之和，并更新答案</span></span><br><span class="line">            ans = max(ans, mx[s] + num)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新数位和为 s 的最大值</span></span><br><span class="line">        <span class="comment">// 确保后续如果有数字也为数位和 s，能匹配到目前为止最大的数字</span></span><br><span class="line">        mx[s] = max(mx[s], num)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：返回两个数中的较大值</span></span><br><span class="line"><span class="comment">// 注意：Go 1.21+ 内置了 max 函数，如果使用旧版本需自行实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: O(N * log M)，其中 N 是数组的长度，M 是数组中元素的最大值（本题中为 10^9）。</p>
<ul>
<li>我们需要遍历数组一次。</li>
<li>对于每个数字，计算数位和的时间与数字的位数成正比，即 log10(M)。</li>
<li>因为 log10(10^9) ≈ 9，是一个很小的常数，所以整体可以看作 O(N)。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>: O(D)，其中 D 是可能的数位和的最大种类数。</p>
<ul>
<li>本题中最大数位和为 81，所以空间复杂度为 O(1)（固定大小的数组）。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>常用数据结构</category>
        <category>常用枚举技巧</category>
        <category>枚举右，维护左</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
        <tag>排序</tag>
        <tag>堆（优先队列）</tag>
        <tag>第302场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1128 | 等价多米诺骨牌对的数量</title>
    <url>//posts/leetcode-1128/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1128 题：<a href="https://leetcode.cn/problems/number-of-equivalent-domino-pairs/">等价多米诺骨牌对的数量</a>。<br>题目核心在于如何对无序对进行“标准化”处理。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一组多米诺骨牌 <code>dominoes</code> 。</p>
<p>形式上，<code>dominoes[i] = [a, b]</code> 与 <code>dominoes[j] = [c, d]</code> <strong>等价</strong> 当且仅当 <code>(a == c 且 b == d)</code> 或者 <code>(a == d 且 b == c)</code> 。即一张骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌。</p>
<p>在 <code>0 &lt;= i &lt; j &lt; dominoes.length</code> 的前提下，找出满足 <code>dominoes[i]</code> 和 <code>dominoes[j]</code> 等价的骨牌对 <code>(i, j)</code> 的数量。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：dominoes = [[1,2],[2,1],[3,4],[5,6]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; dominoes.length &lt;&#x3D; 4 * 10^4</li>
<li>dominoes[i].length &#x3D;&#x3D; 2</li>
<li>1 &lt;&#x3D; dominoes[i][j] &lt;&#x3D; 9</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-问题的核心：标准化"><a href="#1-问题的核心：标准化" class="headerlink" title="1. 问题的核心：标准化"></a>1. 问题的核心：标准化</h4><p>题目中定义的“等价”是指两个二元组的元素相同，不考虑顺序。例如 <code>[1, 2]</code> 和 <code>[2, 1]</code> 是等价的。<br>为了能够使用哈希表或者数组来统计数量，我们需要将这种“无序”的特征转化为“有序”或者“标准”的形式。<br>最简单的方法是对每一个骨牌 <code>[a, b]</code> 进行排序。无论输入是 <code>[1, 2]</code> 还是 <code>[2, 1]</code>，排序后都会变成 <code>(1, 2)</code>。这样，所有等价的骨牌都会拥有相同的键值。</p>
<h4 id="2-枚举右，维护左（一次遍历）"><a href="#2-枚举右，维护左（一次遍历）" class="headerlink" title="2. 枚举右，维护左（一次遍历）"></a>2. 枚举右，维护左（一次遍历）</h4><p>最朴素的做法是两层循环枚举所有的 <code>(i, j)</code> 对，时间复杂度是 O(n^2)，这在数据量达到 4 * 10^4 时会超时。<br>我们可以利用哈希表进行一次遍历优化：</p>
<ol>
<li>创建一个哈希表 <code>cnt</code> 用来记录每种（标准化后的）骨牌出现的次数。</li>
<li>遍历每一个骨牌 <code>d</code>。</li>
<li>首先对 <code>d</code> 进行标准化（排序）。</li>
<li>查询哈希表，看这个标准化的骨牌之前出现过几次。假设之前出现了 <code>k</code> 次，那么当前这块骨牌可以和之前的 <code>k</code> 块骨牌分别组成一个等价对，所以将答案加上 <code>k</code>。</li>
<li>将当前骨牌的计数加 1，存入哈希表，供后续骨牌匹配。</li>
</ol>
<p>这种方法只需要遍历一次数组，效率非常高。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="tabs" id="code_block"><ul class="nav-tabs"><li class="tab active"><a href="#code_block-1">Python</a></li><li class="tab"><a href="#code_block-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_block-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numEquivDominoPairs</span>(<span class="params">self, dominoes: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化答案计数器</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 创建一个哈希表用于存储 &#123;标准化后的骨牌: 出现次数&#125;</span></span><br><span class="line">        <span class="comment"># 使用 defaultdict(int) 可以省去检查 key 是否存在的步骤，默认值为 0</span></span><br><span class="line">        cnt = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历每一个骨牌</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> dominoes:</span><br><span class="line">            <span class="comment"># 标准化：将骨牌内的两个数字排序，并转为元组</span></span><br><span class="line">            <span class="comment"># 转为元组是因为列表是不可哈希的，不能作为字典的 key</span></span><br><span class="line">            <span class="comment"># 例如 [2, 1] 和 [1, 2] 都会变成 (1, 2)</span></span><br><span class="line">            d = <span class="built_in">tuple</span>(<span class="built_in">sorted</span>(d))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当前骨牌可以与之前出现过的 cnt[d] 个同类骨牌组成对</span></span><br><span class="line">            <span class="comment"># 将这些对的数量累加到答案中</span></span><br><span class="line">            ans += cnt[d]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新哈希表，记录当前这种骨牌出现的次数加 1</span></span><br><span class="line">            cnt[d] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code_block-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numEquivDominoPairs</span><span class="params">(dominoes [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化答案</span></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 创建哈希表，key 为长度为 2 的数组（在 Go 中数组可以作为 map 的 key），value 为出现次数</span></span><br><span class="line">    <span class="comment">// [2]int 代表标准化后的骨牌</span></span><br><span class="line">    cnt := <span class="keyword">map</span>[[<span class="number">2</span>]<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历每一个骨牌</span></span><br><span class="line">    <span class="keyword">for</span> _, d := <span class="keyword">range</span> dominoes &#123;</span><br><span class="line">        <span class="comment">// 获取两个数字</span></span><br><span class="line">        a, b := d[<span class="number">0</span>], d[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标准化：确保 a &lt;= b</span></span><br><span class="line">        <span class="comment">// 这样 [1, 2] 和 [2, 1] 都会变成 [1, 2]</span></span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            a, b = b, a</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构造 key</span></span><br><span class="line">        key := [<span class="number">2</span>]<span class="type">int</span>&#123;a, b&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果该 key 存在于 map 中，cnt[key] 就是之前出现的次数</span></span><br><span class="line">        <span class="comment">// 当前骨牌可以与之前每一个相同的骨牌形成一对</span></span><br><span class="line">        ans += cnt[key]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新哈希表中该骨牌的计数</span></span><br><span class="line">        cnt[key]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: <code>O(n)</code><br>其中 <code>n</code> 是 <code>dominoes</code> 的长度。我们只需要遍历一次数组，每次遍历中的排序和哈希表操作都是常数时间 <code>O(1)</code>（因为骨牌只包含 2 个数字）。</p>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(1)</code> (基于题目约束)<br>虽然我们使用了哈希表，但根据题目提示 <code>1 &lt;= dominoes[i][j] &lt;= 9</code>，骨牌的组合情况非常有限。可能的组合只有 <code>(1,1), (1,2)...(9,9)</code> 等几十种情况。因此，哈希表的大小有一个很小的上限（最多 45 种组合），可以视为常数空间 <code>O(1)</code>。如果不考虑数值范围限制，空间复杂度为 <code>O(n)</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>常用数据结构</category>
        <category>常用枚举技巧</category>
        <category>枚举右，维护左</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
        <tag>计数</tag>
        <tag>第146场周赛</tag>
      </tags>
  </entry>
</search>
