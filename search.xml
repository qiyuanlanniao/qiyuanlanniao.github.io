<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode 1011 | 在 D 天内送达包裹的能力</title>
    <url>//posts/leetcode-1011/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1011 题：<a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/description/">在 D 天内送达包裹的能力</a>。<br>本题的核心在于识别出答案的单调性，并将一个求解最优值的问题，巧妙地转化为一个判定性的问题，从而利用二分查找在对数时间内高效求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要找到一艘船的最低运载能力，这艘船需要把传送带上的一系列包裹，在指定的天数 <code>days</code> 内，从一个港口运送到另一个港口。</p>
<p>这里的核心约束条件是：</p>
<ol>
<li>包裹必须按照 <code>weights</code> 数组给出的顺序装运，不能打乱。</li>
<li>每天装载的包裹总重量不能超过船的运载能力。</li>
<li>必须在 <code>days</code> 天（含）之内完成所有包裹的运输。</li>
</ol>
<p>我们的目标是找出满足这些条件的<strong>最低</strong>运载能力。</p>
<p>举个例子，<code>weights = [1,2,3,4,5,6,7,8,9,10]</code>, <code>days = 5</code>。<br>如果船的运载能力是 10，我们需要的天数会超过 5 天。而如果运载能力是 55（所有包裹总和），我们只需要 1 天就能运完。这暗示了运载能力和所需天数之间存在一种反比关系：运载能力越大，所需天数越少。</p>
<p>我们的任务就是在所有可行的运载能力中，找到那个最小的值。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最低运载能力”似乎很困难。一个更直接的想法是：如果我们<strong>假定</strong>一个运载能力 <code>c</code>，我们能否判断出这个能力是否足够在 <code>days</code> 天内运完所有货物？</p>
<p>这个判定问题就简单多了。我们可以写一个辅助函数 <code>canShip(capacity)</code>，贪心地模拟装载过程：</p>
<ul>
<li>初始化天数 <code>d = 1</code>，当前船上已装载重量 <code>current_weight = 0</code>。</li>
<li>按顺序遍历 <code>weights</code> 数组中的每个包裹：<ul>
<li>如果 <code>current_weight</code> 加上当前包裹的重量 <code>w</code> 不超过 <code>capacity</code>，则继续装载，<code>current_weight += w</code>。</li>
<li>否则，说明今天装不下了，需要新的一天。我们让天数 <code>d</code> 增加 1，然后将当前包裹装上新船，<code>current_weight = w</code>。</li>
</ul>
</li>
<li>遍历结束后，得到的 <code>d</code> 就是在运载能力为 <code>capacity</code> 时，运完所有货物所需的最少天数。</li>
<li>最后，我们比较这个 <code>d</code> 和题目给定的 <code>days</code>。如果 <code>d &lt;= days</code>，说明 <code>capacity</code> 是一个可行的运载能力。</li>
</ul>
<p>现在，我们有了一个判定的方法。观察可以发现，这个判定结果具有<strong>单调性</strong>：</p>
<ul>
<li>如果一个运载能力 <code>c</code> 可以在 <code>days</code> 天内完成任务，那么任何大于 <code>c</code> 的运载能力 <code>c&#39;</code> 也一定可以完成。</li>
<li>反之，如果 <code>c</code> 无法完成，任何小于 <code>c</code> 的能力也必然无法完成。</li>
</ul>
<p>这种单调性是应用二分查找的完美信号。 我们可以对“运载能力”这个值进行二分查找，来快速定位到那个“最低可行”的临界点。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：船的运载能力至少要能装下最重的那一个包裹，所以下界是 <code>max(weights)</code>。</li>
<li><strong>上界 (right)</strong>：在最极端的情况下，我们可以用一天把所有包裹都运走，此时需要的运载能力是所有包裹的重量之和，即 <code>sum(weights)</code>。</li>
</ul>
<p>因此，我们就在 <code>[max(weights), sum(weights)]</code> 这个区间内，对运载能力进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = max(weights)</code>：这是可能的最低运载能力。</li>
<li><code>right = sum(weights)</code>：这是可能的最高运载能力。</li>
<li><code>ans</code> 初始化为 <code>right</code>，用来记录我们找到的可行解。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>left &lt;= right</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = left + (right - left) // 2</code> 作为当前的“猜测运载能力”。</li>
<li>调用辅助函数 <code>canShip(mid)</code> 来判定这个猜测值是否可行。<ul>
<li><strong>如果 <code>canShip(mid)</code> 返回 <code>True</code></strong> (即 <code>mid</code> 这个运载能力可以在 <code>days</code> 天内运完)：<ul>
<li>说明 <code>mid</code> 是一个潜在的答案，我们记录下来 <code>ans = mid</code>。</li>
<li>但是我们想找的是“最低”运载能力，所以我们尝试一个更小的值，将搜索范围缩小到左半边：<code>right = mid - 1</code>。</li>
</ul>
</li>
<li><strong>如果 <code>canShip(mid)</code> 返回 <code>False</code></strong> (即 <code>mid</code> 这个运载能力不够)：<ul>
<li>说明我们需要更大的运载能力，将搜索范围缩小到右半边：<code>left = mid + 1</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>ans</code> 中存储的就是满足条件的最低运载能力。在我们的实现中，最后返回 <code>left</code> 也是等价的。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shipWithinDays</span>(<span class="params">self, weights: <span class="type">List</span>[<span class="built_in">int</span>], days: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 确定二分查找的左右边界</span></span><br><span class="line">        <span class="comment"># 运载能力的下限是单个包裹的最大重量</span></span><br><span class="line">        left = <span class="built_in">max</span>(weights)</span><br><span class="line">        <span class="comment"># 运载能力的上限是所有包裹的总重量</span></span><br><span class="line">        right = <span class="built_in">sum</span>(weights)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 辅助函数：检查在给定的运载能力 capacity 下，能否在 days 天内运完</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">can_ship</span>(<span class="params">capacity: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            days_needed = <span class="number">1</span></span><br><span class="line">            current_weight = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> weights:</span><br><span class="line">                <span class="keyword">if</span> current_weight + w &gt; capacity:</span><br><span class="line">                    <span class="comment"># 当前船装不下了，需要新的一天</span></span><br><span class="line">                    days_needed += <span class="number">1</span></span><br><span class="line">                    current_weight = w</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 继续装货</span></span><br><span class="line">                    current_weight += w</span><br><span class="line">            <span class="keyword">return</span> days_needed &lt;= days</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> can_ship(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 可行，说明它可能就是答案，</span></span><br><span class="line">                <span class="comment"># 或者还有更小的可行值，所以我们尝试在左半部分继续寻找</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 不可行，说明运载能力太小，</span></span><br><span class="line">                <span class="comment"># 必须增大，所以去右半部分寻找</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时，left 就是满足条件的最低运载能力</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N * log(S))。<ul>
<li><code>N</code> 是包裹数组 <code>weights</code> 的长度。</li>
<li><code>S</code> 是 <code>sum(weights) - max(weights)</code>，即二分查找的搜索空间大小。</li>
<li>二分查找本身需要 <code>log(S)</code> 次迭代。</li>
<li>在每次迭代中，我们都需要调用 <code>can_ship</code> 函数，该函数需要遍历一次 <code>weights</code> 数组，时间复杂度为 O(N)。</li>
<li>因此，总时间复杂度是这两者的乘积。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)。<ul>
<li>除了输入数组外，我们只使用了几个变量来存储左右边界、中间值和模拟过程中的状态，所以空间复杂度是常数级的。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是二分查找思想应用的经典范例。它教会我们当遇到求解“最小值中的最大值”或者“最大值中的最小值”这类问题时，可以尝试将其转化为一个更简单的“判定性”问题。如果这个判定问题具有单调性，那么就可以利用二分查找，将搜索范围不断折半，从而在对数级别的时间复杂度内找到最优解，这比线性扫描所有可能的答案要高效得多。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最小</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>第128场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1016 | 滑动窗口巧解二进制子串问题</title>
    <url>//posts/leetcode-1016/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1016 题：<a href="https://leetcode.cn/problems/binary-string-with-substrings-representing-1-to-n/description/">子串能表示从 1 到 N 数字的二进制串</a>。<br>这道题巧妙地将字符串子串搜索与数字的二进制表示结合起来，考验我们能否从不同的角度思考问题。虽然存在更直接的解法，但我们同样可以用“滑动窗口”的思想来解决它，从而更深刻地理解其应用范式。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们来仔细分析一下题目：给定一个二进制字符串 <code>s</code> 和一个正整数 <code>n</code>，我们需要判断<strong>从 1 到 n 的每一个整数</strong>，其对应的二进制表示形式是否都是 <code>s</code> 的一个<strong>子字符串</strong>。</p>
<ul>
<li><strong>二进制表示</strong>：这里指的是标准的二进制转换，例如整数 <code>3</code> 对应字符串 <code>&quot;11&quot;</code>。</li>
<li><strong>子字符串</strong>：必须是原字符串中<strong>连续</strong>的字符序列。</li>
</ul>
<p>例如，<code>s = &quot;0110&quot;</code>, <code>n = 3</code>。我们需要检查 <code>1</code>, <code>2</code>, <code>3</code>：</p>
<ul>
<li>整数 <code>1</code> 的二进制是 <code>&quot;1&quot;</code>，它是 <code>s</code> 的子串。</li>
<li>整数 <code>2</code> 的二进制是 <code>&quot;10&quot;</code>，它是 <code>s</code> 的子串。</li>
<li>整数 <code>3</code> 的二进制是 <code>&quot;11&quot;</code>，它是 <code>s</code> 的子串。<br>因为 <code>1</code> 到 <code>3</code> 都满足条件，所以最终返回 <code>true</code>。</li>
</ul>
<p>如果 <code>n = 4</code>，由于 <code>4</code> 的二进制是 <code>&quot;100&quot;</code>，在 <code>s</code> 中找不到，因此应返回 <code>false</code>。</p>
<h3 id="核心思路：转化问题"><a href="#核心思路：转化问题" class="headerlink" title="核心思路：转化问题"></a>核心思路：转化问题</h3><h4 id="常规思路-vs-滑动窗口思路"><a href="#常规思路-vs-滑动窗口思路" class="headerlink" title="常规思路 vs 滑动窗口思路"></a>常规思路 vs 滑动窗口思路</h4><p>一个非常直接的想法是：从 <code>n</code> 开始倒序遍历到 <code>1</code>，对每个数字 <code>i</code>，将其转换为二进制字符串，然后检查这个二进制串是否存在于 <code>s</code> 中。只要有一个数字不满足，就立刻返回 <code>false</code>。这种方法通常是最高效的。</p>
<p>然而，为了探索“滑动窗口”的应用，我们可以<strong>逆向思考</strong>这个问题：我们不去检查 <code>1</code> 到 <code>n</code> 是否在 <code>s</code> 里，而是<strong>从 <code>s</code> 中提取出所有可能的二进制子串，将它们转换为数字，看看这些数字是否完整地覆盖了 <code>1</code> 到 <code>n</code> 的集合</strong>。</p>
<p>这个“生成并检查”的策略，就是滑动窗口思想的一种体现。这里的“窗口”不再是固定的长度，而是所有可能的长度。</p>
<h4 id="滑动窗口登场"><a href="#滑动窗口登场" class="headerlink" title="滑动窗口登场"></a>滑动窗口登场</h4><p>这个思路的实现步骤如下：</p>
<ol>
<li>创建一个<strong>哈希集合（Set）</strong>，用来存放我们在 <code>s</code> 中找到的、且在 <code>[1, n]</code> 范围内的所有数字。集合可以自动处理重复值。</li>
<li>遍历所有可能的子串长度，作为我们滑动窗口的<strong>大小</strong>。</li>
<li>对于每一个确定的窗口大小，我们在 <code>s</code> 上从左到右滑动这个窗口。</li>
<li>在每次滑动中，提取窗口内的子串，将其从二进制转换为十进制数。</li>
<li>如果这个数字在 <code>[1, n]</code> 的范围内，就将其加入哈希集合。</li>
<li>当所有长度、所有位置的窗口都检查完毕后，我们最后判断集合的大小是否等于 <code>n</code>。如果等于，说明 <code>1</code> 到 <code>n</code> 都被找到了。</li>
</ol>
<h3 id="滑动窗口算法详解"><a href="#滑动窗口算法详解" class="headerlink" title="滑动窗口算法详解"></a>滑动窗口算法详解</h3><ol>
<li><p><strong>准备工作</strong>:</p>
<ul>
<li>创建一个空的哈希集合 <code>found_numbers</code>，用于存储找到的有效数字。</li>
</ul>
</li>
<li><p><strong>确定窗口范围</strong>:</p>
<ul>
<li>我们的窗口大小（即子串长度 <code>length</code>）可以从 <code>1</code> 变化到 <code>s</code> 的总长度 <code>len(s)</code>。</li>
<li><strong>优化</strong>：我们可以加入一些剪枝逻辑。例如，如果一个长度为 <code>length</code> 的二进制数（其最小值是 <code>2^(length-1)</code>）已经大于 <code>n</code>，那么更长的子串代表的数字必然也大于 <code>n</code>，后续的长度遍历就可以提前终止。</li>
</ul>
</li>
<li><p><strong>滑动与生成</strong>:</p>
<ul>
<li>外层循环遍历窗口大小 <code>length</code>，从 <code>1</code> 到 <code>len(s)</code>。</li>
<li>内层循环是真正的滑动窗口，遍历窗口的起始位置 <code>i</code>，从 <code>0</code> 到 <code>len(s) - length</code>。</li>
<li><strong>提取与转换</strong>：获取子串 <code>s[i : i+length]</code>。</li>
<li><strong>有效性判断</strong>：将子串转换为数字 <code>num</code>。注意，<code>int(&quot;011&quot;, 2)</code> 会正确得到 <code>3</code>，所以我们不需要手动处理前导零，但可以做一个小优化：如果子串以 <code>&#39;0&#39;</code> 开头，可以跳过，因为它不会是任何正整数的标准二进制表示。</li>
<li><strong>记录结果</strong>：如果 <code>1 &lt;= num &lt;= n</code>，则将 <code>num</code> 添加到 <code>found_numbers</code> 集合中。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>:</p>
<ul>
<li>所有循环结束后，检查 <code>len(found_numbers)</code> 是否等于 <code>n</code>。如果相等，返回 <code>True</code>；否则返回 <code>False</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">queryString</span>(<span class="params">self, s: <span class="built_in">str</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1：准备工作</span></span><br><span class="line">        found_numbers = <span class="built_in">set</span>()</span><br><span class="line">        s_len = <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2 &amp; 3：遍历不同大小的窗口并滑动</span></span><br><span class="line">        <span class="comment"># 外层循环：确定窗口大小 length</span></span><br><span class="line">        <span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, s_len + <span class="number">1</span>):</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 优化：如果当前长度的最小可能值都大于n，则无需继续</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (length - <span class="number">1</span>)) &gt; n:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 内层循环：滑动窗口</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s_len - length + <span class="number">1</span>):</span><br><span class="line">                substring = s[i : i + length]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 优化：非&quot;0&quot;的数字，其标准二进制表示不以&#x27;0&#x27;开头</span></span><br><span class="line">                <span class="keyword">if</span> substring[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 转换并检查数字</span></span><br><span class="line">                num = <span class="built_in">int</span>(substring, <span class="number">2</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> num &gt; n:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 记录在[1, n]范围内的数字</span></span><br><span class="line">                <span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                    found_numbers.add(num)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 4：返回最终结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(found_numbers) == n</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(L²)。其中 L 是字符串 <code>s</code> 的长度。我们有两层循环来生成所有子串，子串数量级为 O(L²)。将一个长度为 <code>k</code> 的二进制串转换为整数的时间大致为 O(k)。由于 <code>k</code> 最大为 <code>L</code>，总时间复杂度近似为 O(L³)。不过，因为 <code>k</code> 的平均长度远小于 <code>L</code>，且有剪枝，实际运行速度会更快。</li>
<li><strong>空间复杂度</strong>: O(N)。在最坏的情况下，哈希集合 <code>found_numbers</code> 需要存储从 <code>1</code> 到 <code>n</code> 的所有 <code>n</code> 个数字。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题提供了一个独特的视角，让我们看到滑动窗口不仅可以用于寻找满足特定<strong>性质</strong>的子串（如字符频率），还可以用于<strong>生成</strong>所有子串来进行检查。</p>
<p>尽管从 <code>n</code> 向 <code>1</code> 遍历的直接解法在性能上通常更优，但通过本题的“滑动窗口”解法，我们锻炼了逆向思维和问题转化的能力。在算法学习中，能够从多个角度分析和解决同一个问题，是提升能力的关键一步。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>位运算</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>第 129 场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1040 | SW脑筋急转弯求解“移动石子直到连续 II”</title>
    <url>//posts/leetcode-1040/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1040 题：<a href="https://leetcode.cn/problems/moving-stones-until-consecutive-ii/description/">移动石子直到连续 II</a>。<br>该题要求我们计算将一组分散的石子移动成连续序列所需的最小和最大步数。最大步数是一个有趣的数学问题，而最小步数则巧妙地伪装成了一个滑动窗口问题，并带有一个需要细心处理的“陷阱”。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们 X 轴上一些不同位置的石子，要求我们通过一系列移动，将它们变成连续的。移动规则如下：</p>
<ol>
<li>只能移动位于<strong>最小</strong>或<strong>最大</strong>位置的<strong>端点石子</strong>。</li>
<li>必须将它移动到一个<strong>未被占用</strong>的位置。</li>
<li>移动后，该石子<strong>不能</strong>成为新的端点石子。这意味着它必须被放置在其他两个石子之间。</li>
</ol>
<p>游戏在所有石子位置连续时结束。我们需要返回一个数组 <code>[最小移动次数, 最大移动次数]</code>。</p>
<p>例如，对于 <code>stones = [7,4,9]</code>，排序后是 <code>[4, 7, 9]</code>。</p>
<ul>
<li><strong>最大移动</strong>：可以先将 <code>4</code> 移动到 <code>6</code>，得到 <code>[6, 7, 9]</code>；再将 <code>9</code> 移动到 <code>8</code>，得到 <code>[6, 7, 8]</code>。共 2 步。</li>
<li><strong>最小移动</strong>：可以将 <code>4</code> 移动到 <code>8</code>，直接得到 <code>[7, 8, 9]</code>。只需 1 步。<br>所以答案是 <code>[1, 2]</code>。</li>
</ul>
<h3 id="核心思路：最大和最小分开击破"><a href="#核心思路：最大和最小分开击破" class="headerlink" title="核心思路：最大和最小分开击破"></a>核心思路：最大和最小分开击破</h3><p>这类要求两个极值的题目，通常可以将最大值和最小值的求解策略分开考虑。</p>
<h4 id="最大移动次数：贪心思想"><a href="#最大移动次数：贪心思想" class="headerlink" title="最大移动次数：贪心思想"></a>最大移动次数：贪心思想</h4><p>要让移动次数最多，我们应该“小步慢走”，每次只填补一个最小的空位，从而为后续移动保留最大的空间。</p>
<ol>
<li><strong>排序</strong>：首先将石子位置 <code>stones</code> 排序。</li>
<li><strong>总空位数</strong>：石子占据的总区间长度是 <code>stones[n-1] - stones[0] + 1</code>。其中有 <code>n</code> 个石子，所以总的空位数是 <code>(stones[n-1] - stones[0] + 1) - n</code>。</li>
<li><strong>贪心策略</strong>：每次移动，我们都会放弃一端的空间。为了保留最大的可操作空间，我们应该总是从<strong>间隙更小</strong>的那一端移动端点石子。例如，如果 <code>stones[1] - stones[0]</code> 比 <code>stones[n-1] - stones[n-2]</code> 小，我们就应该先移动 <code>stones[0]</code>，把 <code>stones[1]</code> 作为新的左端点。</li>
<li><strong>简化公式</strong>：这个过程最终可以简化成一个优美的数学公式。最大移动次数等于<strong>总空位数</strong>减去<strong>两端中较小的那个空隙</strong>。<ul>
<li><code>max_moves = (总空位数) - min(左端空隙, 右端空隙)</code></li>
<li>左端空隙 &#x3D; <code>stones[1] - stones[0] - 1</code></li>
<li>右端空隙 &#x3D; <code>stones[n-1] - stones[n-2] - 1</code></li>
<li>代入化简后可得：<code>max_moves = max(stones[n-1] - stones[1] - n + 2, stones[n-2] - stones[0] - n + 2)</code></li>
</ul>
</li>
</ol>
<h4 id="最小移动次数：滑动窗口"><a href="#最小移动次数：滑动窗口" class="headerlink" title="最小移动次数：滑动窗口"></a>最小移动次数：滑动窗口</h4><p>要让移动次数最少，我们应该尽可能多地保留原地不动的石子。最终，所有石子会占据一个长度为 <code>n</code> 的连续区间。我们的目标就是找到这样一个目标区间，它能容纳最多的原始石子。</p>
<p>这个问题可以转化为：<strong>用一个长度为 <code>n</code> 的尺子（窗口），在数轴上滑动，找到它能覆盖的最多石子数</strong>。</p>
<p>假设我们找到了这个最大可覆盖数 <code>max_coverage</code>。那么，需要移动的石子数就是 <code>n - max_coverage</code>。这就是最小移动次数的基本思路。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><strong>排序</strong>：对 <code>stones</code> 数组进行升序排序。</li>
<li><strong>计算 <code>max_moves</code></strong>：直接套用上面推导出的公式。</li>
<li><strong>计算 <code>min_moves</code></strong>：<ul>
<li>使用一个滑动窗口 <code>[j, i]</code> 遍历排序后的 <code>stones</code> 数组。</li>
<li>对于每个右端点 <code>i</code>，我们向右移动左端点 <code>j</code>，直到窗口代表的区间长度 <code>stones[i] - stones[j] + 1</code> 不超过 <code>n</code>。</li>
<li>此时，窗口 <code>[j, i]</code> 内的石子数是 <code>i - j + 1</code>，这些是可以被一个长度为 <code>n</code> 的最终序列容纳的。我们记录这个数量的最大值 <code>max_coverage</code>。</li>
<li>基本的 <code>min_moves</code> 就是 <code>n - max_coverage</code>。</li>
</ul>
</li>
<li><strong>处理 <code>min_moves</code> 的特殊情况</strong>：<ul>
<li>考虑一种情况：<code>stones = [2,3,4,5,10]</code> (<code>n=5</code>)。我们的滑动窗口会找到 <code>[2,3,4,5]</code> 这 4 个石子，<code>max_coverage = 4</code>，得出 <code>min_moves = 1</code>。</li>
<li>但问题是，我们能一步完成吗？目标是 <code>[2,3,4,5,6]</code>。我们需要移动 <code>10</code> 到 <code>6</code>。移动后，石子 <code>10</code> 位于 <code>6</code>，成为新的最大端点，这违反了规则 “移动后不能是端点石子”。</li>
<li>因此，我们不能直接移动 <code>10</code>。我们必须移动 <code>2</code> 或 <code>5</code>，比如把 <code>5</code> 移动到 <code>6</code>，得到 <code>[2,3,4,6,10]</code>。这之后还需要移动 <code>10</code>，总共需要 2 步。</li>
<li>这个<strong>特殊情况</strong>发生在：当 <code>max_coverage = n-1</code> 且这 <code>n-1</code> 个石子本身是<strong>紧密连续</strong>的，同时那个唯一的“局外石”与这个连续块的距离<strong>大于1</strong>时，最小移动次数是 <strong>2</strong>。</li>
<li>我们可以通过检查排序后数组的两端是否存在这种情况来判断。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numMovesStonesII</span>(<span class="params">self, stones: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stones.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(stones)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算最大移动次数</span></span><br><span class="line">        max_moves = <span class="built_in">max</span>(stones[n-<span class="number">1</span>] - stones[<span class="number">1</span>] - n + <span class="number">2</span>, stones[n-<span class="number">2</span>] - stones[<span class="number">0</span>] - n + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用滑动窗口计算最小移动次数</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        max_coverage = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 保证窗口 `[j, i]` 内的石子可以被一个长度为 n 的尺子覆盖</span></span><br><span class="line">            <span class="keyword">while</span> stones[i] - stones[j] + <span class="number">1</span> &gt; n:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            max_coverage = <span class="built_in">max</span>(max_coverage, i - j + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        min_moves = n - max_coverage</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理特殊情况：n-1个石子连续，且 outlier 距离 &gt; 1</span></span><br><span class="line">        <span class="comment"># 例如 [2,3,4,5,10] (n=5), stones[3]-stones[0]=3 (n-2), stones[4]-stones[3]=5 (&gt;2)</span></span><br><span class="line">        is_consecutive_at_start = (stones[n-<span class="number">2</span>] - stones[<span class="number">0</span>] == n - <span class="number">2</span>)</span><br><span class="line">        is_consecutive_at_end = (stones[n-<span class="number">1</span>] - stones[<span class="number">1</span>] == n - <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (is_consecutive_at_start <span class="keyword">and</span> stones[n-<span class="number">1</span>] - stones[n-<span class="number">2</span>] &gt; <span class="number">2</span>) <span class="keyword">or</span> \</span><br><span class="line">           (is_consecutive_at_end <span class="keyword">and</span> stones[<span class="number">1</span>] - stones[<span class="number">0</span>] &gt; <span class="number">2</span>):</span><br><span class="line">            min_moves = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [min_moves, max_moves]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N log N)。主要开销来自于初始的排序。后续的滑动窗口和计算都是 O(N)。</li>
<li><strong>空间复杂度</strong>: O(1) 或 O(N)，取决于排序算法使用的空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是数学思维和经典算法模型的结合。最大移动次数可以通过分析移动过程中的“状态保持”推导出贪心策略和数学公式。最小移动次数则是一个典型的“最大化保留&#x2F;覆盖”问题，可以优雅地用滑动窗口解决。解题的关键在于不仅要想到滑动窗口模型，还要根据题目独特的移动限制，识别并正确处理那个导致答案从 1 变为 2 的特殊情况。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
        <tag>数学</tag>
        <tag>排序</tag>
        <tag>第135场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1146 | 二分查找实现“快照数组”</title>
    <url>//posts/leetcode-1146/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1146 题：<a href="https://leetcode.cn/problems/snapshot-array/">快照数组</a>。<br>通过为每个数组索引维护一个历史记录列表，并利用二分查找，我们可以在 O(log K) 的时间内高效地获取任意历史快照中的值。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>这道题要求我们设计一个名为 <code>SnapshotArray</code> 的类，它模拟一个数组，但增加了“快照”功能。具体来说，需要实现以下几个接口：</p>
<ul>
<li><code>SnapshotArray(int length)</code>：构造函数，初始化一个长度为 <code>length</code> 的数组，所有元素的初始值都为 0。</li>
<li><code>void set(index, val)</code>：将当前数组在 <code>index</code> 位置的元素值修改为 <code>val</code>。</li>
<li><code>int snap()</code>：对当前数组的状态进行一次“快照”，并返回这次快照的唯一标识 <code>snap_id</code>。这个 ID 是从 0 开始递增的。</li>
<li><code>int get(index, snap_id)</code>：获取在 <code>snap_id</code> 这次快照时，<code>index</code> 位置上元素的值。</li>
</ul>
<p>举个例子来理解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SnapshotArray snapshotArr = new SnapshotArray(3); // 数组为 [0, 0, 0]</span><br><span class="line">snapshotArr.set(0, 5);  // 当前数组为 [5, 0, 0]</span><br><span class="line">snapshotArr.snap();     // 拍了一张快照，snap_id = 0。这张快照记录了 [5, 0, 0] 的状态</span><br><span class="line">snapshotArr.set(0, 6);  // 当前数组为 [6, 0, 0]</span><br><span class="line">snapshotArr.get(0, 0);  // 获取 snap_id=0 的快照中，索引0的值。当时的值是 5，所以返回 5。</span><br></pre></td></tr></table></figure>

<h3 id="核心思路：空间换时间-二分查找"><a href="#核心思路：空间换时间-二分查找" class="headerlink" title="核心思路：空间换时间 + 二分查找"></a>核心思路：空间换时间 + 二分查找</h3><p>一个最直观但效率低下的想法是，每次调用 <code>snap()</code> 时，都完整地复制一份当前数组的全部内容并存储起来。如果数组长度为 <code>L</code>，调用 <code>snap()</code> 的次数为 <code>S</code>，这种方法的空间复杂度将高达 O(L * S)，在 <code>L</code> 和 <code>S</code> 都很大时会消耗巨量内存。同时，<code>snap()</code> 操作本身的时间复杂度也是 O(L)，效率堪忧。</p>
<p>我们可以进行优化。实际上，每次调用 <code>set</code> 时，只有单个元素的值发生了改变。我们没有必要为整个数组创建副本，而只需要记录<strong>哪个元素，在哪个时刻（snap_id），变成了什么值</strong>。</p>
<p>基于这个想法，我们可以为数组的<strong>每一个索引</strong>都维护一个独立的修改历史列表。这个列表里存储的是一个个的 <code>(snap_id, value)</code> 对。</p>
<p>例如，<code>history[0] = [(0, 5), (2, 8)]</code> 就表示：</p>
<ul>
<li>在 <code>snap_id = 0</code> 时，索引 <code>0</code> 的值被设置为了 <code>5</code>。</li>
<li>在 <code>snap_id = 2</code> 时，索引 <code>0</code> 的值被更新为了 <code>8</code>。</li>
</ul>
<p>当我们要调用 <code>get(index, snap_id)</code> 时，问题就转变成了：<strong>在 <code>index</code> 的历史记录中，找到在小于等于 <code>snap_id</code> 的所有记录里，离 <code>snap_id</code> 最近的那一条记录的值。</strong></p>
<p>由于我们是按时间顺序调用 <code>set</code> 和 <code>snap</code> 的，所以每个索引的历史记录中，<code>snap_id</code> 自然是单调递增的。这就为我们使用<strong>二分查找</strong>创造了完美的条件，从而可以快速地定位到目标记录。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>数据结构设计</strong></p>
<ul>
<li>我们需要一个变量 <code>csi</code> (current snap id) 来记录当前的快照编号，初始为 0。</li>
<li>我们需要一个核心数据结构来存储每个索引的历史变更。这里使用一个哈希表（在 Python 中是 <code>defaultdict</code>），键是数组的 <code>index</code>，值是一个列表，列表里存放 <code>(snap_id, val)</code> 的元组。例如：<code>self.history = &#123;0: [(0, 5), (2, 8)], 1: [(0, 4)]&#125;</code>。</li>
</ul>
</li>
<li><p><strong><code>__init__(self, length)</code></strong></p>
<ul>
<li>初始化 <code>csi = 0</code>。</li>
<li>初始化 <code>self.history = defaultdict(list)</code>。</li>
</ul>
</li>
<li><p><strong><code>set(self, index, val)</code></strong></p>
<ul>
<li>向 <code>index</code> 对应的历史记录列表中追加一个新的元组 <code>(self.csi, val)</code>。这表示在当前的快照时间点，<code>index</code> 的值被设置为了 <code>val</code>。</li>
<li><em>优化提示</em>: 如果 <code>index</code> 对应的历史列表不为空，且最后一条记录的 <code>snap_id</code> 与当前的 <code>csi</code> 相同，说明在同一次快照内对同一位置进行了多次 <code>set</code>。此时可以直接覆盖最后一条记录的值，而不是追加，可以节省一点空间。但直接追加在逻辑上也是完全正确的。</li>
</ul>
</li>
<li><p><strong><code>snap(self)</code></strong></p>
<ul>
<li>这个操作非常简单，只需将 <code>csi</code> 加一，并返回加一之前的旧值即可，即 <code>self.csi - 1</code>。</li>
</ul>
</li>
<li><p><strong><code>get(self, index, snap_id)</code></strong></p>
<ul>
<li>这是算法的核心。首先获取 <code>index</code> 对应的历史记录列表 <code>history[index]</code>。</li>
<li>我们需要在这个列表中找到满足 <code>记录的snap_id &lt;= 给定的snap_id</code> 的最右侧（即 <code>snap_id</code> 最大）的那条记录。</li>
<li>我们可以使用二分查找来高效地完成这个任务。具体来说，我们查找第一个 <code>snap_id &gt; 给定的snap_id</code> 的位置。这个位置的前一个元素，就是我们想要的答案。</li>
<li>Python 的 <code>bisect_left</code> 或 <code>bisect_right</code> 模块非常适合这个场景。<code>bisect_left(history[index], (snap_id + 1, ))</code> 会找到 <code>(snap_id + 1, )</code> 这个元组应该插入的位置，这个位置索引 <code>j</code> 正是第一条 <code>snap_id</code> 大于 <code>snap_id</code> 的记录。</li>
<li>因此，<code>j - 1</code> 就是我们目标记录的索引。</li>
<li>需要处理边界情况：<ul>
<li>如果 <code>j - 1</code> 为负数，说明 <code>history[index]</code> 中所有的记录 <code>snap_id</code> 都大于给定的 <code>snap_id</code>，或者这个索引从未被 <code>set</code> 过。根据题意，此时应返回初始值 0。</li>
<li>否则，返回 <code>history[index][j-1]</code> 中存储的值即可。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SnapshotArray</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, length: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># csi: current snap id, 当前快照编号</span></span><br><span class="line">        <span class="variable language_">self</span>.csi = <span class="number">0</span></span><br><span class="line">        <span class="comment"># history: 使用哈希表存储每个索引的历史记录</span></span><br><span class="line">        <span class="comment"># key: 数组索引, value: [(snap_id, val), ...] 列表</span></span><br><span class="line">        <span class="variable language_">self</span>.history = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 在当前快照时间点，记录 index 处的值</span></span><br><span class="line">        <span class="comment"># 如果历史记录的最后一次快照ID和当前ID相同，可以优化为覆盖，但追加更简单且正确</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.history[index] <span class="keyword">and</span> <span class="variable language_">self</span>.history[index][-<span class="number">1</span>][<span class="number">0</span>] == <span class="variable language_">self</span>.csi:</span><br><span class="line">            <span class="variable language_">self</span>.history[index][-<span class="number">1</span>] = (<span class="variable language_">self</span>.csi, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.history[index].append((<span class="variable language_">self</span>.csi, val))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">snap</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 快照数加一，并返回旧的 snap_id</span></span><br><span class="line">        <span class="variable language_">self</span>.csi += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.csi - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index: <span class="built_in">int</span>, snap_id: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 在 index 的历史记录中，二分查找 snap_id</span></span><br><span class="line">        <span class="comment"># 目标是找到 &lt;= snap_id 的最大快照记录</span></span><br><span class="line">        records = <span class="variable language_">self</span>.history[index]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># bisect_left 寻找插入 (snap_id + 1, ) 的位置</span></span><br><span class="line">        <span class="comment"># 这个位置的左边所有元素的 snap_id 都 &lt;= snap_id</span></span><br><span class="line">        <span class="comment"># 因为元组比较时会先比较第一个元素</span></span><br><span class="line">        j = bisect_left(records, (snap_id + <span class="number">1</span>,)) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果 j &gt;= 0，说明找到了一个有效的历史记录</span></span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> records[j][<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 否则，说明在该快照或之前，该索引从未被 set 过，返回初始值 0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><code>N</code> 是数组的长度, <code>C</code> 是 <code>set</code> 操作的总调用次数。</li>
<li><strong>时间复杂度</strong>:<ul>
<li><code>__init__</code>: O(1)。<code>defaultdict</code> 的初始化是常数时间。</li>
<li><code>set</code>: O(1)。向列表末尾追加元素是摊还 O(1) 的时间复杂度。</li>
<li><code>snap</code>: O(1)。仅涉及一次整数自增操作。</li>
<li><code>get</code>: O(log K)。其中 <code>K</code> 是对 <code>index</code> 调用 <code>set</code> 的次数。在最坏的情况下，所有的 <code>set</code> 操作都作用于同一个 <code>index</code>，此时 <code>K</code> 等于 <code>C</code>，所以最坏时间复杂度为 O(log C)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(C)。我们存储了每一次 <code>set</code> 操作的数据。每次 <code>set</code> 都会创建一个 <code>(snap_id, val)</code> 元组，所以总的空间消耗与 <code>set</code> 的调用次数成正比。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预处理 + 二分查找”模式的一个经典应用，同时也考察了数据结构设计的能力。面对可能导致巨大时空开销的朴素解法，我们应该思考<strong>变化的是什么，不变的是什么</strong>。在这里，数组的大部分内容在快照之间是不变的，只有被 <code>set</code> 的部分才变化。抓住这一关键点，通过只记录增量变化（即历史记录）的方式，成功地用可控的空间换取了极高的查询效率。而二分查找，正是利用历史记录中 <code>snap_id</code> 的有序性来实现高效查询的利器。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>哈希表</tag>
        <tag>设计</tag>
        <tag>第148场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1156 | 滑动窗口求解“单字符重复子串的最大长度”</title>
    <url>//posts/leetcode-1156/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1156 题：<a href="https://leetcode.cn/problems/swap-for-longest-repeated-character-substring/">单字符重复子串的最大长度</a>。<br>这道题的有趣之处在于“一次交换”这个操作。它给了我们一次修正错误的机会，让原本不连续的相同字符子串，有了连接起来的可能。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个字符串 <code>text</code>，我们有一次机会可以交换字符串中的任意两个字符（也可以选择不交换）。我们的目标是，在这次操作后，找到一个最长的、只包含同一种字符的子串，并返回其长度。</p>
<p>我们来分析一下“一次交换”能带来什么：</p>
<ol>
<li><strong>修复一个“缺口”</strong>：在一个几乎全是 <code>a</code> 的子串中，如果有一个字符不是 <code>a</code>，例如 <code>&quot;aaabaaa&quot;</code>，我们可以从字符串的其他地方找一个 <code>a</code> 换掉那个 <code>b</code>。</li>
<li><strong>连接两个“断崖”</strong>：如果一个子串像 <code>&quot;aaaa&quot;</code> 这样已经很完美，我们可以尝试从别处找一个 <code>a</code>，换到这个子串的旁边，让它变得更长，例如变成 <code>&quot;aaaaa&quot;</code>。</li>
</ol>
<p>举个例子，对于 <code>text = &quot;aaabaaa&quot;</code>：</p>
<ul>
<li>我们关注字符 <code>a</code>。字符串里总共有 6 个 <code>a</code>。</li>
<li>有一个子串 <code>&quot;aaabaaa&quot;</code>，它的长度是 7，其中包含一个 <code>b</code>。</li>
<li>我们可以用一次交换机会把 <code>b</code> 换成 <code>a</code>。但是，我们需要从字符串的其他位置找到一个 <code>a</code> 来交换。在这个例子里，除了这 6 个 <code>a</code> 之外，没有多余的 <code>a</code> 可以换过来。</li>
<li>因此，即使我们换掉了 <code>b</code>，最多也只能形成一个长度为 6 的 <code>a</code> 串（因为总共就 6 个 <code>a</code>）。所以最大长度是 6。</li>
</ul>
<p>对于 <code>text = &quot;ababa&quot;</code>:</p>
<ul>
<li>我们关注字符 <code>a</code>。总共有 3 个 <code>a</code>。</li>
<li>子串 <code>&quot;ababa&quot;</code> 中，<code>a</code> 被 <code>b</code> 隔开。</li>
<li>我们可以把中间的 <code>b</code> 和末尾的 <code>a</code> 交换，字符串变为 <code>&quot;aaabb&quot;</code>。这样我们就得到了一个长度为 3 的 <code>a</code> 串 <code>&quot;aaa&quot;</code>。</li>
<li>因为总共只有 3 个 <code>a</code>，所以长度 3 就是 <code>a</code> 能达到的极限。</li>
</ul>
<h3 id="核心思路：枚举字符-滑动窗口"><a href="#核心思路：枚举字符-滑动窗口" class="headerlink" title="核心思路：枚举字符 + 滑动窗口"></a>核心思路：枚举字符 + 滑动窗口</h3><p>问题的关键是找到“最长的”单字符重复子串。一个直接的想法是，我们可以对每一种可能出现的字符（<code>a</code> 到 <code>z</code>）都计算一次它能形成的最长子串长度，然后取其中的最大值。</p>
<p>当我们聚焦于某一个特定字符 <code>ch</code> 时，问题就转化为：<strong>只考虑字符 <code>ch</code>，通过一次交换能得到的最长 <code>ch</code> 子串是多长？</strong></p>
<p>这个问题非常适合用<strong>滑动窗口</strong>来解决。我们可以用一个窗口 <code>[l, r]</code> 在字符串上滑动，这个窗口代表我们希望最终全是 <code>ch</code> 的目标子串。因为我们只有一次交换机会，所以这个窗口内最多只能容忍一个“杂质”（即不是 <code>ch</code> 的字符）。</p>
<p>于是，我们的策略是：</p>
<ol>
<li><strong>预处理</strong>：先用哈希表（<code>Counter</code>）统计出整个字符串中每个字符的总数。这个信息至关重要，因为它决定了我们能用来“填补”窗口的原材料上限。</li>
<li><strong>主循环</strong>：遍历从 <code>a</code> 到 <code>z</code> 的每一个字符 <code>ch</code>，将其作为目标字符。</li>
<li><strong>滑动窗口</strong>：<ul>
<li>维护一个窗口 <code>[l, r]</code> 和一个杂质计数器 <code>occ</code>。</li>
<li>当右指针 <code>r</code> 扩张时，如果 <code>text[r]</code> 不是 <code>ch</code>，就增加 <code>occ</code>。</li>
<li>如果 <code>occ</code> 超过 1，说明窗口内的杂质太多，一次交换已经无法修复，必须从左侧 <code>l</code> 收缩窗口，直到 <code>occ</code> 恢复到 1 或 0。</li>
</ul>
</li>
<li><strong>更新答案</strong>：在每一步窗口扩张后，我们都计算当前窗口能形成的最长 <code>ch</code> 子串长度，并更新全局最大值 <code>ans</code>。这里有两种情况：<ul>
<li><strong>情况一：窗口内没有杂质（<code>occ == 0</code>）</strong><ul>
<li>窗口内的子串已经是完美的 <code>ch</code> 串，如 <code>&quot;aaaa&quot;</code>。长度为 <code>w = r-l+1</code>。</li>
<li>我们能否让它更长？可以！如果字符串中还有其他的 <code>ch</code>（即 <code>ch</code> 的总数 <code>tc</code> &gt; <code>w</code>），我们就可以把其中一个 <code>ch</code> 换到窗口旁边，使其长度加一。</li>
<li>所以，这种情况下能达到的最大长度是 <code>w + 1</code>（前提是 <code>tc &gt; w</code>），否则就是 <code>w</code>。</li>
</ul>
</li>
<li><strong>情况二：窗口内有一个杂质（<code>occ == 1</code>）</strong><ul>
<li>窗口内的子串有一个缺口，如 <code>&quot;aaabaa&quot;</code>。长度为 <code>w</code>。</li>
<li>我们可以用一次交换把杂质换成 <code>ch</code>。但这需要我们有足够的 <code>ch</code> 来填充。</li>
<li>我们最多能形成多长的 <code>ch</code> 串，取决于我们拥有的 <code>ch</code> 的总数 <code>tc</code>。我们不可能创造出比 <code>tc</code> 更长的 <code>ch</code> 串。</li>
<li>所以，这种情况下能达到的最大长度是 <code>min(w, tc)</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>对所有 26 个字母执行上述过程，记录下的最大值就是最终答案。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>第一步：预计算字符总数</strong></p>
<ul>
<li>使用 <code>collections.Counter</code> 对 <code>text</code> 进行计数，得到每个字符的总出现次数 <code>cnt</code>。</li>
</ul>
</li>
<li><p><strong>第二步：遍历所有可能的字符</strong></p>
<ul>
<li>循环遍历从 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 的所有字符 <code>ch</code>。如果某个字符在 <code>text</code> 中不存在，直接跳过。</li>
</ul>
</li>
<li><p><strong>第三步：针对每个字符ch，使用滑动窗口计算最大长度</strong></p>
<ul>
<li>初始化左指针 <code>l = 0</code> 和杂质计数器 <code>occ = 0</code>。</li>
<li>用右指针 <code>r</code> 遍历字符串 <code>text</code> (从 <code>0</code> 到 <code>n-1</code>)。</li>
<li>在循环中，如果 <code>text[r]</code> 不是我们当前关注的字符 <code>ch</code>，则 <code>occ += 1</code>。</li>
<li>检查 <code>occ</code> 是否大于 1。如果是，则不断地收缩左边界：如果 <code>text[l]</code> 是一个杂质，则 <code>occ -= 1</code>，然后 <code>l += 1</code>。</li>
<li>计算当前窗口 <code>[l, r]</code> 的大小 <code>w = r - l + 1</code>。</li>
<li>根据杂质数量 <code>occ</code> 更新答案：<ul>
<li>如果 <code>occ == 0</code>，我们有一个纯 <code>ch</code> 窗口。如果 <code>ch</code> 的总数 <code>tc</code> 大于当前窗口大小 <code>w</code>，我们就可以从别处“借”一个 <code>ch</code> 来加长它。所以，候选长度为 <code>w + (1 if tc &gt; w else 0)</code>。</li>
<li>如果 <code>occ == 1</code>，我们有一个带杂质的窗口。我们可以用一个 <code>ch</code> 来替换这个杂质。我们最多能得到的长度受限于 <code>ch</code> 的总数 <code>tc</code>。所以，候选长度为 <code>min(w, tc)</code>。</li>
</ul>
</li>
<li>用计算出的候选长度更新全局最大值 <code>ans</code>。</li>
</ul>
</li>
<li><p><strong>第四步：返回结果</strong></p>
<ul>
<li>遍历完所有字符后，<code>ans</code> 中存储的就是最终答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxRepOpt1</span>(<span class="params">self, text: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1: 预计算每个字符的总数</span></span><br><span class="line">        cnt = Counter(text)</span><br><span class="line">        n = <span class="built_in">len</span>(text)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2: 遍历 &#x27;a&#x27; 到 &#x27;z&#x27;，对每个字符ch进行分析</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>), <span class="built_in">ord</span>(<span class="string">&#x27;z&#x27;</span>) + <span class="number">1</span>):</span><br><span class="line">            ch = <span class="built_in">chr</span>(c)</span><br><span class="line">            tc = cnt[ch] <span class="comment"># 当前关注字符的总数</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果该字符不存在，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> tc == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 步骤 3: 滑动窗口</span></span><br><span class="line">            l = occ = <span class="number">0</span> <span class="comment"># l是左指针，occ是窗口内“杂质”的数量</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> text[r] != ch:</span><br><span class="line">                    occ += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 当杂质多于1个时，收缩左边界</span></span><br><span class="line">                <span class="keyword">while</span> occ &gt; <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> text[l] != ch:</span><br><span class="line">                        occ -= <span class="number">1</span></span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 步骤 4: 更新答案</span></span><br><span class="line">                w = r - l + <span class="number">1</span> <span class="comment"># 当前窗口大小</span></span><br><span class="line">                <span class="keyword">if</span> occ == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 情况一：窗口内没有杂质</span></span><br><span class="line">                    <span class="comment"># 如果字符串中还有多余的ch，可以换过来一个，长度+1</span></span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, w + (<span class="number">1</span> <span class="keyword">if</span> tc &gt; w <span class="keyword">else</span> <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># occ == 1</span></span><br><span class="line">                    <span class="comment"># 情况二：窗口内有一个杂质</span></span><br><span class="line">                    <span class="comment"># 用一个ch替换杂质，最大长度不能超过ch的总数</span></span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(w, tc))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。虽然代码有两层循环，但外层循环是常数 26 次。对于内层的滑动窗口，每个字符作为目标时，<code>l</code> 和 <code>r</code> 指针都只会从头到尾遍历字符串一次。因此总的时间复杂度是 O(26 * N) &#x3D; O(N)。</li>
<li><strong>空间复杂度</strong>: O(Σ)。其中 Σ 是字符集的大小，这里是 26。我们用了一个 <code>Counter</code> 来存储字符频率，空间是常数级别的，所以是 O(1)。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想的一个巧妙应用。通过将问题分解为“为每个字符寻找最优解”，我们将一个复杂问题转化为了 26 个独立的、更简单的子问题。在解决子问题时，滑动窗口是处理连续子数组&#x2F;子串问题的利器。本题的难点在于，更新答案时需要细致地分情况讨论：窗口是“完美的”还是“有缺陷的”，并结合字符总数这一全局信息，来判断一次交换到底能带来多大的收益。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>第149场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1170 | 二分查找解决“比较字符串最小字母出现频次”</title>
    <url>//posts/leetcode-1170/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1170 题：<a href="https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/">比较字符串最小字母出现频次</a>。<br>通过对词汇表进行预处理和排序，我们可以利用二分查找将查询效率从线性级别优化到对数级别。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目首先定义了一个函数 <code>f(s)</code>，它的功能是计算一个非空字符串 <code>s</code> 中，按字典序最小的那个字母出现的次数。例如，对于 <code>s = &quot;dcce&quot;</code>，最小的字母是 ‘c’，它出现了 2 次，所以 <code>f(&quot;dcce&quot;) = 2</code>。</p>
<p>接着，题目给了我们两个字符串数组：一个查询数组 <code>queries</code> 和一个词汇表数组 <code>words</code>。我们的任务是，对于 <code>queries</code> 中的每一个查询字符串 <code>queries[i]</code>，都要计算出在 <code>words</code> 数组中有多少个单词 <code>W</code> 满足 <code>f(queries[i]) &lt; f(W)</code>。最后，返回一个整数数组 <code>answer</code>，其中 <code>answer[i]</code> 就是第 <code>i</code> 次查询的结果。</p>
<p>举个例子，<code>queries = [&quot;bbb&quot;,&quot;cc&quot;]</code>, <code>words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]</code>：</p>
<ul>
<li>对于第一个查询 “bbb”：<ul>
<li>最小字母是 ‘b’，出现 3 次，所以 <code>f(&quot;bbb&quot;) = 3</code>。</li>
<li>我们需要在 <code>words</code> 中找到 <code>f(W) &gt; 3</code> 的单词。</li>
<li><code>f(&quot;a&quot;)=1</code>, <code>f(&quot;aa&quot;)=2</code>, <code>f(&quot;aaa&quot;)=3</code>, <code>f(&quot;aaaa&quot;)=4</code>。只有一个 “aaaa” 满足条件。所以结果是 1。</li>
</ul>
</li>
<li>对于第二个查询 “cc”：<ul>
<li>最小字母是 ‘c’，出现 2 次，所以 <code>f(&quot;cc&quot;) = 2</code>。</li>
<li>我们需要在 <code>words</code> 中找到 <code>f(W) &gt; 2</code> 的单词。</li>
<li>“aaa” 和 “aaaa” 满足条件。所以结果是 2。</li>
</ul>
</li>
<li>因此，最终答案是 <code>[1, 2]</code>。</li>
</ul>
<h3 id="核心思路：预计算-二分查找"><a href="#核心思路：预计算-二分查找" class="headerlink" title="核心思路：预计算 + 二分查找"></a>核心思路：预计算 + 二分查找</h3><p>一个直观的想法是，对每个 <code>query</code>，我们都遍历一遍 <code>words</code> 数组，计算每个 <code>word</code> 的 <code>f</code> 值并进行比较。如果 <code>queries</code> 的长度是 N，<code>words</code> 的长度是 M，那么这种暴力解法的时间复杂度大约是 O(N * M)，在 N 和 M 都达到 2000 的情况下，可能会超时。</p>
<p>注意到，<code>words</code> 数组是固定不变的。我们可以对其进行<strong>预处理</strong>，来加速后续的查询过程。</p>
<p>整个优化的思路分为两步：</p>
<ol>
<li><p><strong>预计算与排序</strong>：我们先遍历一次 <code>words</code> 数组，计算出其中每个单词 <code>W</code> 的 <code>f(W)</code> 值，并将这些频率值存入一个新数组 <code>word_freqs</code> 中。为了能够快速查找，我们对 <code>word_freqs</code> 进行升序排序。</p>
</li>
<li><p><strong>高效查询</strong>：完成预处理后，对于每个 <code>query</code>，我们先计算出它的频率 <code>q_freq</code>。然后，问题就转化成了：<strong>在一个排好序的数组 <code>word_freqs</code> 中，有多少个元素大于 <code>q_freq</code>？</strong> 这是一个典型的二分查找应用场景。我们可以通过二分查找，快速定位到第一个大于 <code>q_freq</code> 的元素的位置。一旦找到了这个位置，那么它后面的所有元素都满足条件，我们就能立刻得到答案。</p>
</li>
</ol>
<p>通过这种方式，每次查询的时间复杂度从 O(M) 降到了 O(log M)，从而显著提高了算法的整体效率。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>定义辅助函数 <code>f(s)</code></strong></p>
<ul>
<li>这个函数接收一个字符串 <code>s</code>。</li>
<li>找到 <code>s</code> 中的最小字符 <code>min_char</code>。</li>
<li>返回 <code>min_char</code> 在 <code>s</code> 中出现的次数。</li>
</ul>
</li>
<li><p><strong>预处理 <code>words</code> 数组</strong></p>
<ul>
<li>创建一个整数数组 <code>word_freqs</code>。</li>
<li>遍历 <code>words</code> 中的每一个 <code>word</code>，调用 <code>f(word)</code> 计算其频率，并将结果添加到 <code>word_freqs</code> 中。</li>
<li>对 <code>word_freqs</code> 数组进行升序排序。</li>
</ul>
</li>
<li><p><strong>处理 <code>queries</code> 数组</strong></p>
<ul>
<li>创建一个空的答案数组 <code>ans</code>。</li>
<li>遍历 <code>queries</code> 中的每一个 <code>query</code>：<ul>
<li>计算其频率 <code>q_freq = f(query)</code>。</li>
<li>在排好序的 <code>word_freqs</code> 数组上执行二分查找，目标是找到第一个<strong>严格大于</strong> <code>q_freq</code> 的元素的索引。</li>
<li>在 Python 中，<code>bisect.bisect_right(array, value)</code> 函数可以完美地实现这个功能。它会返回 <code>value</code> 在 <code>array</code> 中的插入点索引，这个索引恰好是数组中大于 <code>value</code> 的第一个元素的位置。</li>
<li>假设 <code>word_freqs</code> 的长度为 <code>n</code>，找到的索引为 <code>index</code>，那么 <code>word_freqs</code> 中大于 <code>q_freq</code> 的元素个数就是 <code>n - index</code>。</li>
<li>将这个计数结果添加到 <code>ans</code> 数组中。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>遍历结束后，返回 <code>ans</code> 数组。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSmallerByFrequency</span>(<span class="params">self, queries: <span class="type">List</span>[<span class="built_in">str</span>], words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1: 定义辅助函数 f(s)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            min_char = <span class="built_in">min</span>(s)</span><br><span class="line">            <span class="keyword">return</span> s.count(min_char)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2: 预处理 words 数组</span></span><br><span class="line">        <span class="comment"># 计算 words 中每个单词的频率并排序</span></span><br><span class="line">        word_freqs = <span class="built_in">sorted</span>([f(word) <span class="keyword">for</span> word <span class="keyword">in</span> words])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 处理 queries 数组</span></span><br><span class="line">        ans = []</span><br><span class="line">        n = <span class="built_in">len</span>(word_freqs)</span><br><span class="line">        <span class="keyword">for</span> query <span class="keyword">in</span> queries:</span><br><span class="line">            q_freq = f(query)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 使用二分查找找到第一个 &gt; q_freq 的元素的位置</span></span><br><span class="line">            <span class="comment"># n - (该位置的索引) 即为满足条件的单词数量</span></span><br><span class="line">            index = bisect.bisect_right(word_freqs, q_freq)</span><br><span class="line">            count = n - index</span><br><span class="line">            ans.append(count)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 4: 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(M * Lw + M log M + N * (Lq + log M))。<ul>
<li><code>N</code> 是 <code>queries</code> 的长度, <code>M</code> 是 <code>words</code> 的长度。</li>
<li><code>Lq</code> 和 <code>Lw</code> 分别是 <code>queries</code> 和 <code>words</code> 中字符串的最大长度。</li>
<li>计算 <code>word_freqs</code> 需要 O(M * Lw)。</li>
<li>排序 <code>word_freqs</code> 需要 O(M log M)。</li>
<li>对于每个查询，计算 <code>f(query)</code> 需要 O(Lq)，二分查找需要 O(log M)。总共是 O(N * (Lq + log M))。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(M)。我们需要一个额外的数组 <code>word_freqs</code> 来存储 <code>words</code> 数组中每个单词的频率。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预处理 + 二分查找”模式的一个经典应用。当题目要求对一个固定的数据集进行多次查询时，我们应该优先考虑是否能通过对数据集进行一次性的预处理（例如计算、排序等），来为后续的查询操作提供便利，从而将整体复杂度降低一个量级。二分查找正是利用了数据的有序性来实现高效查询的强大工具。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>排序</tag>
        <tag>第151场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1208 | 滑动窗口巧解“尽可能使字符串相等”</title>
    <url>//posts/leetcode-1208/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1208 题：<a href="https://leetcode.cn/problems/get-equal-substrings-within-budget/">尽可能使字符串相等</a>。<br>当题目要求我们寻找一个满足特定条件的<strong>最长连续子数组或子字符串</strong>时，滑动窗口往往是最高效的解法。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们来仔细分析一下题目的要求：</p>
<ol>
<li><strong>转换开销 (Cost)</strong>：将字符串 <code>s</code> 中的一个字符 <code>s[i]</code> 变为 <code>t</code> 中对应的字符 <code>t[i]</code>，需要 <code>|ord(s[i]) - ord(t[i])|</code> 的开销。这其实就是两个字符 ASCII 码值的差的绝对值。</li>
<li><strong>预算限制 (Budget)</strong>：我们有一个总预算 <code>maxCost</code>。我们可以在 <code>s</code> 中选择一个子字符串，将其转换为 <code>t</code> 中对应的子字符串，但总开销不能超过 <code>maxCost</code>。</li>
<li><strong>目标</strong>：找到在预算范围内，可以转换的<strong>最长</strong>子字符串的长度。</li>
</ol>
<p>例如，<code>s = &quot;abcd&quot;</code>, <code>t = &quot;bcdf&quot;</code>, <code>maxCost = 3</code>。<br>我们可以计算每个位置的转换开销：</p>
<ul>
<li><code>&#39;a&#39; -&gt; &#39;b&#39;</code>: |97 - 98| &#x3D; 1</li>
<li><code>&#39;b&#39; -&gt; &#39;c&#39;</code>: |98 - 99| &#x3D; 1</li>
<li><code>&#39;c&#39; -&gt; &#39;d&#39;</code>: |99 - 100| &#x3D; 1</li>
<li><code>&#39;d&#39; -&gt; &#39;f&#39;</code>: |100 - 102| &#x3D; 2</li>
</ul>
<p>如果我们尝试转换子字符串 <code>&quot;abc&quot;</code>，总开销为 <code>1 + 1 + 1 = 3</code>。这个开销没有超过 <code>maxCost</code>，所以这是一个合法的转换，其长度为 3。如果我们尝试转换 <code>&quot;abcd&quot;</code>，总开销为 <code>3 + 2 = 5</code>，超出了预算。因此，能转换的最长子字符串就是 <code>&quot;abc&quot;</code>，答案是 3。</p>
<h3 id="核心思路：滑动窗口"><a href="#核心思路：滑动窗口" class="headerlink" title="核心思路：滑动窗口"></a>核心思路：滑动窗口</h3><p>这个问题要求我们找到一个<strong>连续</strong>的子字符串，其总转换开销不超过一个给定值，并使这个子字符串的<strong>长度最大化</strong>。这正是滑动窗口算法的典型应用场景。</p>
<p>我们可以把 <code>s</code> 的一个子字符串想象成一个“窗口”。这个窗口在字符串上从左到右滑动。</p>
<ol>
<li><strong>窗口的定义</strong>：窗口 <code>[left, right]</code> 表示我们当前正在考虑的 <code>s</code> 的子字符串 <code>s[left...right]</code>。</li>
<li><strong>窗口的状态</strong>：我们需要一个变量 <code>current_cost</code> 来实时记录当前窗口内所有字符的总转换开销。</li>
<li><strong>窗口的移动逻辑</strong>：<ul>
<li><strong>扩大窗口</strong>：我们不断地将窗口的右边界 <code>right</code>向右移动，把新的字符 <code>s[right]</code> 纳入窗口，并将其转换开销累加到 <code>current_cost</code> 中。</li>
<li><strong>收缩窗口</strong>：当 <code>current_cost</code> 超过了预算 <code>maxCost</code> 时，说明当前窗口太“贵”了，不满足条件。此时，我们必须从窗口的左边开始丢弃元素，即将左边界 <code>left</code> 向右移动，并从 <code>current_cost</code> 中减去被丢弃字符 <code>s[left]</code> 的转换开销。我们重复这个过程，直到 <code>current_cost</code> 再次回到预算范围内。</li>
<li><strong>更新结果</strong>：在每一步中，只要窗口是有效的（即 <code>current_cost &lt;= maxCost</code>），它就是一个潜在的答案。我们记录下当前窗口的长度 <code>right - left + 1</code>，并与我们已知的最大长度 <code>max_len</code> 进行比较，随时保留最大值。</li>
</ul>
</li>
</ol>
<p>通过这种方式，窗口在字符串上滑动一次，我们就能找到最长的有效子字符串。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>left = 0</code>：窗口的左边界。</li>
<li><code>current_cost = 0</code>：当前窗口的总开销。</li>
<li><code>max_len = 0</code>：记录满足条件的最大长度。</li>
</ul>
</li>
<li><p><strong>遍历与扩大窗口</strong>：</p>
<ul>
<li>用一个 <code>right</code> 指针从 0 开始遍历整个字符串，它代表窗口的右边界。</li>
<li>在循环的每一步，计算 <code>s[right]</code> 到 <code>t[right]</code> 的开销，并加入到 <code>current_cost</code>。</li>
</ul>
</li>
<li><p><strong>检查与收缩窗口</strong>：</p>
<ul>
<li>在扩大窗口后，立即检查 <code>current_cost</code> 是否大于 <code>maxCost</code>。</li>
<li>如果大于，则进入一个 <code>while</code> 循环：从 <code>current_cost</code> 中减去 <code>s[left]</code> 对应的开销，然后将 <code>left</code> 指针右移一位。重复此操作直到 <code>current_cost &lt;= maxCost</code>。</li>
</ul>
</li>
<li><p><strong>更新最大长度</strong>：</p>
<ul>
<li>当窗口的总开销满足预算时，当前窗口 <code>[left, right]</code> 就是一个有效的子字符串。</li>
<li>计算其长度 <code>right - left + 1</code>，并更新 <code>max_len = max(max_len, right - left + 1)</code>。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>遍历结束后，<code>max_len</code> 就是最终的答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">equalSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span>, maxCost: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用滑动窗口解决问题。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        我们维护一个窗口 [left, right]，表示我们试图转换的子字符串。</span></span><br><span class="line"><span class="string">        current_cost 记录了当前窗口内所有字符的转换总成本。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        current_cost = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># right 指针作为窗口的右边界，用于扩大窗口</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># 步骤 1: 扩大窗口</span></span><br><span class="line">            <span class="comment"># 累加新进入窗口的右侧字符的转换开销</span></span><br><span class="line">            current_cost += <span class="built_in">abs</span>(<span class="built_in">ord</span>(s[right]) - <span class="built_in">ord</span>(t[right]))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 2: 判断是否需要收缩窗口</span></span><br><span class="line">            <span class="comment"># 如果当前窗口的总开销超过了预算</span></span><br><span class="line">            <span class="keyword">while</span> current_cost &gt; maxCost:</span><br><span class="line">                <span class="comment"># 从总开销中减去即将移出窗口的左侧字符的开销</span></span><br><span class="line">                current_cost -= <span class="built_in">abs</span>(<span class="built_in">ord</span>(s[left]) - <span class="built_in">ord</span>(t[left]))</span><br><span class="line">                <span class="comment"># 左指针向右移动，完成收缩</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 3: 更新结果</span></span><br><span class="line">            <span class="comment"># 此时的窗口 [left, right] 是一个有效的窗口</span></span><br><span class="line">            <span class="comment"># 计算其长度并更新最大长度记录</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)，其中 N 是字符串的长度。虽然代码中有一个 <code>while</code> 循环嵌套在 <code>for</code> 循环内部，但 <code>left</code> 和 <code>right</code> 指针都只会从头到尾遍历字符串一次，每个字符最多被访问两次（一次被 <code>right</code> 指针加入，一次被 <code>left</code> 指针移出）。因此，总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了几个额外的变量 (<code>left</code>, <code>current_cost</code>, <code>max_len</code>) 来存储状态，其空间占用与输入字符串的长度无关。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口算法的绝佳练习题。通过这道题，我们可以加深对滑动窗口思想的理解：</p>
<ol>
<li><strong>识别应用场景</strong>：当问题涉及在序列（数组、字符串）上寻找满足条件的<strong>最长&#x2F;最短连续子序列</strong>时，滑动窗口是一个强有力的工具。</li>
<li><strong>双指针与状态维护</strong>：滑动窗口的核心是使用 <code>left</code> 和 <code>right</code> 两个指针来定义一个动态变化的窗口，并高效地维护窗口内的状态（例如本题中的 <code>current_cost</code>）。</li>
<li><strong>“收缩”的智慧</strong>：滑动窗口的精髓在于，当窗口不满足条件时，我们不是暴力地重新开始，而是通过“收缩”窗口的左边界来尝试使其重新满足条件，这大大提高了算法的效率。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
        <tag>前缀和</tag>
        <tag>第 156 场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1234 | 滑动窗口求解“替换子串得到平衡字符串”</title>
    <url>//posts/leetcode-1234/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1234 题：<a href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/">替换子串得到平衡字符串</a>。<br>该题要求我们通过替换一个连续子串，使得 ‘Q’, ‘W’, ‘E’, ‘R’ 四个字符数量相等。问题的关键在于逆向思考：我们不是要决定用什么字符来替换，而是要决定保留哪些字符。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给定一个长度为 <code>n</code> 的字符串 <code>s</code>，它只包含 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符。一个“平衡字符串”是指这四种字符都恰好出现 <code>n/4</code> 次。</p>
<p>我们的任务是找到一个<strong>最短的连续子串</strong>，将它替换成任意等长的字符串后，能使整个 <code>s</code> 变成一个平衡字符串。我们需要返回这个最短子串的长度。如果 <code>s</code> 本身就是平衡的，则返回 0。</p>
<p>举个例子，对于 <code>s = &quot;QQQW&quot;</code>, <code>n = 4</code>：</p>
<ul>
<li>一个平衡字符串需要 ‘Q’, ‘W’, ‘E’, ‘R’ 各出现 1 次 (<code>4/4=1</code>)。</li>
<li>当前 <code>s</code> 中有 3 个 ‘Q’ 和 1 个 ‘W’。’Q’ 超了 2 个，而 ‘E’ 和 ‘R’ 各缺 1 个。</li>
<li>我们可以替换掉开头的 “QQ”，用 “ER” 来替换，得到 “ERQW”。这是一个平衡字符串。</li>
<li>被替换的子串 “QQ” 长度为 2，这是我们能找到的最小长度，所以答案是 2。</li>
</ul>
<p>直接枚举所有子串并判断替换后的结果是否平衡，效率太低。我们需要找到更巧妙的切入点。</p>
<h3 id="核心思路：逆向思考与滑动窗口"><a href="#核心思路：逆向思考与滑动窗口" class="headerlink" title="核心思路：逆向思考与滑动窗口"></a>核心思路：逆向思考与滑动窗口</h3><p>这道题的突破口在于对“替换”操作的理解。当我们选择一个子串 <code>s[l...r]</code> 进行替换时，这个子串内的所有字符都会被“抹去”，我们可以换成任何我们需要的字符。这意味着，最终字符串的平衡性，完全取决于<strong>原字符串中位于子串之外的字符</strong>。</p>
<p>假设目标是每个字符最终都有 <code>k = n/4</code> 个。我们先统计整个字符串 <code>s</code> 中每个字符的出现次数。</p>
<ul>
<li>对于那些出现次数 <code>count(c) &lt;= k</code> 的字符 <code>c</code>，它们不是问题，因为我们可以在替换时补充它们。</li>
<li>对于那些出现次数 <code>count(c) &gt; k</code> 的字符 <code>c</code>，它们是“多余”的。我们必须通过替换操作，将 <code>count(c) - k</code> 个多余的 <code>c</code> 包含在被替换的子串中。</li>
</ul>
<p>这样，问题就从“找到最短的子串去替换”，巧妙地转换成了：<br><strong>找到一个最短的子串，这个子串恰好包含了所有“多余”的字符。</strong></p>
<p>例如 <code>s = &quot;QQQW&quot;</code>，<code>k=1</code>。’Q’ 的数量为 3，多余了 <code>3-1=2</code> 个。我们只需要找到一个最短的子串，它里面至少包含 2 个 ‘Q’。最短的子串就是 “QQ”，长度为 2。</p>
<p>这是一个典型的不定长滑动窗口问题：寻找满足特定条件的最短连续子数组&#x2F;子串。</p>
<ul>
<li><strong>窗口扩张</strong>：移动右指针 <code>r</code>，将新字符纳入窗口。</li>
<li><strong>条件判断</strong>：检查窗口内的字符是否已经满足了“包含所有多余字符”的条件。</li>
<li><strong>窗口收缩</strong>：如果条件满足，记录当前窗口的长度并尝试移动左指针 <code>l</code>，缩小窗口，寻找更短的满足条件的窗口。</li>
</ul>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>预处理</strong>：</p>
<ul>
<li>计算平衡状态下每个字符的目标数量 <code>tc = n / 4</code>。</li>
<li>使用哈希表（或数组）统计整个字符串 <code>s</code> 中 ‘Q’, ‘W’, ‘E’, ‘R’ 的原始数量 <code>fc</code>。</li>
<li>创建一个“多余字符”哈希表 <code>ex</code>。遍历 <code>fc</code>，如果某个字符 <code>c</code> 的数量 <code>cnt &gt; tc</code>，则将 <code>ex[c] = cnt - tc</code> 加入表中。这表示我们需要在滑动窗口中找到 <code>cnt - tc</code> 个 <code>c</code>。</li>
<li>如果 <code>ex</code> 为空，说明字符串已经平衡，直接返回 0。</li>
</ul>
</li>
<li><p><strong>滑动窗口</strong>：</p>
<ul>
<li>初始化左指针 <code>l = 0</code>，最小长度 <code>ans = n</code>。</li>
<li>用右指针 <code>r</code> 从 0 开始遍历字符串 <code>s</code>。</li>
<li>当字符 <code>s[r]</code> 进入窗口时，如果 <code>s[r]</code> 是一个多余字符（即 <code>s[r]</code> 在 <code>ex</code> 中），则将 <code>ex[s[r]]</code> 的计数值减 1。</li>
<li>进入 <code>while</code> 循环，判断窗口是否满足条件：<code>ex</code> 中所有字符的计数值是否都 <code> &lt;= 0</code>。<ul>
<li>如果满足，说明当前窗口 <code>s[l...r]</code> 已经包含了所有多余的字符。我们用当前窗口长度 <code>r - l + 1</code> 更新 <code>ans</code>。</li>
<li>然后，尝试收缩窗口。考察左边界字符 <code>s[l]</code>，如果它是一个多余字符，那么当它离开窗口时，需要将 <code>ex[s[l]]</code> 的计数值加 1（因为它不再被窗口覆盖了）。</li>
<li>将左指针 <code>l</code> 右移一位。</li>
</ul>
</li>
<li>重复此过程，直到右指针 <code>r</code> 遍历完整个字符串。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>遍历结束后，<code>ans</code> 即为所求的最小子串长度。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">balancedString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 目标计数</span></span><br><span class="line">        tc = n//<span class="number">4</span></span><br><span class="line">        <span class="comment"># 频率统计</span></span><br><span class="line">        fc = Counter(s)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 统计需要被替换掉的“多余”的字符</span></span><br><span class="line">        ex = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c ,cnt  <span class="keyword">in</span> fc.items():</span><br><span class="line">            <span class="keyword">if</span> cnt &gt; tc:</span><br><span class="line">                ex[c] = cnt - tc</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果 ex 为空，说明字符串已经平衡</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ex:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        ans = n</span><br><span class="line">        <span class="comment"># 右指针 r 遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> r, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="comment"># 如果当前字符是多余字符，则需求量减一</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> ex:</span><br><span class="line">                ex[c] -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当窗口满足包含所有多余字符的条件时</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">all</span>(v &lt;= <span class="number">0</span> <span class="keyword">for</span> v <span class="keyword">in</span> ex.values()):</span><br><span class="line">                <span class="comment"># 更新最小长度</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans, r - l + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 尝试收缩窗口</span></span><br><span class="line">                lc = s[l]</span><br><span class="line">                <span class="keyword">if</span> lc <span class="keyword">in</span> ex:</span><br><span class="line">                    <span class="comment"># 左边界的字符移出窗口，如果它是多余字符，则需求量加一</span></span><br><span class="line">                    ex[lc] += <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是字符串 <code>s</code> 的长度。左右指针 <code>l</code> 和 <code>r</code> 都只会从头到尾遍历字符串一次，因此总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(Σ)。其中 Σ 是字符集的数量。在这里，字符集为 {‘Q’, ‘W’, ‘E’, ‘R’}，数量是常数 4。因此空间复杂度为 O(1)。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题通过将问题“替换子串使外部平衡”转化为“寻找包含所有超额字符的最短子串”，我们将一个看似复杂的问题简化为了一个经典的算法模型。这种“逆向思考”或“问题转化”的能力，在解决算法题时至关重要。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
        <tag>第159场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1283 | 二分查找解决“使结果不超过阈值的最小除数”</title>
    <url>//posts/leetcode-1283/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1283 题：<a href="https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/description/">使结果不超过阈值的最小除数</a>。<br>本题的核心在于识别出“除数”与“结果和”之间的单调性，从而将问题转化为一个经典的“在答案空间上进行二分查找”的场景。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目要求我们寻找一个<strong>最小的正整数除数</strong>，用这个除数去除数组 <code>nums</code> 中的每个元素，并将所有结果<strong>向上取整</strong>后求和。最终，这个和必须小于或等于给定的 <code>threshold</code>。</p>
<p>关键点在于“向上取整”。例如，<code>7 / 3 = 2.33...</code>，向上取整后是 <code>3</code>；<code>10 / 2 = 5</code>，向上取整后还是 <code>5</code>。</p>
<p>我们来看一个例子：<code>nums = [1,2,5,9], threshold = 6</code>。</p>
<ul>
<li>如果选择除数为 1，和为 <code>ceil(1/1) + ceil(2/1) + ceil(5/1) + ceil(9/1) = 1 + 2 + 5 + 9 = 17</code>。<code>17 &gt; 6</code>，不满足条件。</li>
<li>如果选择除数为 4，和为 <code>ceil(1/4) + ceil(2/4) + ceil(5/4) + ceil(9/4) = 1 + 1 + 2 + 3 = 7</code>。<code>7 &gt; 6</code>，不满足条件。</li>
<li>如果选择除数为 5，和为 <code>ceil(1/5) + ceil(2/5) + ceil(5/5) + ceil(9/5) = 1 + 1 + 1 + 2 = 5</code>。<code>5 &lt;= 6</code>，满足条件。</li>
</ul>
<p>我们找到了一个满足条件的除数 <code>5</code>。但题目要求的是<strong>最小</strong>的那个。我们可以继续验证，发现除数 <code>4</code> 不满足条件，因此 <code>5</code> 就是我们要找的最小除数。</p>
<h3 id="核心思路：在答案上进行二分查找"><a href="#核心思路：在答案上进行二分查找" class="headerlink" title="核心思路：在答案上进行二分查找"></a>核心思路：在答案上进行二分查找</h3><p>一个朴素的想法是，从除数 <code>d = 1</code> 开始，逐个向上尝试，计算每次的和，直到找到第一个满足 <code>sum &lt;= threshold</code> 的除数。然而，<code>nums</code> 中的元素最大可达 <code>10^6</code>，这意味着除数的取值范围也可能很大，线性遍历非常耗时，可能会超时。</p>
<p>这时，我们需要观察问题是否存在某种<strong>单调性</strong>。</p>
<ul>
<li>当<strong>除数增大</strong>时，数组中每个元素 <code>num / divisor</code> 的结果会减小或不变。</li>
<li>因此，所有结果向上取整后的<strong>总和也会减小或不变</strong>。</li>
</ul>
<p>这种“除数”与“总和”之间的单调递减关系，是使用<strong>二分查找</strong>的绝佳信号。我们可以对<strong>答案（也就是除数）本身</strong>进行二分查找。</p>
<ol>
<li><p><strong>确定搜索范围</strong>：</p>
<ul>
<li>除数最小也得是 <code>1</code>，这是我们的左边界。</li>
<li>除数最大是多少呢？如果除数等于 <code>max(nums)</code>，那么每个数相除的结果向上取整后不是 <code>1</code> 就是 <code>0</code>（正整数没有0），所以和最大是 <code>len(nums)</code>。如果除数比 <code>max(nums)</code> 还大，和依然是 <code>len(nums)</code>。因此，将搜索范围的右边界设为 <code>max(nums)</code> 是一个合理的上界。</li>
</ul>
</li>
<li><p><strong>二分过程</strong>：</p>
<ul>
<li>取搜索范围 <code>[left, right]</code> 的中间值 <code>mid</code> 作为候选的除数。</li>
<li>计算当除数为 <code>mid</code> 时的总和。</li>
<li>如果 <code>sum &lt;= threshold</code>，说明 <code>mid</code> 是一个<strong>可能</strong>的解，但我们想找更小的，所以我们尝试在 <code>[left, mid]</code> 这个更小的区间里继续寻找。</li>
<li>如果 <code>sum &gt; threshold</code>，说明 <code>mid</code> 这个除数太小了，导致和超标了。我们需要一个更大的除数，所以在 <code>[mid + 1, right]</code> 区间里继续寻找。</li>
</ul>
</li>
</ol>
<p>通过不断缩小搜索范围，我们最终可以锁定满足条件的最小除数。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分边界</strong></p>
<ul>
<li>左边界 <code>l</code>：最小可能的除数是 <code>1</code>。</li>
<li>右边界 <code>r</code>：最大可能的除数是 <code>max(nums)</code>。</li>
<li><em>注意</em>：代码实现中 <code>l</code> 从 <code>0</code> 开始，但因为 <code>mid</code> 的计算和 <code>l</code> 的更新方式，<code>mid</code> 永远不会是 <code>0</code>，不影响结果。</li>
</ul>
</li>
<li><p><strong>编写 <code>check</code> 函数（求和逻辑）</strong></p>
<ul>
<li>这是二分查找的核心判断条件。给定一个除数 <code>d</code>，我们需要计算 <code>sum(ceil(x/d) for x in nums)</code>。</li>
<li>在整数运算中，<code>ceil(x/d)</code> 有一个巧妙的等价转换：<code>(x + d - 1) // d</code>。</li>
<li>代码中使用了另一个更精妙的转换：<code>ceil(x/d) = (x - 1) // d + 1</code>。</li>
<li>因此，<code>sum(ceil(x/d))</code> 等于 <code>sum((x - 1) // d + 1)</code>，进一步等于 <code>sum((x - 1) // d) + len(nums)</code>。</li>
<li>所以，判断条件 <code>sum(ceil(x/d)) &lt;= threshold</code> 就等价于 <code>sum((x - 1) // d) + len(nums) &lt;= threshold</code>，即 <code>sum((x - 1) // d) &lt;= threshold - len(nums)</code>。这正是代码中所使用的判断逻辑，它通过预先减掉 <code>len(nums)</code> 使得循环内的计算更简洁。</li>
</ul>
</li>
<li><p><strong>循环二分</strong></p>
<ul>
<li>采用 <code>while l + 1 &lt; r</code> 的二分模板。这个模板的循环终止条件是 <code>l</code> 和 <code>r</code> 相邻。</li>
<li>在循环中，计算 <code>mid = (l + r) // 2</code>。</li>
<li>如果 <code>mid</code> 满足条件（和小于等于阈值），说明 <code>mid</code> 是一个潜在的答案，或者还有更小的答案。我们将上界收缩到 <code>mid</code>，即 <code>r = mid</code>，去左半边寻找更优解。</li>
<li>如果 <code>mid</code> 不满足条件，说明 <code>mid</code> 太小了，必须选择一个更大的除数。我们将下界提升到 <code>mid</code>，即 <code>l = mid</code>，去右半边寻找解。</li>
<li>循环结束后，<code>r</code> 就指向了满足条件的最小除数。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestDivisor</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], threshold: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1: 确定二分查找的边界</span></span><br><span class="line">        <span class="comment"># 左边界 l 可以从 0 或 1 开始，因为除数最小为 1。</span></span><br><span class="line">        <span class="comment"># 右边界 r 是数组中的最大值，更大的除数不会产生更小的和。</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">max</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 循环二分</span></span><br><span class="line">        <span class="comment"># 采用 l + 1 &lt; r 的模板，循环直到 l 和 r 相邻</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 防止除以 0 的情况</span></span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span>:</span><br><span class="line">                l = mid</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 2: check 函数逻辑</span></span><br><span class="line">            <span class="comment"># 计算以 mid 为除数时的总和</span></span><br><span class="line">            <span class="comment"># ceil(x/mid) 等价于 (x-1)//mid + 1</span></span><br><span class="line">            <span class="comment"># sum((x-1)//mid + 1) &lt;= threshold 变形为:</span></span><br><span class="line">            <span class="comment"># sum((x-1)//mid) &lt;= threshold - len(nums)</span></span><br><span class="line">            current_sum = <span class="built_in">sum</span>((x - <span class="number">1</span>) // mid <span class="keyword">for</span> x <span class="keyword">in</span> nums)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> current_sum &lt;= threshold - <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="comment"># 如果和满足条件，说明 mid 是一个可能的解</span></span><br><span class="line">                <span class="comment"># 我们尝试寻找更小的解，所以收缩上界</span></span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果和不满足条件，说明 mid 太小了</span></span><br><span class="line">                <span class="comment"># 我们需要更大的除数，所以收缩下界</span></span><br><span class="line">                l = mid</span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 循环结束时, r 是满足条件的最小除数</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>: O(N * log K)</p>
<ul>
<li>其中 <code>N</code> 是数组 <code>nums</code> 的长度，<code>K</code> 是 <code>nums</code> 数组中的最大值。</li>
<li>二分查找的搜索空间大小为 <code>K</code>，因此二分过程需要进行 O(log K) 次迭代。</li>
<li>在每一次迭代中，我们都需要遍历整个 <code>nums</code> 数组来计算总和，这个操作的复杂度是 O(N)。</li>
<li>因此，总的时间复杂度是 O(N * log K)。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>: O(1)</p>
<ul>
<li>算法在执行过程中只使用了有限的几个变量（如 <code>l</code>, <code>r</code>, <code>mid</code>, <code>current_sum</code>），没有使用额外的、与输入规模相关的存储空间。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是二分查找思想的一个典型应用，但它并非直接在输入数组上进行查找，而是在**可能解的范围（答案空间）**上进行查找。解决这类问题的关键在于：</p>
<ol>
<li>分析问题，发现输入与输出之间的单调关系。</li>
<li>确定这个单调关系的定义域，即二分查找的上下边界。</li>
<li>将原问题转化为一个“判定问题”（Check 函数）：给定一个候选解 <code>mid</code>，能否在 O(N) 时间内判断它是否满足条件？</li>
</ol>
<p>一旦这三步完成，就可以套用二分查找模板来高效地解决问题，将时间复杂度从可能的 O(N<em>K) 优化到 O(N</em>log K)。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最小</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>第166场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1287 | 有序数组中出现次数超过四分之一的元素</title>
    <url>//posts/leetcode-1287/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1287 题：<a href="https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/description/">有序数组中出现次数超过四分之一的元素</a>。<br>这道题的优雅解法，完美诠释了如何利用问题的内在约束（“超过25%”）和数据特性（“有序”），将一个看似需要线性扫描的问题，转化为仅需常数次检查的对数级别算法。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="算法优化特性：从-O-n-到-O-log-n-的飞跃"><a href="#算法优化特性：从-O-n-到-O-log-n-的飞跃" class="headerlink" title="算法优化特性：从 O(n) 到 O(log n) 的飞跃"></a>算法优化特性：从 O(n) 到 O(log n) 的飞跃</h3><p>面对这个问题，最直观的想法是遍历整个数组，使用哈希表或计数器来统计每个数字的出现次数，时间复杂度为 O(n)。但题目给出了一个至关重要的线索：<strong>数组是有序的</strong>。这个特性让我们有机会使用二分查找来进行优化。</p>
<p>然而，对谁进行二分查找呢？我们不可能对每个元素都去计算其出现次数，这样效率会更低。</p>
<p>关键的优化点来自对 <strong>“超过 25%”</strong> 这个条件的深度挖掘。如果一个元素在长度为 <code>n</code> 的数组中出现次数超过 <code>n/4</code> 次，那么这个元素的分佈必然具有一个非常特殊的性质，这使得我们<strong>不需要检查所有元素</strong>，而只需要检查<strong>几个固定的“候选”位置</strong>即可。</p>
<p>这个思想将遍历所有元素的 O(n) 思路，降维成了检查常数个候选元素，每次检查使用二分查找，最终实现了 O(log n) 的时间复杂度。</p>
<h3 id="正确性证明：为何只需检查几个点？"><a href="#正确性证明：为何只需检查几个点？" class="headerlink" title="正确性证明：为何只需检查几个点？"></a>正确性证明：为何只需检查几个点？</h3><p>算法的核心是基于一个类似<strong>鸽巢原理</strong>的简单证明：一个长度超过 <code>n/4</code> 的连续区块，不可能完全“躲藏”在数组的四个“角落”里，它必然会跨越我们设定的几个关键“检查点”。</p>
<p>下面我们来严谨地证明这一点。</p>
<ol>
<li><p><strong>定义问题</strong></p>
<ul>
<li>设数组 <code>arr</code> 的长度为 <code>n</code>。</li>
<li>我们要找的特殊整数为 <code>x</code>，其出现次数为 <code>k</code>。</li>
<li>根据题意，<code>k &gt; n / 4</code>。由于 <code>k</code> 是整数，这等价于 <code>k &gt;= floor(n / 4) + 1</code>。</li>
</ul>
</li>
<li><p><strong>利用有序性</strong></p>
<ul>
<li>因为数组是<strong>非递减</strong>的，所有 <code>k</code> 个 <code>x</code> 必定是<strong>连续排列</strong>的。它们会形成一个长度为 <code>k</code> 的连续区块。</li>
</ul>
</li>
<li><p><strong>设置检查点</strong></p>
<ul>
<li>我们可以将数组从概念上分为四段。最直观的分割点（即我们的“检查点”）是位于 <code>n/4</code>, <code>n/2</code>, 和 <code>3n/4</code> 位置上的元素。</li>
<li>为了方便，我们考虑下取整的索引：<code>idx_1 = n // 4</code>, <code>idx_2 = n // 2</code>, <code>idx_3 = 3 * n // 4</code>。</li>
<li>我们的论点是：特殊整数 <code>x</code> <strong>必然</strong>是 <code>arr[idx_1]</code>, <code>arr[idx_2]</code>, <code>arr[idx_3]</code> 中的一个。</li>
</ul>
</li>
<li><p><strong>反证法证明</strong></p>
<ul>
<li>假设特殊整数 <code>x</code> <strong>不是</strong>这三个检查点中的任何一个。</li>
<li>那么，<code>x</code> 所形成的长度为 <code>k</code> 的连续区块，必须完整地存在于由这些检查点分割出的四个“间隙”之一中：<ol>
<li><code>[0, idx_1 - 1]</code></li>
<li><code>[idx_1 + 1, idx_2 - 1]</code></li>
<li><code>[idx_2 + 1, idx_3 - 1]</code></li>
<li><code>[idx_3 + 1, n - 1]</code></li>
</ol>
</li>
<li>现在我们来计算这些“间隙”的最大长度。最长的间隙是第一个，其长度为 <code>(idx_1 - 1) - 0 + 1 = idx_1 = n // 4</code>。其他间隙的长度都不会超过 <code>n // 4</code>。</li>
<li>我们得到一个结论：任何不包含检查点的连续区间，其长度<strong>最大为 <code>n // 4</code></strong>。</li>
<li>这与我们已知的事实——<code>x</code> 的连续区块长度 <code>k</code> <strong>严格大于 <code>n / 4</code></strong>——产生了矛盾！</li>
<li>因此，最初的假设（<code>x</code> 不是任何一个检查点元素）是错误的。</li>
</ul>
</li>
</ol>
<p><strong>结论：</strong> 特殊整数 <code>x</code> 必然是 <code>arr[n//4]</code>, <code>arr[n//2]</code>, 或 <code>arr[3*n//4]</code> 中的一个（或多个）。我们只需要将这三个位置的元素作为候选者，验证它们中哪一个的出现次数超过 <code>n/4</code> 即可。</p>
<h3 id="巧妙的实现"><a href="#巧妙的实现" class="headerlink" title="巧妙的实现"></a>巧妙的实现</h3><p>验证一个候选者 <code>cand</code> 的次数，最直接的方法是找到它的左右边界：<code>count = bisect_right(arr, cand) - bisect_left(arr, cand)</code>。</p>
<p>而下列代码则采用了一种更精炼的“前向检查”技巧，避免了第二次二分查找：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSpecialInteger</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="comment"># 任何出现次数 &gt; n/4 的元素，其个数至少为 m + 1</span></span><br><span class="line">        m = n // <span class="number">4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 候选检查点的索引。其原理是：长度 &gt; m 的连续块必然会跨过这些点之一。</span></span><br><span class="line">        <span class="comment"># 这里选择的点集 (m, 2m+1, ...) 也能起到分割作用，确保间隙长度不大于 m</span></span><br><span class="line">        candidates_indices = (m, m * <span class="number">2</span> + <span class="number">1</span>, m * <span class="number">3</span> + <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> candidates_indices:</span><br><span class="line">            <span class="comment"># 数组边界保护</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= n:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            candidate = arr[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 1. 找到该候选者第一次出现的位置</span></span><br><span class="line">            first_occurrence_idx = bisect.bisect_left(arr, candidate)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 2. 精髓：从第一次出现的位置向后数 m 个位置</span></span><br><span class="line">            <span class="comment"># 如果目标索引仍在数组界内，并且其值仍然是 candidate</span></span><br><span class="line">            <span class="comment"># 则证明从 first_occurrence_idx 到 first_occurrence_idx + m</span></span><br><span class="line">            <span class="comment"># 这 m + 1 个元素都是 candidate，计数达标。</span></span><br><span class="line">            target_idx = first_occurrence_idx + m</span><br><span class="line">            <span class="keyword">if</span> target_idx &lt; n <span class="keyword">and</span> arr[target_idx] == candidate:</span><br><span class="line">                <span class="keyword">return</span> candidate</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 基于题目“恰好有一个”答案的保证，在大多数情况下循环会提前返回。</span></span><br><span class="line">        <span class="comment"># 为覆盖所有边界情况（例如数组长度很短），返回 arr[0] 作为保底。</span></span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码的巧妙之处在于：</p>
<ol>
<li><strong>高效验证</strong>：通过 <code>bisect_left</code> 找到起始点 <code>j</code>，然后直接检查 <code>arr[j + m]</code> 的值。如果它仍然是我们的候选者，就意味着从 <code>j</code> 到 <code>j+m</code>（共 <code>m+1</code> 个）都是同一个数，直接满足了 <code>&gt; n/4</code> 的条件。这比“找左边界再找右边界”的方式更高效。</li>
<li><strong>候选者选择</strong>：选择 <code>m</code>, <code>2m+1</code>, <code>3m+2</code> 等作为检查点索引，同样可以保证覆盖所有可能性，因为它们之间的间隔小于等于 <code>m+1</code>，而目标元素的区块长度大于 <code>m</code>。</li>
<li><strong>确定性</strong>：由于题目保证了答案“恰好有一个”，所以我们测试的几个候选者中必然会有一个满足条件并被返回。</li>
</ol>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(logn)，其中 n 是 arr 的长度。</li>
<li><strong>空间复杂度</strong>: O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>鸽巢原理</tag>
        <tag>第15场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1610 | 几何与滑动窗口：求解可见点的最大数目</title>
    <url>//posts/leetcode-1610/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1610 题：<a href="https://leetcode.cn/problems/maximum-number-of-visible-points/">可见点的最大数目</a>。<br>这道题将一个几何问题巧妙地包装起来，表面上看是在一个二维平面内旋转视野，但其核心可以转化为一个在一维数组上处理循环问题的经典滑动窗口场景。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一组二维点 <code>points</code>，一个观察者的位置 <code>location</code>，以及一个视野角度 <code>angle</code>。我们可以站在 <code>location</code> 原地旋转，视野范围是一个宽度为 <code>angle</code> 的扇形区域。我们需要找到一个最佳的朝向，使得能看到的点的数量最多。</p>
<p>有几个关键点需要注意：</p>
<ol>
<li>与观察者位置重合的点，永远都是可见的。</li>
<li>点不会遮挡其他点。</li>
<li>我们需要求解的是<strong>最多</strong>能同时看到多少个点。</li>
</ol>
<p>直接去模拟旋转并计算每个角度下可见点的数量，无疑是低效且复杂的。我们需要一种更数学化、更高效的方法来解决这个问题。</p>
<h3 id="核心思路：坐标转换与滑动窗口"><a href="#核心思路：坐标转换与滑动窗口" class="headerlink" title="核心思路：坐标转换与滑动窗口"></a>核心思路：坐标转换与滑动窗口</h3><p>这个问题的核心在于，将二维的坐标问题，转化为一维的角度问题。</p>
<ol>
<li><p><strong>坐标系中心化</strong>：首先，我们将观察者的位置 <code>location</code> 视为坐标原点 <code>(0,0)</code>。所有 <code>points</code> 都需要进行相应的平移，即 <code>(px, py)</code> 变为 <code>(px - loc_x, py - loc_y)</code>。</p>
</li>
<li><p><strong>计算极角</strong>：对于每一个平移后的点，我们可以计算它相对于新原点（即观察者位置）和正东方向（x轴正方向）的夹角。在编程中，<code>math.atan2(y, x)</code> 函数是完成这项工作的完美工具，它可以精确地计算出 <code>(-π, π]</code> 范围内的弧度。我们再将弧度转换为 <code>(-180, 180]</code> 范围内的角度。</p>
</li>
<li><p><strong>处理循环问题</strong>：现在，所有的点都被映射到了一系列角度上。我们的视野是一个宽度为 <code>angle</code> 的“窗口”，可以在 <code>[-180, 180]</code> 这个角度圈上滑动。这里最大的挑战是<strong>循环性</strong>。例如，如果 <code>angle</code> 是 90 度，一个从 350 度开始的视野会覆盖到 <code>[350, 360]</code> 和 <code>[0, 80]</code> 这个范围。直接在数组上处理这种跨越边界的情况非常麻烦。</p>
<p><strong>关键技巧</strong>：为了打破这个循环，我们可以将角度数组“线性化”。首先对所有角度进行排序。然后，我们将每个角度值加上 360 度，并将这些新值追加到原数组的末尾。例如，一个排序后的角度数组 <code>[10, 150, 350]</code> 会被扩展为 <code>[10, 150, 350, 370, 510, 710]</code>。</p>
<p>这样做之后，一个从 350 度到 10 度的视野，就等价于在扩展数组中一个从 350 度到 370 度 (<code>10 + 360</code>) 的连续区间。问题就转化成了一个标准的滑动窗口问题。</p>
</li>
<li><p><strong>应用滑动窗口</strong>：在新生成的、线性且有序的角度数组上，我们寻找一个窗口，其宽度（即 <code>angles[right] - angles[left]</code>）不超过 <code>angle</code>，并使其包含的元素数量最多。</p>
</li>
</ol>
<p>最终，滑动窗口找到的最大点数，加上一开始就统计好的、与观察者位置重合的点数，就是我们的答案。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>预处理</strong>：</p>
<ul>
<li>创建一个空列表 <code>angles</code> 用于存放所有点的角度。</li>
<li>初始化一个计数器 <code>same_location_points = 0</code>。</li>
<li>遍历所有 <code>points</code>，如果一个点与 <code>location</code> 重合，则 <code>same_location_points</code> 加一。</li>
</ul>
</li>
<li><p><strong>计算并转换角度</strong>：</p>
<ul>
<li>对于不与 <code>location</code> 重合的点，将其坐标相对于 <code>location</code> 平移。</li>
<li>使用 <code>math.atan2(y, x)</code> 计算角度（弧度制），然后用 <code>math.degrees()</code> 转换为角度制。将结果存入 <code>angles</code> 列表。</li>
</ul>
</li>
<li><p><strong>排序与数组扩展</strong>：</p>
<ul>
<li>对 <code>angles</code> 列表进行升序排序。</li>
<li>为了处理视野跨越 0&#x2F;360 度的情况，遍历排序后的 <code>angles</code> 列表，将每个角度 <code>a</code> 加上 360 后，作为一个新元素追加到 <code>angles</code> 列表的末尾。</li>
</ul>
</li>
<li><p><strong>滑动窗口</strong>：</p>
<ul>
<li>初始化左指针 <code>left = 0</code> 和最大可见点数 <code>max_visible = 0</code>。</li>
<li>用右指针 <code>right</code> 从 <code>0</code> 开始遍历扩展后的 <code>angles</code> 数组。</li>
<li>在循环中，检查当前窗口 <code>angles[left]</code> 到 <code>angles[right]</code> 的角度差是否大于 <code>angle</code>。</li>
<li>如果 <code>angles[right] - angles[left] &gt; angle</code>，说明窗口过大，需要收缩。我们将 <code>left</code> 指针向右移动，直到窗口重新满足条件。</li>
<li>在每次移动 <code>right</code> 之后（并可能收缩 <code>left</code> 之后），当前窗口 <code>s[left:right+1]</code> 是一个有效的视野范围。我们用它的长度 <code>right - left + 1</code> 来更新 <code>max_visible</code>。</li>
</ul>
</li>
<li><p><strong>计算最终答案</strong>：</p>
<ul>
<li>遍历结束后，<code>max_visible</code> 就是在非重合点中能看到的最大数量。</li>
<li>最终结果是 <code>max_visible + same_location_points</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">visiblePoints</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], angle: <span class="built_in">int</span>, location: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        angles = []</span><br><span class="line">        same_location_points = <span class="number">0</span></span><br><span class="line">        loc_x, loc_y = location[<span class="number">0</span>], location[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 1 &amp; 2: 处理重合点并计算所有其他点的角度</span></span><br><span class="line">        <span class="keyword">for</span> p_x, p_y <span class="keyword">in</span> points:</span><br><span class="line">            <span class="keyword">if</span> p_x == loc_x <span class="keyword">and</span> p_y == loc_y:</span><br><span class="line">                same_location_points += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 使用 atan2 计算弧度，再转换为角度</span></span><br><span class="line">                rad = math.atan2(p_y - loc_y, p_x - loc_x)</span><br><span class="line">                angles.append(math.degrees(rad))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 排序并扩展数组以处理循环</span></span><br><span class="line">        angles.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(angles)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            angles.append(angles[i] + <span class="number">360.0</span>)</span><br><span class="line">            </span><br><span class="line">        max_visible = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果除了重合点外没有其他点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> angles:</span><br><span class="line">            <span class="keyword">return</span> same_location_points</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 4: 滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(angles)):</span><br><span class="line">            <span class="comment"># 如果窗口角度范围超过 angle，收缩左边界</span></span><br><span class="line">            <span class="keyword">while</span> angles[right] - angles[left] &gt; angle:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新最大可见点数</span></span><br><span class="line">            max_visible = <span class="built_in">max</span>(max_visible, right - left + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 步骤 5: 最终结果是窗口内的最大点数加上重合点数</span></span><br><span class="line">        <span class="keyword">return</span> max_visible + same_location_points</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N log N)。其中 N 是点的数量。算法的瓶颈在于对所有点的角度进行排序。计算角度和滑动窗口部分都是 O(N) 的。</li>
<li><strong>空间复杂度</strong>: O(N)。我们需要一个列表来存储 N 个点的角度，并且为了处理循环问题，这个列表的长度会翻倍。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是一个很好的例子，展示了如何将一个几何问题抽象和转化为我们熟悉的算法模型。核心的转化步骤有两步：</p>
<ol>
<li><strong>降维</strong>：通过计算极角，将二维坐标问题转化为一维的角度数组问题。</li>
<li><strong>线性化</strong>：通过排序和扩展数组，将一个循环数组上的问题转化为一个普通线性数组上的问题。</li>
</ol>
<p>完成这两步转化后，问题就变成了一个可以用滑动窗口模板轻松解决的经典问题。这个“扩展数组以处理循环”的技巧在很多涉及环形数组的问题中都非常有用。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
        <tag>数学</tag>
        <tag>排序</tag>
        <tag>几何</tag>
        <tag>第209场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1658 | 逆向思维+滑动窗口求解“将 x 减到 0 的最小操作数”</title>
    <url>//posts/leetcode-1658/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1658 题：<a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/">将 x 减到 0 的最小操作数</a>。<br>这道题看似复杂，因为它允许从数组的两端进行操作。但只要我们转换一下思路，它就会变成一个非常经典的滑动窗口问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目要求我们从一个整数数组 <code>nums</code> 的最左边或最右边移除元素，每次移除一个元素，它的值就从 <code>x</code> 中减去。目标是用<strong>最少的操作次数</strong>将 <code>x</code> 恰好减到 0。</p>
<p>我们来分析一下这个操作：</p>
<ul>
<li>可以只从左边移除</li>
<li>可以只从右边移除</li>
<li>可以两边都移除</li>
</ul>
<p>例如，对于 <code>nums = [1,1,4,2,3], x = 5</code>：</p>
<ul>
<li>我们可以从左边移除 <code>1</code> 和 <code>1</code>，再从右边移除 <code>3</code>，总和为 <code>1+1+3=5</code>，操作 3 次。</li>
<li>我们也可以直接从右边移除 <code>3</code> 和 <code>2</code>，总和为 <code>3+2=5</code>，操作 2 次。</li>
</ul>
<p>因为 <code>2 &lt; 3</code>，所以最小操作数是 2。</p>
<p>直接模拟所有“左边取 i 个，右边取 j 个”的组合会非常低效。我们需要找到一个更优雅的切入点。</p>
<h3 id="核心思路：逆向思维与问题转化"><a href="#核心思路：逆向思维与问题转化" class="headerlink" title="核心思路：逆向思维与问题转化"></a>核心思路：逆向思维与问题转化</h3><p>直接求解“两端移除的最小元素数量”比较困难，那我们不妨换个角度思考：<strong>当我们从两端移除一部分元素后，剩下的是什么？</strong></p>
<p>答案是：<strong>一个连续的、位于数组中间的子数组。</strong></p>
<p>我们的目标是让移除的元素之和恰好为 <code>x</code>，并且移除的元素数量最少。这等价于什么呢？</p>
<p><strong>让保留在中间的子数组最长！</strong></p>
<p>如果数组的总和是 <code>total_sum</code>，要移除的元素之和是 <code>x</code>，那么保留在中间的那个连续子数组，其元素之和就必须是 <code>target = total_sum - x</code>。</p>
<p>这样一来，原问题就被我们巧妙地转化成了另一个问题：<br><strong>在数组 <code>nums</code> 中，找到一个和为 <code>total_sum - x</code> 的最长的连续子数组。</strong></p>
<p>只要我们找到了这个最长的子数组，用数组的总长度 <code>n</code> 减去这个子数组的长度，就是我们要求的“最小操作数”。</p>
<p>而“寻找和为定值的最长连续子数组”正是一个可以用滑动窗口高效解决的经典问题！</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>问题转化</strong>:</p>
<ul>
<li>首先计算整个数组的总和 <code>total_sum</code>。</li>
<li>计算出我们要在中间寻找的目标子数组的和 <code>target = total_sum - x</code>。</li>
<li>处理一些边界情况：<ul>
<li>如果 <code>target &lt; 0</code>，说明 <code>x</code> 本身就比数组所有元素之和还大，不可能凑成，返回 <code>-1</code>。</li>
<li>如果 <code>target == 0</code>，说明需要移除所有元素才能使 <code>x</code> 减到 0，此时最长的中间子数组为空，但我们需要移除所有元素，答案是数组长度 <code>n</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>滑动窗口求解</strong>:</p>
<ul>
<li>现在，我们在数组 <code>nums</code> 上寻找和为 <code>target</code> 的最长连续子数组。</li>
<li>初始化左指针 <code>left = 0</code>，当前窗口内元素的和 <code>current_sum = 0</code>，以及记录最长长度的 <code>max_len = -1</code>（-1 表示尚未找到）。</li>
<li>使用右指针 <code>right</code> 遍历数组，<code>right</code> 每向右移动一步，就将 <code>nums[right]</code> 加入 <code>current_sum</code>，这代表窗口在向右扩张。</li>
<li>当 <code>current_sum &gt; target</code> 时，说明当前窗口的和太大了，需要缩小。我们让 <code>left</code> 指针向右移动，并从 <code>current_sum</code> 中减去 <code>nums[left]</code>，直到 <code>current_sum &lt;= target</code>。</li>
<li>在每一步扩张或收缩后，如果 <code>current_sum == target</code>，我们就找到了一个符合条件的子数组。计算其长度 <code>right - left + 1</code>，并更新 <code>max_len</code>。</li>
</ul>
</li>
<li><p><strong>计算最终结果</strong>:</p>
<ul>
<li>遍历结束后，如果 <code>max_len</code> 仍然是 <code>-1</code>，说明数组中不存在和为 <code>target</code> 的子数组，即无法通过移除操作使 <code>x</code> 减到 0，返回 <code>-1</code>。</li>
<li>否则，最小操作数就是 <code>n - max_len</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        total_sum = <span class="built_in">sum</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1: 问题转化，计算目标和</span></span><br><span class="line">        target = total_sum - x</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 边界情况：x 大于数组总和，无解</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 边界情况：需要移除所有元素</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2: 滑动窗口寻找和为 target 的最长子数组</span></span><br><span class="line">        max_len = -<span class="number">1</span>  <span class="comment"># 记录最长子数组的长度</span></span><br><span class="line">        current_sum = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span>  <span class="comment"># 窗口左边界</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 窗口右边界扩张</span></span><br><span class="line">            current_sum += nums[right]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当窗口和大于 target 时，收缩左边界</span></span><br><span class="line">            <span class="keyword">while</span> current_sum &gt; target <span class="keyword">and</span> left &lt;= right:</span><br><span class="line">                current_sum -= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果窗口和等于 target，更新最大长度</span></span><br><span class="line">            <span class="keyword">if</span> current_sum == target:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 3: 计算最终结果</span></span><br><span class="line">        <span class="comment"># 如果 max_len 未被更新，说明找不到满足条件的子数组</span></span><br><span class="line">        <span class="keyword">if</span> max_len == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> n - max_len</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是数组 <code>nums</code> 的长度。滑动窗口的左、右指针 <code>left</code> 和 <code>right</code> 都只会从头到尾遍历数组一次，因此总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个额外变量（如 <code>left</code>, <code>right</code>, <code>current_sum</code> 等），没有使用额外的数据结构。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题的核心在于<strong>逆向思维</strong>。当我们面对一个从两端操作、看似复杂的问题时，不妨思考一下操作的“补集”是什么。通过将“求两端最小移除数”转化为“求中间最长保留数”，问题瞬间豁然开朗，变成了一个我们非常熟悉的滑动窗口模板题。这个思路在很多算法题中都非常有效，是工具箱中必备的思维技巧。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>前缀和</tag>
        <tag>第215场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1763 | 滑动窗口求解“最长的美好子字符串”</title>
    <url>//posts/leetcode-1763/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1763 题：<a href="https://leetcode.cn/problems/longest-nice-substring/description/">最长的美好子字符串</a>。<br>该题要求在字符串中寻找一个最长的子串且其中每个字母大小写必须同时存在。直接枚举所有子串的复杂度较高，我们可以通过枚举子串的“属性”，将问题转化为滑动窗口来高效求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目定义了一个“美好字符串”：对于字符串中出现的任意一种字母，它的大写和小写形式必须同时存在。例如 <code>&quot;aAa&quot;</code> 是美好的，因为 <code>&#39;a&#39;</code> 和 <code>&#39;A&#39;</code> 都出现了。而 <code>&quot;abA&quot;</code> 不是美好的，因为 <code>&#39;b&#39;</code> 出现了但 <code>&#39;B&#39;</code> 没有。</p>
<p>我们的任务是，给定一个字符串 <code>s</code>，找到它最长的一个“美好子字符串”。如果长度相同，返回最先出现的那一个。</p>
<p>直接用暴力法（枚举所有子串 <code>s[i:j]</code> 并逐一检查）的时间复杂度会达到 O(N³)，对于 <code>N=100</code> 的限制虽然可行，但不够优雅。我们可以构思一个更高效的算法。</p>
<h3 id="核心思路：枚举字符类型的滑动窗口"><a href="#核心思路：枚举字符类型的滑动窗口" class="headerlink" title="核心思路：枚举字符类型的滑动窗口"></a>核心思路：枚举字符类型的滑动窗口</h3><p>一个常规的滑动窗口通常依赖于一个单调的性质（比如窗口内不同字符数不超过 <code>k</code>）。但“美好”这个性质并非单调的：给一个美好的子串 <code>&quot;aA&quot;</code> 添加一个字符 <code>&#39;b&#39;</code> 会使其变得不美好；给一个不美好的子串 <code>&quot;aAb&quot;</code> 添加 <code>&#39;B&#39;</code> 又可能使其变得美好。</p>
<p>这种性质的复杂性让我们很难用一个简单的规则来收缩窗口。此时，一个高级的技巧是**“枚举窗口属性”<strong>。与其让窗口自己寻找满足复杂条件的子串，不如我们</strong>指定窗口应该满足的某个简单属性**，然后用滑动窗口来寻找符合这个简单属性的最优解。</p>
<p>在这里，我们可以枚举美好子串中<strong>包含的唯一字母类型的数量</strong>，设为 <code>k</code>（例如，<code>&quot;aAZ&quot;</code> 包含 <code>&#39;a&#39;/&#39;A&#39;</code> 和 <code>&#39;z&#39;/&#39;Z&#39;</code> 两种类型，所以 <code>k=2</code>）。<code>k</code> 的取值范围是 1 到 26。</p>
<p>对于每一个固定的 <code>k</code>，问题就转化为：<strong>寻找一个最长的子字符串，它恰好包含 <code>k</code> 种字母类型，并且这 <code>k</code> 种类型都是“美好”的（即大小写齐全）。</strong></p>
<p>这个问题就非常适合用滑动窗口来解决了。窗口需要维护两个核心信息：</p>
<ol>
<li>当前窗口内有多少种唯一字母类型。</li>
<li>这其中，有多少种是“美好”的。</li>
</ol>
<p>当两个计数器都等于我们正在枚举的 <code>k</code> 时，就意味着我们找到了一个候选的子字符串。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>外层循环</strong>：我们用一个循环来枚举唯一字母类型的数量 <code>k</code>，从 1 遍历到 26。</p>
</li>
<li><p><strong>内层滑动窗口</strong>：对于每个 <code>k</code>，我们执行一次完整的滑动窗口遍历。</p>
<ul>
<li><strong>状态维护</strong>：我们需要 <code>lower_count</code> 和 <code>upper_count</code> 两个数组来记录窗口内26个字母大小写的频率。此外，还需要两个计数器：<code>unique_types</code> 记录窗口内唯一字母类型的总数，<code>nice_types</code> 记录大小写都存在的字母类型数。</li>
<li><strong>扩张窗口</strong>：<code>right</code> 指针向右移动，将新字符 <code>s[right]</code> 纳入窗口。相应地更新 <code>lower/upper_count</code> 数组，并根据新字符的加入，判断 <code>unique_types</code> 和 <code>nice_types</code> 是否需要增加。</li>
<li><strong>收缩窗口</strong>：扩张后，如果 <code>unique_types &gt; k</code>，说明当前窗口包含的字母类型太多了，不符合我们对 <code>k</code> 的设定。此时需要移动 <code>left</code> 指针向右，从窗口中移除 <code>s[left]</code>，并同步更新 <code>lower/upper_count</code> 和两个计数器。这个过程一直持续到 <code>unique_types &lt;= k</code> 为止。</li>
<li><strong>更新答案</strong>：当窗口收缩完毕后（也可能无需收缩），我们检查是否满足 <code>unique_types == k</code> 并且 <code>nice_types == k</code>。如果满足，说明当前窗口 <code>s[left:right+1]</code> 就是一个恰好包含 <code>k</code> 种美好字母类型的子串。我们用它的长度来更新全局的最大长度和起始位置。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：外层循环结束后，记录下的最长长度和起始位置对应的子串即为最终答案。</p>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestNiceSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        result_start = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># k: 枚举窗口中唯一字母类型的数量</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">27</span>):</span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            lower_count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            upper_count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            unique_types = <span class="number">0</span></span><br><span class="line">            nice_types = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># --- 1. 右指针扩张窗口 ---</span></span><br><span class="line">                char_r = s[right]</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> &lt;= char_r &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">                    idx = <span class="built_in">ord</span>(char_r) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                    <span class="keyword">if</span> lower_count[idx] == <span class="number">0</span> <span class="keyword">and</span> upper_count[idx] == <span class="number">0</span>:</span><br><span class="line">                        unique_types += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> lower_count[idx] == <span class="number">0</span> <span class="keyword">and</span> upper_count[idx] &gt; <span class="number">0</span>:</span><br><span class="line">                        nice_types += <span class="number">1</span></span><br><span class="line">                    lower_count[idx] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 大写字母</span></span><br><span class="line">                    idx = <span class="built_in">ord</span>(char_r) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                    <span class="keyword">if</span> lower_count[idx] == <span class="number">0</span> <span class="keyword">and</span> upper_count[idx] == <span class="number">0</span>:</span><br><span class="line">                        unique_types += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> upper_count[idx] == <span class="number">0</span> <span class="keyword">and</span> lower_count[idx] &gt; <span class="number">0</span>:</span><br><span class="line">                        nice_types += <span class="number">1</span></span><br><span class="line">                    upper_count[idx] += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># --- 2. 左指针收缩窗口 ---</span></span><br><span class="line">                <span class="keyword">while</span> unique_types &gt; k:</span><br><span class="line">                    char_l = s[left]</span><br><span class="line">                    <span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> &lt;= char_l &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">                        idx = <span class="built_in">ord</span>(char_l) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                        lower_count[idx] -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> lower_count[idx] == <span class="number">0</span> <span class="keyword">and</span> upper_count[idx] &gt; <span class="number">0</span>:</span><br><span class="line">                            nice_types -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> lower_count[idx] == <span class="number">0</span> <span class="keyword">and</span> upper_count[idx] == <span class="number">0</span>:</span><br><span class="line">                            unique_types -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>: <span class="comment"># 大写字母</span></span><br><span class="line">                        idx = <span class="built_in">ord</span>(char_l) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                        upper_count[idx] -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> upper_count[idx] == <span class="number">0</span> <span class="keyword">and</span> lower_count[idx] &gt; <span class="number">0</span>:</span><br><span class="line">                            nice_types -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> lower_count[idx] == <span class="number">0</span> <span class="keyword">and</span> upper_count[idx] == <span class="number">0</span>:</span><br><span class="line">                            unique_types -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># --- 3. 更新结果 ---</span></span><br><span class="line">                <span class="keyword">if</span> unique_types == k <span class="keyword">and</span> nice_types == k:</span><br><span class="line">                    current_len = right - left + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> current_len &gt; max_len:</span><br><span class="line">                        max_len = current_len</span><br><span class="line">                        result_start = left</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> max_len == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> s[result_start : result_start + max_len]</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(C * N)，其中 C 是字符集的大小（这里是 26），N 是字符串 <code>s</code> 的长度。外层循环固定为 26 次，内部的滑动窗口逻辑中，<code>left</code> 和 <code>right</code> 指针都只遍历一次字符串。因此，总时间复杂度为 O(N)。</li>
<li><strong>空间复杂度</strong>: O(C)。我们使用了几个固定大小的数组（<code>lower_count</code>, <code>upper_count</code>）来存储状态，空间是常数级别的。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口技巧的一个精彩应用。当窗口需要满足的条件比较复杂、不单调时，可以尝试**“升维”**的思路：通过枚举窗口的某个关键属性（本题中是唯一字母类型的数量），将一个复杂问题分解为一系列具有更清晰约束的简单子问题，然后逐一用滑动窗口求解。这种“分类讨论 + 滑动窗口”的模式是解决困难字符串问题的一个有力武器。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>位运算</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>分治</tag>
        <tag>第46场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1818 | 二分查找优化绝对差值和</title>
    <url>//posts/leetcode-1818/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1818 题：<a href="https://leetcode.cn/problems/minimum-absolute-sum-difference/">绝对差值和</a>。<br>本题的关键在于，将问题转化为寻找最大“收益”的单次替换。通过对<code>nums1</code>排序并利用二分查找，我们可以高效地为<code>nums2</code>中的每个元素找到最佳匹配，从而将寻找最优解的复杂度从 O(n²) 优化到 O(n log n)。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们两个长度相等的正整数数组 <code>nums1</code> 和 <code>nums2</code>。首先，我们需要理解“绝对差值和”的定义，即 <code>sum(|nums1[i] - nums2[i]|)</code>。</p>
<p>核心任务是：我们可以对 <code>nums1</code> 进行<strong>至多一次</strong>修改，即用 <code>nums1</code> 中的<strong>任意</strong>一个元素替换 <code>nums1</code> 中的某个元素，目标是让这个“绝对差值和”变得尽可能小。最后返回这个最小的和，并对 <code>10^9 + 7</code> 取余。</p>
<p>举个例子，<code>nums1 = [1,7,5]</code>, <code>nums2 = [2,3,5]</code>：</p>
<ul>
<li><strong>不替换</strong>：初始的绝对差值和是 <code>|1-2| + |7-3| + |5-5| = 1 + 4 + 0 = 5</code>。</li>
<li><strong>尝试替换</strong>：我们希望通过一次替换来最大化地减小这个和。<ul>
<li>观察到 <code>|7-3|=4</code> 是最大的差值项。如果我们能将 <code>nums1[1]</code>（值为7）换成一个更接近 <code>nums2[1]</code>（值为3）的数，收益可能最大。</li>
<li><code>nums1</code> 中有哪些元素可选？有 <code>1</code> 和 <code>5</code>。</li>
<li>如果用 <code>1</code> 替换 <code>7</code>，新 <code>nums1</code> 为 <code>[1,1,5]</code>。差值和变为 <code>|1-2| + |1-3| + |5-5| = 1 + 2 + 0 = 3</code>。</li>
<li>如果用 <code>5</code> 替换 <code>7</code>，新 <code>nums1</code> 为 <code>[1,5,5]</code>。差值和变为 <code>|1-2| + |5-3| + |5-5| = 1 + 2 + 0 = 3</code>。</li>
</ul>
</li>
<li><strong>结论</strong>：最小的绝对差值和是 3。</li>
</ul>
<h3 id="核心思路：贪心-二分查找"><a href="#核心思路：贪心-二分查找" class="headerlink" title="核心思路：贪心 + 二分查找"></a>核心思路：贪心 + 二分查找</h3><p>问题的本质是找到一个最优的替换方案。对于 <code>n</code> 个位置中的每一个 <code>i</code>，我们都有机会将其 <code>nums1[i]</code> 替换掉，从而改变 <code>|nums1[i] - nums2[i]|</code> 这一项。我们的目标是让这次替换带来的<strong>收益</strong>（即差值和的减少量）最大化。</p>
<p>对于任意一个位置 <code>i</code>，其原始差值为 <code>diff_i = |nums1[i] - nums2[i]|</code>。如果我们用 <code>nums1</code> 中的某个值 <code>val</code> 来替换 <code>nums1[i]</code>，那么新的差值变为 <code>new_diff_i = |val - nums2[i]|</code>。这次替换带来的收益就是 <code>reduction = diff_i - new_diff_i</code>。</p>
<p>要想让 <code>reduction</code> 最大，我们就必须让 <code>new_diff_i</code> 最小。这意味着，对于当前的 <code>nums2[i]</code>，我们需要在整个 <code>nums1</code> 数组中，找到一个与它最接近的数。</p>
<p><strong>如何高效地找到这个“最接近的数”？</strong><br>如果我们对每一个 <code>nums2[i]</code> 都遍历一遍 <code>nums1</code> 来寻找最接近的值，那么单次查找的时间复杂度是 O(n)，总时间复杂度将是 O(n²)，对于 n 高达 10^5 的情况，这显然会超时。</p>
<p>注意到 <code>nums1</code> 数组是固定的。我们可以先对其进行<strong>排序</strong>。在一个有序数组中查找一个数，或者查找与它最接近的数，正是<strong>二分查找</strong>的经典应用场景。</p>
<p>因此，我们的整体策略是：</p>
<ol>
<li><strong>预处理</strong>：先对 <code>nums1</code> 进行排序，得到一个有序版本 <code>sorted_nums1</code>。</li>
<li><strong>计算初始值</strong>：计算不做任何替换时的原始绝对差值和 <code>total_diff</code>。</li>
<li><strong>寻找最大收益</strong>：遍历 <code>i</code> 从 <code>0</code> 到 <code>n-1</code>，对于每一个 <code>nums2[i]</code>，利用二分查找在 <code>sorted_nums1</code> 中找到与它最接近的数。从而计算出替换 <code>nums1[i]</code> 能带来的最大收益 <code>max_reduction</code>。</li>
<li><strong>计算最终结果</strong>：最终的最小绝对差值和就是 <code>total_diff - max_reduction</code>。</li>
</ol>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>计算初始总和</strong></p>
<ul>
<li>定义模 <code>MOD = 10^9 + 7</code>。</li>
<li>遍历 <code>nums1</code> 和 <code>nums2</code>，累加 <code>|nums1[i] - nums2[i]|</code> 得到初始总和 <code>total_diff</code>。</li>
</ul>
</li>
<li><p><strong>排序 <code>nums1</code></strong></p>
<ul>
<li>创建一个 <code>nums1</code> 的副本并对其进行升序排序，得到 <code>sorted_nums1</code>。</li>
</ul>
</li>
<li><p><strong>寻找最大可减少量 (max_reduction)</strong></p>
<ul>
<li>初始化 <code>max_reduction = 0</code>。</li>
<li>再次遍历两个数组，对于每个索引 <code>i</code>：<ul>
<li>获取原始差值 <code>original_diff = |nums1[i] - nums2[i]|</code>。</li>
<li>以 <code>target = nums2[i]</code> 为目标，在 <code>sorted_nums1</code> 中执行二分查找。</li>
<li>二分查找会返回一个插入点 <code>j</code>。<code>target</code> 最接近的两个候选值就是 <code>sorted_nums1[j]</code> (如果 <code>j</code> 没越界) 和 <code>sorted_nums1[j-1]</code> (如果 <code>j &gt; 0</code>)。</li>
<li>计算 <code>target</code> 与这两个候选值的差的绝对值，取其中较小的一个作为 <code>min_new_diff</code>。</li>
<li>当前位置 <code>i</code> 能产生的最大收益为 <code>reduction = original_diff - min_new_diff</code>。</li>
<li>更新全局最大收益：<code>max_reduction = max(max_reduction, reduction)</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>最终的答案是 <code>(total_diff - max_reduction) % MOD</code>。为了防止结果为负（在某些语言的取模运算中），可以使用 <code>(total_diff - max_reduction + MOD) % MOD</code> 来保证结果非负。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minAbsoluteSumDiff</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums1)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 1: 创建 nums1 的排序副本</span></span><br><span class="line">        sorted_nums1 = <span class="built_in">sorted</span>(nums1)</span><br><span class="line"></span><br><span class="line">        total_diff = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 步骤 2: 计算原始的绝对差值和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            total_diff += <span class="built_in">abs</span>(nums1[i] - nums2[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> total_diff == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        max_reduction = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 步骤 3: 遍历查找最大的可减少量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            original_diff = <span class="built_in">abs</span>(nums1[i] - nums2[i])</span><br><span class="line">            target = nums2[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 4: 使用二分查找在 sorted_nums1 中寻找最接近 target 的值</span></span><br><span class="line">            j = bisect.bisect_left(sorted_nums1, target)</span><br><span class="line">            </span><br><span class="line">            min_new_diff = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 候选1: 插入点右侧（或本身）的元素</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; n:</span><br><span class="line">                min_new_diff = <span class="built_in">min</span>(min_new_diff, <span class="built_in">abs</span>(sorted_nums1[j] - target))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 候选2: 插入点左侧的元素</span></span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                min_new_diff = <span class="built_in">min</span>(min_new_diff, <span class="built_in">abs</span>(sorted_nums1[j-<span class="number">1</span>] - target))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算当前替换能带来的收益</span></span><br><span class="line">            reduction = original_diff - min_new_diff</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新全局最大收益</span></span><br><span class="line">            max_reduction = <span class="built_in">max</span>(max_reduction, reduction)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 5: 从原始总和中减去最大收益并取模</span></span><br><span class="line">        result = (total_diff - max_reduction + MOD) % MOD</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(n log n)。<ul>
<li><code>n</code> 是数组的长度。</li>
<li>对 <code>nums1</code> 排序需要 O(n log n)。</li>
<li>计算初始的 <code>total_diff</code> 需要 O(n)。</li>
<li>主循环执行 <code>n</code> 次，每次循环内部执行一次二分查找，需要 O(log n)。这部分总共是 O(n log n)。</li>
<li>因此，总的时间复杂度由排序和主循环决定，为 O(n log n)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(n)。<ul>
<li>我们需要一个额外的数组 <code>sorted_nums1</code> 来存储 <code>nums1</code> 的排序副本，占用了 O(n) 的空间。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是一个很好的例子，展示了如何通过<strong>预处理</strong>和<strong>数据结构&#x2F;算法</strong>的选择来优化暴力解法。通过贪心地锁定“最大化收益”这一目标，我们将一个复杂的替换问题简化为了一系列查找问题。而排序和二分查找这对经典组合，则为我们提供了高效完成查找任务的强大工具，使得算法的性能满足了题目的要求。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>排序</tag>
        <tag>有序集合</tag>
        <tag>第235场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1838 | 滑动窗口求解“最高频元素的频数”</title>
    <url>//posts/leetcode-1838/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1838 题：<a href="https://leetcode.cn/problems/frequency-of-the-most-frequent-element/">最高频元素的频数</a>。<br>这道题巧妙地将“操作次数”的限制与“最大频数”的目标结合起来，通过“排序”加“滑动窗口”的组合拳，可以高效地找到答案。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个整数数组 <code>nums</code> 和一个操作预算 <code>k</code>。我们被允许执行一种操作：将数组中的任意一个元素的值增加 1。我们的目标是，在执行不超过 <code>k</code> 次操作的前提下，让数组中某一个元素的出现次数（即频数）变得尽可能大，并返回这个最大的可能频数。</p>
<p>我们来分析一下这个目标：</p>
<ul>
<li>我们想让某个数 <code>x</code> 出现的次数最多。</li>
<li>为了实现这个目标，我们需要挑选数组中的一些元素，通过增加它们的值，让它们都等于 <code>x</code>。</li>
<li>由于我们只能执行“增加”操作，一个非常重要的贪心思路是：如果我们想让一组数都变成 <code>x</code>，那么 <code>x</code> 必须是这组数中最大的那个数。否则，如果 <code>x</code> 不是最大的，我们就需要把那个比 <code>x</code> 还大的数也变成 <code>x</code>，但这是“增加”操作无法做到的。</li>
</ul>
<p>举个例子，对于 <code>nums = [1,2,4], k = 5</code>：</p>
<ul>
<li>我们的目标是找到一个子集，能用最多 5 次操作让它们全部相等。</li>
<li>如果我们选择 <code>[1, 2, 4]</code> 这个子集，为了让它们相等，最划算的方式是把它们都变成其中最大的 <code>4</code>。</li>
<li>需要的操作次数为：<code>(4 - 1) + (4 - 2) = 3 + 2 = 5</code>。</li>
<li>这个操作次数正好等于 <code>k</code>，是允许的。此时，我们得到了 <code>[4, 4, 4]</code>，元素 <code>4</code> 的频数是 3。这就是本例的最优解。</li>
</ul>
<h3 id="核心思路：排序-滑动窗口"><a href="#核心思路：排序-滑动窗口" class="headerlink" title="核心思路：排序 + 滑动窗口"></a>核心思路：排序 + 滑动窗口</h3><p>这类求解“满足特定条件的最长连续子数组”的问题，通常是滑动窗口算法的用武之地。而本题的“特定条件”与元素的值有关，因此，<strong>先排序</strong>是至关重要的一步。</p>
<p><strong>为什么需要排序？</strong><br>排序后，对于任意一个连续的子数组（即我们的“窗口”），其中最大的元素就是最右侧的那个元素。这就完美契合了我们之前的贪心思路：将窗口内的所有元素都变成窗口内的最大值，这样操作成本最低。</p>
<p>算法的动态过程如下：</p>
<ol>
<li><strong>排序</strong>：首先对 <code>nums</code> 数组进行升序排序。</li>
<li><strong>窗口设定</strong>：我们使用 <code>left</code> 和 <code>right</code> 两个指针来维护一个窗口 <code>nums[left...right]</code>。</li>
<li><strong>窗口扩张</strong>：<code>right</code> 指针不断向右移动，将新元素 <code>nums[right]</code> 纳入窗口。</li>
<li><strong>成本计算与窗口收缩</strong>：<ul>
<li>我们的目标是将窗口内所有元素都变成 <code>nums[right]</code>。</li>
<li>要实现这个目标，需要的总操作次数（成本）为：<code>(nums[right] * 窗口长度) - (窗口内元素的当前总和)</code>。</li>
<li>如果计算出的<strong>成本大于 <code>k</code></strong>，说明当前窗口过长，无法在预算内完成目标。此时，我们必须收缩窗口的左边界，即把 <code>left</code> 指针向右移动，并将 <code>nums[left]</code> 从窗口中移除，直到成本重新回到 <code>k</code> 的预算之内。</li>
</ul>
</li>
<li><strong>结果更新</strong>：<code>right</code> 指针每移动一步，在确保窗口有效（成本 <code>&lt;= k</code>）之后，当前窗口的长度 <code>right - left + 1</code> 就是一个可能的频数。我们用它来更新全局的最大频数 <code>max_freq</code>。</li>
</ol>
<p>通过这个“扩张-收缩”的循环，我们就能在一次遍历中找到满足条件的最长窗口，其长度就是答案。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>排序</strong>：</p>
<ul>
<li>对输入数组 <code>nums</code> 进行升序排序。</li>
</ul>
</li>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>左指针 <code>left = 0</code>。</li>
<li>记录最大频数 <code>max_freq = 0</code>。</li>
<li>记录窗口内元素的总和 <code>current_sum = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历与扩张</strong>：</p>
<ul>
<li>用右指针 <code>right</code> 从 <code>0</code> 到 <code>n-1</code> 遍历整个数组。</li>
<li>在循环的每一步，首先将新元素 <code>nums[right]</code> 加入窗口，更新 <code>current_sum += nums[right]</code>。</li>
</ul>
</li>
<li><p><strong>收缩</strong>：</p>
<ul>
<li>紧接着，使用一个 <code>while</code> 循环检查窗口的有效性。条件是：<code>nums[right] * (right - left + 1) &gt; current_sum + k</code>。</li>
<li>只要条件成立，就说明成本超支，窗口需要收缩。</li>
<li>收缩操作：从 <code>current_sum</code> 中减去 <code>nums[left]</code>，然后将左指针 <code>left</code> 右移一位。</li>
<li><code>while</code> 循环会一直执行，直到窗口恢复到成本不超支的状态。</li>
</ul>
</li>
<li><p><strong>更新结果</strong>：</p>
<ul>
<li>在 <code>while</code> 循环结束后，当前窗口 <code>nums[left:right+1]</code> 一定是有效的。</li>
<li>计算当前窗口长度 <code>right - left + 1</code>，并更新 <code>max_freq = max(max_freq, right - left + 1)</code>。</li>
</ul>
</li>
<li><p><strong>返回</strong>：</p>
<ul>
<li><code>right</code> 指针遍历完整个数组后，<code>max_freq</code> 中存储的就是最终答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxFrequency</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1: 排序是关键前提</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2: 初始化指针和状态变量</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        max_freq = <span class="number">0</span></span><br><span class="line">        current_sum = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 遍历数组，right 指针用于扩张窗口</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            current_sum += nums[right]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 4: 当窗口不满足条件时 (成本 &gt; k)，进行收缩</span></span><br><span class="line">            <span class="comment"># 成本 = 目标总和 - 当前总和</span></span><br><span class="line">            <span class="comment"># 目标总和 = nums[right] * 窗口长度</span></span><br><span class="line">            <span class="keyword">while</span> (nums[right] * (right - left + <span class="number">1</span>)) &gt; current_sum + k:</span><br><span class="line">                <span class="comment"># 从左侧移出元素</span></span><br><span class="line">                current_sum -= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 5: 更新最大频数，此时的窗口一定是有效的</span></span><br><span class="line">            max_freq = <span class="built_in">max</span>(max_freq, right - left + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> max_freq</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N log N)。其中 N 是数组 <code>nums</code> 的长度。算法的瓶颈在于初始的排序步骤，其时间复杂度为 O(N log N)。后续的滑动窗口遍历中，<code>left</code> 和 <code>right</code> 指针都只移动 N 次，所以是 O(N) 的。因此，总的时间复杂度为 O(N log N)。</li>
<li><strong>空间复杂度</strong>: O(log N) 或 O(N)。这取决于编程语言中排序算法的实现。例如，Python 的 Timsort 在最坏情况下需要 O(N) 的空间，而一些快速排序的实现会使用 O(log N) 的递归栈空间。如果我们不考虑排序所用的空间，则算法本身只使用了常数个额外变量，空间复杂度为 O(1)。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是一个“排序 + 滑动窗口”的经典范例。解决这类问题的关键在于：</p>
<ol>
<li><strong>发现贪心性质</strong>：通过分析题目，找到一个贪心策略（如本题的“将所有数变为窗口最大值”），这个策略往往需要先对数据进行排序。</li>
<li><strong>定义窗口有效性</strong>：明确一个窗口需要满足的“条件”。在本题中，这个条件就是 <code>(窗口目标和 - 窗口当前和) &lt;= k</code>。</li>
<li><strong>实现窗口的动规过程</strong>：清晰地定义窗口在扩张和收缩时，需要更新哪些状态变量（本题中是 <code>current_sum</code>），以确保能够高效地判断窗口的有效性。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>滑动窗口</tag>
        <tag>排序</tag>
        <tag>前缀和</tag>
        <tag>第 238 场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1888 | 利用滑动窗口巧解循环字符串反转问题</title>
    <url>//posts/leetcode-1888/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 1888 题：<a href="https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/description/">使二进制字符串交替的最少反转次数</a>。<br>这是一道非常有趣的中等难度题目，它巧妙地将字符串循环操作和经典算法模型“滑动窗口”结合了起来。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>首先，我们来分析一下题目的要求。给定一个二进制字符串 <code>s</code>，我们有两种操作：</p>
<ul>
<li><strong>类型 1（循环移位）</strong>: 将字符串的第一个字符移动到末尾。这个操作可以执行任意次，意味着字符串的<strong>起点可以是任意位置</strong>。例如，<code>&quot;111000&quot;</code> 可以变成 <code>&quot;110001&quot;</code>、<code>&quot;100011&quot;</code> 等。</li>
<li><strong>类型 2（字符反转）</strong>: 将任意一个 <code>&#39;0&#39;</code> 变成 <code>&#39;1&#39;</code>，或者 <code>&#39;1&#39;</code> 变成 <code>&#39;0&#39;</code>。</li>
</ul>
<p>我们的目标是，通过这两种操作，将原字符串变成一个“交替字符串”（如 <code>&quot;01010...&quot;</code> 或 <code>&quot;10101...&quot;</code>），并求出<strong>最少的类型 2（反转）操作次数</strong>。</p>
<h3 id="核心思路：转化问题"><a href="#核心思路：转化问题" class="headerlink" title="核心思路：转化问题"></a>核心思路：转化问题</h3><h4 id="如何处理“循环移位”？"><a href="#如何处理“循环移位”？" class="headerlink" title="如何处理“循环移位”？"></a>如何处理“循环移位”？</h4><p>“任意次循环移位”是一个非常关键的信息。它暗示我们，最终的字符串可能是原字符串通过旋转得到的任何一种形态。直接枚举所有旋转结果再计算会非常低效。</p>
<p>处理这类环形或循环问题的经典技巧是：<strong>将字符串复制一份拼接在原字符串后面</strong>。</p>
<p>例如，如果 <code>s = &quot;1110&quot;</code>，我们构造一个新的字符串 <code>s&#39; = s + s = &quot;11101110&quot;</code>。<br>现在，在 <code>s&#39;</code> 上任意一个长度为 <code>n</code>（原字符串长度）的子串，都对应了原字符串 <code>s</code> 的一种循环移位结果。</p>
<ul>
<li><code>s&#39;</code> 从索引 0 开始的子串: <code>&quot;1110&quot;</code> (原字符串)</li>
<li><code>s&#39;</code> 从索引 1 开始的子串: <code>&quot;1101&quot;</code> (相当于原字符串循环移位 1 次)</li>
<li><code>s&#39;</code> 从索引 2 开始的子串: <code>&quot;1011&quot;</code> (相当于原字符串循环移位 2 次)</li>
<li><code>s&#39;</code> 从索引 3 开始的子串: <code>&quot;0111&quot;</code> (相当于原字符串循环移位 3 次)</li>
</ul>
<p>通过这个转换，我们就把一个复杂的“循环问题”转化成了一个更熟悉的“<strong>在固定长度的字符串上寻找最优子串</strong>”的问题。这自然而然地引出了我们的主角——<strong>滑动窗口</strong>。</p>
<h4 id="确定我们的“目标”"><a href="#确定我们的“目标”" class="headerlink" title="确定我们的“目标”"></a>确定我们的“目标”</h4><p>我们的目标是把字符串变成一个交替字符串。对于一个固定长度 <code>n</code> 的字符串，交替的形式只有两种：</p>
<ol>
<li>以 <code>&#39;0&#39;</code> 开头：我们称之为 <code>target1</code>，例如 <code>n=6</code> 时为 <code>&quot;010101&quot;</code>。</li>
<li>以 <code>&#39;1&#39;</code> 开头：我们称之为 <code>target2</code>，例如 <code>n=6</code> 时为 <code>&quot;101010&quot;</code>。</li>
</ol>
<p>我们的任务就是在 <code>s&#39;</code> 上滑动一个长度为 <code>n</code> 的窗口，对于每一个窗口，计算它变成 <code>target1</code> 或 <code>target2</code> 所需的最小反转次数，然后取所有这些结果中的最小值。</p>
<h3 id="滑动窗口算法详解"><a href="#滑动窗口算法详解" class="headerlink" title="滑动窗口算法详解"></a>滑动窗口算法详解</h3><ol>
<li><p><strong>准备工作</strong>:</p>
<ul>
<li>令 <code>n</code> 为原字符串 <code>s</code> 的长度。</li>
<li>构造新字符串 <code>s&#39; = s + s</code>，其长度为 <code>2n</code>。</li>
<li>构造两个长度为 <code>2n</code> 的目标字符串 <code>target1</code> 和 <code>target2</code>。</li>
</ul>
</li>
<li><p><strong>初始化窗口</strong>:</p>
<ul>
<li>计算 <code>s&#39;</code> 的前 <code>n</code> 个字符（即第一个窗口）与 <code>target1</code> 的前 <code>n</code> 个字符有多少位不同，记为 <code>diff1</code>。</li>
<li>同理，计算与 <code>target2</code> 的前 <code>n</code> 个字符的不同位数，记为 <code>diff2</code>。</li>
<li>此时，我们得到的最小反转次数 <code>ans = min(diff1, diff2)</code>。</li>
</ul>
</li>
<li><p><strong>滑动窗口</strong>:</p>
<ul>
<li>窗口从索引 <code>1</code> 开始向右滑动，直到窗口的起始点到达 <code>n</code>。</li>
<li>每次窗口向右滑动一格，我们不需要重新计算整个窗口的 <code>diff</code>。我们只需要更新变化的部分：<ul>
<li><strong>移出字符</strong>：检查即将离开窗口的那个字符（例如 <code>s&#39;[i-1]</code>）是否与目标字符串的对应位置不同。如果不同，说明我们之前为这个不同点计了 1 次反转，现在它离开窗口了，所以 <code>diff</code> 应该减 1。</li>
<li><strong>移入字符</strong>：检查新进入窗口的那个字符（例如 <code>s&#39;[i+n-1]</code>）是否与目标字符串的对应位置不同。如果不同，<code>diff</code> 应该加 1。</li>
</ul>
</li>
<li>每次滑动后，我们都更新 <code>diff1</code> 和 <code>diff2</code>，并用 <code>min(diff1, diff2)</code> 来更新全局的 <code>ans</code>。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>:</p>
<ul>
<li>遍历完所有窗口后，<code>ans</code> 就是最终答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minFlips</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        s = s + s <span class="comment"># 步骤 1：处理循环问题</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 1：构建两种目标交替字符串</span></span><br><span class="line">        target1 = <span class="string">&quot;&quot;</span> <span class="comment"># 形式如 &quot;010101...&quot;</span></span><br><span class="line">        target2 = <span class="string">&quot;&quot;</span> <span class="comment"># 形式如 &quot;101010...&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * n):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                target1 += <span class="string">&quot;0&quot;</span></span><br><span class="line">                target2 += <span class="string">&quot;1&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                target1 += <span class="string">&quot;1&quot;</span></span><br><span class="line">                target2 += <span class="string">&quot;0&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2：初始化第一个窗口的差异（需要反转的次数）</span></span><br><span class="line">        diff1 = <span class="number">0</span> <span class="comment"># 与 target1 的差异</span></span><br><span class="line">        diff2 = <span class="number">0</span> <span class="comment"># 与 target2 的差异</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> s[i] != target1[i]:</span><br><span class="line">                diff1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] != target2[i]:</span><br><span class="line">                diff2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化最小反转次数</span></span><br><span class="line">        ans = <span class="built_in">min</span>(diff1, diff2)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 3：开始滑动窗口</span></span><br><span class="line">        <span class="comment"># left 是移出窗口的字符索引，i 是移入窗口的字符索引</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, <span class="number">2</span> * n):</span><br><span class="line">            left = i - n</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新与 target1 的差异</span></span><br><span class="line">            <span class="keyword">if</span> s[left] != target1[left]:        </span><br><span class="line">                diff1 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] != target1[i]:</span><br><span class="line">                diff1 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新与 target2 的差异</span></span><br><span class="line">            <span class="keyword">if</span> s[left] != target2[left]:        </span><br><span class="line">                diff2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] != target2[i]:</span><br><span class="line">                diff2 += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 更新全局最小反转次数</span></span><br><span class="line">            ans = <span class="built_in">min</span>(ans, diff1, diff2)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(n)。我们只遍历了长度为 <code>2n</code> 的新字符串一次。</li>
<li><strong>空间复杂度</strong>: O(n)。我们需要额外的空间来存储拼接后的字符串 <code>s&#39;</code> 以及两个目标字符串。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题的核心在于将“循环移位”操作通过拼接字符串的方式，转化为一个可以在线性结构上求解的滑动窗口问题，这是一种非常值得学习和掌握的技巧。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
        <tag>动态规划</tag>
        <tag>第244场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2024 | 滑动窗口求解“考试的最大困扰度”</title>
    <url>//posts/leetcode-2024/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2024 题：<a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/description/">考试的最大困扰度</a>。<br>该题核心在于，如何维护一个“窗口”，使得窗口内的子字符串可以通过不超过 k 次修改，变成一个全 ‘T’ 或全 ‘F’ 的字符串。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们来仔细分析一下题目的目标：<strong>最大化连续相同结果的题数</strong>。</p>
<p>这意味着我们要找到一个最长的子字符串，这个子字符串要么是 <code>TT...T</code>，要么是 <code>FF...F</code>。我们拥有一个强大的能力：最多可以将 <code>k</code> 个字符进行修改。</p>
<p>这个问题可以分解为两个子问题：</p>
<ol>
<li>找到一个最长的子字符串，它最多包含 <code>k</code> 个 <code>&#39;F&#39;</code>。这样我们就可以把这些 <code>&#39;F&#39;</code> 都改成 <code>&#39;T&#39;</code>，从而得到一串连续的 <code>&#39;T&#39;</code>。</li>
<li>找到一个最长的子字符串，它最多包含 <code>k</code> 个 <code>&#39;T&#39;</code>。这样我们就可以把这些 <code>&#39;T&#39;</code> 都改成 <code>&#39;F&#39;</code>，从而得到一串连续的 <code>&#39;F&#39;</code>。</li>
</ol>
<p>最终的答案就是这两个子问题结果中的最大值。这两个子问题都可以用滑动窗口完美解决。更巧妙的是，我们可以将这两个问题合二为一进行求解。</p>
<h3 id="核心思路：滑动窗口"><a href="#核心思路：滑动窗口" class="headerlink" title="核心思路：滑动窗口"></a>核心思路：滑动窗口</h3><p>当我们看到“最长连续子串”这类问题时，通常可以考虑使用滑动窗口。滑动窗口就像一个在字符串上移动的框，我们关心的是这个框内的内容是否满足特定条件。</p>
<p>在这个问题中，窗口需要满足的条件是：<strong>窗口内需要修改的字符数不能超过 <code>k</code></strong>。</p>
<p>如何计算“需要修改的字符数”呢？假设当前窗口大小为 <code>len</code>，窗口内 ‘T’ 的数量为 <code>countT</code>，’F’ 的数量为 <code>countF</code>。</p>
<ul>
<li>要将窗口内所有字符变为 ‘T’，需要修改 <code>countF</code> 次。</li>
<li>要将窗口内所有字符变为 ‘F’，需要修改 <code>countT</code> 次。</li>
</ul>
<p>我们希望用最少的操作次数，所以我们会选择将数量较少的字符修改成数量较多的字符。因此，需要修改的次数就是 <code>min(countT, countF)</code>。不过，换一种思路会更简单：<br><strong>需要修改的字符数 &#x3D; 窗口长度 - 窗口内出现次数最多的字符的数量</strong></p>
<p>所以，窗口的“有效”条件就变成了：<br><code>(窗口长度) - max(countT, countF) &lt;= k</code></p>
<h4 id="滑动窗口的运作流程"><a href="#滑动窗口的运作流程" class="headerlink" title="滑动窗口的运作流程"></a>滑动窗口的运作流程</h4><ol>
<li><strong>窗口扩张</strong>：我们使用右指针 <code>right</code> 不断向右移动，扩大窗口，并将新字符纳入统计。</li>
<li><strong>条件判断</strong>：每扩大一步，我们都检查上述“有效”条件是否还成立。</li>
<li><strong>窗口收缩</strong>：如果条件不成立，说明当前窗口“太长了”，包含了太多需要修改的字符。此时，我们必须从左边收缩窗口，即移动左指针 <code>left</code>，并将被移出窗口的字符从统计中移除，直到窗口重新变得“有效”。</li>
<li><strong>更新结果</strong>：在整个过程中，窗口的最大尺寸就是我们所求的答案。因为窗口收缩时，<code>left</code> 和 <code>right</code> 同步右移，长度不变；只有在不收缩时，<code>right</code> 右移，长度才会增加。所以，<code>right - left + 1</code> 始终记录着当前有效的最大窗口长度。</li>
</ol>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化</strong>:</p>
<ul>
<li>定义左右指针 <code>left = 0</code>, <code>right = 0</code>。</li>
<li>定义一个计数器（<code>dict</code> 或 <code>Counter</code>）来统计窗口内 <code>&#39;T&#39;</code> 和 <code>&#39;F&#39;</code> 的数量。</li>
<li>初始化最大长度 <code>max_len = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历扩张</strong>:</p>
<ul>
<li>用 <code>right</code> 指针遍历整个字符串 <code>answerKey</code>。</li>
<li>在循环中，将 <code>answerKey[right]</code> 对应的字符计数加一。</li>
</ul>
</li>
<li><p><strong>判断与收缩</strong>:</p>
<ul>
<li>计算当前窗口内出现次数最多的字符的数量 <code>max_freq</code>。</li>
<li>检查 <code>(right - left + 1) - max_freq</code> 是否大于 <code>k</code>。</li>
<li>如果大于 <code>k</code>，说明需要修改的字符超过了限制，必须收缩窗口：<ul>
<li>将 <code>answerKey[left]</code> 对应的字符计数减一。</li>
<li>将左指针 <code>left</code> 右移一位。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>记录结果</strong>:</p>
<ul>
<li>经过收缩（或不收缩）后，当前窗口 <code>[left, right]</code> 必然是有效的。我们用它的长度 <code>right - left + 1</code> 来更新 <code>max_len</code>。</li>
</ul>
</li>
<li><p><strong>返回</strong>:</p>
<ul>
<li>遍历结束后，<code>max_len</code> 即为最终答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxConsecutiveAnswers</span>(<span class="params">self, answerKey: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(answerKey)</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        counts = Counter()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># right 指针负责扩大窗口</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 将新字符计入窗口</span></span><br><span class="line">            counts[answerKey[right]] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 窗口内出现次数最多的字符的数量</span></span><br><span class="line">            <span class="comment"># A more robust way is `max_freq = max(counts.get(&#x27;T&#x27;, 0), counts.get(&#x27;F&#x27;, 0))`</span></span><br><span class="line">            <span class="comment"># but since counts will not be empty, max(counts.values()) is fine.</span></span><br><span class="line">            max_freq = <span class="built_in">max</span>(counts.values())</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 判断窗口是否需要收缩</span></span><br><span class="line">            <span class="comment"># 窗口长度: right - left + 1</span></span><br><span class="line">            <span class="comment"># 需要改变的字符数: (right - left + 1) - max_freq</span></span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span>) - max_freq &gt; k:</span><br><span class="line">                <span class="comment"># 从窗口左边移出一个字符</span></span><br><span class="line">                counts[answerKey[left]] -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 左指针右移，收缩窗口</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 经过上面的调整，当前窗口 [left, right] 肯定是有效的</span></span><br><span class="line">            <span class="comment"># 我们用它的长度更新最大长度</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> max_len</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)，其中 N 是字符串 <code>answerKey</code> 的长度。因为 <code>left</code> 和 <code>right</code> 指针都只会从头到尾遍历字符串一次。</li>
<li><strong>空间复杂度</strong>: O(1)。我们使用的计数器 <code>counts</code> 最多只会存储两个键（’T’ 和 ‘F’），所以其空间占用是常数级别的。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想的直接应用，考察的是对滑动窗口“维护一个满足特定条件的区间”这一核心思想的理解。<br>关键的收获是：</p>
<ol>
<li><strong>问题转化</strong>：将原问题“在 k 次修改下，最长的连续 T&#x2F;F 串”转化为“找到一个最长的子串，其中数量较少的字符不超过 k 个”。</li>
<li><strong>窗口条件</strong>：巧妙地利用 <code>(窗口长度) - (主要元素数量) &lt;= k</code> 来作为窗口的有效性判断条件，这个公式同时兼顾了求最长连续 ‘T’ 和最长连续 ‘F’ 两种情况。</li>
<li><strong>动态维护</strong>：通过扩张和收缩窗口，动态地维护一个始终满足条件的、尽可能长的区间，从而得到最终答案。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
        <tag>前缀和</tag>
        <tag>双指针</tag>
        <tag>第 62 场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2070 | 二分查找解决“每一个查询的最大美丽值”</title>
    <url>//posts/leetcode-2070/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2070 题：<a href="https://leetcode.cn/problems/most-beautiful-item-for-each-query/description/">每一个查询的最大美丽值</a>。<br>对于每个价格查询，如何高效找到符合条件物品中的最大美丽值？通过预处理和二分查找，我们可以将问题迎刃而解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个二维数组 <code>items</code>，其中每个元素 <code>items[i] = [price_i, beauty_i]</code> 代表一件物品的价格和美丽值。同时，我们还有一个查询数组 <code>queries</code>，里面包含了一系列的价格。</p>
<p>我们的任务是，对于 <code>queries</code> 中的每一个价格 <code>q</code>，找出所有价格<strong>小于或等于</strong> <code>q</code> 的物品中，<strong>美丽值最大</strong>的是多少。如果不存在价格小于或等于 <code>q</code> 的物品，那么该查询的结果就是 0。最终，我们需要返回一个包含所有查询结果的数组。</p>
<p>举个例子，<code>items = [[1,2],[3,2],[2,4],[5,6],[3,5]]</code>, <code>queries = [1,2,3,4,5,6]</code>：</p>
<ul>
<li>对于查询 <code>q = 1</code>：只有 <code>[1,2]</code> 的价格 <code>&lt;= 1</code>。最大美丽值是 2。</li>
<li>对于查询 <code>q = 2</code>：有 <code>[1,2]</code> 和 <code>[2,4]</code> 的价格 <code>&lt;= 2</code>。最大美丽值是 4。</li>
<li>对于查询 <code>q = 3</code>：有 <code>[1,2]</code>, <code>[2,4]</code>, <code>[3,2]</code>, <code>[3,5]</code> 的价格 <code>&lt;= 3</code>。它们中的最大美丽值是 5。</li>
<li>对于查询 <code>q = 4</code>：符合条件的物品和 <code>q=3</code> 时一样，最大美丽值仍然是 5。</li>
<li>对于查询 <code>q = 5</code> 和 <code>q = 6</code>：所有物品都符合条件，最大美丽值是 6。</li>
<li>因此，最终答案是 <code>[2,4,5,5,6,6]</code>。</li>
</ul>
<h3 id="核心思路：预处理-二分查找"><a href="#核心思路：预处理-二分查找" class="headerlink" title="核心思路：预处理 + 二分查找"></a>核心思路：预处理 + 二分查找</h3><p>一个显而易见的暴力解法是：对每一个 <code>query</code>，都完整遍历一次 <code>items</code> 数组，筛选出所有价格符合条件的物品，然后找到其中的最大美丽值。如果 <code>queries</code> 的长度是 M，<code>items</code> 的长度是 N，这种方法的时间复杂度将是 O(M * N)，在 N 和 M 都达到 10^5 的情况下，计算量过大，会导致超时。</p>
<p>注意到，<code>items</code> 数组是固定不变的，而查询是多次的。这提示我们可以对 <code>items</code> 进行<strong>预处理</strong>，以加速后续的查询过程。</p>
<p>优化的核心思路是：</p>
<ol>
<li><strong>排序</strong>：如果我们按价格对 <code>items</code> 数组进行升序排序，那么对于一个查询价格 <code>q</code>，所有符合条件的物品都会集中在数组的开头部分。</li>
<li><strong>预计算最大美丽值</strong>：仅仅排序还不够，因为我们仍然需要遍历这个开头部分来找最大美丽值。关键的优化在于，我们可以在排序后再次遍历 <code>items</code> 数组，将每个物品的美丽值更新为<strong>到它为止（包括它自己）所有物品中的最大美丽值</strong>。也就是说，<code>items[i][1]</code> 将存储价格不高于 <code>items[i][0]</code> 的所有物品中的最大美丽值。</li>
<li><strong>二分查找</strong>：完成预处理后，对于每个查询 <code>q</code>，问题就变成了：在排序好的 <code>items</code> 数组中，找到价格 <code>&lt;= q</code> 的最后一个物品。由于我们已经预处理了最大美丽值，这个物品所存储的美丽值就是该查询的最终答案。这个查找过程可以通过高效的二分查找来完成。</li>
</ol>
<p>通过这种“预处理 + 二分查找”的模式，每次查询的时间复杂度可以从 O(N) 降低到 O(log N)，从而极大地提升了算法的整体性能。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><h4 id="解法一：原地更新最大美丽值"><a href="#解法一：原地更新最大美丽值" class="headerlink" title="解法一：原地更新最大美丽值"></a>解法一：原地更新最大美丽值</h4><ol>
<li><p><strong>排序</strong>：</p>
<ul>
<li>首先，按价格（<code>item[0]</code>）对 <code>items</code> 数组进行升序排序。</li>
</ul>
</li>
<li><p><strong>预处理 <code>items</code> 数组</strong>：</p>
<ul>
<li>遍历排序后的 <code>items</code> 数组，从第二个元素开始（索引为 1）。</li>
<li>将当前物品 <code>items[i]</code> 的美丽值更新为它自身美丽值与前一个物品 <code>items[i-1]</code> 美丽值的较大者，即 <code>items[i][1] = max(items[i][1], items[i-1][1])</code>。</li>
<li>这次遍历完成后，<code>items[i][1]</code> 就代表了在价格不超过 <code>items[i][0]</code> 的所有物品里，能找到的最大美丽值。</li>
</ul>
</li>
<li><p><strong>处理 <code>queries</code> 数组</strong>：</p>
<ul>
<li>遍历 <code>queries</code> 中的每一个查询价格 <code>q</code>。</li>
<li>使用二分查找（例如 Python 的 <code>bisect_right</code>）在 <code>items</code> 数组中查找 <code>q</code>。<code>bisect_right</code> 会返回一个插入点索引 <code>j</code>，这个索引是第一个价格<strong>严格大于</strong> <code>q</code> 的物品的位置。</li>
<li>因此，所有价格小于或等于 <code>q</code> 的物品的索引范围是 <code>0</code> 到 <code>j-1</code>。</li>
<li>如果 <code>j</code> 为 0，表示没有物品的价格小于等于 <code>q</code>，答案为 0。</li>
<li>否则，价格小于等于 <code>q</code> 的最后一个物品是 <code>items[j-1]</code>。根据我们的预处理，<code>items[j-1][1]</code> 就是我们想要的答案。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>将所有查询的结果收集起来并返回。</li>
</ul>
</li>
</ol>
<h4 id="解法二：压缩数组（空间优化）"><a href="#解法二：压缩数组（空间优化）" class="headerlink" title="解法二：压缩数组（空间优化）"></a>解法二：压缩数组（空间优化）</h4><p>这种解法在思路上与解法一类似，但在预处理阶段有所不同。它不是更新每一个物品的美丽值，而是创建一个“浓缩”版的 <code>items</code> 列表，只保留那些有意义的物品。一个物品 <code>items[i]</code> 如果其价格更高但美丽值却不比前面的物品更高，那么它对于寻找最大美丽值是没有贡献的。</p>
<ol>
<li><p><strong>排序</strong>：</p>
<ul>
<li>同解法一，按价格对 <code>items</code> 数组进行升序排序。</li>
</ul>
</li>
<li><p><strong>预处理（压缩数组）</strong>：</p>
<ul>
<li>使用一个指针 <code>k</code> 来记录有效物品列表的末尾（初始为 0）。</li>
<li>遍历排序后的 <code>items</code> 数组（从索引 1 开始）。如果当前物品 <code>items[i]</code> 的美丽值大于 <code>items[k]</code> 的美丽值，说明这是一个更优的选择，我们将其保留下来，更新 <code>k</code> 并将 <code>items[i]</code> 移动到 <code>k</code> 的位置：<code>k += 1; items[k] = items[i]</code>。</li>
<li>这样，我们就原地生成了一个长度为 <code>k+1</code> 的有效物品列表，其中价格和美丽值都是单调递增的。</li>
</ul>
</li>
<li><p><strong>查询与返回</strong>：</p>
<ul>
<li>对每个查询 <code>q</code>，在这个长度为 <code>k+1</code> 的有效列表上执行二分查找。其余逻辑与解法一完全相同。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumBeauty</span>(<span class="params">self, items: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], queries: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">      <span class="comment"># 步骤 1: 按价格排序</span></span><br><span class="line">      items.sort(key=<span class="keyword">lambda</span> item:item[<span class="number">0</span>])</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 步骤 2: 预处理，更新每个物品为其价格及以下的最大美丽值</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(items)):</span><br><span class="line">        items[i][<span class="number">1</span>] = <span class="built_in">max</span>(items[i][<span class="number">1</span>], items[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">      </span><br><span class="line">      ans = []</span><br><span class="line">      <span class="comment"># 步骤 3 &amp; 4: 对每个查询进行二分查找</span></span><br><span class="line">      <span class="keyword">for</span> q <span class="keyword">in</span> queries:</span><br><span class="line">        <span class="comment"># 找到第一个价格 &gt; q 的物品的索引 j</span></span><br><span class="line">        j = bisect.bisect_right(items, q, key=<span class="keyword">lambda</span> item:item[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 如果 j &gt; 0, 那么 items[j-1] 就是价格 &lt;= q 的物品中美丽值最大的</span></span><br><span class="line">        <span class="comment"># 这个美丽值已经是我们预处理好的前缀最大值</span></span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">          ans.append(items[j-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          <span class="comment"># 没有物品价格 &lt;= q</span></span><br><span class="line">          ans.append(<span class="number">0</span>)</span><br><span class="line">          </span><br><span class="line">      <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumBeauty</span>(<span class="params">self, items: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], queries: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 步骤 1: 按价格排序</span></span><br><span class="line">        items.sort(key=<span class="keyword">lambda</span> t: t[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2: 预处理，原地压缩数组，只保留美丽值递增的项</span></span><br><span class="line">        k = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(items)):</span><br><span class="line">            <span class="keyword">if</span> items[i][<span class="number">1</span>] &gt; items[k][<span class="number">1</span>]:</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">                items[k] = items[i]</span><br><span class="line">        </span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 步骤 3 &amp; 4: 在压缩后的数组部分进行二分查找</span></span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> queries:</span><br><span class="line">            <span class="comment"># 在 items[0...k] 范围内查找</span></span><br><span class="line">            j = bisect.bisect_right(items, q, hi=k+<span class="number">1</span>, key=<span class="keyword">lambda</span> t: t[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">              ans.append(items[j-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              ans.append(<span class="number">0</span>)</span><br><span class="line">              </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>令 <code>N</code> 为 <code>items</code> 数组的长度，<code>M</code> 为 <code>queries</code> 数组的长度。</p>
<ul>
<li><p><strong>时间复杂度</strong>: O((N+M)log N)</p>
<ul>
<li>对 <code>items</code> 数组进行排序所需时间为 O(N log N)。</li>
<li>预处理阶段（无论是更新美丽值还是压缩数组）都只需要一次线性遍历，时间复杂度为 O(N)。</li>
<li>处理 <code>M</code> 个查询，每个查询都进行一次二分查找，目标数组长度为 <code>N</code>（或压缩后的 <code>k+1</code>，最坏情况也是 <code>N</code>），所以二分查找的时间复杂度是 O(log N)。<code>M</code> 次查询总共是 O(M log N)。</li>
<li>因此，总的时间复杂度为 O(N log N + N + M log N)，简化后为 O(N log N + M log N)。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>: O(1)</p>
<ul>
<li>两种解法都是在输入数组 <code>items</code> 上进行原地修改。</li>
<li>如果不考虑排序算法本身可能使用的栈空间（或少量临时空间），我们没有创建任何与输入规模 <code>N</code> 或 <code>M</code> 成正比的额外数据结构。</li>
<li>返回的答案数组 <code>ans</code> 所占用的空间通常不计入额外空间复杂度。</li>
<li>因此，忽略排序的栈开销，额外空间复杂度为 O(1)。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预处理 + 二分查找”模式的一个典型应用。当题目涉及到对一个静态数据集进行多次范围性（如“小于等于”）查询时，应首先考虑是否能通过排序来建立有序性。在此基础上，通过一次线性扫描进行预处理（如计算前缀和、前缀最大&#x2F;最小值等），可以将每次查询的复杂度从线性降低到对数级别。二分查找正是利用数据有序性来实现高效查询的利器。两种解法在核心思想和复杂度上没有本质区别，都出色地解决了问题。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>排序</tag>
        <tag>第65场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2106 | 滑动窗口求解“摘水果”</title>
    <url>//posts/leetcode-2106/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2106 题：<a href="https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/">摘水果</a>。<br>该题要求我们在有限的步数内，规划一条路径以摘取最大数量的水果。路径的选择（先左还是先右）似乎复杂。实际上可以通过巧妙地定义移动成本，将其转化为一个经典的滑动窗口问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个无限长的 x 轴，上面分布着一些水果。我们用一个数组 <code>fruits</code> 来描述，其中 <code>fruits[i] = [positioni, amounti]</code> 表示在位置 <code>positioni</code> 有 <code>amounti</code> 个水果。这个数组已经按位置升序排列。</p>
<p>我们从一个给定的 <code>startPos</code> 出发，总共可以移动最多 <code>k</code> 步。目标是规划一条路径，使得摘到的水果总数最多。</p>
<p>举个例子，对于 <code>fruits = [[2,8],[6,3],[8,6]]</code>, <code>startPos = 5</code>, <code>k = 4</code>：</p>
<ul>
<li>我们的目标是在 4 步内，从位置 5 出发，摘到最多的水果。</li>
<li>一种可行的方案是：向右走到位置 6 (1 步)，摘 3 个水果。再向右走到位置 8 (2 步)，摘 6 个水果。总步数是 (8 - 5) &#x3D; 3，小于 4。总水果数是 3 + 6 &#x3D; 9。</li>
<li>另一种方案：向左走到位置 2 (3 步)，摘 8 个水果。总步数是 (5 - 2) &#x3D; 3，小于 4。总水果数是 8。</li>
<li>我们能找到的最优解是先到 6 再到 8，共摘 9 个水果。</li>
</ul>
<p>直接模拟所有可能的路径组合（比如左走 <code>i</code> 步，右走 <code>k-i</code> 步）会非常复杂，且效率低下。</p>
<h3 id="核心思路：滑动窗口与成本计算"><a href="#核心思路：滑动窗口与成本计算" class="headerlink" title="核心思路：滑动窗口与成本计算"></a>核心思路：滑动窗口与成本计算</h3><p>首先，一个关键的观察是：<strong>我们最优的采摘方案一定是采摘 x 轴上一个连续区间内的所有水果</strong>。因为如果我们在路径上跳过了一个水果点，我们完全可以在不增加额外成本的情况下把它摘掉（因为我们已经路过了）。</p>
<p>因此，问题就转化成了：<strong>寻找一个连续的水果区间 <code>[left, right]</code>，使得从 <code>startPos</code> 出发，访问完这个区间内所有水果的总步数不超过 <code>k</code>，并且这个区间的水果总量最大。</strong></p>
<p>这正是滑动窗口算法的用武之地。我们可以把 <code>[left, right]</code> 看作一个在 <code>fruits</code> 数组上滑动的窗口。</p>
<p>这个问题的核心难点在于如何计算访问一个区间 <code>[left_pos, right_pos]</code> 所需的<strong>最小步数</strong>。从 <code>startPos</code> 出发，要覆盖这个区间，无非就两种回头路策略：</p>
<ol>
<li><strong>先去区间的左端点，再一路走到右端点</strong>：步数为 <code>(startPos - left_pos) + (right_pos - left_pos)</code>。</li>
<li><strong>先去区间的右端点，再一路走到左端点</strong>：步数为 <code>(right_pos - startPos) + (right_pos - left_pos)</code>。</li>
</ol>
<p>当然，如果 <code>startPos</code> 本身就在区间的某一边，就不需要走回头路了：</p>
<ul>
<li>如果 <code>startPos</code> 在区间左侧 (<code>startPos &lt;= left_pos</code>)，我们只能一路向右，成本是 <code>right_pos - startPos</code>。</li>
<li>如果 <code>startPos</code> 在区间右侧 (<code>startPos &gt;= right_pos</code>)，我们只能一路向左，成本是 <code>startPos - left_pos</code>。</li>
<li>如果 <code>startPos</code> 在区间内部 (<code>left_pos &lt; startPos &lt; right_pos</code>)，我们就需要从上面两种回头路策略中选择步数更少的那一种。</li>
</ul>
<p>一旦我们确定了这个成本计算方法，就可以套用滑动窗口模板了：</p>
<ul>
<li>用 <code>right</code> 指针扩大窗口。</li>
<li>当窗口的移动成本超过 <code>k</code> 时，用 <code>left</code> 指针收缩窗口。</li>
<li>在每一步都用当前有效窗口的水果总量更新最大值。</li>
</ul>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>滑动窗口初始化</strong>：</p>
<ul>
<li>左指针 <code>left = 0</code>。</li>
<li>记录最大水果数 <code>max_fruits = 0</code>。</li>
<li>记录当前窗口内的水果总数 <code>current_sum = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历与窗口扩张</strong>：</p>
<ul>
<li>用右指针 <code>right</code> 从 <code>0</code> 遍历到 <code>n-1</code>（<code>n</code> 是 <code>fruits</code> 的长度）。</li>
<li>在循环的每一步，将 <code>fruits[right]</code> 的水果数量加入 <code>current_sum</code>。</li>
</ul>
</li>
<li><p><strong>成本判断与窗口收缩</strong>：</p>
<ul>
<li>扩张后，计算覆盖当前窗口 <code>[fruits[left]...fruits[right]]</code> 所需的最小步数 <code>dist</code>。</li>
<li>我们使用一个 <code>while</code> 循环来检查和调整窗口：<ul>
<li>只要 <code>dist &gt; k</code>，就说明当前窗口太“远”或太“宽”，需要从左侧收缩。</li>
<li>将左侧水果 <code>fruits[left]</code> 的数量从 <code>current_sum</code> 中减去，然后将 <code>left</code> 指针右移。</li>
<li>这个 <code>while</code> 循环会一直执行，直到窗口重新满足步数限制 (<code>dist &lt;= k</code>) 为止。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>更新结果</strong>：</p>
<ul>
<li>在每次 <code>right</code> 指针移动后，并且在（可能发生的）收缩操作完成后，当前的窗口 <code>[left...right]</code> 一定是有效的。</li>
<li>我们用 <code>current_sum</code> 来更新 <code>max_fruits</code>。</li>
</ul>
</li>
<li><p><strong>返回最终答案</strong>：</p>
<ul>
<li>遍历结束后，<code>max_fruits</code> 就是我们能找到的最大水果总数。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTotalFruits</span>(<span class="params">self, fruits: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], startPos: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用滑动窗口解决摘水果问题。</span></span><br><span class="line"><span class="string">        我们维护一个水果区间 [left, right] 作为窗口。</span></span><br><span class="line"><span class="string">        随着 right 指针向右移动来扩大窗口，我们检查覆盖当前窗口所需的步数是否超过 k。</span></span><br><span class="line"><span class="string">        如果超过，我们就移动 left 指针来收缩窗口，直到满足步数限制为止。</span></span><br><span class="line"><span class="string">        在每一步，我们都用当前有效窗口内的水果总数来更新最大值。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        max_fruits = <span class="number">0</span></span><br><span class="line">        current_sum = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(fruits)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># right 指针用于扩大窗口</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            right_pos, amount = fruits[right]</span><br><span class="line">            current_sum += amount</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当窗口不满足步数限制时，从左边收缩窗口</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                left_pos = fruits[left][<span class="number">0</span>]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 计算访问 [left_pos, right_pos] 区间的成本</span></span><br><span class="line">                dist = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 情况1: startPos 在整个区间的左侧或重合于左端点，只能向右走</span></span><br><span class="line">                <span class="keyword">if</span> startPos &lt;= left_pos:</span><br><span class="line">                    dist = right_pos - startPos</span><br><span class="line">                <span class="comment"># 情况2: startPos 在整个区间的右侧或重合于右端点，只能向左走</span></span><br><span class="line">                <span class="keyword">elif</span> startPos &gt;= right_pos:</span><br><span class="line">                    dist = startPos - left_pos</span><br><span class="line">                <span class="comment"># 情况3: startPos 在区间内部，需要走回头路</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 策略A: 先左后右 vs 策略B: 先右后左</span></span><br><span class="line">                    dist = <span class="built_in">min</span>(startPos - left_pos, right_pos - startPos) + (right_pos - left_pos)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果所需步数大于 k，则收缩窗口</span></span><br><span class="line">                <span class="keyword">if</span> dist &gt; k:</span><br><span class="line">                    current_sum -= fruits[left][<span class="number">1</span>]</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 否则，当前窗口有效，停止收缩</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 用当前有效窗口的水果总数更新最大值</span></span><br><span class="line">            max_fruits = <span class="built_in">max</span>(max_fruits, current_sum)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> max_fruits</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是 <code>fruits</code> 数组的长度。滑动窗口的左指针 <code>left</code> 和右指针 <code>right</code> 都只会从头到尾各自扫描一遍数组，每个元素最多被访问两次。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个额外变量来存储指针和计数值。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题的核心在于将一个路径规划问题，转化为寻找<strong>最优连续区间</strong>的问题。其难点在于为这个“区间”（即我们的滑动窗口）建立一个正确的成本模型。一旦我们分析清楚了从起点出发覆盖一个区间的两种基本走法（先左后右 vs 先右后左），并处理好边界情况，剩下的就是滑动窗口算法的经典应用了。这个思路将复杂路径问题简化为线性扫描，是算法优化中的一个重要思想。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>滑动窗口</tag>
        <tag>前缀和</tag>
        <tag>第 271 场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2156 | 滚动哈希巧解给定哈希值的子串</title>
    <url>//posts/leetcode-2156/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2156 题：<a href="https://leetcode.cn/problems/find-substring-with-given-hash-value/description/">查找给定哈希值的子串</a>。<br>这道题将我们带入了“滚动哈希”（Rolling Hash）的精妙世界。它不仅仅是一个简单的滑动窗口，更是一次关于如何在模运算下高效更新哈希值的深刻实践。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目要求我们根据一个自定义的哈希函数，在一个长字符串 <code>s</code> 中找到<strong>第一个</strong>长度为 <code>k</code> 且哈希值等于 <code>hashValue</code> 的子串。</p>
<p>这个哈希函数定义如下：<br><code>hash(sub, p, m) = (val(sub[0])*p^0 + val(sub[1])*p^1 + ... + val(sub[k-1])*p^(k-1)) mod m</code></p>
<p>其中 <code>val(c)</code> 是字符 <code>c</code> 的字母表顺序值（<code>&#39;a&#39;</code>&#x3D;1, <code>&#39;b&#39;</code>&#x3D;2, …）。</p>
<ul>
<li><strong>关键点</strong>：我们需要在一个大字符串中，对所有长度为 <code>k</code> 的子串计算哈希值。</li>
<li><strong>目标</strong>：找到满足 <code>hash(sub) == hashValue</code> 的<strong>最靠前</strong>的那个子串。</li>
</ul>
<p>例如，对于 <code>s = &quot;fbxzaad&quot;</code>, <code>p = 31</code>, <code>m = 100</code>, <code>k = 3</code>, <code>hashValue = 32</code>，子串 <code>&quot;fbx&quot;</code> 和 <code>&quot;bxz&quot;</code> 的哈希值都是 32。但因为 <code>&quot;fbx&quot;</code> 在字符串中出现得更早，所以它是正确答案。</p>
<h3 id="核心思路：逆向的滚动哈希"><a href="#核心思路：逆向的滚动哈希" class="headerlink" title="核心思路：逆向的滚动哈希"></a>核心思路：逆向的滚动哈希</h3><h4 id="暴力法的瓶颈"><a href="#暴力法的瓶颈" class="headerlink" title="暴力法的瓶颈"></a>暴力法的瓶颈</h4><p>最直观的方法是遍历 <code>s</code> 中每一个长度为 <code>k</code> 的子串，然后对每个子串都独立计算一次哈希值。这种方法的时间复杂度是 O(N<em>K)，其中 N 是 <code>s</code> 的长度。对于题目给定的数据范围 (<code>N</code> 可达 2</em>10^4)，这种方法会“超出时间限制”。</p>
<h4 id="从左向右滑动的困境"><a href="#从左向右滑动的困境" class="headerlink" title="从左向右滑动的困境"></a>从左向右滑动的困境</h4><p>为了优化，我们自然会想到滑动窗口：当窗口从 <code>s[i:i+k]</code> 滑动到 <code>s[i+1:i+k+1]</code> 时，能否在 O(1) 的时间内更新哈希值？</p>
<ul>
<li><strong>移出</strong>：我们需要减去 <code>val(s[i]) * p^0</code> 的贡献。</li>
<li><strong>移入</strong>：我们需要加入 <code>val(s[i+k]) * p^k</code>… 等等，这里就出现了问题。</li>
</ul>
<p>为了让原有的 <code>val(s[i+1])*p^1</code> 变为 <code>val(s[i+1])*p^0</code>，我们需要将整个哈希值（减去 <code>val(s[i])</code> 之后）除以 <code>power</code>。在模运算中，除以一个数等于乘以它的<strong>模逆元</strong>。计算模逆元本身就很复杂，而且当 <code>power</code> 和 <code>modulo</code> 不互质时，模逆元甚至不存在。这条路走不通。</p>
<h4 id="柳暗花明：从右向左滑动"><a href="#柳暗花明：从右向左滑动" class="headerlink" title="柳暗花明：从右向左滑动"></a>柳暗花明：从右向左滑动</h4><p>既然从左向右有困难，我们何不逆向思考？<strong>从右向左滑动窗口</strong>！</p>
<p>假设我们已知窗口 <code>s[i+1 : i+k+1]</code> 的哈希值 <code>h_old</code>，现在要计算它左边的窗口 <code>s[i : i+k]</code> 的哈希值 <code>h_new</code>。</p>
<ul>
<li><code>h_old = (val(s[i+1])*p^0 + ... + val(s[i+k])*p^(k-1)) mod m</code></li>
</ul>
<p>观察 <code>h_new</code> 的构成：</p>
<ul>
<li><code>h_new = (val(s[i])*p^0 + val(s[i+1])*p^1 + ... + val(s[i+k-1])*p^(k-1)) mod m</code></li>
</ul>
<p>我们可以找到一个递推关系：</p>
<ol>
<li>从 <code>h_old</code> 中减去最右侧字符 <code>s[i+k]</code> 的贡献，即 <code>val(s[i+k]) * p^(k-1)</code>。</li>
<li>将剩余的部分整体乘以 <code>p</code>，这使得每一项的幂次都增加了 1 (<code>p^0</code> -&gt; <code>p^1</code>, <code>p^1</code> -&gt; <code>p^2</code>…)。</li>
<li>最后，加上新进入窗口的字符 <code>s[i]</code> 的贡献，即 <code>val(s[i]) * p^0</code>。</li>
</ol>
<p>于是，我们得到了一个完美的 O(1) 更新公式：<br><code>h_new = ((h_old - val(s[i+k]) * p^(k-1)) * p + val(s[i])) mod m</code><br>这个公式只涉及加、减、乘，在模运算下非常简单！</p>
<h3 id="滑动窗口算法详解"><a href="#滑动窗口算法详解" class="headerlink" title="滑动窗口算法详解"></a>滑动窗口算法详解</h3><ol>
<li><p><strong>准备工作</strong>:</p>
<ul>
<li>预先计算 <code>power^(k-1) % modulo</code>，记为 <code>pk_1</code>。这个值在每次移除窗口最右侧字符时都会用到。</li>
</ul>
</li>
<li><p><strong>初始化窗口</strong>:</p>
<ul>
<li>我们从字符串的<strong>最右端</strong>开始。首先完整计算最后一个窗口 <code>s[n-k : n]</code> 的哈希值，作为我们的初始 <code>current_hash</code>。</li>
<li>检查这个初始哈希值是否与 <code>hashValue</code> 匹配。如果匹配，记录下当前的起始索引 <code>n-k</code> 作为候选答案。</li>
</ul>
</li>
<li><p><strong>逆向滑动窗口</strong>:</p>
<ul>
<li>从 <code>i = n-k-1</code> 开始，循环递减至 <code>0</code>。<code>i</code> 代表新窗口的起始位置。</li>
<li>在每次循环中，使用上面推导出的滚动哈希公式来更新 <code>current_hash</code>。<ul>
<li><strong>移出</strong>：减去旧窗口最右侧字符 <code>s[i+k]</code> 的贡献。</li>
<li><strong>乘幂</strong>：将结果乘以 <code>power</code>。</li>
<li><strong>移入</strong>：加上新窗口最左侧字符 <code>s[i]</code> 的贡献。</li>
<li><strong>注意</strong>：在进行模减法时，为防止出现负数，应写成 <code>(a - b + modulo) % modulo</code>。</li>
</ul>
</li>
<li>每次更新哈希值后，都与 <code>hashValue</code> 进行比较。</li>
<li>由于我们是从右向左遍历，任何一次匹配都意味着我们找到了一个比之前更靠前的答案。因此，只要匹配成功，就更新结果索引为当前的 <code>i</code>。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>:</p>
<ul>
<li>循环结束后，记录的最终索引就是题目所求的第一个满足条件的子串的起始位置。返回该子串即可。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subStrHash</span>(<span class="params">self, s: <span class="built_in">str</span>, power: <span class="built_in">int</span>, modulo: <span class="built_in">int</span>, k: <span class="built_in">int</span>, hashValue: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 辅助函数，将 &#x27;a&#x27;-&#x27;z&#x27; 映射到 1-26</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">val</span>(<span class="params">c</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 1：预计算 p^(k-1) % m，用于移除窗口最右侧字符</span></span><br><span class="line">        pk_1 = <span class="built_in">pow</span>(power, k - <span class="number">1</span>, modulo)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2：计算最右侧第一个窗口 s[n-k : n] 的哈希值</span></span><br><span class="line">        current_h = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            i = n - k + j <span class="comment"># 窗口内字符的索引</span></span><br><span class="line">            current_h = (current_h + val(s[i]) * <span class="built_in">pow</span>(power, j, modulo)) % modulo</span><br><span class="line">        </span><br><span class="line">        res_index = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> current_h == hashValue:</span><br><span class="line">            res_index = n - k</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 3：从右向左滑动窗口</span></span><br><span class="line">        <span class="comment"># i 是新窗口的起始索引</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - k - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># old_hash (current_h) 对应 s[i+1 : i+k+1]</span></span><br><span class="line">            <span class="comment"># new_hash (将要计算的) 对应 s[i : i+k]</span></span><br><span class="line">            </span><br><span class="line">            old_right_val = val(s[i + k])</span><br><span class="line">            new_left_val = val(s[i])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 应用滚动哈希公式</span></span><br><span class="line">            <span class="comment"># a) 移除旧窗口最右侧字符的贡献</span></span><br><span class="line">            term_to_remove = (old_right_val * pk_1) % modulo</span><br><span class="line">            current_h = (current_h - term_to_remove + modulo) % modulo</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># b) 所有项幂次加一</span></span><br><span class="line">            current_h = (current_h * power) % modulo</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># c) 加上新窗口最左侧字符的贡献</span></span><br><span class="line">            current_h = (current_h + new_left_val) % modulo</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 检查哈希值是否匹配</span></span><br><span class="line">            <span class="keyword">if</span> current_h == hashValue:</span><br><span class="line">                res_index = i <span class="comment"># 更新为更靠前的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 4：返回结果</span></span><br><span class="line">        <span class="keyword">return</span> s[res_index : res_index + k]</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是字符串 <code>s</code> 的长度。初始哈希计算耗时 O(K)，逆向滑动窗口循环 N-K 次，每次更新是 O(1)。总复杂度为 O(K + N - K) &#x3D; O(N)，实现了线性时间求解。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个变量来存储哈希值和中间计算结果。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滚动哈希算法的绝佳应用案例。它告诉我们，当标准的从左到右的滑动窗口遇到数学难题（如模逆元）时，不妨换个方向思考。<strong>逆向滑动</strong>在本题中优雅地绕开了复杂的模除法，将哈希值的更新简化为基础的模运算，充分展现了算法设计的灵活性和数学之美。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
        <tag>哈希函数</tag>
        <tag>滚动哈希</tag>
        <tag>第 278 场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2271 | 滑动窗口求解“毯子覆盖的最多白色砖块数”</title>
    <url>//posts/leetcode-2271/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2271 题：<a href="https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet/">毯子覆盖的最多白色砖块数</a>。<br>此题的核心在于如何高效地计算一个固定长度的“毯子”在任意位置能够覆盖的最大瓷砖数。通过将问题巧妙转化为“端点对齐”，并结合“排序”与“滑动窗口”，我们可以找到优雅的线性时间解法。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个二维数组 <code>tiles</code>，其中每个 <code>tiles[i] = [li, ri]</code> 代表一段连续的白色瓷砖。同时，我们还有一个长度为 <code>carpetLen</code> 的毯子。我们的目标是，将这块毯子放置在某个位置，使其能够覆盖的白色瓷砖数量达到最大，并返回这个最大值。</p>
<p>我们来分析一下这个目标：</p>
<ul>
<li>我们有一块固定长度的毯子，可以放置在数轴的任何位置。</li>
<li>我们需要找到一个最佳的起始点，使得区间 <code>[start, start + carpetLen - 1]</code> 覆盖的白色瓷砖总数最多。</li>
<li>一个非常关键的观察是：<strong>毯子的最优摆放位置，其左端点或右端点必然与某块瓷砖的端点对齐</strong>。为什么呢？试想，如果一个最优位置的毯子，其两端都没有与任何瓷砖的端点对齐，我们总可以将它向左或向右平移，直到有一个端点对齐为止，而这个过程中覆盖的瓷砖数不会减少。</li>
</ul>
<p>基于这个观察，我们可以简化问题：我们只需要考虑所有“毯子右端点与某块瓷砖的右端点对齐”的情况，并从中找出最优解即可。（选择左端点对齐也是同理的）。</p>
<p>举个例子，对于 <code>tiles = [[1,5], [10,11]], carpetLen = 6</code>：</p>
<ul>
<li>如果我们让毯子右端点与 <code>tiles[0]</code> 的右端点 <code>5</code> 对齐，毯子覆盖的区间是 <code>[5 - 6 + 1, 5] = [0, 5]</code>。这个区间覆盖了 <code>[1,5]</code> 这一整块瓷砖，长度为 5。</li>
<li>如果我们让毯子右端点与 <code>tiles[1]</code> 的右端点 <code>11</code> 对齐，毯子覆盖的区间是 <code>[11 - 6 + 1, 11] = [6, 11]</code>。这个区间覆盖了 <code>[10,11]</code> 这一整块瓷砖，长度为 2。</li>
<li>比较可知，最大覆盖数为 5。</li>
</ul>
<h3 id="核心思路：排序-滑动窗口"><a href="#核心思路：排序-滑动窗口" class="headerlink" title="核心思路：排序 + 滑动窗口"></a>核心思路：排序 + 滑动窗口</h3><p>这类在连续区间上求解最值的问题，通常是滑动窗口算法的绝佳应用场景。为了让窗口能够顺利地在瓷砖上“滑动”，<strong>先按瓷砖的起始位置排序</strong>是必不可少的一步。</p>
<p><strong>为什么需要排序？</strong><br>排序后，我们可以从左到右依次处理每一块瓷砖，保证了我们的窗口指针不会来回跳跃。这使得我们能够维护一个包含“可能被当前毯子覆盖的”瓷砖集合的窗口。</p>
<p>算法的动态过程如下：</p>
<ol>
<li><strong>排序</strong>：首先对 <code>tiles</code> 数组按照每块瓷砖的起始位置进行升序排序。</li>
<li><strong>窗口设定</strong>：我们使用 <code>left</code> 和 <code>right</code> 两个指针来维护一个窗口 <code>tiles[left...right]</code>。</li>
<li><strong>窗口扩张</strong>：<code>right</code> 指针不断向右移动，考察以 <code>tiles[right]</code> 为最右侧瓷砖的覆盖情况。</li>
<li><strong>成本计算与窗口收缩</strong>：<ul>
<li>我们假设毯子的<strong>右端点</strong>与 <code>tiles[right]</code> 的<strong>右端点</strong>对齐。那么毯子的起始位置就是 <code>carpet_start = tiles[right][1] - carpetLen + 1</code>。</li>
<li>此时，窗口内的瓷砖 <code>tiles[left]</code> 可能已经完全处在这块毯子的左侧（即 <code>tiles[left][1] &lt; carpet_start</code>），对当前的覆盖没有任何贡献。</li>
<li>如果出现这种情况，我们就需要收缩窗口，将 <code>left</code> 指针向右移动，并将 <code>tiles[left]</code> 的长度从当前覆盖总数中减去，直到 <code>tiles[left]</code> 至少有一部分能被当前毯子覆盖。</li>
</ul>
</li>
<li><strong>结果更新</strong>：<ul>
<li>在窗口调整完毕后，窗口 <code>[left...right]</code> 内的所有瓷砖都与当前毯子有交集。</li>
<li>但需要特别注意，最左侧的 <code>tiles[left]</code> 可能只有<strong>一部分</strong>被覆盖。我们需要计算出它“伸出”毯子左侧的部分，并从总覆盖数中减去。</li>
<li>用这个精确的覆盖数来更新全局的最大覆盖数。</li>
</ul>
</li>
</ol>
<p>通过这个“扩张-计算-收缩”的循环，我们就能在 O(N) 的时间内（排序后）找到答案。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>排序</strong>：</p>
<ul>
<li>对输入数组 <code>tiles</code> 按起始位置 <code>l_i</code> 进行升序排序。</li>
</ul>
</li>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>左指针 <code>left = 0</code>。</li>
<li>记录最大覆盖数 <code>max_coverage = 0</code>。</li>
<li>记录当前窗口内所有瓷砖的总长度 <code>current_coverage = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历与扩张</strong>：</p>
<ul>
<li>用右指针 <code>right</code> 从 <code>0</code> 到 <code>n-1</code> 遍历排序后的 <code>tiles</code> 数组。</li>
<li>在循环的每一步，首先将新瓷砖 <code>tiles[right]</code> 的完整长度加入 <code>current_coverage</code>。</li>
</ul>
</li>
<li><p><strong>收缩</strong>：</p>
<ul>
<li>确定当前毯子的理论起始位置 <code>carpet_start = tiles[right][1] - carpetLen + 1</code>。</li>
<li>使用一个 <code>while</code> 循环检查窗口左边界的有效性。条件是：<code>tiles[left][1] &lt; carpet_start</code>。</li>
<li>只要条件成立，说明 <code>tiles[left]</code> 完全在毯子左侧，需要将其移出窗口。</li>
<li>收缩操作：从 <code>current_coverage</code> 中减去 <code>tiles[left]</code> 的长度，然后将 <code>left</code> 指针右移一位。</li>
</ul>
</li>
<li><p><strong>计算精确覆盖并更新结果</strong>：</p>
<ul>
<li><code>while</code> 循环结束后，<code>tiles[left]</code> 是第一个与毯子有交集的瓷砖。</li>
<li>计算 <code>tiles[left]</code> 可能伸出毯子左侧的长度（即未被覆盖的部分）：<code>lost_coverage = max(0, carpet_start - tiles[left][0])</code>。</li>
<li>当前毯子位置的实际覆盖数是 <code>current_coverage - lost_coverage</code>。</li>
<li>用这个实际覆盖数更新全局最大值：<code>max_coverage = max(max_coverage, current_coverage - lost_coverage)</code>。</li>
</ul>
</li>
<li><p><strong>返回</strong>：</p>
<ul>
<li><code>right</code> 指针遍历完整个数组后，<code>max_coverage</code> 中存储的就是最终答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumWhiteTiles</span>(<span class="params">self, tiles: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], carpetLen: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1: 排序是关键前提</span></span><br><span class="line">        tiles.sort()</span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(tiles)</span><br><span class="line">        <span class="comment"># 步骤 2: 初始化指针和状态变量</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        max_coverage = <span class="number">0</span></span><br><span class="line">        current_coverage = <span class="number">0</span>  <span class="comment"># 窗口内瓷砖的总长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 遍历数组，right 指针用于扩张窗口</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            start_r, end_r = tiles[right]</span><br><span class="line">            current_coverage += (end_r - start_r + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 确定当前毯子的理论起始位置</span></span><br><span class="line">            carpet_start = end_r - carpetLen + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 4: 当窗口左边界不满足条件时，进行收缩</span></span><br><span class="line">            <span class="keyword">while</span> tiles[left][<span class="number">1</span>] &lt; carpet_start:</span><br><span class="line">                start_l, end_l = tiles[left]</span><br><span class="line">                current_coverage -= (end_l - start_l + <span class="number">1</span>)</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 5: 计算精确覆盖并更新结果</span></span><br><span class="line">            <span class="comment"># 此时，tiles[left] 可能被部分覆盖，计算其未被覆盖的长度</span></span><br><span class="line">            lost_coverage = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> tiles[left][<span class="number">0</span>] &lt; carpet_start:</span><br><span class="line">                lost_coverage = carpet_start - tiles[left][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 用 (窗口内总长度 - 左侧未覆盖长度) 更新最大值</span></span><br><span class="line">            max_coverage = <span class="built_in">max</span>(max_coverage, current_coverage - lost_coverage)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> max_coverage</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N log N)。其中 N 是 <code>tiles</code> 数组的长度。算法的瓶颈在于初始的排序步骤，其时间复杂度为 O(N log N)。后续的滑动窗口遍历中，<code>left</code> 和 <code>right</code> 指针都只会从头到尾移动一次，所以是 O(N) 的。因此，总的时间复杂度为 O(N log N)。</li>
<li><strong>空间复杂度</strong>: O(log N) 或 O(N)。这取决于编程语言中排序算法的实现。例如，Python 的 Timsort 在最坏情况下需要 O(N) 的空间，而一些快速排序的实现会使用 O(log N) 的递归栈空间。如果我们不考虑排序所用的空间，则算法本身只使用了常数个额外变量，空间复杂度为 O(1)。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“排序 + 滑动窗口”组合拳的又一个典型应用。解决这类问题的关键路径非常清晰：</p>
<ol>
<li><strong>发现简化问题的关键性质</strong>：通过分析题目，找到一个可以简化搜索范围的策略。在本题中，这个策略就是“最优毯子的端点必然与某块瓷砖的端点对齐”。</li>
<li><strong>排序</strong>：为了方便地处理区间，排序几乎是必须的预处理步骤。</li>
<li><strong>定义窗口与状态</strong>：明确滑动窗口的左右边界代表什么，以及需要维护哪些状态变量来高效判断窗口的有效性（本题中是 <code>current_coverage</code>）。</li>
<li><strong>处理边界情况</strong>：滑动窗口问题中，最精髓也最容易出错的地方，就是对窗口边界处部分元素的处理（本题中是对 <code>tiles[left]</code> 的部分覆盖计算）。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>滑动窗口</tag>
        <tag>排序</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2302 | 滑动窗口求解“统计得分小于 K 的子数组数目”</title>
    <url>//posts/leetcode-2302/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2302 题：<a href="https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/">统计得分小于 K 的子数组数目</a>。<br>该题定义了一种新颖的“分数”计算方式（数组和 * 数组长），要求我们统计所有分数严格小于给定值 k 的子数组数量。这是一个典型的可以使用不定长滑动窗口解决的子数组计数问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目定义了一个数组的“分数”，其计算方式为该数组所有元素之和乘以其长度。例如，数组 <code>[1, 2, 3]</code> 的分数为 <code>(1 + 2 + 3) * 3 = 18</code>。</p>
<p>我们需要处理一个给定的正整数数组 <code>nums</code> 和一个整数 <code>k</code>，任务是找出 <code>nums</code> 中有多少个非空子数组，其分数 <strong>严格小于</strong> <code>k</code>。</p>
<p>我们来看一个例子，<code>nums = [2,1,4,3,5], k = 10</code>：</p>
<ul>
<li>子数组 <code>[2, 1]</code> 的分数为 <code>(2 + 1) * 2 = 6</code>。因为 <code>6 &lt; 10</code>，所以这是一个符合条件的子数组。</li>
<li>子数组 <code>[1, 4]</code> 的分数为 <code>(1 + 4) * 2 = 10</code>。因为分数没有严格小于 10，所以这个子数组 <strong>不</strong> 符合条件。</li>
<li>所有单个元素的子数组如 <code>[2]</code>、<code>[1]</code> 等，它们的分数分别为 2, 1, 4, 3, 5，都小于 10。</li>
</ul>
<p>我们的目标就是计算出所有这类符合条件的子数组的总数。</p>
<h3 id="核心思路：不定长滑动窗口"><a href="#核心思路：不定长滑动窗口" class="headerlink" title="核心思路：不定长滑动窗口"></a>核心思路：不定长滑动窗口</h3><p>暴力解法是枚举所有的子数组，计算其分数并判断是否小于 <code>k</code>。一个有 N 个元素的数组，有 O(N^2) 个子数组，计算每个子数组的和还需要时间，总复杂度至少为 O(N^2)，对于 <code>N = 10^5</code> 的数据规模来说太慢了。</p>
<p>这类涉及连续子数组统计的问题，通常可以考虑使用滑动窗口来优化。我们观察分数的计算公式：<code>score = sum * length</code>。当窗口向右扩大时，<code>sum</code> 和 <code>length</code> 都在增加，因此 <code>score</code> 也是单调递增的。这个单调性是使用滑动窗口的绝佳信号。</p>
<p>我们的策略如下：</p>
<ol>
<li>我们用一个窗口 <code>[l, r]</code>（表示子数组 <code>nums[l...r]</code>）在数组上滑动。我们固定右端点 <code>r</code>，然后找到一个最左边的左端点 <code>l</code>，使得 <code>[l, r]</code> 这个窗口的分数刚好满足 <code>&lt; k</code>。</li>
<li>由于分数的单调性，如果 <code>[l, r]</code> 的分数小于 <code>k</code>，那么所有以 <code>r</code> 为右端点，但比 <code>[l, r]</code> 更短的子数组（例如 <code>[l+1, r]</code>, <code>[l+2, r]</code> 等）的分数也必然小于 <code>k</code>。</li>
<li>因此，一旦我们为 <code>r</code> 找到了这个最左的 <code>l</code>，那么以 <code>r</code> 为右端点的所有有效子数组就是：<code>[l, r]</code>, <code>[l+1, r]</code>, …, <code>[r, r]</code>。它们的数量正好是 <code>r - l + 1</code>。</li>
<li>我们让 <code>r</code> 从头到尾遍历数组，在每一步都找出对应的 <code>l</code> 并累加子数组数量，就能得到最终答案。因为当 <code>r</code> 向右移动时，<code>l</code> 只会向右移动或保持不变（绝不会向左），所以两个指针的总移动次数是线性的，保证了 O(N) 的时间复杂度。</li>
</ol>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><strong>初始化</strong>: 初始化左指针 <code>l = 0</code>，当前窗口的和 <code>current_sum = 0</code>，以及结果 <code>ans = 0</code>。</li>
<li><strong>遍历与扩张</strong>: 使用右指针 <code>r</code> 遍历数组，从 <code>0</code> 到 <code>n-1</code>。在循环的每一步，首先将 <code>nums[r]</code> 加到 <code>current_sum</code> 中，这代表窗口向右扩张了一步。</li>
<li><strong>检查与收缩</strong>: 此时窗口为 <code>[l, r]</code>。我们需要检查它的分数是否满足条件。使用一个 <code>while</code> 循环判断，只要 <code>current_sum * (r - l + 1) &gt;= k</code>，就说明当前窗口的分数过大或等于 <code>k</code>，不满足”严格小于”的要求。因此，我们需要从左边收缩窗口：将 <code>nums[l]</code> 从 <code>current_sum</code> 中减去，然后将 <code>l</code> 指针右移一位 (<code>l += 1</code>)。</li>
<li><strong>计数</strong>: <code>while</code> 循环结束后，我们保证了当前窗口 <code>[l, r]</code> 的分数是严格小于 <code>k</code> 的。如核心思路所述，这意味着所有以 <code>r</code> 为右端点、<code>l</code> 或更右的位置为左端点的子数组都是有效的。这些子数组的数量为 <code>r - l + 1</code>。我们将这个数量累加到 <code>ans</code> 上。</li>
<li><strong>循环</strong>: 指针 <code>r</code> 继续向右移动，重复步骤 2 到 4，直到遍历完整个数组。</li>
<li><strong>返回</strong>: 最终 <code>ans</code> 中就存储了所有满足条件的子数组数目。</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><p>下面是该思路的 Python3 代码实现，也就是您在问题中提供的优雅解法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubarrays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># ans: 结果计数</span></span><br><span class="line">        <span class="comment"># l: 滑动窗口的左指针</span></span><br><span class="line">        <span class="comment"># w: 当前窗口内元素的和 (window_sum)</span></span><br><span class="line">        ans = l = <span class="number">0</span></span><br><span class="line">        w = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># r 是右指针，x 是当前右指针指向的元素值</span></span><br><span class="line">        <span class="keyword">for</span> r, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 步骤 2: 扩大窗口，将新元素加入和</span></span><br><span class="line">            w += x</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 3: 检查分数，如果分数不满足条件则收缩窗口</span></span><br><span class="line">            <span class="comment"># 窗口长度是 r - l + 1</span></span><br><span class="line">            <span class="keyword">while</span> w * (r - l + <span class="number">1</span>) &gt;= k:</span><br><span class="line">                <span class="comment"># 从和中移除最左边的元素</span></span><br><span class="line">                w -= nums[l]</span><br><span class="line">                <span class="comment"># 左指针右移</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 4: 计数</span></span><br><span class="line">            <span class="comment"># 此时 [l, r] 是最大的有效窗口</span></span><br><span class="line">            <span class="comment"># 所有以 r 结尾的有效子数组数量为 r - l + 1</span></span><br><span class="line">            ans += r - l + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是数组 <code>nums</code> 的长度。右指针 <code>r</code> 和左指针 <code>l</code> 都只从左到右遍历数组一次，每个元素最多被访问两次（一次被 <code>r</code> 访问，一次被 <code>l</code> 访问）。因此，总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个额外变量（<code>ans</code>, <code>l</code>, <code>w</code>, <code>r</code>, <code>x</code>），没有使用与输入规模相关的额外空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想的一个经典应用。问题的关键在于识别出“分数”这个指标随着子数组的扩张具有单调性。一旦发现了这个特性，就可以抛弃 O(N^2) 的暴力枚举，转而使用双指针维护一个“有效”的窗口。通过高效地扩张和收缩窗口，在单次遍历中完成所有子数组的统计，从而达到 O(N) 的最优时间复杂度。这个从“固定一端，寻找另一端”到“两端协同移动”的思维转变，是掌握滑动窗口技巧的核心。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>滑动窗口</tag>
        <tag>前缀和</tag>
        <tag>第80场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2401 | 滑动窗口求解“最长优雅子数组”</title>
    <url>//posts/leetcode-2401/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2401 题：<a href="https://leetcode.cn/problems/longest-nice-subarray/description/">最长优雅子数组</a>。<br>该题要求寻找一个最长的子数组，其中任意两个元素的按位与（AND）都为 0。这是一个非常适合使用滑动窗口解决的问题，关键在于如何高效地维护窗口的“优雅”属性。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个正整数组成的数组 <code>nums</code>，需要我们找到一个<strong>最长</strong>的<strong>连续子数组</strong>，这个子数组被称为“优雅的”。</p>
<p>一个子数组是“优雅的”，当且仅当其中任意两个不同位置的数字，它们的按位与（AND）运算结果都等于 0。这意味着，在一个优雅子数组中，所有数字的二进制表示里，任意一个为 ‘1’ 的 bit 位，在其他所有数字的对应 bit 位上都必须是 ‘0’。</p>
<p>举个例子，对于 <code>nums = [1,3,8,48,10]</code>：</p>
<ul>
<li>我们来看子数组 <code>[3, 8, 48]</code>：<ul>
<li>3 的二进制是 <code>00011</code></li>
<li>8 的二进制是 <code>01000</code></li>
<li>48 的二进制是 <code>110000</code></li>
</ul>
</li>
<li>检查任意一对：<ul>
<li><code>3 &amp; 8</code> &#x3D; <code>00011 &amp; 01000</code> &#x3D; <code>0</code></li>
<li><code>3 &amp; 48</code> &#x3D; <code>00011 &amp; 110000</code> &#x3D; <code>0</code></li>
<li><code>8 &amp; 48</code> &#x3D; <code>01000 &amp; 110000</code> &#x3D; <code>0</code></li>
</ul>
</li>
<li>所有配对的按位与结果都为 0，所以 <code>[3, 8, 48]</code> 是一个优雅子数组，长度为 3。题目要求我们返回这个最长的长度。</li>
</ul>
<p>如果用暴力法枚举所有子数组，再对子数组里的每一对数字进行检查，时间复杂度会非常高，无法通过。我们需要一种更高效的方法。</p>
<h3 id="核心思路：滑动窗口与位运算"><a href="#核心思路：滑动窗口与位运算" class="headerlink" title="核心思路：滑动窗口与位运算"></a>核心思路：滑动窗口与位运算</h3><p>这道题的“连续子数组”和“最长”两个关键词强烈地指向了<strong>滑动窗口</strong>算法。我们可以维护一个窗口 <code>[l, r]</code>，确保这个窗口内的子数组始终是“优雅的”，然后不断尝试扩大这个窗口，并记录其最大长度。</p>
<p>问题的关键在于：当窗口右边界 <code>r</code> 纳入一个新元素 <code>nums[r]</code> 时，我们如何快速判断窗口 <code>[l, r]</code> 是否仍然优雅？</p>
<p>如果逐一检查 <code>nums[r]</code> 与窗口内 <code>nums[l]</code> 到 <code>nums[r-1]</code> 的每一个数，效率依然很低。这里有一个重要的转换：<strong>一个子数组是优雅的，等价于这个子数组中所有元素的按位或（OR）结果等于它们的按位异或（XOR）结果，也等价于所有元素的按位或（OR）结果等于它们的和</strong>。</p>
<p>一个更直接的判断方法是：如果我们将窗口内已有元素 <code>nums[l...r-1]</code> 的所有 bit 位 ‘1’ 合并成一个集合（通过按位或运算），那么新元素 <code>nums[r]</code> 要能被加入窗口，当且仅当 <code>nums[r]</code> 的所有 bit 位 ‘1’ 在这个集合中都没有出现过。</p>
<p>这可以用一个简单的位运算来检查：<br><code>(窗口内所有元素的 OR 值) &amp; (新元素 nums[r]) == 0</code></p>
<p>基于这个思想，我们的滑动窗口策略就变得清晰了：</p>
<ol>
<li>维护一个变量 <code>or_sum</code>，它存储了当前窗口 <code>[l, r]</code> 内所有数字的按位或（OR）结果。</li>
<li>当右指针 <code>r</code> 向右移动，我们考虑加入新元素 <code>x = nums[r]</code>。</li>
<li>我们检查 <code>or_sum &amp; x</code> 是否为 0。<ul>
<li>如果不为 0，说明 <code>x</code> 的某个 bit 位在 <code>or_sum</code> 中已经存在，产生了冲突。此时，我们需要从左边收缩窗口，即<code>l++</code>。在收缩时，需要将 <code>nums[l]</code> 的影响从 <code>or_sum</code> 中移除。因为优雅子数组中所有数的 bit 位都不同，OR 和 XOR 的效果是一样的，所以我们可以通过 <code>or_sum ^= nums[l]</code> 来移除 <code>nums[l]</code> 的 bit 位。我们重复此过程，直到 <code>or_sum &amp; x</code> 等于 0 为止。</li>
<li>如果为 0（或者经过收缩后变为 0），说明 <code>x</code> 可以安全地加入窗口。我们更新 <code>or_sum</code>，<code>or_sum |= x</code>，将 <code>x</code> 的 bit 位合并进来。</li>
</ul>
</li>
<li>每一次成功扩大窗口后，我们用当前的窗口长度 <code>r - l + 1</code> 来更新最终答案。</li>
</ol>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化</strong>:</p>
<ul>
<li><code>ans = 0</code>: 存储最长优雅子数组的长度。</li>
<li><code>l = 0</code>: 滑动窗口的左边界。</li>
<li><code>or_sum = 0</code> (在代码中用 <code>_</code> 表示): 存储当前窗口内所有元素的按位或结果。</li>
</ul>
</li>
<li><p><strong>遍历与窗口移动</strong>:</p>
<ul>
<li>使用 <code>for</code> 循环，让右边界 <code>r</code> 从 0 遍历到数组末尾，<code>x</code> 为当前元素 <code>nums[r]</code>。</li>
<li><strong>检查冲突与收缩窗口</strong>：用一个 <code>while</code> 循环检查 <code>(or_sum &amp; x) != 0</code>。只要存在冲突：<ul>
<li>从 <code>or_sum</code> 中移除最左侧元素 <code>nums[l]</code> 的影响：<code>or_sum ^= nums[l]</code>。</li>
<li>将左边界右移：<code>l += 1</code>。</li>
</ul>
</li>
<li><strong>扩大窗口</strong>：<code>while</code> 循环结束后，说明冲突已解决，新元素 <code>x</code> 可以加入。更新 <code>or_sum</code>：<code>or_sum |= x</code>。</li>
<li><strong>更新答案</strong>：此时的窗口 <code>[l, r]</code> 是优雅的，其长度为 <code>r - l + 1</code>。更新 <code>ans = max(ans, r - l + 1)</code>。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>:</p>
<ul>
<li>遍历结束后，<code>ans</code> 即为所求。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><p>下面是题目给出的 Python 代码，逻辑清晰地实现了上述思路。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestNiceSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = l = _ = <span class="number">0</span> <span class="comment"># _ 用来存储窗口内元素的按位或(OR)结果</span></span><br><span class="line">        <span class="keyword">for</span> r,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 当新元素 x 与窗口内已有元素的 OR 结果有重叠的 bit 位时</span></span><br><span class="line">            <span class="keyword">while</span> _ &amp; x:</span><br><span class="line">                <span class="comment"># 从窗口左侧移出元素 nums[l]</span></span><br><span class="line">                <span class="comment"># 因为在优雅子数组中，OR 和 XOR 效果相同，所以用 XOR 移除</span></span><br><span class="line">                _ ^= nums[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将新元素 x 的 bit 位加入到集合中</span></span><br><span class="line">            _ |= x</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新最长长度</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans,r-l+<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是 <code>nums</code> 的长度。虽然代码中有 <code>while</code> 循环嵌套在 <code>for</code> 循环中，但左右两个指针 <code>l</code> 和 <code>r</code> 都始终只向右移动，不回退。每个元素最多被右指针访问一次，被左指针访问一次。因此，总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了几个额外的变量 (<code>ans</code>, <code>l</code>, <code>_</code>)，占用的空间是常数级别的。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题巧妙地将一个看似复杂的子数组性质判断问题，通过<strong>位运算</strong>的洞察，转化成了一个可以在 O(1) 时间内完成的状态检查。这使得标准的<strong>滑动窗口</strong>算法得以高效应用。它是一个很好的例子，展示了如何利用问题的数学或逻辑特性来优化算法，将一个暴力解法可能会达到 O(N³) 的问题，降维到 O(N) 解决。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>位运算</tag>
        <tag>滑动窗口</tag>
        <tag>第309场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2516 | 滑动窗口与逆向思维：求解“每种字符至少取 K 个”</title>
    <url>//posts/leetcode-2516/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2516 题：<a href="https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/">每种字符至少取 K 个</a>。<br>这道题要求我们从字符串的两端拿走字符，乍看之下似乎需要复杂的双指针或动态规划。但如果我们转换一下思路，它就变成了一个非常巧妙的滑动窗口问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个仅包含 ‘a’, ‘b’, ‘c’ 的字符串 <code>s</code> 和一个整数 <code>k</code>。我们需要从字符串的<strong>最左侧</strong>或<strong>最右侧</strong>取走字符，目标是达成“每种字符 (‘a’, ‘b’, ‘c’) 都至少取了 <code>k</code> 个”的条件。我们要找到满足这个条件所需的最少操作次数（即取走的最少字符总数）。</p>
<p>举个例子，对于 <code>s = &quot;aabaaaacaabc&quot;</code>, <code>k = 2</code>：</p>
<ul>
<li>我们的目标是最终取走的字符集合中，至少有 2 个 ‘a’，2 个 ‘b’，和 2 个 ‘c’。</li>
<li>一种可行的方案是：从左边取 3 个字符 (<code>&quot;aab&quot;</code>)，从右边取 5 个字符 (<code>&quot;aabc&quot;</code>)。</li>
<li>总共取走的字符是 <code>&quot;aab&quot;</code> 和 <code>&quot;aabc&quot;</code> 的组合，包含了 3 个 ‘a’，2 个 ‘b’，2 个 ‘c’，满足条件。</li>
<li>总共取走的字符数是 3 + 5 &#x3D; 8。题目要求我们找到这个最小的总数。</li>
</ul>
<p>直接去模拟从两端取字符的过程，情况会非常复杂，因为左边取 <code>i</code> 个，右边就要相应地调整，很难找到最优解。</p>
<h3 id="核心思路：逆向思维与滑动窗口"><a href="#核心思路：逆向思维与滑动窗口" class="headerlink" title="核心思路：逆向思维与滑动窗口"></a>核心思路：逆向思维与滑动窗口</h3><p>当“两端操作求最优解”变得困难时，我们不妨逆向思考：<strong>从两端取走最少的字符，等价于在中间保留最长的连续子串。</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/11/29/example-1.png" alt="Sliding Window Explanation"></p>
<p>我们的问题就转化成了：在 <code>s</code> 中寻找一个<strong>最长的连续子字符串</strong>，使得这个子字符串<strong>之外</strong>的剩余部分，’a’, ‘b’, ‘c’ 的数量都至少为 <code>k</code>。</p>
<p>假设整个字符串 <code>s</code> 中 ‘a’, ‘b’, ‘c’ 的总数分别是 <code>total_a</code>, <code>total_b</code>, <code>total_c</code>。<br>如果我们中间保留的窗口（子字符串）中 ‘a’, ‘b’, ‘c’ 的数量是 <code>window_a</code>, <code>window_b</code>, <code>window_c</code>。</p>
<p>那么，在窗口之外（也就是我们从两端取走的部分）的字符数量就是：</p>
<ul>
<li>取走的 ‘a’ 数量：<code>total_a - window_a</code></li>
<li>取走的 ‘b’ 数量：<code>total_b - window_b</code></li>
<li>取走的 ‘c’ 数量：<code>total_c - window_c</code></li>
</ul>
<p>根据题意，我们需要满足：</p>
<ul>
<li><code>total_a - window_a &gt;= k</code></li>
<li><code>total_b - window_b &gt;= k</code></li>
<li><code>total_c - window_c &gt;= k</code></li>
</ul>
<p>将这些不等式变形，我们就可以得到对<strong>中间保留窗口</strong>的约束条件：</p>
<ul>
<li><code>window_a &lt;= total_a - k</code></li>
<li><code>window_b &lt;= total_b - k</code></li>
<li><code>window_c &lt;= total_c - k</code></li>
</ul>
<p>现在，问题变得清晰了：<strong>找到一个最长的连续子字符串，其中 ‘a’, ‘b’, ‘c’ 的数量分别不超过 <code>total_a - k</code>、<code>total_b - k</code> 和 <code>total_c - k</code></strong>。</p>
<p>这正是滑动窗口算法擅长解决的“寻找满足特定条件的最长子串”问题！我们只需要用滑动窗口找到这个最长窗口的长度 <code>max_len</code>，最终答案就是 <code>s</code> 的总长度减去 <code>max_len</code>。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>预处理与边界检查</strong>：</p>
<ul>
<li>如果 <code>k=0</code>，不需要取任何字符，直接返回 0。</li>
<li>统计整个字符串 <code>s</code> 中 ‘a’, ‘b’, ‘c’ 的总数 <code>total_counts</code>。</li>
<li>如果任意一种字符的总数本身就小于 <code>k</code>，那无论如何也无法满足条件，直接返回 -1。</li>
</ul>
</li>
<li><p><strong>确定窗口约束</strong>：</p>
<ul>
<li>计算出中间保留的窗口内，每种字符允许的最大数量 <code>max_allowed</code>。例如，<code>max_allowed[&#39;a&#39;] = total_counts[&#39;a&#39;] - k</code>。</li>
</ul>
</li>
<li><p><strong>滑动窗口初始化</strong>：</p>
<ul>
<li>左指针 <code>left = 0</code>。</li>
<li>记录最长有效窗口的长度 <code>max_len = 0</code>。</li>
<li>用一个字典或数组 <code>window_counts</code> 实时记录当前窗口内 ‘a’, ‘b’, ‘c’ 的数量。</li>
</ul>
</li>
<li><p><strong>遍历与窗口扩张</strong>：</p>
<ul>
<li>用右指针 <code>right</code> 从 <code>0</code> 遍历到 <code>n-1</code>。</li>
<li>在循环的每一步，将 <code>s[right]</code> 这个新字符纳入窗口，并更新 <code>window_counts</code>。</li>
</ul>
</li>
<li><p><strong>条件判断与窗口收缩</strong>：</p>
<ul>
<li>扩张后，检查当前窗口是否依然满足约束（即 <code>window_counts</code> 中每种字符的数量是否都小于等于 <code>max_allowed</code> 中对应的上限）。</li>
<li>如果不满足，说明窗口“太大了”，需要从左侧收缩。我们使用一个 <code>while</code> 循环来执行这个操作：<ul>
<li>只要窗口不满足约束，就将左侧字符 <code>s[left]</code> 移出窗口（更新 <code>window_counts</code>），然后将 <code>left</code> 指针右移。</li>
<li>这个 <code>while</code> 循环会一直执行，直到窗口重新满足约束为止。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>更新结果</strong>：</p>
<ul>
<li>在每次 <code>right</code> 指针移动后，并且在（可能发生的）收缩操作完成后，当前的窗口 <code>s[left:right+1]</code> 一定是有效的。</li>
<li>我们计算当前有效窗口的长度 <code>right - left + 1</code>，并用它来更新 <code>max_len</code>。</li>
</ul>
</li>
<li><p><strong>计算最终答案</strong>：</p>
<ul>
<li>遍历结束后，<code>max_len</code> 就是我们找到的“可以保留的最长子串”的长度。</li>
<li>那么，需要取走的最少字符数就是 <code>len(s) - max_len</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">takeCharacters</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1: 预处理与边界检查</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        total_counts = collections.Counter(s)</span><br><span class="line">        <span class="keyword">if</span> total_counts[<span class="string">&#x27;a&#x27;</span>] &lt; k <span class="keyword">or</span> total_counts[<span class="string">&#x27;b&#x27;</span>] &lt; k <span class="keyword">or</span> total_counts[<span class="string">&#x27;c&#x27;</span>] &lt; k:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 2: 确定窗口内每种字符的数量上限</span></span><br><span class="line">        max_allowed = &#123;c: total_counts[c] - k <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span> <span class="comment"># 存储满足条件的最长窗口长度</span></span><br><span class="line">        window_counts = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 4: 滑动窗口，扩张右边界</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            char_right = s[right]</span><br><span class="line">            window_counts[char_right] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 5: 如果窗口不满足条件，收缩左边界</span></span><br><span class="line">            <span class="keyword">while</span> (window_counts[<span class="string">&#x27;a&#x27;</span>] &gt; max_allowed[<span class="string">&#x27;a&#x27;</span>] <span class="keyword">or</span> </span><br><span class="line">                   window_counts[<span class="string">&#x27;b&#x27;</span>] &gt; max_allowed[<span class="string">&#x27;b&#x27;</span>] <span class="keyword">or</span> </span><br><span class="line">                   window_counts[<span class="string">&#x27;c&#x27;</span>] &gt; max_allowed[<span class="string">&#x27;c&#x27;</span>]):</span><br><span class="line">                char_left = s[left]</span><br><span class="line">                window_counts[char_left] -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 6: 当前窗口有效，更新最大长度</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 7: 最终结果是总长度减去最长保留子串的长度</span></span><br><span class="line">        <span class="keyword">return</span> n - max_len</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是字符串 <code>s</code> 的长度。滑动窗口的左指针 <code>left</code> 和右指针 <code>right</code> 都只会从头到尾各自扫描一遍字符串，每个元素最多被访问两次。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个额外变量来存储字符计数，因为字符集是固定的 (‘a’, ‘b’, ‘c’)。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题的核心在于<strong>逆向思维</strong>，它将一个看似复杂的“两端操作”问题，巧妙地转化为了一个经典的“寻找满足条件的最长子串”问题。一旦完成了这个思路转换，剩下的就是滑动窗口算法的模板化应用了。这个技巧在处理类似问题时非常有效，值得我们牢记。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>第 325 场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2555 | DP与SW求解“两个线段获得的最多奖品”</title>
    <url>//posts/leetcode-2555/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2555 题：<a href="https://leetcode.cn/problems/maximize-win-from-two-segments/description/">两个线段获得的最多奖品</a>。<br>该题要求放置两个固定长度的线段来覆盖最多的点。直接寻找两个线段的最优位置组合非常复杂，但如果我们固定一个，再去优化另一个，问题就豁然开朗了。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个非递减的整数数组 <code>prizePositions</code>，代表 X 轴上奖品的位置，以及一个整数 <code>k</code>。我们需要在 X 轴上放置<strong>两个</strong>长度为 <code>k</code> 的线段，目标是让这两个线段覆盖的奖品总数达到最大。线段的端点必须是整数，并且它们可以重叠。</p>
<p>举个例子，对于 <code>prizePositions = [1,1,2,2,3,3,5]</code>, <code>k = 2</code>：</p>
<ul>
<li>我们的目标是找到两个长度为 2 的线段，覆盖最多的奖品。</li>
<li>一个最优解是选择线段 <code>[1, 3]</code> 和 <code>[3, 5]</code>。<ul>
<li>线段 <code>[1, 3]</code> 覆盖了位置在 1, 2, 3 的所有奖品，共 6 个。</li>
<li>线段 <code>[3, 5]</code> 覆盖了位置在 3, 5 的所有奖品，共 3 个。</li>
<li>但是因为位置 3 的两个奖品被重复计算了，我们应该看它们覆盖的奖品集合。<code>[1,3]</code> 覆盖 <code>&#123;1,1,2,2,3,3&#125;</code>，<code>[3,5]</code> 覆盖 <code>&#123;3,3,5&#125;</code>。总共覆盖的奖品是 <code>&#123;1,1,2,2,3,3,5&#125;</code>，共 7 个。</li>
</ul>
</li>
<li>题目要求的就是这个最大值 7。</li>
</ul>
<p>直接去枚举两个线段的所有可能位置，复杂度太高。我们需要一种更高效的策略。</p>
<h3 id="核心思路：动态规划与滑动窗口的结合"><a href="#核心思路：动态规划与滑动窗口的结合" class="headerlink" title="核心思路：动态规划与滑动窗口的结合"></a>核心思路：动态规划与滑动窗口的结合</h3><p>当需要同时优化两个变量（这里是两个线段的位置）时，一个常见的降维打击思路是：<strong>先固定一个，再优化另一个</strong>。</p>
<p>假设我们正在考虑第二个线段的位置。当我们用一个滑动窗口 <code>[j, i]</code> 来代表第二个线段覆盖的奖品时（即 <code>prizePositions[i] - prizePositions[j] &lt;= k</code>），这个线段本身能获得的奖品数是固定的。为了让总数最大化，我们只需要为它搭配一个<strong>在它左侧</strong>的最佳第一线段。</p>
<p>这个“左侧最佳”正是动态规划可以发挥作用的地方。我们可以预先计算出对于任意位置 <code>x</code>，在 <code>x</code> 的左侧区域内，用<strong>一个</strong>线段能获得的最大奖品数是多少。</p>
<p>于是，整个解法分为清晰的两步：</p>
<ol>
<li><p><strong>预计算（第一遍滑动窗口）</strong>：<br>我们创建一个 <code>pre_max</code> 数组，其中 <code>pre_max[i]</code> 存储在 <code>prizePositions[0...i]</code> 这个前缀范围内，使用<strong>一个</strong>线段能获得的最大奖品数。这个数组可以通过一次滑动窗口遍历来高效计算。</p>
</li>
<li><p><strong>最终求解（第二遍滑动窗口）</strong>：<br>我们再次使用一个滑动窗口 <code>[j, i]</code> 来枚举所有可能的<strong>第二个线段</strong>。对于每一个确定的第二个线段（覆盖 <code>i-j+1</code> 个奖品），我们利用 <code>pre_max</code> 数组，瞬间就能查到在它左边（即 <code>j</code> 之前）的最佳第一线段能覆盖多少奖品（<code>pre_max[j-1]</code>）。两者相加，就是当前组合下的总奖品数。我们遍历所有可能的第二个线段，就能找到全局最优解。</p>
</li>
</ol>
<p><img src="https://assets.leetcode.com/uploads/2023/01/21/screenshot-2023-01-22-at-000100.png" alt="Diagram Explanation"><em>上图形象地展示了第二个线段（蓝色）和其左侧最优的第一线段（绿色）的组合</em></p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>第一步：预计算 <code>pre_max</code> 数组</strong></p>
<ul>
<li>初始化一个与 <code>prizePositions</code> 等长的 <code>pre_max</code> 数组，所有元素为 0。</li>
<li>使用一个滑动窗口 <code>[left, right]</code> 从左到右遍历 <code>prizePositions</code>。</li>
<li>对于每个 <code>right</code>，我们向右移动 <code>left</code> 指针，直到窗口满足 <code>prizePositions[right] - prizePositions[left] &lt;= k</code>。</li>
<li>此时，窗口 <code>[left, right]</code> 覆盖的奖品数为 <code>right - left + 1</code>。</li>
<li>我们更新 <code>pre_max[right]</code>。它的值应该等于“在 <code>right</code> 之前能获得的最大奖品数 (<code>pre_max[right-1]</code>)”和“当前窗口覆盖的奖品数”中的较大者。即 <code>pre_max[right] = max(pre_max[right-1], right - left + 1)</code>。这确保了 <code>pre_max[i]</code> 存储的是 <code>0</code> 到 <code>i</code> 范围内的最优解。</li>
</ul>
</li>
<li><p><strong>第二步：计算最终结果</strong></p>
<ul>
<li>初始化最终答案 <code>ans = 0</code>。</li>
<li>再次使用一个滑动窗口 <code>[j, i]</code> 从左到右遍历 <code>prizePositions</code>，这个窗口代表<strong>第二个线段</strong>。</li>
<li>对于每个 <code>i</code>，同样移动 <code>j</code> 以维持窗口 <code>prizePositions[i] - prizePositions[j] &lt;= k</code>。</li>
<li>第二个线段覆盖的奖品数为 <code>prizes_second = i - j + 1</code>。</li>
<li>第一个线段必须在第二个线段的左侧。它能获得的最大奖品数我们已经算好了，就是 <code>pre_max[j-1]</code>。（需要注意边界，如果 <code>j=0</code>，则左侧没有空间，奖品数为 0）。</li>
<li>计算当前组合的总奖品数 <code>total = prizes_second + (pre_max[j-1] if j &gt; 0 else 0)</code>。</li>
<li>用 <code>total</code> 更新全局最大值 <code>ans</code>。</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>遍历结束后，<code>ans</code> 即为所求。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximizeWin</span>(<span class="params">self, prizePositions: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prizePositions)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 1: 预计算 pre_max 数组</span></span><br><span class="line">        <span class="comment"># pre_max[i] 表示在 prizePositions[0...i] 范围内，用一个线段能获得的最大奖品数</span></span><br><span class="line">        pre_max = [<span class="number">0</span>] * n</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 维持窗口大小 prizePositions[right] - prizePositions[left] &lt;= k</span></span><br><span class="line">            <span class="keyword">while</span> prizePositions[right] - prizePositions[left] &gt; k:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            current_prizes = right - left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right &gt; <span class="number">0</span>:</span><br><span class="line">                pre_max[right] = <span class="built_in">max</span>(pre_max[right - <span class="number">1</span>], current_prizes)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre_max[right] = current_prizes</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2: 第二遍滑动窗口，计算最终结果</span></span><br><span class="line">        <span class="comment"># 窗口 [j, i] 代表第二个线段</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> prizePositions[i] - prizePositions[j] &gt; k:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 第二个线段覆盖的奖品数</span></span><br><span class="line">            prizes_second_segment = i - j + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 第一个线段在 j 左侧能获得的最大奖品数</span></span><br><span class="line">            prizes_first_segment = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                prizes_first_segment = pre_max[j - <span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新全局最大值</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, prizes_first_segment + prizes_second_segment)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是 <code>prizePositions</code> 的长度。我们对数组进行了两次独立的遍历，每次遍历中的左右指针都只单向移动，因此每次遍历都是线性的。</li>
<li><strong>空间复杂度</strong>: O(N)。我们使用了一个与输入等长的 <code>pre_max</code> 数组来存储中间结果。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是一个非常典型的“通过预计算降低复杂度”的案例。直接处理两个相互影响的变量很困难，但通过动态规划的思想，将其中一个变量的最优解预计算出来，再与另一个变量结合，问题就从 O(N^2) 级别的复杂度降低到了 O(N)。这种“先算一部分，再用算出的结果去算整体”的模式，是解决许多复杂数组和区间问题的金钥匙。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>滑动窗口</tag>
        <tag>前缀和</tag>
        <tag>动态规划</tag>
        <tag>第97场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2730 | 滑动窗口求解“找到最长的半重复子字符串”</title>
    <url>//posts/leetcode-2730/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2730 题：<a href="https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/description/">找到最长的半重复子字符串</a>。<br>这道题是“寻找满足特定条件的最长子字符串”这一类问题的典型代表，非常适合使用滑动窗口算法来优雅地解决。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目要求我们从一个数字字符串 <code>s</code> 中，找出一个最长的子字符串，这个子字符串需要满足一个特殊的性质，即“半重复”。</p>
<p>“半重复”的定义是：一个字符串中<strong>至多有一对</strong>相邻字符是相等的。</p>
<p>我们来具体分析一下这个定义：</p>
<ul>
<li>没有相邻重复字符的字符串是半重复的，例如 <code>&quot;0123&quot;</code>、<code>&quot;5494&quot;</code>。</li>
<li>只有一对相邻重复字符的字符串也是半重复的，例如 <code>&quot;0010&quot;</code>、<code>&quot;54944&quot;</code>。</li>
<li>有两对或更多对相邻重复字符的字符串则不是半重复的，例如 <code>&quot;52233&quot;</code>（有 <code>22</code> 和 <code>33</code> 两对）、<code>&quot;111&quot;</code>（<code>s[0]==s[1]</code> 和 <code>s[1]==s[2]</code>，也算两对）。</li>
</ul>
<p>我们的目标就是从原字符串 <code>s</code> 中，找到一个最长的、满足“半重复”条件的连续子字符串，并返回它的长度。</p>
<p>例如，对于 <code>s = &quot;52233&quot;</code>：</p>
<ul>
<li>子字符串 <code>&quot;5223&quot;</code> 中只有一对相邻重复 <code>22</code>，是半重复的，长度为 4。</li>
<li>整个字符串 <code>&quot;52233&quot;</code> 中有 <code>22</code> 和 <code>33</code> 两对，不是半重复的。</li>
<li>子字符串 <code>&quot;111&quot;</code> 中有两对相邻重复，不是半重复的，但它的子串 <code>&quot;11&quot;</code> 是半重复的，长度为 2。</li>
</ul>
<h3 id="核心思路：滑动窗口"><a href="#核心思路：滑动窗口" class="headerlink" title="核心思路：滑动窗口"></a>核心思路：滑动窗口</h3><p>这类求解“最长连续子数组&#x2F;子字符串”且该子串需满足特定条件的问题，是滑动窗口算法的绝佳应用场景。</p>
<p>我们可以用 <code>left</code> 和 <code>right</code> 两个指针来维护一个“窗口”，即子字符串 <code>s[left:right+1]</code>。我们的目标是让这个窗口始终保持“半重复”的状态，并在这个过程中找到它能达到的最大宽度。</p>
<p>为了判断窗口是否满足条件，我们需要一个状态变量来记录窗口内<strong>相邻重复字符对的数量</strong>，我们称之为 <code>pair_count</code>。</p>
<p>算法的动态过程如下：</p>
<ol>
<li><strong>窗口扩张</strong>：<code>right</code> 指针不断向右移动，将新的字符纳入窗口。每当新字符 <code>s[right]</code> 与它前面的字符 <code>s[right-1]</code> 相同时，就意味着窗口内新增了一对相邻重复，我们让 <code>pair_count</code> 加 1。</li>
<li><strong>条件判断与窗口收缩</strong>：在扩张后，如果发现 <code>pair_count</code> 的值大于 1，说明当前窗口已经不再是“半重复”的了，不满足题意。此时，我们必须从左侧收缩窗口，即把 <code>left</code> 指针向右移动。</li>
<li><strong>状态更新</strong>：在收缩窗口（移动 <code>left</code> 指针）时，我们需要检查被移出窗口的旧字符 <code>s[left]</code> 是否是某一对相邻重复的开端（即 <code>s[left] == s[left+1]</code>）。如果是，那么随着 <code>s[left]</code> 的移除，这对重复也就被破坏了，所以我们需要将 <code>pair_count</code> 减 1。</li>
<li><strong>结果更新</strong>：<code>right</code> 指针每移动一步，在确保窗口有效（即 <code>pair_count &lt;= 1</code>）之后，我们都计算当前窗口的长度 <code>right - left + 1</code>，并用它来更新我们记录的全局最大长度 <code>max_len</code>。</li>
</ol>
<p>通过这个“扩张-收缩”的循环过程，我们就能在一次遍历中找到最长的半重复子字符串。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>左指针 <code>left = 0</code>。</li>
<li>记录最大长度 <code>max_len = 0</code>。</li>
<li>记录窗口内相邻重复对的数量 <code>pair_count = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历与扩张</strong>：</p>
<ul>
<li>用右指针 <code>right</code> 从 <code>0</code> 到 <code>n-1</code> 遍历整个字符串 <code>s</code>。</li>
<li>在循环的每一步，首先检查新加入窗口的字符 <code>s[right]</code>。如果 <code>right &gt; 0</code> 且 <code>s[right] == s[right-1]</code>，则 <code>pair_count</code> 自增 1。</li>
</ul>
</li>
<li><p><strong>收缩</strong>：</p>
<ul>
<li>紧接着，使用一个 <code>while</code> 循环检查窗口的有效性：<code>while pair_count &gt; 1</code>。</li>
<li>只要条件成立，就说明窗口需要收缩。在收缩前，检查 <code>s[left]</code> 和 <code>s[left+1]</code> 是否相等。如果相等，说明一个重复对即将被移出，所以 <code>pair_count</code> 自减 1。</li>
<li>然后，将左指针 <code>left</code> 右移一位。</li>
<li><code>while</code> 循环会一直执行，直到 <code>pair_count</code> 重新变回 1 或 0，窗口恢复有效状态。</li>
</ul>
</li>
<li><p><strong>更新结果</strong>：</p>
<ul>
<li>在 <code>while</code> 循环结束后（或者根本没进入 <code>while</code> 循环），当前窗口 <code>s[left:right+1]</code> 一定是半重复的。</li>
<li>计算当前长度 <code>right - left + 1</code>，并更新 <code>max_len = max(max_len, right - left + 1)</code>。</li>
</ul>
</li>
<li><p><strong>返回</strong>：</p>
<ul>
<li><code>right</code> 指针遍历完整个字符串后，<code>max_len</code> 中存储的就是最终答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestSemiRepetitiveSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        pair_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 步骤 2: 窗口扩张，并检查是否形成新的重复对</span></span><br><span class="line">            <span class="keyword">if</span> right &gt; <span class="number">0</span> <span class="keyword">and</span> s[right] == s[right - <span class="number">1</span>]:</span><br><span class="line">                pair_count += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 3: 当窗口不满足条件时，进行收缩</span></span><br><span class="line">            <span class="keyword">while</span> pair_count &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 检查将要移出窗口的 s[left] 是否是重复对的一部分</span></span><br><span class="line">                <span class="keyword">if</span> s[left] == s[left + <span class="number">1</span>]:</span><br><span class="line">                    pair_count -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 4: 更新最大长度，此时的窗口一定是有效的</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是字符串 <code>s</code> 的长度。滑动窗口的左指针 <code>left</code> 和右指针 <code>right</code> 都只会从头到尾遍历字符串一次，每个元素最多被访问两次（一次被 <code>right</code> 纳入，一次被 <code>left</code> 移出）。因此，总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个额外变量（如 <code>left</code>, <code>right</code>, <code>pair_count</code> 等），没有使用随输入规模增长的额外空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想的一个直接且经典的应用。解决这类问题的关键在于三点：</p>
<ol>
<li><strong>确定窗口维护的“状态”</strong>：在本题中，这个状态就是“相邻重复对的数量 <code>pair_count</code>”。</li>
<li><strong>定义窗口扩张时的状态更新逻辑</strong>：<code>right</code> 指针移动，如何影响 <code>pair_count</code>。</li>
<li><strong>定义窗口收缩时的状态更新逻辑</strong>：<code>left</code> 指针移动，如何影响 <code>pair_count</code>。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
        <tag>第106场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 275 | H 指数 II</title>
    <url>//posts/leetcode-275/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 275 题：<a href="https://leetcode.cn/problems/h-index-ii/description/">H 指数 II</a>。<br>本文将深入探讨解决此问题的四种不同二分查找区间写法。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要计算一位研究者的 h 指数。h 指数的定义是：一名科研人员的 n 篇论文中，有<strong>至少</strong> <code>h</code> 篇论文分别被引用了<strong>至少</strong> <code>h</code> 次。</p>
<p>题目给出了一个整数数组 <code>citations</code>，其中 <code>citations[i]</code> 是第 <code>i</code> 篇论文的被引次数，并且该数组已经<strong>按非降序（升序）排列</strong>。我们的目标是设计一个时间复杂度为对数级别的算法来找出这个 h 指数。</p>
<p>例如，对于 <code>citations = [0, 1, 3, 5, 6]</code>：</p>
<ul>
<li>我们有 5 篇论文。</li>
<li>检查 h&#x3D;3：是否有至少 3 篇论文的引用次数都 &gt;&#x3D; 3？<ul>
<li>引用次数最高的 3 篇论文是 <code>[3, 5, 6]</code>。</li>
<li>这三篇论文的引用次数都满足 &gt;&#x3D; 3 的条件。所以 h&#x3D;3 是一个可能的答案。</li>
</ul>
</li>
<li>检查 h&#x3D;4：是否有至少 4 篇论文的引用次数都 &gt;&#x3D; 4？<ul>
<li>引用次数最高的 4 篇论文是 <code>[1, 3, 5, 6]</code>。</li>
<li>其中 <code>1 &lt; 4</code> 且 <code>3 &lt; 4</code>，不满足条件。</li>
</ul>
</li>
<li>因此，最大的满足条件的 h 值是 3，所以 h 指数就是 3。</li>
</ul>
<h3 id="核心思路：在“答案”上进行二分查找"><a href="#核心思路：在“答案”上进行二分查找" class="headerlink" title="核心思路：在“答案”上进行二分查找"></a>核心思路：在“答案”上进行二分查找</h3><p>直接寻找这个 h 指数似乎需要逐个尝试。但我们可以观察到答案 <code>h</code> 具有<strong>单调性</strong>：</p>
<ul>
<li>如果一个值 <code>h</code> 满足 h 指数的定义，那么所有小于 <code>h</code> 的值（例如 <code>h-1</code>）也一定满足。</li>
<li>如果一个值 <code>h</code> 不满足 h 指数的定义，那么所有大于 <code>h</code> 的值（例如 <code>h+1</code>）也一定不满足。</li>
</ul>
<p>这种单调性是应用二分查找的完美信号。我们可以不直接在 <code>citations</code> 数组的索引上进行二分，而是在<strong>可能的答案 <code>h</code></strong> 上进行二分。<code>h</code> 的取值范围是 <code>[0, n]</code>，其中 <code>n</code> 是论文总数。</p>
<p>我们的目标就变成了：在 <code>[0, n]</code> 这个答案空间中，找到满足条件的最大的 <code>h</code>。</p>
<p>为了实现二分查找，我们需要一个<strong>判定函数</strong> <code>check(h)</code>，来判断任意一个猜测的 <code>h</code> 值是否满足条件。</p>
<ul>
<li><strong>如何判定 <code>h</code> 是否可行？</strong><ul>
<li>根据定义，我们需要检查是否存在 <code>h</code> 篇论文，其引用次数都大于或等于 <code>h</code>。</li>
<li>由于 <code>citations</code> 数组是升序的，引用次数最高的 <code>h</code> 篇论文必然是数组末尾的 <code>h</code> 个元素。</li>
<li>我们只需要检查这 <code>h</code> 篇论文中被引次数最少的那一篇，即 <code>citations[n-h]</code>，是否满足 <code>&gt;= h</code>。</li>
<li>如果 <code>citations[n-h] &gt;= h</code>，那么它后面的所有论文引用次数也都大于等于 <code>h</code>，总共就有 <code>h</code> 篇满足条件。</li>
<li>因此，判定条件可以简化为 <code>citations[n-h] &gt;= mid</code> (其中 <code>mid</code> 是我们猜测的 <code>h</code> 值)。</li>
</ul>
</li>
</ul>
<p>有了这个 O(1) 的判定函数，我们就可以在 <code>[0, n]</code> 的答案空间内高效地进行二分查找了。</p>
<h3 id="四种二分算法的-Python-代码实现"><a href="#四种二分算法的-Python-代码实现" class="headerlink" title="四种二分算法的 Python 代码实现"></a>四种二分算法的 Python 代码实现</h3><p>下面将展示四种经典的二分查找区间写法，它们在边界处理和循环条件上略有不同，但最终都能得到正确答案。</p>
<h4 id="解法一：闭区间-left-right"><a href="#解法一：闭区间-left-right" class="headerlink" title="解法一：闭区间 [left, right]"></a>解法一：闭区间 <code>[left, right]</code></h4><p>这是最常见的一种写法，搜索区间两端都包含在内。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(citations)</span><br><span class="line">        <span class="comment"># 在区间 [left, right] 内询问</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 区间不为空</span></span><br><span class="line">            <span class="comment"># 循环不变量：</span></span><br><span class="line">            <span class="comment"># left-1 的回答一定为「是」（即 h=left-1 满足条件）</span></span><br><span class="line">            <span class="comment"># right+1 的回答一定为「否」（即 h=right+1 不满足条件）</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span>: <span class="comment"># h=0 恒成立，特殊处理或调整 left 初始值</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 检查 h=mid 是否可行：</span></span><br><span class="line">            <span class="comment"># 引用次数最多的 mid 篇论文，其引用次数均需 &gt;= mid</span></span><br><span class="line">            <span class="comment"># 相当于检查第 n-mid 篇论文（引用最少的）是否 citations[n-mid] &gt;= mid</span></span><br><span class="line">            <span class="keyword">if</span> citations[n - mid] &gt;= mid:</span><br><span class="line">                <span class="comment"># mid 可行，尝试更大的 h</span></span><br><span class="line">                left = mid + <span class="number">1</span>  <span class="comment"># 询问范围缩小到 [mid+1, right]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># mid 不可行，需要减小 h</span></span><br><span class="line">                right = mid - <span class="number">1</span>  <span class="comment"># 询问范围缩小到 [left, mid-1]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束后 right 等于 left-1</span></span><br><span class="line">        <span class="comment"># 根据循环不变量，right 现在是最大的回答为「是」的数</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">```**逻辑解读**：当 `check(mid)` 成功时，意味着 `mid` 是一个潜在的答案，但我们想找最大的 `h`，所以我们向右搜索 `[mid+<span class="number">1</span>, right]`；反之，`mid` 太大了，向左搜索 `[left, mid-<span class="number">1</span>]`。循环结束时 `left = right + <span class="number">1</span>`，`right` 指向的是最后一个满足条件的 `h`。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 解法二：左闭右开区间 `[left, right)`</span></span><br><span class="line"></span><br><span class="line">这种写法中，`right` 边界是“开”的，即不包含在搜索区间内。`right` 通常被看作是第一个“不满足”条件的位置。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(citations)</span><br><span class="line">        <span class="comment"># 在区间 [left, right) 内询问</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">            <span class="comment"># 循环不变量：</span></span><br><span class="line">            <span class="comment"># left-1 的回答一定为「是」</span></span><br><span class="line">            <span class="comment"># right 的回答一定为「否」</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span>: <span class="comment"># h=0 恒成立</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 引用次数最多的 mid 篇论文，引用次数均 &gt;= mid</span></span><br><span class="line">            <span class="keyword">if</span> citations[n - mid] &gt;= mid:</span><br><span class="line">                left = mid + <span class="number">1</span>  <span class="comment"># 询问范围缩小到 [mid+1, right)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid  <span class="comment"># 询问范围缩小到 [left, mid)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时 left == right，它指向第一个回答为「否」的数</span></span><br><span class="line">        <span class="comment"># 根据循环不变量，left-1 现在是最大的回答为「是」的数</span></span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>逻辑解读</strong>：当 <code>check(mid)</code> 成功时，我们更新 <code>left = mid + 1</code>，继续向右探索。当 <code>check(mid)</code> 失败时，<code>mid</code> 本身就是一个“不满足”的值，所以我们更新 <code>right = mid</code>，将这个“第一个不满足”的边界向左移动。循环结束时 <code>left</code> 就是那个第一个不满足条件的 <code>h</code>，因此 <code>left - 1</code> 就是答案。</p>
<hr>
<h4 id="解法三：左开右闭区间-left-right"><a href="#解法三：左开右闭区间-left-right" class="headerlink" title="解法三：左开右闭区间 (left, right]"></a>解法三：左开右闭区间 <code>(left, right]</code></h4><p>与上一种相反，这种写法的 <code>left</code> 边界是“开”的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(citations)</span><br><span class="line">        <span class="comment"># 在区间 (left, right] 内询问</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">            <span class="comment"># 循环不变量：</span></span><br><span class="line">            <span class="comment"># left 的回答一定为「是」</span></span><br><span class="line">            <span class="comment"># right+1 的回答一定为「否」</span></span><br><span class="line">            mid = (left + right + <span class="number">1</span>) // <span class="number">2</span>  <span class="comment"># 向上取整，避免死循环</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 引用次数最多的 mid 篇论文，引用次数均 &gt;= mid</span></span><br><span class="line">            <span class="keyword">if</span> citations[n - mid] &gt;= mid:</span><br><span class="line">                left = mid  <span class="comment"># 询问范围缩小到 (mid, right]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span>  <span class="comment"># 询问范围缩小到 (left, mid-1]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束时 left == right</span></span><br><span class="line">        <span class="comment"># 根据循环不变量，left 现在是最大的回答为「是」的数</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p><strong>逻辑解读</strong>：这里 <code>mid</code> 的计算方式是 <code>(left + right + 1) // 2</code> 向上取整，这是为了防止当 <code>left = right - 1</code> 且 <code>check</code> 成功时，<code>mid</code> 仍等于 <code>left</code> 导致无限循环。当 <code>check(mid)</code> 成功时，<code>mid</code> 成为新的“最后一个满足条件”的候选，所以 <code>left = mid</code>；反之，则收缩右边界 <code>right = mid - 1</code>。循环结束时 <code>left</code> 即为答案。</p>
<hr>
<h4 id="解法四：开区间-left-right"><a href="#解法四：开区间-left-right" class="headerlink" title="解法四：开区间 (left, right)"></a>解法四：开区间 <code>(left, right)</code></h4><p>这种写法保证 <code>left</code> 和 <code>right</code> 之间始终有空间，循环条件是 <code>left + 1 &lt; right</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(citations)</span><br><span class="line">        <span class="comment"># 在区间 (left, right) 内询问</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">            <span class="comment"># 循环不变量：</span></span><br><span class="line">            <span class="comment"># left 的回答一定为「是」</span></span><br><span class="line">            <span class="comment"># right 的回答一定为「否」</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 引用次数最多的 mid 篇论文，引用次数均 &gt;= mid</span></span><br><span class="line">            <span class="keyword">if</span> citations[n - mid] &gt;= mid:</span><br><span class="line">                left = mid  <span class="comment"># 询问范围缩小到 (mid, right)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid  <span class="comment"># 询问范围缩小到 (left, mid)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束后 left + 1 == right</span></span><br><span class="line">        <span class="comment"># 根据循环不变量，left 现在是最大的回答为「是」的数</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p><strong>逻辑解读</strong>：<code>left</code> 始终维护“已知的满足条件的最大值”，而 <code>right</code> 始终维护“已知的第一个不满足条件的值”。循环不断地用 <code>mid</code> 来更新这两个边界，直到它们相邻。最终的答案就是 <code>left</code>。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(log N)<ul>
<li><code>N</code> 是论文的总数 <code>len(citations)</code>。</li>
<li>二分查找在大小为 <code>N+1</code> 的答案空间 <code>[0, N]</code> 中进行。</li>
<li>每次迭代，判定函数 <code>check(mid)</code> 的时间复杂度为 O(1)，因为它只需要访问数组中的一个元素。</li>
<li>因此，总的时间复杂度为 O(log N)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)<ul>
<li>我们只使用了有限的几个变量（<code>left</code>, <code>right</code>, <code>mid</code>, <code>n</code>），没有使用与输入大小成比例的额外空间。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>H 指数 II 是一个典型的“二分答案”问题。当问题的解具有单调性，并且我们可以高效地对任意一个猜测的解进行“判定”时，就可以考虑使用二分查找。本文通过四种不同的区间写法，展示了二分查找在实现细节上的灵活性。理解每种写法的循环不变量是掌握二分查找、避免边界错误的关键。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最大</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2762 | 滑动窗口求解“不间断子数组”</title>
    <url>//posts/leetcode-2762/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2762 题：<a href="https://leetcode.cn/problems/continuous-subarrays/">不间断子数组</a>。<br>该题要求统计所有满足“最大元素与最小元素之差不超过2”的子数组。这是一个典型的不定长滑动窗口问题，可以使用哈希表或更优的单调队列来解决。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目要求我们统计一个数组 <code>nums</code> 中“不间断子数组”的总数。一个子数组被称为“不间断”的，需要满足其中任意两个元素之间的差的绝对值都不超过 2。</p>
<p>这个条件 <code>|nums[i1] - nums[i2]| &lt;= 2</code> 其实等价于子数组中的最大值 <code>max</code> 和最小值 <code>min</code> 满足 <code>max - min &lt;= 2</code>。 因为如果最大值和最小值的差满足条件，那么其他任意两个元素之间的差也必然满足条件。</p>
<p>以 <code>nums = [5,4,2,4]</code> 为例：</p>
<ul>
<li>子数组 <code>[5, 4]</code> 是不间断的，因为 <code>max(5, 4) - min(5, 4) = 1 &lt;= 2</code>。</li>
<li>子数组 <code>[4, 2]</code> 是不间断的，因为 <code>max(4, 2) - min(4, 2) = 2 &lt;= 2</code>。</li>
<li>子数组 <code>[5, 4, 2]</code> 不是不间断的，因为 <code>max(5, 4, 2) - min(5, 4, 2) = 5 - 2 = 3 &gt; 2</code>。</li>
</ul>
<p>我们需要做的就是找出所有这样的子数组并计数。</p>
<h3 id="核心思路：不定长滑动窗口"><a href="#核心思路：不定长滑动窗口" class="headerlink" title="核心思路：不定长滑动窗口"></a>核心思路：不定长滑动窗口</h3><p>暴力枚举所有子数组并检查每个子数组的条件，时间复杂度会达到 O(N^2) 甚至更高，对于 <code>N=10^5</code> 的数据规模来说是不可接受的。</p>
<p>这类问题通常可以采用滑动窗口来优化。 关键在于问题是否具有单调性：</p>
<ul>
<li>如果一个子数组 <code>[l, r]</code> 是不间断的，那么它的任何一个子数组（例如 <code>[l+1, r]</code> 或 <code>[l, r-1]</code>）也一定是不间断的。</li>
<li>如果一个子数组 <code>[l, r]</code> 不是不间断的，那么任何包含它的更长的子数组（例如 <code>[l-1, r]</code> 或 <code>[l, r+1]</code>）也一定不是不间断的。</li>
</ul>
<p>这种单调性是使用滑动窗口的完美信号。 我们可以维护一个窗口 <code>[l, r]</code>，不断向右移动右指针 <code>r</code> 来扩大窗口。如果窗口内的数组不再满足 <code>max - min &lt;= 2</code> 的条件，我们就从左边移动左指针 <code>l</code> 来缩小窗口，直到窗口重新满足条件。</p>
<p>对于每一个确定的右指针 <code>r</code>，我们找到了最远的左指针 <code>l</code> 使得 <code>[l, r]</code> 区间是不间断的。根据单调性，以 <code>r</code> 为右端点的所有子数组 <code>[l, r], [l+1, r], ..., [r, r]</code> 都是不间断的。这样的子数组共有 <code>r - l + 1</code> 个。我们将这个数量累加到最终答案中。</p>
<p>这个算法的挑战在于：如何在窗口滑动时，高效地获取窗口内的最大值和最小值？</p>
<h3 id="解法一：滑动窗口-哈希表-Counter"><a href="#解法一：滑动窗口-哈希表-Counter" class="headerlink" title="解法一：滑动窗口 + 哈希表 (Counter)"></a>解法一：滑动窗口 + 哈希表 (Counter)</h3><p>一个直观的方法是使用哈希表（在 Python 中是 <code>collections.Counter</code>）来维护窗口内每个数字出现的次数。</p>
<h4 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h4><ol>
<li>初始化左右指针 <code>l = 0</code>，答案 <code>ans = 0</code>，以及一个哈希表 <code>cnt</code>。</li>
<li>遍历数组，用右指针 <code>r</code> 代表窗口的右边界。</li>
<li>将新元素 <code>nums[r]</code> 加入窗口，即在 <code>cnt</code> 中增加它的计数。</li>
<li><strong>检查条件</strong>：检查当前窗口 <code>[l, r]</code> 是否满足 <code>max(cnt) - min(cnt) &lt;= 2</code>。<code>max(cnt)</code> 和 <code>min(cnt)</code> 分别是哈希表中当前所有键（即窗口内的元素）的最大值和最小值。</li>
<li><strong>收缩窗口</strong>：如果条件不满足，说明窗口需要从左侧收缩。我们不断地将左指针 <code>l</code> 右移，并从 <code>cnt</code> 中减少 <code>nums[l]</code> 的计数。如果 <code>nums[l]</code> 的计数变为 0，就从哈希表中删除这个键。这个过程一直持续到窗口重新满足 <code>max(cnt) - min(cnt) &lt;= 2</code> 为止。</li>
<li><strong>更新答案</strong>：在窗口 <code>[l, r]</code> 满足条件后，我们知道以 <code>r</code> 为结尾的不间断子数组有 <code>r - l + 1</code> 个，将这个数目加到 <code>ans</code> 上。</li>
<li>重复步骤 3-6，直到 <code>r</code> 遍历完整个数组。</li>
</ol>
<h4 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter, deque</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">continuousSubarrays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = l = <span class="number">0</span></span><br><span class="line">        cnt = Counter()</span><br><span class="line">        <span class="keyword">for</span> r, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            cnt[x] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 当窗口不满足条件时，从左侧收缩</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">max</span>(cnt) - <span class="built_in">min</span>(cnt) &gt; <span class="number">2</span>:</span><br><span class="line">                y = nums[l]</span><br><span class="line">                cnt[y] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cnt[y] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> cnt[y]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 此时窗口 [l, r] 是合法的</span></span><br><span class="line">            <span class="comment"># 所有以 r 结尾的子数组 [l,r], [l+1,r]...[r,r] 都是合法的</span></span><br><span class="line">            ans += r - l + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li><strong>时间复杂度</strong>: O(N * K)，其中 N 是数组长度，K 是窗口内不同元素的数量。虽然左右指针都只遍历数组一次，但在 <code>while</code> 循环中，<code>max(cnt)</code> 和 <code>min(cnt)</code> 的操作需要遍历哈希表中的所有键，最坏情况下时间复杂度是 O(K)。在一些极端测试用例下可能会超时。</li>
<li><strong>空间复杂度</strong>: O(K)，哈希表存储窗口内不同元素所需的空间。</li>
</ul>
<h3 id="解法二：滑动窗口-单调队列-Monotonic-Deque"><a href="#解法二：滑动窗口-单调队列-Monotonic-Deque" class="headerlink" title="解法二：滑动窗口 + 单调队列 (Monotonic Deque)"></a>解法二：滑动窗口 + 单调队列 (Monotonic Deque)</h3><p>为了将获取窗口最大&#x2F;最小值的操作优化到 O(1)，我们可以使用单调队列。 我们需要两个双端队列（deque）：</p>
<ul>
<li><code>max_q</code>：一个单调递减队列，队首永远是当前窗口最大值的<strong>下标</strong>。</li>
<li><code>min_q</code>：一个单调递增队列，队首永远是当前窗口最小值的<strong>下标</strong>。</li>
</ul>
<h4 id="算法详解-1"><a href="#算法详解-1" class="headerlink" title="算法详解"></a>算法详解</h4><ol>
<li>初始化左右指针 <code>l = 0</code>，答案 <code>ans = 0</code>，以及两个双端队列 <code>min_q</code> 和 <code>max_q</code>。</li>
<li>遍历数组，用右指针 <code>r</code> 代表窗口的右边界。</li>
<li><strong>维护单调队列</strong>：<ul>
<li>对于 <code>max_q</code>，当新元素 <code>nums[r]</code> 加入时，从队尾移除所有值小于等于 <code>nums[r]</code> 的元素下标，然后将 <code>r</code> 加入队尾。这保证了队列的单调递减性。</li>
<li>对于 <code>min_q</code>，当新元素 <code>nums[r]</code> 加入时，从队尾移除所有值大于等于 <code>nums[r]</code> 的元素下标，然后将 <code>r</code> 加入队尾。这保证了队列的单调递增性。</li>
</ul>
</li>
<li><strong>检查条件</strong>：当前窗口的最大值是 <code>nums[max_q[0]]</code>，最小值是 <code>nums[min_q[0]]</code>。我们检查 <code>nums[max_q[0]] - nums[min_q[0]] &gt; 2</code> 是否成立。</li>
<li><strong>收缩窗口</strong>：如果条件不满足，我们需要移动左指针 <code>l</code>。注意，这里的收缩逻辑和解法一略有不同。我们不断增加 <code>l</code>，并且检查队首的下标（<code>max_q[0]</code> 或 <code>min_q[0]</code>）是否已经小于新的 <code>l</code>。如果是，说明最大&#x2F;最小值已经滑出窗口，需要从队首弹出。</li>
<li><strong>更新答案</strong>：在窗口 <code>[l, r]</code> 满足条件后，以 <code>r</code> 为结尾的不间断子数组数量为 <code>r - l + 1</code>，累加到 <code>ans</code>。</li>
<li>重复步骤 3-6，直到 <code>r</code> 遍历完整个数组。</li>
</ol>
<h4 id="Python-代码实现-1"><a href="#Python-代码实现-1" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">continuousSubarrays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_q = deque()</span><br><span class="line">        max_q = deque()</span><br><span class="line">        ans = l = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 维护 min_q 为单调递增</span></span><br><span class="line">            <span class="keyword">while</span> min_q <span class="keyword">and</span> x &lt;= nums[min_q[-<span class="number">1</span>]]:</span><br><span class="line">                min_q.pop()</span><br><span class="line">            min_q.append(r)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 维护 max_q 为单调递减</span></span><br><span class="line">            <span class="keyword">while</span> max_q <span class="keyword">and</span> x &gt;= nums[max_q[-<span class="number">1</span>]]:</span><br><span class="line">                max_q.pop()</span><br><span class="line">            max_q.append(r)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当窗口不满足条件时，移动左指针</span></span><br><span class="line">            <span class="keyword">while</span> nums[max_q[<span class="number">0</span>]] - nums[min_q[<span class="number">0</span>]] &gt; <span class="number">2</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 检查队首元素是否已滑出窗口</span></span><br><span class="line">                <span class="keyword">if</span> min_q[<span class="number">0</span>] &lt; l:</span><br><span class="line">                    min_q.popleft()</span><br><span class="line">                <span class="keyword">if</span> max_q[<span class="number">0</span>] &lt; l:</span><br><span class="line">                    max_q.popleft()</span><br><span class="line">            </span><br><span class="line">            ans += r - l + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li><strong>时间复杂度</strong>: O(N)。每个元素的下标最多被压入和弹出队列各一次，因此维护队列的总时间是线性的。左右指针也各遍历数组一次。</li>
<li><strong>空间复杂度</strong>: O(N)。在最坏情况下（例如一个严格递增或递减的数组），队列中可能存储所有元素的下标。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是不定长滑动窗口的一个绝佳应用。通过分析题目条件的单调性，我们可以确定滑动窗口是正确的解题方向。而问题的核心瓶颈——如何快速获取窗口内的最值——则可以通过不同的数据结构来解决。哈希表提供了一个相对简单但效率稍逊的方案，而单调队列则是解决此类滑动窗口最值问题的标准、高效的工具。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>有序集合</tag>
        <tag>堆（优先队列）</tag>
        <tag>单调队列</tag>
        <tag>第352场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2781 | 滑动窗口与后缀校验求解“最长合法子字符串”</title>
    <url>//posts/leetcode-2781/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2781 题：<a href="https://leetcode.cn/problems/length-of-the-longest-valid-substring/">最长合法子字符串的长度</a>。<br>这道题要求我们寻找一个不含任何“禁用词”的最长子串。它是一个典型的滑动窗口问题，但其巧妙之处在于如何高效地判断窗口的“合法性”，避免在每次窗口移动时都进行暴力检查。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个字符串 <code>word</code> 和一个禁用词列表 <code>forbidden</code>。如果一个子字符串不包含 <code>forbidden</code> 中的任何字符串，我们就称它是“合法的”。我们的任务是返回 <code>word</code> 中最长合法子字符串的长度。</p>
<p>举个例子，对于 <code>word = &quot;cbaaaabc&quot;</code>, <code>forbidden = [&quot;aaa&quot;,&quot;cb&quot;]</code>：</p>
<ul>
<li>子字符串 <code>&quot;cbaaa&quot;</code> 是非法的，因为它包含了禁用词 <code>&quot;aaa&quot;</code>。</li>
<li>子字符串 <code>&quot;aabc&quot;</code> 是合法的，因为它不包含 <code>&quot;aaa&quot;</code> 也不包含 <code>&quot;cb&quot;</code>。</li>
<li>在所有合法的子字符串中，<code>&quot;aabc&quot;</code> 的长度是 4，也是最长的。因此答案是 4。</li>
</ul>
<p>一个简单的思路是找出 <code>word</code> 的所有子字符串，然后逐一检查它们是否包含禁用词。但这种方法的时间复杂度非常高（大约是 O(N^2 * M * L)），在 <code>word</code> 长度达到 10^5 时会严重超时。我们需要一个更高效的算法。</p>
<h3 id="核心思路：滑动窗口与高效校验"><a href="#核心思路：滑动窗口与高效校验" class="headerlink" title="核心思路：滑动窗口与高效校验"></a>核心思路：滑动窗口与高效校验</h3><p>这个问题非常适合使用滑动窗口来解决。“寻找满足条件的最长子串”是滑动窗口的经典应用场景。我们用 <code>left</code> 和 <code>right</code> 两个指针来维护一个窗口 <code>word[left:right+1]</code>。</p>
<p>关键的挑战在于：当 <code>right</code> 指针向右移动一位，我们如何快速判断新窗口是否仍然合法？</p>
<p>常规的滑动窗口问题，通常是在窗口扩张后，通过一个 <code>while</code> 循环收缩左边界，直到窗口再次满足条件。但在这里，“不包含任何禁用词”这个条件很难通过简单地增减字符计数来维护。</p>
<p>这里的突破口在于：<strong>当我们将 <code>word[right]</code> 加入窗口时，所有新产生的、可能导致窗口非法的子字符串，都必然是以 <code>word[right]</code> 结尾的。</strong></p>
  <!-- 这是一个示意图的占位符 -->

<p>换句话说，我们不需要检查整个 <code>word[left:right+1]</code>。我们只需要检查以 <code>word[right]</code> 结尾的各个后缀，例如 <code>word[right:right+1]</code>, <code>word[right-1:right+1]</code>, <code>word[right-2:right+1]</code> 等，看它们是否是禁用词。</p>
<p>题目中还有一个至关重要的提示：<code>forbidden[i].length &lt;= 10</code>。这意味着我们最多只需要检查长度为 10 的后缀。</p>
<p>这样，我们的策略就清晰了：</p>
<ol>
<li>用 <code>right</code> 指针扩张窗口。</li>
<li>每扩张一步，就检查以 <code>word[right]</code> 结尾的、长度不超过 10 的所有后缀。</li>
<li>如果发现一个后缀 <code>word[j:right+1]</code> 是禁用词，那么就说明整个窗口 <code>word[left:right+1]</code> 是非法的。不仅如此，任何以 <code>j</code> 或 <code>j</code> 之前的字符为起点的、延伸到 <code>right</code> 的子串都是非法的。</li>
<li>因此，为了让窗口重新合法，我们必须将左边界 <code>left</code> 移动到 <code>j + 1</code> 的位置。</li>
</ol>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>预处理</strong>：</p>
<ul>
<li>将 <code>forbidden</code> 列表转换成一个哈希集合（Set），这样我们就能以 O(1) 的平均时间复杂度查询一个字符串是否为禁用词。</li>
</ul>
</li>
<li><p><strong>滑动窗口初始化</strong>：</p>
<ul>
<li>左指针 <code>left = 0</code>。</li>
<li>记录最长合法子串的长度 <code>max_len = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历与窗口扩张</strong>：</p>
<ul>
<li>用右指针 <code>right</code> 从 <code>0</code> 遍历到 <code>n-1</code>，其中 <code>n</code> 是 <code>word</code> 的长度。</li>
</ul>
</li>
<li><p><strong>合法性校验与窗口调整</strong>：</p>
<ul>
<li>在 <code>right</code> 每移动一步后，我们启动一个内部循环，从 <code>j = right</code> 开始，向左回溯。</li>
<li>这个内部循环检查子字符串 <code>word[j:right+1]</code>。由于禁用词长度不超过 10，<code>j</code> 最多回溯到 <code>right - 9</code> 即可。同时，<code>j</code> 不能小于当前的左边界 <code>left</code>。所以，<code>j</code> 的范围是 <code>[max(left, right - 9), right]</code>。</li>
<li>如果在回溯检查中，发现 <code>word[j:right+1]</code> 存在于禁用词集合中，我们就找到了一个破坏合法性的源头。此时，我们将左指针 <code>left</code> 直接更新为 <code>j + 1</code>，并立即跳出内部的回溯检查。</li>
</ul>
</li>
<li><p><strong>更新结果</strong>：</p>
<ul>
<li>在（可能发生的）窗口调整之后，当前的窗口 <code>word[left:right+1]</code> 一定是合法的。</li>
<li>我们计算其长度 <code>right - left + 1</code>，并用它来更新 <code>max_len</code>。</li>
</ul>
</li>
<li><p><strong>返回最终答案</strong>：</p>
<ul>
<li>遍历结束后，<code>max_len</code> 就是题目的答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestValidSubstring</span>(<span class="params">self, word: <span class="built_in">str</span>, forbidden: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1: 预处理，转换为集合以快速查找</span></span><br><span class="line">        forbidden_set = <span class="built_in">set</span>(forbidden)</span><br><span class="line">        n = <span class="built_in">len</span>(word)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2: 初始化左指针和最大长度</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 遍历字符串，扩张右边界</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 步骤 4: 回溯检查以 right 结尾的后缀</span></span><br><span class="line">            <span class="comment"># 最多回溯 10 个字符，且不能越过左边界 left</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right, <span class="built_in">max</span>(left, right - <span class="number">10</span>) - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                substring = word[j : right + <span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> substring <span class="keyword">in</span> forbidden_set:</span><br><span class="line">                    <span class="comment"># 发现禁用词，窗口不合法</span></span><br><span class="line">                    <span class="comment"># 新的合法起点必须在禁用词之后，所以移动 left</span></span><br><span class="line">                    left = j + <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 找到一个即可，无需继续检查更长的后缀</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 5: 当前窗口 [left, right] 合法，更新最大长度</span></span><br><span class="line">            current_length = right - left + <span class="number">1</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, current_length)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 6: 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N * C)。其中 N 是字符串 <code>word</code> 的长度，C 是 <code>forbidden</code> 中字符串的最大长度（本题中 C &lt;&#x3D; 10）。外层循环遍历 <code>word</code> 一次，内层循环最多执行 C 次。由于 C 是一个很小的常数，所以时间复杂度接近线性 O(N)。</li>
<li><strong>空间复杂度</strong>: O(M * C)。其中 M 是 <code>forbidden</code> 列表的长度。这部分空间主要用于存储 <code>forbidden_set</code>。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题通过一个精妙的优化，将滑动窗口算法应用到了看似复杂的字符串匹配问题上。其核心思想是：<strong>在窗口扩张时，只检查新产生的、以新字符结尾的后缀</strong>。这个方法避免了对整个窗口的重复扫描，而题目中关于禁用词长度的限制则是实现这一优化的关键。这个技巧告诉我们，在处理滑动窗口问题时，要仔细分析窗口状态变化的本质，寻找最高效的合法性校验方式。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>第 354 场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2875 | 滑动窗口巧解“无限数组的最短子数组”</title>
    <url>//posts/leetcode-2875/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2875 题：<a href="https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/description/">无限数组的最短子数组</a>。<br>该题要求在一个由原数组无限重复构成的虚拟数组中，寻找和为目标值的最短子数组。面对“无限”，可以通过巧妙的数学转换简化为一个经典的定长数组滑动窗口问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个数组 <code>nums</code> 和一个目标值 <code>target</code>。我们需要想象一个通过无限次拼接 <code>nums</code> 自身形成的无限数组 <code>infinite_nums</code>。任务是在这个 <code>infinite_nums</code> 中，找到一个元素和恰好等于 <code>target</code> 的<strong>最短</strong>子数组，并返回其长度。如果不存在这样的子数组，则返回 -1。</p>
<p>举个例子，对于 <code>nums = [1,2,3], target = 5</code>:</p>
<ul>
<li><code>infinite_nums</code> 就好像是 <code>[1,2,3,1,2,3,1,2,...]</code>。</li>
<li>我们可以找到子数组 <code>[2,3]</code>，其和为 5，长度为 2。</li>
<li>我们也可以找到子数组 <code>[3,1,2]</code>（跨越了第一个 <code>nums</code> 的末尾和第二个 <code>nums</code> 的开头），其和为 6。</li>
<li>经过检查，<code>[2,3]</code> 是和为 5 的最短子数组，因此答案是 2。</li>
</ul>
<p>最主要的挑战在于 <code>target</code> 可能非常大，而数组是“无限”的，我们显然不能真的去构建它。</p>
<h3 id="核心思路：数学转换-滑动窗口"><a href="#核心思路：数学转换-滑动窗口" class="headerlink" title="核心思路：数学转换 + 滑动窗口"></a>核心思路：数学转换 + 滑动窗口</h3><p>解决这个问题的关键在于将“无限”问题转化为“有限”问题。我们可以观察到，任何一个目标和 <code>target</code> 都可以被 <code>nums</code> 的总和 <code>t</code> 分解。</p>
<p>假设 <code>t = sum(nums)</code>。那么 <code>target</code> 可以表示为：<br><code>target = (target // t) * t + (target % t)</code></p>
<p>这公式告诉我们，任何一个满足条件的子数组，必然由两部分构成：</p>
<ol>
<li><strong>整数倍部分</strong>：包含 <code>q = target // t</code> 个完整的 <code>nums</code> 数组。这部分的长度是固定的，即 <code>q * len(nums)</code>。</li>
<li><strong>余数部分</strong>：一个和为 <code>re = target % t</code> 的子数组。</li>
</ol>
<p>我们的总目标是找到最短的子数组。因为整数倍部分的长度是固定的，所以问题被巧妙地转化成了：<strong>在 <code>infinite_nums</code> 中寻找和为 <code>re</code> 的最短子数组</strong>。</p>
<p>那么如何寻找这个和为 <code>re</code> 的最短子数组呢？这个子数组可能完全位于一个 <code>nums</code> 拷贝内部，也可能跨越两个 <code>nums</code> 拷贝的边界（例如，一部分在 <code>nums</code> 的末尾，一部分在下一个 <code>nums</code> 的开头）。</p>
<p>为了优雅地处理这种“环形”或“跨界”的情况，我们可以使用一个经典技巧：<strong>在长度为 <code>2n</code> 的数组上进行搜索</strong>。我们将数组 <code>nums</code> 复制一份并拼接到自己后面（形成 <code>nums + nums</code> 的概念），然后在这个长度为 <code>2n</code> 的数组上使用滑动窗口寻找和为 <code>re</code> 的最短子数组。这样就能保证所有可能的连续子数组（包括跨界的）都被考虑到。</p>
<p>于是，整个解法分为清晰的两步：</p>
<ol>
<li><strong>数学转换</strong>：计算出 <code>nums</code> 的总和 <code>t</code>，然后计算出目标 <code>target</code> 需要完整 <code>nums</code> 的数量 <code>q = target // t</code> 和剩余的目标和 <code>re = target % t</code>。</li>
<li><strong>滑动窗口</strong>：在一个概念上的“双倍”<code>nums</code> 数组上，使用滑动窗口寻找和为 <code>re</code> 的最短子数组长度 <code>min_len</code>。</li>
</ol>
<p>最终答案就是 <code>q * n + min_len</code>。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>第一步：问题简化</strong></p>
<ul>
<li>计算 <code>n = len(nums)</code> 和 <code>t = sum(nums)</code>。</li>
<li>计算我们需要在 <code>infinite_nums</code> 中寻找的剩余和 <code>re = target % t</code>。</li>
<li>计算已经由完整 <code>nums</code> 数组贡献的长度 <code>base_len = (target // t) * n</code>。</li>
</ul>
</li>
<li><p><strong>第二步：滑动窗口寻找最短子数组</strong></p>
<ul>
<li>初始化最小长度 <code>ans = infinity</code>，当前窗口和 <code>s = 0</code>，左指针 <code>l = 0</code>。</li>
<li>我们让右指针 <code>r</code> 从 <code>0</code> 遍历到 <code>2*n - 1</code>，这等同于在 <code>nums</code> 和其拷贝组成的数组上滑动。为了获取元素，我们使用 <code>nums[r % n]</code>。</li>
<li>在循环中，将 <code>nums[r % n]</code> 加入当前和 <code>s</code>。</li>
<li>使用 <code>while</code> 循环，当 <code>s &gt; re</code> 时，说明窗口和过大，需要从左侧收缩窗口。减去 <code>nums[l % n]</code> 并将 <code>l</code> 右移。</li>
<li>如果 <code>s == re</code>，说明找到了一个满足条件的子数组。我们用它的长度 <code>r - l + 1</code> 来更新 <code>ans</code> 的最小值。</li>
</ul>
</li>
<li><p><strong>第三步：组合结果</strong></p>
<ul>
<li>滑动窗口结束后，检查 <code>ans</code> 是否仍然是 <code>infinity</code>。</li>
<li>如果是，说明在 <code>infinite_nums</code> 中找不到和为 <code>re</code> 的子数组，因此也无法构成 <code>target</code>，返回 <code>-1</code>。</li>
<li>如果不是，最终答案就是 <code>base_len + ans</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> inf</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSizeSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1: 问题简化</span></span><br><span class="line">        t = <span class="built_in">sum</span>(nums)</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 剩余的目标和</span></span><br><span class="line">        re = target % t</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 由整数倍的 nums 数组构成的基础长度</span></span><br><span class="line">        base_len = (target // t) * n</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> re == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 如果 target 恰好是 t 的整数倍，那么最短子数组就是 target/t 个完整的 nums</span></span><br><span class="line">            <span class="comment"># 但题目要求的是最短子数组，如果 target = t，最短的就是 nums 本身，长度为 n。</span></span><br><span class="line">            <span class="comment"># 我们的逻辑 re=0 会找到长度为 0 的子数组，加上 base_len 正好是 (target/t)*n</span></span><br><span class="line">            <span class="comment"># 但有一个特殊情况是，如果 target=t，base_len=n，re=0，我们的代码会找到一个空数组长度0</span></span><br><span class="line">            <span class="comment"># 最终返回 n+0 = n，这是对的。所以 re=0 的情况可以被统一处理。</span></span><br><span class="line">            <span class="comment"># 这里单独处理只是为了逻辑清晰。</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2: 滑动窗口寻找和为 re 的最短子数组</span></span><br><span class="line">        ans = inf</span><br><span class="line">        l = <span class="number">0</span>  <span class="comment"># 左指针</span></span><br><span class="line">        s = <span class="number">0</span>  <span class="comment"># 当前窗口和</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 在一个长度为 2n 的虚拟数组上滑动</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(n * <span class="number">2</span>):</span><br><span class="line">            s += nums[r % n]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当窗口和大于目标时，从左侧收缩</span></span><br><span class="line">            <span class="keyword">while</span> s &gt; re:</span><br><span class="line">                s -= nums[l % n]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果窗口和等于目标，更新最小长度</span></span><br><span class="line">            <span class="keyword">if</span> s == re:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, r - l + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 组合结果</span></span><br><span class="line">        <span class="keyword">if</span> ans == inf:</span><br><span class="line">            <span class="comment"># 如果 ans 未被更新，说明找不到和为 re 的子数组</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ans + base_len</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是 <code>nums</code> 的长度。计算数组总和是 O(N)，滑动窗口的左右指针最多移动 <code>2N</code> 次，因此也是 O(N)。总体复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个额外变量，没有创建与输入规模相关的数据结构。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“数学思维”与“算法技巧”结合的典范。通过取模运算，我们将一个看似复杂的“无限”问题，成功降维成一个可以在有限范围内解决的经典问题——在循环数组中寻找最短子数组和。而处理循环数组的“双倍数组”技巧，则是滑动窗口应用中的一个常用且强大的模式。当我们遇到看似无从下手的“无限”、“环形”等问题时，不妨先思考一下是否能通过数学变换将其转化为我们熟悉的模型。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>前缀和</tag>
        <tag>第365场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2904 | SW求解最短且字典序最小的美丽子串</title>
    <url>//posts/leetcode-2904/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2904 题：<a href="https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/description/">最短且字典序最小的美丽子字符串</a>。<br>该题要求在一个二进制字符串中，寻找一个包含 <code>k</code> 个 ‘1’ 的子串，这个子串需要满足两个条件：首先长度最短，其次在所有最短的子串中，它的字典序最小。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个二进制字符串 <code>s</code> 和一个正整数 <code>k</code>。我们需要找到 <code>s</code> 的一个“美丽子字符串”。</p>
<p>一个子字符串被称为“美丽”的，当且仅当它包含的 ‘1’ 的数量恰好为 <code>k</code>。</p>
<p>我们的目标是：</p>
<ol>
<li>在所有“美丽子字符串”中，找到那些长度最短的。</li>
<li>在所有这些最短的“美丽子字符串”中，找到字典序最小的那一个。</li>
</ol>
<p>如果不存在这样的子字符串，我们应该返回一个空字符串。</p>
<p>举个例子，对于 <code>s = &quot;100011001&quot;</code>, <code>k = 3</code>：</p>
<ul>
<li>子字符串 <code>&quot;100011&quot;</code> 是美丽的（3 个 ‘1’），长度为 6。</li>
<li>子字符串 <code>&quot;011001&quot;</code> 也是美丽的（3 个 ‘1’），长度为 6。</li>
<li>子字符串 <code>&quot;11001&quot;</code> 还是美丽的（3 个 ‘1’），长度为 5。</li>
<li>最短的美丽子字符串长度是 5。</li>
<li>在所有长度为 5 的美丽子字符串中（这里只有一个 <code>&quot;11001&quot;</code>），字典序最小的就是 <code>&quot;11001&quot;</code>，因此它就是答案。</li>
</ul>
<h3 id="核心思路：不定长滑动窗口"><a href="#核心思路：不定长滑动窗口" class="headerlink" title="核心思路：不定长滑动窗口"></a>核心思路：不定长滑动窗口</h3><p>这类寻找满足特定条件的“最优”子字符串的问题，是滑动窗口算法的绝佳应用场景。我们可以维护一个窗口 <code>[left, right]</code>，它代表了我们正在考察的子字符串。</p>
<p>我们的策略如下：</p>
<ol>
<li><p><strong>扩展窗口</strong>：我们不断地将 <code>right</code> 指针向右移动，以扩大窗口。每当一个新字符进入窗口时，我们更新窗口内 ‘1’ 的数量。</p>
</li>
<li><p><strong>收缩窗口</strong>：一旦窗口内 ‘1’ 的数量达到了 <code>k</code>，我们就找到了一个“美丽子字符串”的候选者。这时，我们不能停下，因为这个候选者不一定是最短的。</p>
<ul>
<li><strong>评估候选者</strong>：我们将当前窗口代表的子字符串与已找到的最佳答案进行比较。如果当前子串更短，或者长度相同但字典序更小，我们就更新答案。</li>
<li><strong>启动收缩</strong>：为了寻找可能存在的、更短的美丽子字符串，我们必须从左侧收缩窗口。我们将 <code>left</code> 指针向右移动，并相应地更新 ‘1’ 的数量。这个收缩过程会一直持续，直到窗口不再满足 ‘1’ 的数量为 <code>k</code> 的条件，之后我们再继续扩展 <code>right</code> 指针。</li>
</ul>
</li>
</ol>
<p>通过这种“扩展-评估-收缩”的循环，我们能确保遍历所有可能的美丽子字符串，并最终找到最优解。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>min_len</code>：用于记录当前找到的最短美丽子串的长度，初始为无穷大。</li>
<li><code>result</code>：用于存储最终答案，初始为空字符串 <code>&quot;&quot;</code>。</li>
<li><code>left = 0</code>：滑动窗口的左边界。</li>
<li><code>ones_count = 0</code>：当前滑动窗口内 ‘1’ 的数量。</li>
</ul>
</li>
<li><p><strong>遍历与扩展</strong>：</p>
<ul>
<li>使用 <code>right</code> 指针从头到尾遍历字符串 <code>s</code>。</li>
<li>当 <code>s[right]</code> 为 ‘1’ 时，<code>ones_count</code> 加 1。</li>
</ul>
</li>
<li><p><strong>触发收缩与评估</strong>：</p>
<ul>
<li>当 <code>ones_count</code> 恰好等于 <code>k</code> 时，我们找到了一个美丽子字符串。此时，启动一个 <code>while</code> 循环，因为 <code>[left, right]</code> 是一个候选项，<code>[left+1, right]</code> 也可能是（如果 <code>s[left]</code> 是 ‘0’）。</li>
<li><strong>在 <code>while (ones_count == k)</code> 循环内</strong>：<ol>
<li>获取当前窗口的长度 <code>current_len = right - left + 1</code> 和子字符串 <code>current_substring = s[left:right+1]</code>。</li>
<li><strong>比较与更新</strong>：<ul>
<li>如果 <code>current_len &lt; min_len</code>，说明我们找到了一个更短的，直接更新 <code>min_len = current_len</code> 和 <code>result = current_substring</code>。</li>
<li>如果 <code>current_len == min_len</code>，我们需要比较字典序。如果 <code>current_substring &lt; result</code>，则更新 <code>result = current_substring</code>。</li>
</ul>
</li>
<li><strong>收缩</strong>：将 <code>left</code> 指针右移一位。如果被移出窗口的字符 <code>s[left]</code> 是 ‘1’，则将 <code>ones_count</code> 减 1。这一步可能会导致 <code>ones_count</code> 变为 <code>k-1</code>，从而结束 <code>while</code> 循环。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>主循环结束后，<code>result</code> 中存储的就是最终答案。如果从未找到过美丽子字符串，<code>result</code> 将保持其初始值 <code>&quot;&quot;</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shortestBeautifulSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 如果 s 中 &#x27;1&#x27; 的总数都小于 k，则不可能有美丽子字符串</span></span><br><span class="line">        <span class="keyword">if</span> s.count(<span class="string">&#x27;1&#x27;</span>) &lt; k:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        min_len = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        result = <span class="string">&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        ones_count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 扩展窗口</span></span><br><span class="line">            <span class="keyword">if</span> s[right] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                ones_count += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当窗口内 &#x27;1&#x27; 的数量达到 k 时，开始评估和收缩</span></span><br><span class="line">            <span class="keyword">while</span> ones_count == k:</span><br><span class="line">                current_len = right - left + <span class="number">1</span></span><br><span class="line">                current_substring = s[left : right + <span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 评估：如果找到了更短的，或同样短但字典序更小的</span></span><br><span class="line">                <span class="keyword">if</span> current_len &lt; min_len:</span><br><span class="line">                    min_len = current_len</span><br><span class="line">                    result = current_substring</span><br><span class="line">                <span class="keyword">elif</span> current_len == min_len <span class="keyword">and</span> current_substring &lt; result:</span><br><span class="line">                    result = current_substring</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 收缩窗口</span></span><br><span class="line">                <span class="keyword">if</span> s[left] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    ones_count -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)，其中 N 是字符串 <code>s</code> 的长度。虽然代码里有嵌套的 <code>while</code> 循环，但 <code>left</code> 和 <code>right</code> 两个指针都只从左到右单向移动一次，每个字符最多被访问两次（一次被 <code>right</code> 指针纳入，一次被 <code>left</code> 指针排除），因此总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个额外变量来存储窗口状态和结果。返回的字符串 <code>result</code> 的空间不算在额外空间复杂度内。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想的直接应用。解决此题的关键在于清晰地定义窗口的“合法”状态（<code>ones_count == k</code>），并在进入此状态时，不仅要与全局最优解进行比较，还要尝试通过收缩窗口来寻找一个可能更优的解。双重优化目标（长度优先，字典序其次）的逻辑判断是本题的核心细节。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
        <tag>第367场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2953 | 分治+滑动窗口巧解“统计完全子字符串”</title>
    <url>//posts/leetcode-2953/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2953 题：<a href="https://leetcode.cn/problems/count-complete-substrings/description/">统计完全子字符串</a>。<br>这道题巧妙地将“分治思想”和“滑动窗口”结合在了一起。通过识别问题中的强约束条件来分解问题，是解决复杂问题的关键一步。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们来仔细分析一下题目中的“完全子字符串”需要满足的两个条件：</p>
<ol>
<li><strong>频率条件</strong>：子字符串 <code>s</code> 中的<strong>每个字符</strong>，都恰好出现 <code>k</code> 次。</li>
<li><strong>相邻条件</strong>：子字符串 <code>s</code> 中，任意<strong>两个相邻字符</strong>在字母表中的位置之差<strong>至多为 2</strong>。</li>
</ol>
<p>例如，<code>word = &quot;igigee&quot;</code>, <code>k = 2</code>。<br>子串 <code>&quot;igig&quot;</code> 满足相邻条件 (<code>&#39;i&#39;</code> 和 <code>&#39;g&#39;</code> 相差 2)，也满足频率条件（<code>&#39;i&#39;</code> 和 <code>&#39;g&#39;</code> 均出现 2 次），所以它是一个完全子字符串。<br>子串 <code>&quot;igigee&quot;</code> 中，<code>&#39;g&#39;</code> 和 <code>&#39;e&#39;</code> 相差 2，<code>&#39;e&#39;</code> 和 <code>&#39;e&#39;</code> 相差 0，满足相邻条件。但频率不对（<code>&#39;i&#39;</code> 出现 2 次, <code>&#39;g&#39;</code> 出现 2 次, <code>&#39;e&#39;</code> 出现 2 次），因此它也是一个完全子字符串。</p>
<p>而对于 <code>word = &quot;abacaba&quot;, k = 1</code>，子串 <code>&quot;abac&quot;</code> 不满足相邻条件，因为 <code>&#39;a&#39;</code> 和 <code>&#39;c&#39;</code> 的位置差是 2，但它们不相邻，相邻的是<code>&#39;b&#39;</code>和<code>&#39;a&#39;</code>，<code>&#39;a&#39;</code>和<code>&#39;c&#39;</code>。但是，在子串<code>&quot;ac&quot;</code>中，<code>&#39;a&#39;</code>和<code>&#39;c&#39;</code>相邻，位置差为2，满足条件。</p>
<h3 id="核心思路：分治-滑动窗口"><a href="#核心思路：分治-滑动窗口" class="headerlink" title="核心思路：分治 + 滑动窗口"></a>核心思路：分治 + 滑动窗口</h3><p>直接在一个循环里处理两个条件会非常复杂。我们注意到，“相邻条件”是一个非常强的局部约束。如果 <code>word</code> 中存在两个相邻字符 <code>word[i]</code> 和 <code>word[i-1]</code>，它们的字母表位置差大于 2，那么任何<strong>跨越</strong> <code>i-1</code> 和 <code>i</code> 这两个位置的子字符串都<strong>不可能</strong>是完全子字符串。</p>
<p>这个特性给了我们一个绝佳的“分治”机会！</p>
<h4 id="分割字符串（Divide）"><a href="#分割字符串（Divide）" class="headerlink" title="分割字符串（Divide）"></a>分割字符串（Divide）</h4><p>我们可以根据“相邻条件”将原字符串 <code>word</code> 切分成若干个独立的、更小的“有效子段”。在每个有效子段内部，任意相邻字符的位置差都 <code>&lt;= 2</code>。这样，我们只需要在这些独立的子段内部寻找满足“频率条件”的子字符串即可。</p>
<p>例如，如果 <code>word = &quot;aaabccdeeff&quot;, k = 2</code>，字符 <code>&#39;c&#39;</code> 和 <code>&#39;d&#39;</code> 的位置差为1，但<code>&#39;c&#39;</code>和<code>&#39;e&#39;</code>位置差为2，而<code>&#39;b&#39;</code> 和 <code>&#39;c&#39;</code> 的位置差为 1。假设 <code>word = &quot;aaabcxyz&quot;</code>，<code>&#39;c&#39;</code> 和 <code>&#39;x&#39;</code> 的位置差远大于 2，所以我们可以在它们之间切一刀，将问题分解为在 <code>&quot;aaabc&quot;</code> 和 <code>&quot;xyz&quot;</code> 两个子串中分别求解。</p>
<h4 id="在子段内求解（Conquer）"><a href="#在子段内求解（Conquer）" class="headerlink" title="在子段内求解（Conquer）"></a>在子段内求解（Conquer）</h4><p>对于每一个被分割出的有效子段，我们现在只需要解决一个简化版的问题：<strong>找出所有满足“每个字符恰好出现 k 次”的子字符串</strong>。</p>
<p>这正是滑动窗口的用武之地。但这里有一个挑战：完全子字符串的长度不是固定的。</p>
<ul>
<li>如果子字符串包含 1 种不同字符，其长度必须是 <code>1 * k</code>。</li>
<li>如果子字符串包含 2 种不同字符，其长度必须是 <code>2 * k</code>。</li>
<li>…</li>
<li>如果子字符串包含 <code>d</code> 种不同字符，其长度必须是 <code>d * k</code>。</li>
</ul>
<p>因此，我们可以遍历所有可能的“不同字符数”（从 1 到 26），对于每一种情况，我们使用一个<strong>定长滑动窗口</strong>来寻找答案。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>分割阶段</strong>:</p>
<ul>
<li>遍历整个字符串 <code>word</code>。使用一个指针 <code>i</code> 标记当前有效子段的开始。</li>
<li>使用另一个指针 <code>j</code> 从 <code>i</code> 开始向后寻找，直到 <code>abs(ord(word[j]) - ord(word[j+1])) &gt; 2</code> 或到达字符串末尾。</li>
<li>此时，<code>word[i:j+1]</code> 就是一个内部满足“相邻条件”的有效子段。</li>
<li>将这个子段交给下一步处理，然后将 <code>i</code> 更新为 <code>j+1</code>，开始寻找下一个有效子段。</li>
</ul>
</li>
<li><p><strong>处理子段阶段</strong>:</p>
<ul>
<li>对于上一步得到的每个有效子段 <code>s</code>，我们设计一个函数来计算其中的完全子字符串数量。</li>
<li>在这个函数内部，我们遍历“不同字符数 <code>d</code>”，从 1 到 26。</li>
<li>对于每个 <code>d</code>，我们计算出对应的窗口长度 <code>window_len = d * k</code>。如果 <code>window_len</code> 大于当前子段 <code>s</code> 的长度，就没有必要继续了。</li>
<li>使用一个长度为 <code>window_len</code> 的滑动窗口遍历子段 <code>s</code>。</li>
<li>在窗口滑动的每一步，我们都检查窗口内的子串是否满足：<ul>
<li>恰好包含 <code>d</code> 种不同的字符。</li>
<li>每种字符的出现次数都为 <code>k</code>。</li>
</ul>
</li>
<li>如果满足，则结果计数加一。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countCompleteSubstrings</span>(<span class="params">self, word: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(word)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1: 分割字符串</span></span><br><span class="line">        <span class="comment"># 根据相邻字符差异 &gt; 2 的地方作为切分点</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># 找到当前有效子段的终点</span></span><br><span class="line">            <span class="keyword">while</span> j + <span class="number">1</span> &lt; n <span class="keyword">and</span> <span class="built_in">abs</span>(<span class="built_in">ord</span>(word[j]) - <span class="built_in">ord</span>(word[j+<span class="number">1</span>])) &lt;= <span class="number">2</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 对子串 word[i:j+1] 进行处理</span></span><br><span class="line">            res += <span class="variable language_">self</span>._count_in_segment(word[i:j+<span class="number">1</span>], k)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 移动到下一个子段的起点</span></span><br><span class="line">            i = j + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_count_in_segment</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        在已满足“相邻条件”的子段 s 中，计算满足“频率条件”的完全子字符串数量。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 步骤 2: 遍历所有可能的窗口长度</span></span><br><span class="line">        <span class="comment"># distinct_chars 是窗口内不同字符的数量，从 1 到 26</span></span><br><span class="line">        <span class="keyword">for</span> distinct_chars <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">27</span>):</span><br><span class="line">            window_len = distinct_chars * k</span><br><span class="line">            <span class="keyword">if</span> window_len &gt; <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="comment"># 窗口长度已超过子段长度，后续更长的窗口也无意义</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 使用固定长度为 window_len 的滑动窗口</span></span><br><span class="line">            w_cnt = Counter(s[:window_len])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 检查第一个窗口</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>._is_complete(w_cnt, k):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 开始滑动</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(window_len, <span class="built_in">len</span>(s)):</span><br><span class="line">                l = r - window_len</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 窗口右侧加入一个新字符</span></span><br><span class="line">                w_cnt[s[r]] += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 窗口左侧移出一个旧字符</span></span><br><span class="line">                w_cnt[s[l]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> w_cnt[s[l]] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> w_cnt[s[l]]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 检查当前窗口是否为完全子字符串</span></span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>._is_complete(w_cnt, k):</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_is_complete</span>(<span class="params">self, counter: Counter, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        辅助函数：检查一个计数器中的所有字符频率是否都严格为 k。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> counter:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 遍历计数器中所有字符的计数值</span></span><br><span class="line">        <span class="keyword">for</span> freq <span class="keyword">in</span> counter.values():</span><br><span class="line">            <span class="keyword">if</span> freq != k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。虽然代码有两层循环，但我们可以这样分析：外层循环负责分割字符串，对 <code>word</code> 的每个字符访问一次，是 O(N)。内层的 <code>_count_in_segment</code> 函数，其循环 <code>for distinct_chars in range(1, 27)</code> 最多执行 26 次。在每次循环中，滑动窗口会线性扫描一次子段。由于所有子段的长度之和为 N，所以总的时间复杂度是 O(26 * N)，即 O(N)。</li>
<li><strong>空间复杂度</strong>: O(K)，其中 K 是字符集的大小（这里是 26）。<code>Counter</code> 最多存储 26 个字符的频率，因此空间复杂度是 O(1)。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“困难”题中的一股清流，它展示了如何通过分析问题约束来简化问题。<br>关键的收获是：</p>
<ol>
<li><strong>识别强约束</strong>：题目中的“相邻条件”是比“频率条件”更强的局部约束，它可以作为我们分割问题的依据。</li>
<li><strong>分而治之</strong>：将一个复杂问题分解为多个独立的、更简单的子问题。</li>
<li><strong>模式识别</strong>：在子问题中，我们识别出了一个“变种”的滑动窗口问题——窗口长度可变但有规律，通过遍历所有可能的长度来解决。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2968 | 滑动窗口求解“执行操作使频率分数最大”</title>
    <url>//posts/leetcode-2968/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 2968 题：<a href="https://leetcode.cn/problems/apply-operations-to-maximize-frequency-score/description/">执行操作使频率分数最大</a>。<br>该题要求我们通过对数组元素进行有限次数的增减操作，来最大化某个元素的出现频率。问题的核心在于，要让一组数字变得相同，最经济的方式是什么？答案指向了它们的中位数。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个整数数组 <code>nums</code> 和一个预算 <code>k</code>。我们可以执行的操作是：选择任意一个元素 <code>nums[i]</code>，将其增加或减少 1。每次操作消耗 1。我们的总消耗不能超过 <code>k</code>。</p>
<p>目标是最大化操作后数组中某个数出现的次数（即“频率分数”）。</p>
<p>举个例子，对于 <code>nums = [1,2,6,4]</code>, <code>k = 3</code>：</p>
<ul>
<li>我们的目标是，用不超过 3 的总代价，让尽可能多的数字变成同一个数。</li>
<li>比如，我们可以选择让一部分数字都变成 2。<ul>
<li><code>1</code> 变成 <code>2</code>，代价是 <code>|2-1|=1</code>。</li>
<li><code>4</code> 变成 <code>2</code>，代价是 <code>|2-4|=2</code>。</li>
<li>总代价是 <code>1 + 2 = 3</code>，正好在预算内。</li>
<li>操作后数组可以是 <code>[2,2,6,2]</code>。数字 <code>2</code> 出现了 3 次。</li>
</ul>
</li>
<li>我们可以达到的最大频率就是 3。</li>
</ul>
<p>直接枚举最终要变成哪个数，以及选择哪些原始数字来变成它，组合非常多，复杂度会爆炸。我们需要一个更系统性的方法。</p>
<h3 id="核心思路：排序-滑动窗口"><a href="#核心思路：排序-滑动窗口" class="headerlink" title="核心思路：排序 + 滑动窗口"></a>核心思路：排序 + 滑动窗口</h3><p>为了让最终的频率分数为 <code>m</code>，我们必须选择 <code>m</code> 个原始数字，并将它们全部变成同一个目标值 <code>t</code>。我们的策略应该是：</p>
<ol>
<li><p><strong>选择哪 <code>m</code> 个数？</strong><br>直觉上，为了让操作总代价最小，我们应该选择那些本身就比较接近的数字。将数组排序后，这些数字会形成一个连续的子数组。因此，我们的问题转化为了在<strong>排序后</strong>的数组上寻找一个子数组。</p>
</li>
<li><p><strong>目标值 <code>t</code> 应该是什么？</strong><br>对于一个给定的子数组（比如 <code>[a, b, c, d]</code>），要将它们全部变成同一个值 <code>t</code>，总代价为 <code>|a-t| + |b-t| + |c-t| + |d-t|</code>。这是一个经典的数学问题：要使绝对差之和最小，目标值 <code>t</code> 必须是这个子数组的<strong>中位数</strong>。</p>
</li>
</ol>
<p>结合这两点，问题豁然开朗：<br><strong>问题转化为：在排序后的 <code>nums</code> 数组中，找到一个最长的连续子数组 <code>nums[left...right]</code>，使得将该子数组中的所有元素都变成其中位数 <code>nums[(left+right)//2]</code> 的总代价不超过 <code>k</code>。</strong></p>
<p>这个子数组的长度，就是我们能获得的最大频率分数。</p>
<p>这完美地契合了<strong>不定长滑动窗口</strong>的模型。我们可以用 <code>[left, right]</code> 来表示我们正在考虑的子数组。</p>
<ul>
<li>我们不断向右扩展窗口的右边界 <code>right</code>。</li>
<li>同时计算将窗口内所有元素统一到其中位数的代价。</li>
<li>如果代价超过了预算 <code>k</code>，我们就从左边收缩窗口，即增大 <code>left</code>，直到代价重新回到预算内。</li>
<li>在这个过程中，我们记录下窗口的最大长度 <code>right - left + 1</code>，它就是最终的答案。</li>
</ul>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>排序</strong><br>首先对 <code>nums</code> 数组进行升序排序。这是后续所有步骤的基础。</p>
</li>
<li><p><strong>滑动窗口</strong></p>
<ul>
<li>初始化窗口的左右边界 <code>left = 0</code>，<code>right = 0</code>。</li>
<li>用一个变量 <code>s</code> 记录当前窗口 <code>[left, right]</code> 内的元素统一到其中位数的总代价。</li>
<li>遍历 <code>right</code> 从 <code>0</code> 到 <code>n-1</code>，不断扩大窗口：<br>a.  当 <code>right</code> 指向新元素 <code>x</code> (<code>nums[right]</code>) 时，我们计算将这个新元素加入窗口后，新的总代价。<br>b.  代价 <code>s</code> 的更新是本题的巧妙之处。可以证明，当窗口从 <code>[left, right-1]</code> 扩展到 <code>[left, right]</code> 时，总代价的变化可以通过一个简单的公式计算。同样，当窗口从 <code>[left, right]</code> 收缩到 <code>[left+1, right]</code> 时，代价的变化也有规律。<br>c.  判断当前的总代价 <code>s</code> 是否大于 <code>k</code>。<br>d.  如果 <code>s &gt; k</code>，说明当前窗口过长，成本超支。我们需要收缩窗口，将 <code>left</code> 指针右移，并从 <code>s</code> 中减去 <code>nums[left]</code> 贡献的成本。持续这个过程，直到 <code>s &lt;= k</code>。<br>e.  在每一次窗口调整后，当前窗口 <code>[left, right]</code> 都是一个有效的方案，其长度 <code>right - left + 1</code> 是一个可能的频率分数。我们用它来更新全局最大值 <code>ans</code>。</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>遍历结束后，<code>ans</code> 即为所求。</li>
</ul>
</li>
</ol>
<p>这个算法的关键在于如何高效地更新代价 <code>s</code>。虽然可以通过前缀和在 O(1) 时间内计算任意窗口的代价，但给出的代码采用了更精妙的增量更新方式，省去了前缀和数组的空间。</p>
<p>让我们来理解一下代码中的代价更新逻辑：</p>
<ul>
<li><code>s += x - nums[(left + right) // 2]</code>：当窗口向右扩大，加入 <code>x = nums[right]</code> 时，新的中位数是 <code>m_new = nums[(left + right) // 2]</code>。<code>s</code> 的增量被计算为 <code>x - m_new</code>。</li>
<li><code>s += nums[left] - nums[(left + right + 1) // 2]</code>：当窗口从左边收缩，移除 <code>nums[left]</code> 时，新窗口 <code>[left+1, right]</code> 的中位数是 <code>m&#39;_new = nums[(left + right + 1) // 2]</code>。<code>s</code> 的减量被计算为 <code>m&#39;_new - nums[left]</code>。</li>
</ul>
<p>这些看似简单的更新，其背后是利用了中位数变化的规律，巧妙地对总代价进行了调整，从而避免了每次都重新计算整个窗口的成本。</p>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxFrequencyScore</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 1: 排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="comment"># s 是窗口内元素与窗口中位数的绝对差之和，即总代价</span></span><br><span class="line">        s = <span class="number">0</span>  </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2: 滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span> right, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 扩大窗口：加入 nums[right]</span></span><br><span class="line">            <span class="comment"># 计算并累加新窗口的代价</span></span><br><span class="line">            <span class="comment"># m_new 是 [left...right] 的中位数</span></span><br><span class="line">            m_new = nums[(left + right) // <span class="number">2</span>]</span><br><span class="line">            s += x - m_new</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果代价超支，收缩窗口</span></span><br><span class="line">            <span class="keyword">while</span> s &gt; k:</span><br><span class="line">                <span class="comment"># m_after_shrink 是 [left+1...right] 的中位数</span></span><br><span class="line">                m_after_shrink = nums[(left + right + <span class="number">1</span>) // <span class="number">2</span>]</span><br><span class="line">                <span class="comment"># 从总代价 s 中减去移除 nums[left] 带来的变化</span></span><br><span class="line">                s -= (m_after_shrink - nums[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 更新最大频率分数（即最大有效窗口长度）</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N log N)。其中 N 是 <code>nums</code> 的长度。排序的复杂度是 O(N log N)，后续的滑动窗口遍历中，<code>left</code> 和 <code>right</code> 指针都只单向移动 N 次，所以是 O(N)。总的瓶颈在排序。</li>
<li><strong>空间复杂度</strong>: O(1) 或 O(log N) 或 O(N)。这取决于排序算法使用的额外空间。如果我们忽略排序所用的空间，则算法本身是 O(1)。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是一个将实际问题转化为标准算法模型的绝佳例子。通过两个关键的洞察——“选择排序后连续的子数组代价更小”和“目标值应为子数组的中位数”，我们将一个看似复杂的组合问题，成功转换为了一个可以在排序数组上用滑动窗口高效求解的问题。代码中对窗口代价 <code>s</code> 的精妙增量更新，是该解法在实现层面的点睛之笔，值得细细品味。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>滑动窗口</tag>
        <tag>排序</tag>
        <tag>前缀和</tag>
        <tag>第376场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3 | 无重复字符的最长子串</title>
    <url>//posts/leetcode-3/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3 题：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a>。<br>这道题通过维护一个动态的、满足特定条件的窗口，在 O(N) 的时间内优雅地解决问题，是每位算法学习者都应掌握的核心技巧。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目的要求非常直白：给定一个字符串 <code>s</code>，找出其中<strong>不含有重复字符</strong>的<strong>最长子串</strong>的长度。</p>
<p>我们需要理解两个关键点：</p>
<ol>
<li><strong>子串 (Substring)</strong>：必须是原字符串中连续的一段字符。例如，<code>&quot;wke&quot;</code> 是 <code>&quot;pwwkew&quot;</code> 的一个子串。</li>
<li><strong>无重复字符</strong>：子串中的每个字符都只出现一次。</li>
</ol>
<p>我们来看几个例子：</p>
<ul>
<li><code>s = &quot;abcabcbb&quot;</code>：最长的无重复子串是 <code>&quot;abc&quot;</code>，长度为 3。</li>
<li><code>s = &quot;bbbbb&quot;</code>：最长的无重复子串是 <code>&quot;b&quot;</code>，长度为 1。</li>
<li><code>s = &quot;pwwkew&quot;</code>：最长的无重复子串是 <code>&quot;wke&quot;</code>，长度为 3。这里需要特别注意，<code>&quot;pwke&quot;</code> 是一个子序列 (subsequence) 而不是子串，因此不是有效答案。</li>
</ul>
<h3 id="核心思路：滑动窗口"><a href="#核心思路：滑动窗口" class="headerlink" title="核心思路：滑动窗口"></a>核心思路：滑动窗口</h3><p>暴力解法（枚举所有子串并检查是否有重复字符）的时间复杂度会达到 O(N³)，显然无法接受。这正是“滑动窗口”大显身手的场景。</p>
<p>我们可以想象有一个“窗口”在字符串上滑动，这个窗口的内部始终维护着一个<strong>无重复字符的子串</strong>。我们的目标就是让这个窗口尽可能地宽。</p>
<p>该如何实现这个“滑动”呢？</p>
<ol>
<li>我们用两个指针，<code>left</code> 和 <code>right</code>，来表示窗口的左右边界，初始时都指向字符串的开头。</li>
<li><code>right</code> 指针不断向右移动，尝试扩大窗口。每移动一步，就将新字符纳入窗口。</li>
<li>在纳入新字符 <code>s[right]</code> 时，我们需要检查它是否已存在于当前窗口中。</li>
<li><strong>如果 <code>s[right]</code> 不在窗口内</strong>：说明窗口依然满足无重复的条件。此时 <code>right</code> 指针可以继续向右移动，窗口成功扩大。</li>
<li><strong>如果 <code>s[right]</code> 已经在窗口内</strong>：说明出现了重复字符，当前窗口不再合法。此时我们必须收缩窗口。具体操作是，将 <code>left</code> 指针向右移动，并将 <code>s[left]</code> 移出窗口，直到那个与 <code>s[right]</code> 重复的字符被移出窗口为止。</li>
<li>在每一次窗口状态合法时（即扩大或收缩后），我们都计算一下当前窗口的长度 <code>right - left + 1</code>，并更新我们记录的最大长度。</li>
</ol>
<p>为了能以 O(1) 的时间复杂度快速判断一个字符是否存在于当前窗口中，以及快速地添加和删除字符，<strong>哈希集合 (Hash Set)</strong> 是最理想的数据结构。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化</strong>:</p>
<ul>
<li>创建一个哈希集合 <code>char_set</code>，用来存储当前窗口内的所有字符。</li>
<li>初始化左指针 <code>left = 0</code>。</li>
<li>初始化最大长度 <code>max_len = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历与扩张</strong>:</p>
<ul>
<li>使用右指针 <code>right</code> 从 0 开始遍历整个字符串 <code>s</code>。</li>
<li>对于每个 <code>s[right]</code>，进入一个循环，检查 <code>s[right]</code> 是否已经存在于 <code>char_set</code> 中。</li>
</ul>
</li>
<li><p><strong>检查与收缩</strong>:</p>
<ul>
<li><strong>如果 <code>s[right]</code> 存在</strong>，说明遇到了重复字符。我们需要收缩窗口的左边界。</li>
<li>从 <code>char_set</code> 中移除 <code>s[left]</code> 对应的字符。</li>
<li>将 <code>left</code> 指针向右移动一位 (<code>left += 1</code>)。</li>
<li>重复此过程，直到 <code>s[right]</code> 在 <code>char_set</code> 中不再存在为止。</li>
</ul>
</li>
<li><p><strong>更新状态</strong>:</p>
<ul>
<li>（经过上一步的收缩后）现在可以保证将 <code>s[right]</code> 加入窗口是安全的。将 <code>s[right]</code> 添加到 <code>char_set</code> 中。</li>
<li>此时，窗口 <code>[left, right]</code> 是一个有效的无重复子串。计算其长度 <code>right - left + 1</code>，并与 <code>max_len</code> 比较，取较大值更新 <code>max_len</code>。</li>
</ul>
</li>
<li><p><strong>结束</strong>:</p>
<ul>
<li><code>right</code> 指针遍历完整个字符串后，<code>max_len</code> 中存储的就是最终的答案。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 哈希集合，用于存储当前窗口中的字符</span></span><br><span class="line">        char_set = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 左指针和结果变量</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 右指针遍历整个字符串</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># 当 s[right] 存在于当前窗口中时，</span></span><br><span class="line">            <span class="comment"># 需要从窗口左侧开始移除元素，直到窗口中不再包含重复的 s[right]。</span></span><br><span class="line">            <span class="keyword">while</span> s[right] <span class="keyword">in</span> char_set:</span><br><span class="line">                char_set.remove(s[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将当前字符添加到窗口（哈希集合）中</span></span><br><span class="line">            char_set.add(s[right])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新找到的最大长度。</span></span><br><span class="line">            <span class="comment"># 此时的窗口范围是 [left, right]，长度为 right - left + 1</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> max_len</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)，其中 N 是字符串 <code>s</code> 的长度。虽然代码中有一个 <code>while</code> 循环嵌套在 <code>for</code> 循环内部，但每个字符最多被 <code>left</code> 指针和 <code>right</code> 指针各访问一次。因此，总的操作次数与字符串长度成线性关系。</li>
<li><strong>空间复杂度</strong>: O(K)，其中 K 是字符集的大小。在最坏的情况下，如果字符串中的所有字符都不同，<code>char_set</code> 将会存储所有这些字符。对于 ASCII 字符集，K 的大小是固定的（如 128 或 256），因此也可以看作是 O(1) 的空间复杂度。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口技巧的奠基石，完美地诠释了其核心思想：</p>
<ol>
<li><strong>双指针界定窗口</strong>：使用 <code>left</code> 和 <code>right</code> 指针定义一个处理区间。</li>
<li><strong>条件驱动指针移动</strong>：根据窗口内是否满足“无重复字符”这一条件，来决定是移动 <code>right</code> 指针（扩张）还是 <code>left</code> 指针（收缩）。</li>
<li><strong>借助高效数据结构</strong>：使用哈希集合来优化查询效率，使得检查重复和更新窗口状态的操作接近 O(1)。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 30 | 滑动窗口巧解串联所有单词的子串</title>
    <url>//posts/leetcode-30/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 30 题：<a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">串联所有单词的子串</a>。<br>这道题是滑动窗口思想的一次精彩升级。它不再是处理单个字符，而是将“单词”作为窗口滑动的基本单位，同时引入了“分组”处理的巧妙思想，是理解滑动窗口灵活性的绝佳案例。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们来仔细分析一下题目：给定一个主字符串 <code>s</code> 和一个单词数组 <code>words</code>，要求找出 <code>s</code> 中所有“串联子串”的起始索引。</p>
<ul>
<li><strong>串联子串</strong>：这个子串由 <code>words</code> 中的<strong>所有</strong>单词<strong>恰好一次</strong>、以<strong>任意顺序</strong>拼接而成。</li>
<li><strong>关键约束</strong>：<code>words</code> 中的所有单词长度都<strong>相同</strong>。这是一个非常重要的突破口。</li>
</ul>
<p>例如，如果 <code>words = [&quot;foo&quot;, &quot;bar&quot;]</code>，那么 <code>s</code> 中的 <code>&quot;foobar&quot;</code> 和 <code>&quot;barfoo&quot;</code> 都是串联子串。子串 <code>&quot;barfoothefoobarman&quot;</code> 中，从索引 <code>0</code> 开始的 <code>&quot;barfoo&quot;</code> 和从索引 <code>9</code> 开始的 <code>&quot;foobar&quot;</code> 都是有效的串联子串。</p>
<h3 id="核心思路：从字符窗口到单词窗口"><a href="#核心思路：从字符窗口到单词窗口" class="headerlink" title="核心思路：从字符窗口到单词窗口"></a>核心思路：从字符窗口到单词窗口</h3><p>直接检查 <code>s</code> 中每一个可能的子串是否由 <code>words</code> 的排列构成，效率会很低。正确的思路依然是<strong>滑动窗口</strong>，但需要进行一些关键的调整。</p>
<h4 id="滑动单位的转变"><a href="#滑动单位的转变" class="headerlink" title="滑动单位的转变"></a>滑动单位的转变</h4><p>该题的基本单位不再是单个字符，而是一个个<strong>单词</strong>。</p>
<ul>
<li>目标 <code>words</code> 包含 <code>k</code> 个长度为 <code>len</code> 的单词。</li>
<li>那么，一个有效的“串联子串”的总长度是固定的：<code>total_len = k * len</code>。</li>
<li>我们的滑动窗口大小也应该是 <code>total_len</code>。</li>
<li>窗口每次滑动的步长，不再是 <code>1</code> 个字符，而应该是 <code>len</code> 个字符，即一个单词的长度。</li>
</ul>
<h4 id="分组滑动的巧妙构思"><a href="#分组滑动的巧妙构思" class="headerlink" title="分组滑动的巧妙构思"></a>分组滑动的巧妙构思</h4><p>一个最关键的问题是：滑动窗口的起点应该在哪里？</p>
<p>如果单词长度 <code>len = 3</code>，一个有效的串联子串可能从索引 <code>0, 3, 6, ...</code> 开始，也可能从 <code>1, 4, 7, ...</code> 或 <code>2, 5, 8, ...</code> 开始。这三种情况是<strong>完全独立、互不干扰</strong>的。</p>
<p>因此，我们可以把对 <code>s</code> 的一次遍历，拆分成 <code>len</code> 次独立的遍历。</p>
<ul>
<li>第一次遍历，我们只考虑从 <code>s[0]</code> 开始，以 <code>len</code> 为步长构建的单词序列。</li>
<li>第二次遍历，我们只考虑从 <code>s[1]</code> 开始，以 <code>len</code> 为步长构建的单词序列。</li>
<li>…</li>
<li>第 <code>len</code> 次遍历，我们只考虑从 <code>s[len-1]</code> 开始的序列。</li>
</ul>
<p>通过这种方式，我们用一个外层循环（遍历 <code>0</code> 到 <code>len-1</code> 这 <code>len</code> 种起始偏移）和内层滑动窗口相结合，就能覆盖所有可能的情况。</p>
<h3 id="滑动窗口算法详解"><a href="#滑动窗口算法详解" class="headerlink" title="滑动窗口算法详解"></a>滑动窗口算法详解</h3><ol>
<li><p><strong>准备工作</strong>:</p>
<ul>
<li>获取单词长度 <code>word_len</code>，单词数量 <code>num_words</code>，以及串联子串总长 <code>total_len</code>。</li>
<li>处理边界情况，例如 <code>s</code> 或 <code>words</code> 为空，或 <code>s</code> 的长度小于 <code>total_len</code>。</li>
<li>使用哈希表 <code>words_cnt</code> 统计 <code>words</code> 数组中每个单词的出现频率。</li>
</ul>
</li>
<li><p><strong>外层循环（分组）</strong>:</p>
<ul>
<li>启动一个 <code>for</code> 循环，<code>i</code> 从 <code>0</code> 遍历到 <code>word_len - 1</code>。这个 <code>i</code> 代表每组滑动的起始偏移量。</li>
</ul>
</li>
<li><p><strong>内层循环（滑动窗口）</strong>:</p>
<ul>
<li>在每组中，初始化一个左指针 <code>l = i</code> 和一个用于记录窗口内单词频率的哈希表 <code>window_cnt</code>。</li>
<li>用右指针 <code>r</code> 从 <code>i</code> 开始，以 <code>word_len</code> 为步长向右遍历 <code>s</code>。</li>
<li><strong>移入单词</strong>：在每次迭代中，从 <code>s</code> 中截取 <code>s[r : r + word_len]</code> 作为一个新单词。</li>
<li><strong>处理新单词</strong>:<ul>
<li>如果这个新单词<strong>不在</strong> <code>words_cnt</code> 中，说明它是一个无效单词。当前窗口内的所有单词都无法构成串联，因此直接清空 <code>window_cnt</code>，并将左指针 <code>l</code> 移动到这个无效单词的后面，即 <code>l = r + word_len</code>。</li>
<li>如果新单词是有效单词，则将其计入 <code>window_cnt</code>。</li>
<li><strong>处理冗余</strong>：检查 <code>window_cnt</code> 中该单词的数量是否超过了 <code>words_cnt</code> 中的需求。如果是，则需要从窗口左侧不断移出单词（<code>l</code> 右移 <code>word_len</code>），直到这个单词的数量恢复正常。</li>
</ul>
</li>
<li><strong>检查匹配</strong>:<ul>
<li>在窗口不包含冗余单词后，检查当前窗口内的单词总数 <code>(r - l) // word_len + 1</code> 是否等于 <code>num_words</code>。</li>
<li>如果相等，说明我们找到了一个完整的串联子串，其起始位置就是当前的左指针 <code>l</code>，将其加入结果列表。</li>
<li>找到后，为了继续搜索，我们将窗口最左侧的单词移出（<code>l</code> 右移 <code>word_len</code>），以便寻找下一个可能的匹配。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong>:</p>
<ul>
<li>所有分组遍历完成后，返回记录所有起始索引的结果列表。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 步骤 1：准备工作</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> words:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        num_words = <span class="built_in">len</span>(words)</span><br><span class="line">        word_len = <span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line">        total_len = num_words * word_len</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n &lt; total_len:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        words_cnt = Counter(words)</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2：外层循环，处理 len 种不同的分组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(word_len):</span><br><span class="line">            <span class="comment"># 初始化滑动窗口的左右指针和当前窗口的单词频率表</span></span><br><span class="line">            l = i</span><br><span class="line">            window_cnt = Counter()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤 3：内层循环，以 word_len 为步长滑动窗口</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(i, n - word_len + <span class="number">1</span>, word_len):</span><br><span class="line">                <span class="comment"># 从右侧移入一个新单词</span></span><br><span class="line">                word = s[r : r + word_len]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">in</span> words_cnt:</span><br><span class="line">                    window_cnt[word] += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 如果窗口中此单词数量过多，从左侧收缩窗口</span></span><br><span class="line">                    <span class="keyword">while</span> window_cnt[word] &gt; words_cnt[word]:</span><br><span class="line">                        left_word = s[l : l + word_len]</span><br><span class="line">                        window_cnt[left_word] -= <span class="number">1</span></span><br><span class="line">                        l += word_len</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 步骤 3.检查匹配：窗口大小正好等于所需单词数</span></span><br><span class="line">                    <span class="keyword">if</span> (r - l) // word_len + <span class="number">1</span> == num_words:</span><br><span class="line">                        res.append(l)</span><br><span class="line">                        <span class="comment"># 匹配成功后，将窗口左侧单词移出，继续寻找下一个匹配</span></span><br><span class="line">                        left_word = s[l : l + word_len]</span><br><span class="line">                        window_cnt[left_word] -= <span class="number">1</span></span><br><span class="line">                        l += word_len</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果遇到无效单词，之前的所有努力都作废</span></span><br><span class="line">                    <span class="comment"># 重置窗口，并将左指针移到无效单词之后</span></span><br><span class="line">                    window_cnt.clear()</span><br><span class="line">                    l = r + word_len</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(L * W)。其中 L 是字符串 <code>s</code> 的长度，W 是单个单词的长度 <code>word_len</code>。外层循环执行 W 次，内层循环对 <code>s</code> 的遍历步长为 W，每次截取子串的成本是 W。所以总的时间复杂度近似为 W * (L&#x2F;W) * W &#x3D; O(L * W)。</li>
<li><strong>空间复杂度</strong>: O(K * W)，其中 K 是 <code>words</code> 中不同单词的个数，W 是单词的长度。这部分空间主要用于存储 <code>words_cnt</code> 和 <code>window_cnt</code> 这两个哈希表。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口技巧应用的绝佳进阶范例。它告诉我们，滑动窗口的“单位”和“步长”都可以是灵活的。通过<strong>将问题分解为 <code>word_len</code> 个独立的子问题</strong>，我们成功地将一个看似复杂的问题，用清晰的滑动窗口逻辑进行了求解。这种“分组处理”的思想在解决某些具有特定步长或周期的字符串问题时非常有效。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3048 | 标记所有下标的最早秒数 I</title>
    <url>//posts/leetcode-3048/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3048 题：<a href="https://leetcode.cn/problems/earliest-second-to-mark-indices-i/description/">标记所有下标的最早秒数 I</a>。<br>本题的关键在于识别出答案（秒数）具备单调性，从而可以将求解“最早秒数”这个最优化问题，转化为一个判定“给定秒数是否可行”的问题，并利用二分查找高效求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们有两个数组，<code>nums</code> 和 <code>changeIndices</code>，长度分别为 <code>n</code> 和 <code>m</code>。我们的目标是找到一个<strong>最早</strong>的秒数，在此时刻之前（含），能够将 <code>nums</code> 数组的所有 <code>n</code> 个下标都“标记”一遍。</p>
<p>每一秒，我们有三种选择：</p>
<ol>
<li>将任意一个 <code>nums[i]</code> 的值减 1。</li>
<li>如果 <code>nums[changeIndices[s]-1]</code> 的值恰好为 0，我们可以标记 <code>changeIndices[s]-1</code> 这个下标。</li>
<li>什么都不做。</li>
</ol>
<p>核心约束是：</p>
<ul>
<li>标记操作只能在特定秒数 <code>s</code> 对特定的下标 <code>changeIndices[s]-1</code> 进行。</li>
<li>标记一个下标 <code>i</code> 的前提是 <code>nums[i]</code> 必须已经被减为 0。</li>
</ul>
<p>我们需要在 <code>m</code> 秒的时间窗口内，找到满足条件的最小秒数。如果无法完成任务，则返回 -1。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最早秒数”比较复杂，因为它涉及到一系列操作的最优调度。但这类“求最小值&#x2F;最大值”的问题，通常可以尝试使用二分查找来解决。</p>
<p>我们可以对<strong>答案（秒数 <code>s</code>）<strong>进行二分查找。为此，我们需要验证答案的</strong>单调性</strong>：</p>
<ul>
<li>如果在 <code>s</code> 秒内可以标记所有下标，那么在 <code>s+1</code> 秒内，我们拥有更多的时间和操作机会，必然也可以完成任务。</li>
<li>反之，如果在 <code>s</code> 秒内无法完成任务，那么在更短的 <code>s-1</code> 秒内，也必然无法完成。</li>
</ul>
<p>这种单调性是应用二分查找的完美前提。我们可以将原问题从“找到<strong>最早</strong>的那个秒数”，转化为一个更简单的判定问题：“给定 <code>s</code> 秒，我们能<strong>不能</strong>标记所有下标？”</p>
<p>我们可以设计一个辅助函数 <code>check(s)</code> 来回答这个判定问题。如果能高效地实现 <code>check(s)</code>，就可以通过二分查找在 <code>[1, m]</code> 的范围内快速定位到最小的可行秒数。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><h4 id="1-确定二分查找的范围"><a href="#1-确定二分查找的范围" class="headerlink" title="1. 确定二分查找的范围"></a>1. 确定二分查找的范围</h4><ul>
<li><strong>下界 (left)</strong>：至少需要 1 秒，所以下界是 <code>1</code>。</li>
<li><strong>上界 (right)</strong>：最多有 <code>m</code> 秒可用，所以上界是 <code>m</code>。</li>
</ul>
<p>我们就在 <code>[1, m]</code> 这个区间内对秒数 <code>s</code> 进行二分查找。</p>
<h4 id="2-check-s-函数的设计（贪心策略）"><a href="#2-check-s-函数的设计（贪心策略）" class="headerlink" title="2. check(s) 函数的设计（贪心策略）"></a>2. <code>check(s)</code> 函数的设计（贪心策略）</h4><p><code>check(s)</code> 是整个算法的核心。给定 <code>s</code> 秒，我们如何判断是否能完成任务？这需要一个明智的策略来安排我们的操作。</p>
<p><strong>核心贪心思想</strong>：对于任何一个需要标记的下标 <code>i</code>，为了给“减 1”操作留出尽可能多的时间，我们应该选择在 <code>s</code> 秒内<strong>最后一次</strong>出现 <code>i</code> 的机会来标记它。这样做可以最大化在该标记操作之前可用的、能够自由支配的“减 1”秒数。</p>
<p>基于这个思想，<code>check(s)</code> 的步骤如下：</p>
<ol>
<li><p><strong>找到最后的标记时机</strong>：</p>
<ul>
<li>遍历 <code>changeIndices</code> 的前 <code>s</code> 个元素（即从第 1 秒到第 <code>s</code> 秒）。</li>
<li>使用一个哈希表或数组 <code>last_pos</code>，记录每个下标 <code>i</code> (1 到 n) 在这 <code>s</code> 秒内最后一次出现的时间点。</li>
<li>如果在遍历后，发现某个下标 <code>i</code> 从未在 <code>changeIndices</code> 的前 <code>s</code> 秒中出现过，那么它就不可能被标记，<code>check(s)</code> 直接返回 <code>False</code>。</li>
</ul>
</li>
<li><p><strong>模拟过程，检查资源是否足够</strong>：</p>
<ul>
<li>我们从第 1 秒开始，一直模拟到第 <code>s</code> 秒。维护一个计数器 <code>ops</code>，表示我们积累了多少可以自由使用的“减 1”操作次数。</li>
<li>在第 <code>t</code> 秒 (<code>1 &lt;= t &lt;= s</code>)：<ul>
<li>查看 <code>changeIndices</code> 在这一秒指向的下标 <code>idx</code>。</li>
<li>判断当前秒 <code>t</code> 是否是 <code>idx</code> 的预定标记时间（即 <code>t == last_pos[idx]</code>）。<ul>
<li><strong>如果是</strong>：我们必须在这一秒标记 <code>idx</code>。为此，我们需要确保 <code>nums[idx-1]</code> 已经归零。这需要 <code>nums[idx-1]</code> 次“减 1”操作。我们检查积累的 <code>ops</code> 是否足够（<code>ops &gt;= nums[idx-1]</code>）。<ul>
<li>如果不够，说明时间不够，<code>check(s)</code> 返回 <code>False</code>。</li>
<li>如果足够，我们就“消耗”掉这些操作次数：<code>ops -= nums[idx-1]</code>。</li>
</ul>
</li>
<li><strong>如果不是</strong>：这一秒不是 <code>idx</code> 的最后标记机会。根据我们的贪心策略，我们不会在此时标记它，而是将这一秒视为一个宝贵的、可用于“减 1”的空闲时间。因此，<code>ops</code> 加 1。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>如果整个模拟过程（从第 1 秒到第 <code>s</code> 秒）都能顺利进行，没有因为 <code>ops</code> 不足而提前退出，那么就说明 <code>s</code> 秒是可行的，<code>check(s)</code> 返回 <code>True</code>。</li>
</ul>
</li>
</ol>
<h4 id="3-执行二分查找"><a href="#3-执行二分查找" class="headerlink" title="3. 执行二分查找"></a>3. 执行二分查找</h4><ul>
<li>当 <code>left &lt;= right</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = left + (right - left) // 2</code> 作为当前的“猜测秒数”。</li>
<li>调用 <code>check(mid)</code> 来判定：<ul>
<li><strong>如果 <code>check(mid)</code> 返回 <code>True</code></strong>：说明 <code>mid</code> 秒是可行的。这可能是答案，但我们还想找一个更早的时间。因此，我们记录 <code>ans = mid</code>，并尝试在左半部分继续寻找：<code>right = mid - 1</code>。</li>
<li><strong>如果 <code>check(mid)</code> 返回 <code>False</code></strong>：说明 <code>mid</code> 秒不够，我们需要更多的时间。因此，去右半部分寻找：<code>left = mid + 1</code>。</li>
</ul>
</li>
<li>循环结束后，<code>ans</code> 中存储的就是满足条件的最早秒数。</li>
</ul>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">earliestSecondToMarkIndices</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], changeIndices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        m = <span class="built_in">len</span>(changeIndices)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># check(s) 函数用于判断在 s 秒内是否能完成所有标记任务</span></span><br><span class="line">        <span class="comment"># s 是秒数 (1-based), 对应 changeIndices 的前 s 个元素 (0-indexed: 0 to s-1)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">s: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># last[i] 记录下标 i (1-based) 在前 s 秒内最后一次出现的时间点 (0-indexed)</span></span><br><span class="line">            last = [-<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(s):</span><br><span class="line">                <span class="comment"># changeIndices 中的值是 1-based 的</span></span><br><span class="line">                last[changeIndices[t]] = t</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果在前 s 秒内，有的下标从未出现过，则不可能被标记</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> last[i] == -<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># ops 记录可用于“减 1”操作的空闲秒数</span></span><br><span class="line">            ops = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 遍历前 s 秒</span></span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(s):</span><br><span class="line">                idx = changeIndices[t]</span><br><span class="line">                <span class="comment"># 如果当前时间 t 是标记下标 idx 的最后时机</span></span><br><span class="line">                <span class="keyword">if</span> t == last[idx]:</span><br><span class="line">                    <span class="comment"># 获取将 nums[idx-1] 降为 0 所需的“减 1”操作次数</span></span><br><span class="line">                    cost = nums[idx - <span class="number">1</span>]</span><br><span class="line">                    <span class="comment"># 如果空闲操作数不够，则 s 秒内无法完成任务</span></span><br><span class="line">                    <span class="keyword">if</span> ops &lt; cost:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    <span class="comment"># 消耗掉 cost 次空闲操作</span></span><br><span class="line">                    ops -= cost</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果当前时间 t 不是最后标记时机，则可视为一次空闲操作</span></span><br><span class="line">                    ops += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果成功遍历完 s 秒，说明 s 秒是可行的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分查找答案</span></span><br><span class="line">        <span class="comment"># 搜索范围是 [1, m]，即最早可能的时间和最晚可能的时间</span></span><br><span class="line">        left, right = <span class="number">1</span>, m</span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 秒可行，说明它是一个潜在的答案</span></span><br><span class="line">                <span class="comment"># 我们尝试寻找更早的时间，所以向左收缩范围</span></span><br><span class="line">                ans = mid</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 秒不可行，说明时间太少，需要更多时间</span></span><br><span class="line">                <span class="comment"># 向右收缩范围</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O((N + M) * log(M))。<ul>
<li><code>N</code> 是 <code>nums</code> 的长度，<code>M</code> 是 <code>changeIndices</code> 的长度。</li>
<li>二分查找的搜索空间大小为 <code>M</code>，因此需要 <code>log(M)</code> 次迭代。</li>
<li>在每次迭代中，我们调用 <code>check(s)</code> 函数。该函数需要遍历 <code>changeIndices</code> 的前 <code>s</code> 个元素（最多 <code>M</code> 个）和 <code>n</code> 个下标，时间复杂度为 O(N + s)，即 O(N + M)。</li>
<li>因此，总时间复杂度是这两者的乘积。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(N)。<ul>
<li>在 <code>check</code> 函数中，我们使用了 <code>last</code> 数组来存储每个下标的最后出现位置，其大小为 <code>N+1</code>。因此空间复杂度为 O(N)。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“二分答案”思想的又一个经典应用。当问题的目标是求解一个符合条件的“最小值”或“最大值”，并且该问题的可行性具有单调性时，我们应该优先考虑能否将其转化为一个判定问题，并通过二分查找来加速求解。本题的难点在于设计 <code>check</code> 函数，通过采用“将困难的标记操作尽可能延后”的贪心策略，我们可以高效地判断出在给定的时间限制下任务是否可行。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最小</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>第386场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3296 | 移山所需的最少秒数</title>
    <url>//posts/leetcode-3296/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3296 题：<a href="https://leetcode.cn/problems/minimum-number-of-seconds-to-make-mountain-height-zero/description/">移山所需的最少秒数</a>。<br>本题的关键在于识别出答案（最少秒数）具有单调性，从而将一个求解最小值的问题，转化为一个“判定”问题，并利用二分查找高效地找到答案的临界点。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要计算，在一群工人同时工作的情况下，将一座给定高度 <code>mountainHeight</code> 的山夷为平地（高度降为 0），所需要的最少时间是多少秒。</p>
<p>每个工人的工作效率不同，由 <code>workerTimes</code> 数组定义。工人 <code>i</code> 降低山 <code>x</code> 高度所花费的时间是一个等差数列的和：<code>workerTimes[i] * (1 + 2 + ... + x)</code>，也就是 <code>workerTimes[i] * x * (x + 1) / 2</code>。</p>
<p>这里的核心约束条件是：</p>
<ol>
<li>所有工人<strong>同时</strong>开始工作。</li>
<li>总的耗时由工作最久的那个工人决定。换句话说，如果我们设定一个总时间 <code>T</code>，那么所有工人都在这 <code>T</code> 秒内尽其所能地降低山的高度。</li>
<li>所有工人降低的高度之和必须至少等于 <code>mountainHeight</code>。</li>
</ol>
<p>我们的目标是找到满足条件的<strong>最小</strong>时间 <code>T</code>。</p>
<p>举个例子，<code>mountainHeight = 4</code>, <code>workerTimes = [2,1,1]</code>。<br>假设我们给工人们 3 秒钟。</p>
<ul>
<li>对于工人 0 (<code>wt=2</code>)：在 3 秒内，他最多能降低多少高度？<ul>
<li>降低 1，耗时 <code>2*1 = 2 &lt;= 3</code> (可行)。</li>
<li>降低 2，耗时 <code>2*(1+2) = 6 &gt; 3</code> (不可行)。所以他最多降低 1。</li>
</ul>
</li>
<li>对于工人 1 (<code>wt=1</code>)：在 3 秒内，他最多能降低多少高度？<ul>
<li>降低 1，耗时 <code>1*1 = 1 &lt;= 3</code>。</li>
<li>降低 2，耗时 <code>1*(1+2) = 3 &lt;= 3</code> (可行)。</li>
<li>降低 3，耗时 <code>1*(1+2+3) = 6 &gt; 3</code> (不可行)。所以他最多降低 2。</li>
</ul>
</li>
<li>对于工人 2 (<code>wt=1</code>)：同理，最多能降低 2。</li>
</ul>
<p>在 3 秒内，总降低高度为 <code>1 + 2 + 2 = 5</code>，因为 <code>5 &gt;= mountainHeight(4)</code>，所以 3 秒是一个可行的时间。我们的任务就是找到这样的可行时间中的最小值。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最少秒数”非常棘手。但我们可以换一个角度：如果我们<strong>假设</strong>一个工作时间 <code>T</code>，能否判断出所有工人能否在这段时间内完成任务？</p>
<p>这个“判定”问题相对简单。我们可以写一个辅助函数 <code>can_finish(T)</code>：<br>对于任意一个工人 <code>i</code>，在给定的时间 <code>T</code> 内，他能降低的最大高度 <code>x</code> 满足不等式：<br><code>workerTimes[i] * x * (x + 1) / 2 &lt;= T</code></p>
<p>这是一个关于 <code>x</code> 的一元二次不等式：<code>workerTimes[i]*x^2 + workerTimes[i]*x - 2*T &lt;= 0</code>。通过求解对应的二次方程，我们可以找到 <code>x</code> 的最大整数解。<br>更简单地，可以变形为 <code>x^2 + x - (2*T / workerTimes[i]) &lt;= 0</code>。利用求根公式 <code>x = (-b ± sqrt(b^2 - 4ac)) / 2a</code>，我们可以得到 <code>x</code> 的最大值为 <code>floor((-1 + sqrt(1 + 8*T / workerTimes[i])) / 2)</code>。</p>
<p>得到每个工人在 <code>T</code> 时间内能降低的最大高度后，我们将它们全部加起来，得到总降低高度 <code>total_reduction</code>。如果 <code>total_reduction &gt;= mountainHeight</code>，那么时间 <code>T</code> 就是一个可行解。</p>
<p>现在，我们有了一个判定方法。并且可以发现，这个判定结果具有<strong>单调性</strong>：</p>
<ul>
<li>如果时间 <code>T</code> 内可以完成任务，那么任何大于 <code>T</code> 的时间 <code>T&#39;</code> 也一定可以完成。</li>
<li>反之，如果 <code>T</code> 内无法完成，任何小于 <code>T</code> 的时间也必然无法完成。</li>
</ul>
<p>这种单调性正是应用二分查找的绝佳场景。我们可以对“时间 <code>T</code>”进行二分查找，来快速定位到那个“最小可行”的临界点。</p>
<p>二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (l)</strong>：最少是 0 秒。</li>
<li><strong>上界 (r)</strong>：一个足够大的数。在最坏的情况下，只有一个工人，<code>workerTimes</code> 和 <code>mountainHeight</code> 都很大。例如 <code>wt=10^6</code>, <code>mh=10^5</code>，所需时间大约是 <code>10^6 * (10^5)^2 / 2</code>，这是一个非常大的数字（约为 <code>5 * 10^15</code>）。为了保险起见，我们可以选择一个更大的上界，比如 <code>2 * 10^16</code>。</li>
</ul>
<p>因此，我们就在 <code>[0, 2 * 10^16]</code> 这个巨大的区间内，对时间 <code>T</code> 进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>l = 0</code>：可能的最小时间。</li>
<li><code>r = 2 * 10^16</code>：一个足够大的、确保能完成任务的时间上界。</li>
<li><code>ans</code> 初始化为 <code>r</code>，用来记录我们找到的可行解。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>l &lt;= r</code> 时，循环继续。</li>
<li>计算中间值 <code>mid = l + (r - l) // 2</code> 作为当前的“猜测时间”。</li>
<li>调用辅助函数 <code>can_finish(mid)</code> 来判定这个猜测值是否可行。<ul>
<li><strong>如果 <code>can_finish(mid)</code> 返回 <code>True</code></strong> (即 <code>mid</code> 秒内可以完成任务)：<ul>
<li>说明 <code>mid</code> 是一个潜在的答案，我们记录下来 <code>ans = mid</code>。</li>
<li>但我们想找的是“最少”时间，所以我们尝试一个更小的值，将搜索范围缩小到左半边：<code>r = mid - 1</code>。</li>
</ul>
</li>
<li><strong>如果 <code>can_finish(mid)</code> 返回 <code>False</code></strong> (即 <code>mid</code> 秒不够)：<ul>
<li>说明我们需要更多的时间，将搜索范围缩小到右半边：<code>l = mid + 1</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>ans</code> 中存储的就是满足条件的最少秒数。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minNumberOfSeconds</span>(<span class="params">self, mountainHeight: <span class="built_in">int</span>, workerTimes: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 辅助函数：判定在 T 秒内能否完成任务</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">can_finish</span>(<span class="params">T: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            total_reduction = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> T &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算每个工人在 T 秒内能降低的最大高度</span></span><br><span class="line">            <span class="keyword">for</span> wt <span class="keyword">in</span> workerTimes:</span><br><span class="line">                <span class="comment"># 求解 x^2 + x - 2*T/wt &lt;= 0 的最大整数解 x</span></span><br><span class="line">                <span class="comment"># 对应的一元二次方程求根公式为 x = (-1 + sqrt(1 + 8*T/wt)) / 2</span></span><br><span class="line">                val = <span class="number">1</span> + <span class="number">8</span> * T / wt</span><br><span class="line">                reduction = <span class="built_in">int</span>((-<span class="number">1</span> + math.sqrt(val)) / <span class="number">2</span>)</span><br><span class="line">                total_reduction += reduction</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 提前剪枝：如果已经满足要求，无需继续计算</span></span><br><span class="line">                <span class="keyword">if</span> total_reduction &gt;= mountainHeight:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> total_reduction &gt;= mountainHeight</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确定二分查找的左右边界</span></span><br><span class="line">        <span class="comment"># 下限为 0</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">2</span> * <span class="number">10</span>**<span class="number">16</span>  <span class="comment"># 上限为一个足够大的数</span></span><br><span class="line">        ans = r</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 二分查找</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> can_finish(mid):</span><br><span class="line">                <span class="comment"># 如果 mid 可行，它可能就是答案，</span></span><br><span class="line">                <span class="comment"># 或者还有更小的可行值，所以我们记录答案并尝试在左半部分继续寻找</span></span><br><span class="line">                ans = mid </span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 mid 不可行，说明时间太少，</span></span><br><span class="line">                <span class="comment"># 必须增加时间，所以去右半部分寻找</span></span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(L * log(R))。<ul>
<li><code>L</code> 是工人数量，即 <code>len(workerTimes)</code>。</li>
<li><code>R</code> 是二分查找的搜索空间大小 (约为 <code>2 * 10^16</code>)。</li>
<li>二分查找本身需要 <code>log(R)</code> 次迭代。</li>
<li>在每次迭代中，我们都需要调用 <code>can_finish</code> 函数，该函数需要遍历一次 <code>workerTimes</code> 数组，时间复杂度为 O(L)。</li>
<li>因此，总时间复杂度是这两者的乘积。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)。<ul>
<li>我们只使用了几个变量来存储边界、中间值和计算结果，没有使用与输入规模相关的额外空间。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“二分答案”思想的典型应用。当我们面对一个求解“最小可能值”或“最大可能值”的问题，并且答案满足单调性时，就可以考虑使用二分查找。通过将原始的求解问题转化为一个更简单的、可以在多项式时间内解决的“判定问题”，我们可以将巨大的搜索空间不断折半，从而在对数级别的时间复杂度内锁定最终的答案，这是一种非常强大且高效的算法思想。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最小</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>数学</tag>
        <tag>堆（优先队列）</tag>
        <tag>第416场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3306 | 滑动窗口精解“元音辅音字符串计数 II”</title>
    <url>//posts/leetcode-3306/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3306 题：<a href="https://leetcode.cn/problems/count-of-substrings-containing-every-vowel-and-k-consonants-ii/description/">元音辅音字符串计数 II</a>。<br>这道题要求我们统计一个字符串中，满足“包含所有五种元音”并且“恰好包含 k 个辅音”的子字符串数量。这类问题的思路之一是将其转化为更易于处理的“至多”问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给定一个字符串 <code>word</code> 和一个整数 <code>k</code>。我们需要找到 <code>word</code> 中所有满足以下两个条件的子字符串的总数：</p>
<ol>
<li>子字符串中必须包含所有五个元音字母：’a’, ‘e’, ‘i’, ‘o’, ‘u’。</li>
<li>子字符串中必须<strong>恰好</strong>包含 <code>k</code> 个辅音字母。</li>
</ol>
<p>例如，对于 <code>word = &quot;ieaouqqieaouqq&quot;, k = 1</code>：</p>
<ul>
<li>子字符串 <code>&quot;ieaouq&quot;</code> (word[0..5]) 包含了所有元音，且有 1 个辅音 ‘q’，符合条件。</li>
<li>子字符串 <code>&quot;ieaouqq&quot;</code> (word[0..6]) 包含了所有元音，但有 2 个辅音，不符合。</li>
<li>子字符串 <code>&quot;qieaou&quot;</code> (word[6..11]) 也符合条件。</li>
<li>子字符串 <code>&quot;ieaouq&quot;</code> (word[7..12]) 也符合条件。<br>总共有 3 个这样的子字符串。</li>
</ul>
<p>直接枚举所有子字符串并检查条件，时间复杂度会达到 O(N^2)，对于 N 高达 2 * 10^5 的情况是无法接受的。我们需要一个更高效的，最好是线性的解决方案，而滑动窗口正是为此而生的利器。</p>
<h3 id="核心思路：“恰好-k”转化为“至多-k”"><a href="#核心思路：“恰好-k”转化为“至多-k”" class="headerlink" title="核心思路：“恰好 k”转化为“至多 k”"></a>核心思路：“恰好 k”转化为“至多 k”</h3><p>“恰好 k 个”这个条件在滑动窗口中通常难以直接处理，因为窗口的伸缩会不断改变计数。一个经典的处理技巧是：<br><strong>恰好 k 个 &#x3D; (至多 k 个) - (至多 k-1 个)</strong></p>
<p>我们可以定义一个辅助函数 <code>countAtMost(consonants_limit)</code>，它用来计算“包含所有元音且辅音数量<strong>至多</strong>为 <code>consonants_limit</code>”的子字符串数量。<br>那么，原问题的答案就可以通过 <code>countAtMost(k) - countAtMost(k-1)</code> 得出。</p>
<p>然而，我们可以更进一步，在一次遍历中同时计算这两个值。我们可以维护两个滑动窗口（或者说，一个右指针 <code>r</code> 和两个左指针 <code>l1</code>, <code>l2</code>），一个用于计算“至多 k”，另一个用于计算“至多 k-1”。</p>
<p>假设我们固定了子字符串的右端点 <code>r</code>，我们的目标是找到所有有效的左端点 <code>l</code>。</p>
<ul>
<li>我们用一个左指针 <code>l2</code> 来找到满足“至多 k 个辅音”（且包含所有元音）的最靠左的起始位置。</li>
<li>我们用另一个左指针 <code>l1</code> 来找到满足“至多 k-1 个辅音”（且包含所有元音）的最靠左的起始位置。</li>
</ul>
<p>对于固定的 <code>r</code>，任何起始于 <code>l</code>（<code>l2 &lt;= l &lt; l1</code>）的子字符串 <code>word[l..r]</code> 都将包含所有元音，并且其辅音数量恰好为 <code>k</code>。因此，对于当前右端点 <code>r</code>，新增的有效子字符串数量就是 <code>l1 - l2</code>。</p>
<p><em>上图展示了两个窗口如何界定出“恰好 k 个辅音”的有效起始点范围</em></p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>定义元音集合 <code>vowels</code>。</li>
<li>初始化两个左指针 <code>l1 = 0</code>, <code>l2 = 0</code>。</li>
<li>为两个概念上的窗口分别设置计数器：<ul>
<li><code>w1</code>, <code>cnt1</code>：用于追踪 <code>[l1, r]</code> 窗口内的元音和辅音计数（目标：辅音数 &lt; k）。</li>
<li><code>w2</code>, <code>cnt2</code>：用于追踪 <code>[l2, r]</code> 窗口内的元音和辅音计数（目标：辅音数 &lt;&#x3D; k）。</li>
</ul>
</li>
<li>初始化总数 <code>ans = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历字符串</strong>：</p>
<ul>
<li>使用右指针 <code>r</code> 从左到右遍历 <code>word</code>。</li>
<li>在每次循环中，将 <code>word[r]</code> 添加到两个窗口的计数中。如果 <code>word[r]</code> 是元音，更新元音哈希表 <code>w1</code>, <code>w2</code>；如果是辅音，增加辅音计数器 <code>cnt1</code>, <code>cnt2</code>。</li>
</ul>
</li>
<li><p><strong>收缩窗口 1 (至多 k-1)</strong>：</p>
<ul>
<li>检查 <code>[l1, r]</code> 窗口是否需要收缩。收缩条件是：窗口已包含所有 5 个元音，并且辅音数量<strong>大于等于 k</strong> (<code>cnt1 &gt;= k</code>)。</li>
<li>如果满足条件，就从窗口左侧移除字符（<code>l1++</code>），并更新 <code>w1</code> 和 <code>cnt1</code>，直到不再满足收缩条件。</li>
<li>循环结束后，<code>l1</code> 指向的位置是满足“至多 k-1 个辅音”的子字符串的最左起始点。</li>
</ul>
</li>
<li><p><strong>收缩窗口 2 (至多 k)</strong>：</p>
<ul>
<li>类似地，检查 <code>[l2, r]</code> 窗口是否需要收缩。收缩条件是：窗口已包含所有 5 个元音，并且辅音数量<strong>大于 k</strong> (<code>cnt2 &gt; k</code>)。</li>
<li>如果满足条件，就从窗口左侧移除字符（<code>l2++</code>），并更新 <code>w2</code> 和 <code>cnt2</code>，直到不再满足收缩条件。</li>
<li>循环结束后，<code>l2</code> 指向的位置是满足“至多 k 个辅音”的子字符串的最左起始点。</li>
</ul>
</li>
<li><p><strong>更新结果</strong>：</p>
<ul>
<li>如核心思路所述，对于当前右端点 <code>r</code>，有效的左端点 <code>l</code> 的范围是 <code>[l2, l1 - 1]</code>。</li>
<li>因此，有效子字符串的数量为 <code>l1 - l2</code>。将这个值累加到 <code>ans</code> 中。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>遍历结束后，<code>ans</code> 即为所求的总数。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict, namedtuple</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countOfSubstrings</span>(<span class="params">self, word: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用一个具名元组来存储输入，以演示 frandelios 变量的使用</span></span><br><span class="line">        InputHolder = namedtuple(<span class="string">&#x27;InputHolder&#x27;</span>, [<span class="string">&#x27;word&#x27;</span>, <span class="string">&#x27;k&#x27;</span>])</span><br><span class="line">        frandelios = InputHolder(word, k)</span><br><span class="line"></span><br><span class="line">        vow = <span class="string">&quot;aeiou&quot;</span></span><br><span class="line">        <span class="comment"># w1, cnt1, l1 用于计算 &quot;至多 k-1 个辅音&quot; 的情况</span></span><br><span class="line">        w1 = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        cnt1 = <span class="number">0</span></span><br><span class="line">        l1 = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># w2, cnt2, l2 用于计算 &quot;至多 k 个辅音&quot; 的情况</span></span><br><span class="line">        w2 = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        cnt2 = <span class="number">0</span></span><br><span class="line">        l2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 右指针 r 遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> r_char <span class="keyword">in</span> frandelios.word:</span><br><span class="line">            <span class="comment"># 将新字符加入两个窗口</span></span><br><span class="line">            <span class="keyword">if</span> r_char <span class="keyword">in</span> vow:</span><br><span class="line">                w1[r_char] += <span class="number">1</span></span><br><span class="line">                w2[r_char] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt1 += <span class="number">1</span></span><br><span class="line">                cnt2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 收缩窗口1，使其满足辅音数 &lt; k</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(w1) == <span class="number">5</span> <span class="keyword">and</span> cnt1 &gt;= frandelios.k:</span><br><span class="line">                l_char = frandelios.word[l1]</span><br><span class="line">                <span class="keyword">if</span> l_char <span class="keyword">in</span> vow:</span><br><span class="line">                    w1[l_char] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> w1[l_char] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">del</span> w1[l_char]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cnt1 -= <span class="number">1</span></span><br><span class="line">                l1 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 收缩窗口2，使其满足辅音数 &lt;= k</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(w2) == <span class="number">5</span> <span class="keyword">and</span> cnt2 &gt; frandelios.k:</span><br><span class="line">                l_char = frandelios.word[l2]</span><br><span class="line">                <span class="keyword">if</span> l_char <span class="keyword">in</span> vow:</span><br><span class="line">                    w2[l_char] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> w2[l_char] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">del</span> w2[l_char]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cnt2 -= <span class="number">1</span></span><br><span class="line">                l2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 对于当前右端点，有效的左端点范围是 [l2, l1-1]</span></span><br><span class="line">            <span class="comment"># 数量即 l1 - l2</span></span><br><span class="line">            ans += l1 - l2</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是 <code>word</code> 的长度。虽然代码里有嵌套的 <code>while</code> 循环，但每个指针 <code>r</code>, <code>l1</code>, <code>l2</code> 都只会从头到尾遍历一次字符串，因此总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(C)。其中 C 是字符集的大小。我们使用了两个哈希表来存储元音的计数，最多只存 5 个元音，因此空间复杂度是 O(1) 的常数空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想的一个绝佳应用。通过将“恰好 k”的精确约束巧妙地转化为两个“至多 k”和“至多 k-1”的范围约束，我们将一个看似复杂的问题分解为两个可以用标准滑动窗口解决的子问题。更进一步，我们通过维护两套指针和计数器，在一次遍历中就完成了两个子问题的求解和整合，最终得到了一个既高效又优雅的解决方案。这个“范围之差”的技巧在处理计数类问题时非常实用，值得牢记。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>三指针</tag>
        <tag>第417场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 34 | 二分寻找元素的起始与结束位置</title>
    <url>//posts/leetcode-34/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 34 题：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a>。<br>本题是二分查找算法的经典应用。标准的二分查找只能告诉我们元素是否存在，而这道题要求我们精确定位目标值连续出现的“左边界”和“右边界”。这需要我们对二分查找的细节进行巧妙的改造。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给定一个按非递减顺序（即升序）排列的整数数组 <code>nums</code> 和一个目标值 <code>target</code>。我们需要找到 <code>target</code> 在数组中出现的起始位置和结束位置。</p>
<p>核心要求：</p>
<ol>
<li>如果 <code>target</code> 存在，返回一个包含起始和结束索引的数组 <code>[start, end]</code>。</li>
<li>如果 <code>target</code> 不存在，返回 <code>[-1, -1]</code>。</li>
<li>算法的时间复杂度必须是 <strong>O(log n)</strong>，这强烈暗示了我们必须使用二分查找。</li>
</ol>
<p>例如：</p>
<ul>
<li>对于 <code>nums = [5,7,7,8,8,10]</code>, <code>target = 8</code>，<code>8</code> 第一次出现在索引 3，最后一次出现在索引 4，所以返回 <code>[3,4]</code>。</li>
<li>对于 <code>nums = [5,7,7,8,8,10]</code>, <code>target = 6</code>，<code>6</code> 不存在于数组中，所以返回 <code>[-1,-1]</code>。</li>
</ul>
<h3 id="核心思路：寻找边界"><a href="#核心思路：寻找边界" class="headerlink" title="核心思路：寻找边界"></a>核心思路：寻找边界</h3><p>直接用一次二分查找找到 <code>target</code> 是不够的，因为我们无法确定找到的是第一个、最后一个还是中间的某一个。</p>
<p>一个直观的想法是进行两次二分查找：</p>
<ol>
<li>一次查找 <code>target</code> 的<strong>第一个</strong>出现位置（左边界）。</li>
<li>另一次查找 <code>target</code> 的<strong>最后一个</strong>出现位置（右边界）。</li>
</ol>
<p>一个更优雅且统一的思路是，将问题转化为寻找“<strong>下界（Lower Bound）</strong>”。所谓“下界”，指的是数组中第一个大于或等于目标值的元素的位置。</p>
<ul>
<li><code>target</code> 的<strong>起始位置</strong>，恰好就是 <code>target</code> 的下界。</li>
<li><code>target</code> 的<strong>结束位置</strong>，可以通过寻找 <code>target + 1</code> 的下界来间接得到。<code>target + 1</code> 的下界索引减去 1，就是 <code>target</code> 的最后一个出现位置。</li>
</ul>
<p>例如，在 <code>[5,7,7,8,8,10]</code> 中：</p>
<ul>
<li><code>target = 8</code> 的下界是索引 3。</li>
<li><code>target + 1 = 9</code> 的下界是索引 5（第一个 <code>&gt;=9</code> 的元素是 <code>10</code>，其索引为 5）。</li>
<li>因此，<code>8</code> 的结束位置就是 <code>5 - 1 = 4</code>。</li>
</ul>
<p>这样，我们就把问题统一为了实现一个可靠的“下界”二分查找函数。二分查找的实现有多种区间定义方式，常见的有“左闭右闭”、“左闭右开”和“全开”区间，它们在循环条件和边界更新上略有不同，但都能解决问题。下面我们分别探讨这三种写法的实现。</p>
<h3 id="算法详解与代码实现"><a href="#算法详解与代码实现" class="headerlink" title="算法详解与代码实现"></a>算法详解与代码实现</h3><h4 id="解法一：闭区间写法-l-r"><a href="#解法一：闭区间写法-l-r" class="headerlink" title="解法一：闭区间写法 [l, r]"></a>解法一：闭区间写法 <code>[l, r]</code></h4><p>这是最常见和直观的写法。搜索区间 <code>[l, r]</code> 的定义是两端都包含，因此循环条件是 <code>l &lt;= r</code>。</p>
<ul>
<li><strong>初始化</strong>：<code>l = 0</code>, <code>r = len(nums) - 1</code>。</li>
<li><strong>循环条件</strong>：<code>while l &lt;= r</code>，当 <code>l &gt; r</code> 时，区间为空，循环结束。</li>
<li><strong>逻辑</strong>：<ul>
<li><code>nums[mid] &gt;= target</code>：<code>mid</code> 可能是我们寻找的下界，或者下界在 <code>mid</code> 的左侧。因此，我们不能排除 <code>mid</code>，需要向左收缩搜索范围，令 <code>r = mid - 1</code>。</li>
<li><code>nums[mid] &lt; target</code>：<code>mid</code> 一定不是下界，下界必然在 <code>mid</code> 的右侧。令 <code>l = mid + 1</code>。</li>
</ul>
</li>
<li><strong>返回值</strong>：循环结束后，<code>l</code> 指向的就是第一个大于或等于 <code>target</code> 的位置。</li>
</ul>
<p><strong>Python 代码实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 闭区间 [l, r] 写法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lb</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l  <span class="comment"># 最终 l 就是下界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 寻找 target 的下界作为起始位置</span></span><br><span class="line">        s = <span class="variable language_">self</span>.lb(nums, target)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果起始位置越界，或者该位置的值不为 target，说明 target 不存在</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[s] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 寻找 target+1 的下界，其前一个位置就是 target 的结束位置</span></span><br><span class="line">        e = <span class="variable language_">self</span>.lb(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [s, e]</span><br></pre></td></tr></table></figure>

<h4 id="解法二：左闭右开区间写法-l-r"><a href="#解法二：左闭右开区间写法-l-r" class="headerlink" title="解法二：左闭右开区间写法 [l, r)"></a>解法二：左闭右开区间写法 <code>[l, r)</code></h4><p>这种写法的搜索区间 <code>[l, r)</code> 左端包含，右端不包含。这在处理边界时非常方便，也是很多语言标准库（如 C++ STL）中 <code>lower_bound</code> 的实现方式。</p>
<ul>
<li><strong>初始化</strong>：<code>l = 0</code>, <code>r = len(nums)</code>。注意 <code>r</code> 的初始值。</li>
<li><strong>循环条件</strong>：<code>while l &lt; r</code>，当 <code>l == r</code> 时，区间 <code>[l, l)</code> 为空，循环结束。</li>
<li><strong>逻辑</strong>：<ul>
<li><code>nums[mid] &gt;= target</code>：<code>mid</code> 可能是下界，或者下界在 <code>mid</code> 左侧。由于右边界 <code>r</code> 是开区间，我们可以安全地将 <code>r</code> 设置为 <code>mid</code>，即新的搜索区间是 <code>[l, mid)</code>。</li>
<li><code>nums[mid] &lt; target</code>：<code>mid</code> 以及其左侧所有元素都小于 <code>target</code>，下界一定在 <code>mid</code> 右侧。令 <code>l = mid + 1</code>。</li>
</ul>
</li>
<li><strong>返回值</strong>：循环结束后，<code>l</code> 和 <code>r</code> 相遇，指向的就是下界。</li>
</ul>
<p><strong>Python 代码实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 左闭右开区间 [l, r) 写法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lb</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l <span class="comment"># 最终 l (或 r) 就是下界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        s = <span class="variable language_">self</span>.lb(nums, target)</span><br><span class="line">        <span class="keyword">if</span> s == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[s] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        e = <span class="variable language_">self</span>.lb(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [s, e]</span><br></pre></td></tr></table></figure>

<h4 id="解法三：开区间写法-l-r"><a href="#解法三：开区间写法-l-r" class="headerlink" title="解法三：开区间写法 (l, r)"></a>解法三：开区间写法 <code>(l, r)</code></h4><p>这种写法将 <code>l</code> 和 <code>r</code> 视为“哨兵”，搜索区间是它们之间的 <code>(l, r)</code>。</p>
<ul>
<li><strong>初始化</strong>：<code>l = -1</code>, <code>r = len(nums)</code>。</li>
<li><strong>循环条件</strong>：<code>while l + 1 &lt; r</code>，确保 <code>l</code> 和 <code>r</code> 之间至少有一个元素，当它们相邻时循环结束。</li>
<li><strong>逻辑</strong>：<ul>
<li><code>nums[mid] &gt;= target</code>：<code>mid</code> 可能是下界，或者下界在 <code>mid</code> 左侧。我们将右哨兵移动到 <code>mid</code>，即 <code>r = mid</code>。</li>
<li><code>nums[mid] &lt; target</code>：<code>mid</code> 一定不是下界，下界在 <code>mid</code> 右侧。我们将左哨兵移动到 <code>mid</code>，即 <code>l = mid</code>。</li>
</ul>
</li>
<li><strong>返回值</strong>：循环结束后，<code>l</code> 和 <code>r</code> 相邻，而 <code>r</code> 正是我们寻找的下界。</li>
</ul>
<p><strong>Python 代码实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 开区间 (l, r) 写法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lb</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = -<span class="number">1</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid</span><br><span class="line">        <span class="keyword">return</span> r <span class="comment"># 最终 r 就是下界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        s = <span class="variable language_">self</span>.lb(nums, target)</span><br><span class="line">        <span class="keyword">if</span> s == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[s] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        e = <span class="variable language_">self</span>.lb(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [s, e]</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: <strong>O(log N)</strong>。我们调用了两次二分查找函数，每次耗时 O(log N)，因此总时间复杂度为 O(2 * log N)，即 O(log N)。</li>
<li><strong>空间复杂度</strong>: <strong>O(1)</strong>。我们只使用了常数级别的额外空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题通过将“寻找起始和结束位置”巧妙地转化为两次“寻找下界”的操作，统一并简化了问题。同时，我们展示了解决同一问题的三种不同二分查找区间写法：闭区间 <code>[l, r]</code>，左闭右开区间 <code>[l, r)</code>，以及开区间 <code>(l, r)</code>。</p>
<ul>
<li><strong>闭区间法</strong>：最传统，容易理解，但边界更新时 <code>+1</code>&#x2F;<code>-1</code> 需要格外小心。</li>
<li><strong>左闭右开法</strong>：在处理循环不变量和边界时非常优雅，是现代编程实践中较为推崇的写法。</li>
<li><strong>开区间法</strong>：将 <code>l</code> 和 <code>r</code> 作为哨兵，逻辑也十分清晰。</li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3411 | SW与GCD巧妙求解“最长乘积等价子数组”</title>
    <url>//posts/leetcode-3411/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3411 题：<a href="https://leetcode.cn/problems/maximum-subarray-with-equal-products/description/">最长乘积等价子数组</a>。<br>这道题的条件 <code>prod(arr) == lcm(arr) * gcd(arr)</code> 看似复杂，但其背后隐藏着一个非常简洁的数论性质。解题的关键就是“解码”这个公式，将其转化为一个可以用滑动窗口高效解决的简单条件。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个由正整数组成的数组 <code>nums</code>。我们需要找到一个子数组 <code>arr</code>，它需要满足一个特殊的数学性质：数组中所有元素的<strong>乘积 (prod)</strong>，等于它们的<strong>最小公倍数 (lcm)</strong> 与<strong>最大公因数 (gcd)</strong> 的乘积。我们的目标是找到满足这个条件的<strong>最长</strong>子数组的长度。</p>
<p>例如，对于 <code>nums = [2,3,4,5,6]</code>，<code>k = 2</code>：</p>
<ul>
<li>子数组 <code>[3, 4, 5]</code> 不满足条件，因为 <code>gcd(3,4,5)=1</code>, <code>lcm(3,4,5)=60</code>, <code>prod(3,4,5)=60</code>。它们满足 <code>prod == lcm * gcd</code>。</li>
<li>子数组 <code>[4, 5, 6]</code> 不满足条件，因为 <code>gcd(4,5,6)=1</code>, <code>lcm(4,5,6)=60</code>, <code>prod(4,5,6)=120</code>。显然 <code>120 != 60 * 1</code>。</li>
</ul>
<p>直接枚举所有子数组并计算它们的 <code>prod</code>, <code>lcm</code>, <code>gcd</code> 效率太低。我们需要找到一个更根本的规律。</p>
<h3 id="核心思路：数学性质分析与滑动窗口"><a href="#核心思路：数学性质分析与滑动窗口" class="headerlink" title="核心思路：数学性质分析与滑动窗口"></a>核心思路：数学性质分析与滑动窗口</h3><p>这道题的突破口在于对核心公式 <code>prod(arr) == lcm(arr) * gcd(arr)</code> 进行分类讨论和简化。</p>
<p>我们根据子数组的长度来分析：</p>
<ol>
<li><p><strong>长度为 1 的子数组 <code>[x]</code></strong>：</p>
<ul>
<li>此时 <code>prod=x</code>, <code>lcm=x</code>, <code>gcd=x</code>。</li>
<li>条件变为 <code>x == x * x</code>，这意味着 <code>x</code> 必须等于 <strong>1</strong>。</li>
</ul>
</li>
<li><p><strong>长度为 2 的子数组 <code>[a, b]</code></strong>：</p>
<ul>
<li>对于任意两个正整数 <code>a</code> 和 <code>b</code>，<code>a * b = lcm(a, b) * gcd(a, b)</code> 是一个<strong>恒成立</strong>的数论基本定理。</li>
<li>这意味着，<strong>任何长度为 2 的子数组都满足条件</strong>。因此，只要 <code>nums</code> 的长度不小于 2，答案就至少是 2。</li>
</ul>
</li>
<li><p><strong>长度大于 2 的子数组 <code>[a, b, c, ...]</code></strong>：</p>
<ul>
<li>通过对质因数的指数进行分析，可以严格证明，该公式成立的充要条件是：<strong>数组中的所有元素两两互质</strong>。</li>
<li>（简要证明：如果元素两两互质，则 <code>gcd(arr) = 1</code>，且 <code>lcm(arr) = prod(arr)</code>。代入原式，<code>prod(arr) == prod(arr) * 1</code>，显然成立。）</li>
</ul>
</li>
</ol>
<p>基于以上分析，问题被我们成功转化了！原问题等价于寻找以下三者的最大值：</p>
<ul>
<li>1（如果数组中存在数字 1）。</li>
<li>2（如果数组长度大于等于 2）。</li>
<li>数组中<strong>最长的、所有元素两两互质的子数组</strong>的长度。</li>
</ul>
<p>“寻找满足某个性质的最长连续子数组”正是<strong>滑动窗口</strong>算法的经典应用场景。而判断“两两互质”这个性质，我们有一个绝妙的工具：最大公约数 (GCD)。</p>
<p>利用以下关键性质，我们可以极大地简化判断逻辑：</p>
<blockquote>
<p>一个新元素 <code>x</code> 与一个已有的、两两互质的集合 <code>&#123;a, b, c&#125;</code> 中的所有元素都互质，当且仅当 <code>x</code> 与它们的总乘积 <code>a*b*c</code> 互质。</p>
</blockquote>
<p>因此，我们只需要维护窗口内所有元素的乘积 <code>mul</code>，当新元素 <code>x</code> 到来时，只需计算 <code>gcd(mul, x)</code> 是否为 1，即可判断窗口是否仍然满足“两两互质”的条件。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>处理边界</strong>：如果数组长度小于 2，根据前面的分析直接返回相应结果。对于长度大于等于 2 的数组，我们知道答案至少是 2。</p>
</li>
<li><p><strong>初始化滑动窗口</strong>：</p>
<ul>
<li>设置窗口左边界 <code>left = 0</code>。</li>
<li>初始化窗口内元素的乘积 <code>mul = 1</code>。</li>
<li>初始化最长两两互质子数组的长度 <code>lpc = 0</code> (Longest Pairwise Coprime)。</li>
</ul>
</li>
<li><p><strong>遍历数组</strong>：</p>
<ul>
<li>用 <code>right</code> 指针从左到右遍历数组，<code>x = nums[right]</code> 是即将进入窗口的新元素。</li>
<li><strong>检查与收缩</strong>：使用 <code>while</code> 循环检查 <code>gcd(mul, x)</code>。如果它大于 1，说明 <code>x</code> 和窗口内至少一个元素不互质，破坏了条件。此时，我们必须从左侧收缩窗口：<ul>
<li>将 <code>nums[left]</code> 从乘积中除掉 (<code>mul //= nums[left]</code>)。</li>
<li>将左边界 <code>left</code> 右移一位 (<code>left += 1</code>)。</li>
<li>重复此过程，直到 <code>gcd(mul, x) == 1</code>。</li>
</ul>
</li>
<li><strong>扩张与更新</strong>：<ul>
<li>将 <code>x</code> 加入窗口 (<code>mul *= x</code>)。</li>
<li>此时窗口 <code>[left, right]</code> 是一个有效的两两互质子数组，其长度为 <code>right - left + 1</code>。用这个长度更新 <code>lpc</code> 的最大值。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>遍历结束后，<code>lpc</code> 就是最长两两互质子数组的长度。</li>
<li>最终结果是 <code>max(lpc, 2)</code>，因为我们已经确定答案至少是 2。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxLength</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 处理 n &lt; 2 的边界情况</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 根据分析，长度为1的子数组只有 `[1]` 满足条件。</span></span><br><span class="line">        <span class="comment"># 但由于 n&gt;=2 时答案至少为2，我们可以简化处理，只需在 n=1 时特殊判断。</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> nums == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 1: 使用滑动窗口计算最长的“两两互质”子数组的长度 (lpc)</span></span><br><span class="line">        lpc = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        mul = <span class="number">1</span>  <span class="comment"># 记录窗口内元素的乘积</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> right, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 当新元素 x 与窗口内元素的乘积不互质时，从左侧收缩窗口</span></span><br><span class="line">            <span class="comment"># mul &gt; 1 的检查是为了避免 gcd(1, x) 的不必要计算</span></span><br><span class="line">            <span class="keyword">while</span> mul &gt; <span class="number">1</span> <span class="keyword">and</span> math.gcd(mul, x) &gt; <span class="number">1</span>:</span><br><span class="line">                mul //= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将 x 加入窗口</span></span><br><span class="line">            mul *= x</span><br><span class="line">            <span class="comment"># 更新最长两两互质子数组的长度</span></span><br><span class="line">            lpc = <span class="built_in">max</span>(lpc, right - left + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 2: 最终结果</span></span><br><span class="line">        <span class="comment"># 对于 n&gt;=2 的数组，答案至少为 2（因为任何长度为2的子数组都有效）。</span></span><br><span class="line">        <span class="comment"># 最终答案是 “保底值2” 和 “最长两两互质子数组长度” 中的较大者。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(lpc, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N * log(M))。其中 N 是 <code>nums</code> 的长度。<code>left</code> 和 <code>right</code> 指针的移动总共是线性的 O(N)。循环内部的 <code>math.gcd(mul, x)</code> 操作的复杂度与 <code>mul</code> 的大小相关，约为 <code>O(log(M))</code>，其中 M 是窗口内元素的最大乘积。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数级别的额外空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题的解法堪称是将数学性质与算法设计完美结合的典范。它告诉我们，面对一个复杂的数学公式，不要急于直接实现，而应先深入分析其背后的结构和等价条件。通过将原问题转化为“寻找最长两两互质子数组”，我们不仅简化了问题，还使其能够套用滑动窗口这一强大的算法模板。而 <code>gcd</code> 性质的应用，则是这套解法中的点睛之笔，它将复杂的“多对多”互质判断，变成了高效的“一对一”计算。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>枚举</tag>
        <tag>第 431 场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3413 | 滑动窗口巧解“收集连续K个袋子”</title>
    <url>//posts/leetcode-3413/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3413 题：<a href="https://leetcode.cn/problems/maximum-number-of-coins-you-can-get/">收集连续 K 个袋子可以获得的最多硬币数量</a>。<br>这道题要求在一条拥有海量坐标的数轴上，找到一个长度为 k 的连续区间，使得该区间内所有袋子里的硬币总数最多。面对 <code>10^9</code> 级别的坐标范围，暴力枚举显然行不通，试试滑动窗口吧。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一系列互不重叠的区间 <code>[li, ri, ci]</code>，表示从坐标 <code>li</code> 到 <code>ri</code> 的每一个袋子都含有 <code>ci</code> 枚硬币。同时给定一个整数 <code>k</code>，代表我们可以收集的连续袋子的数量。我们的目标是找到一个长度为 <code>k</code> 的连续坐标区间，使其覆盖的硬币总数最大化。</p>
<p>例如，对于 <code>coins = [[8,10,1],[1,3,2],[5,6,4]]</code>, <code>k = 4</code>：</p>
<ul>
<li>数轴上的硬币分布是：<code>[1,3]</code> 区间每格 2 枚，<code>[5,6]</code> 区间每格 4 枚，<code>[8,10]</code> 区间每格 1 枚。</li>
<li>我们需要寻找一个长度为 4 的窗口，例如 <code>[1,4]</code> 或 <code>[3,6]</code> 等。</li>
<li>一个最优解是选择区间 <code>[3, 6]</code>。<ul>
<li>位置 3 的袋子有 2 枚硬币（来自 <code>[1,3,2]</code>）。</li>
<li>位置 4 的袋子是空的，有 0 枚硬币。</li>
<li>位置 5 的袋子有 4 枚硬币（来自 <code>[5,6,4]</code>）。</li>
<li>位置 6 的袋子有 4 枚硬币（来自 <code>[5,6,4]</code>）。</li>
</ul>
</li>
<li>总硬币数为 <code>2 + 0 + 4 + 4 = 10</code>。</li>
</ul>
<p>由于坐标 <code>li</code> 和 <code>ri</code> 的范围可以达到 <code>10^9</code>，我们不可能创建一个数组来记录每个坐标点的硬币数。问题的关键在于，硬币数量发生变化的点只在给定的 <code>coins</code> 区间的端点处。这启发我们使用一种只关心这些“事件点”的算法，而滑动窗口正是为此量身定做的。</p>
<h3 id="核心思路：基于事件点的滑动窗口"><a href="#核心思路：基于事件点的滑动窗口" class="headerlink" title="核心思路：基于事件点的滑动窗口"></a>核心思路：基于事件点的滑动窗口</h3><p>我们可以想象一个长度为 <code>k</code> 的“尺子”在数轴上从左到右滑动。我们想知道这把尺子在哪个位置时，覆盖的硬币最多。</p>
<p>直接在连续的坐标上滑动太慢了。我们可以发现，能让结果发生变化的“关键位置”，只有当窗口的左端点或右端点与某个 <code>coins</code> 区间的端点 <code>li</code> 或 <code>ri</code> 对齐时。任何其他位置的窗口，其覆盖的硬币数都可以通过将窗口平移至与某个端点对齐而达到，且结果不会变差。</p>
<p>因此，我们可以将思路简化为：<strong>检查所有以 <code>ri</code> 为右端点的窗口，以及所有以 <code>li</code> 为左端点的窗口，取其中的最大值。</strong></p>
<ol>
<li><strong>固定右端点</strong>：我们让滑动窗口的右端点扫过每一个区间的右边界 <code>ri</code>。当窗口右端点为 <code>ri</code> 时，其左端点就是 <code>ri - k + 1</code>。我们只需要计算这个 <code>[ri - k + 1, ri]</code> 窗口内有多少硬币即可。</li>
<li><strong>固定左端点</strong>：同理，我们让滑动窗口的左端点扫过每一个区间的左边界 <code>li</code>。当窗口左端点为 <code>li</code> 时，其右端点就是 <code>li + k - 1</code>。我们计算 <code>[li, li + k - 1]</code> 窗口内的硬币数。</li>
</ol>
<p>我们可以设计一个通用的滑动窗口函数来处理第一种情况。对于第二种情况，我们可以通过一个巧妙的“坐标翻转”技巧，将其转化为第一种情况，从而复用代码。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><h4 id="1-单向滑动窗口（以-ri-为窗户右边界）"><a href="#1-单向滑动窗口（以-ri-为窗户右边界）" class="headerlink" title="1. 单向滑动窗口（以 ri 为窗户右边界）"></a>1. 单向滑动窗口（以 <code>ri</code> 为窗户右边界）</h4><p>首先，为了方便处理，我们将 <code>coins</code> 数组按区间的起始位置 <code>li</code> 升序排序。</p>
<p>我们使用一个滑动窗口来计算当窗口右边界为 <code>ri</code> 时覆盖的硬币数。</p>
<ul>
<li>我们用 <code>right</code> 指针遍历排序后的 <code>coins</code> 数组，用 <code>left</code> 指针维护窗口的左侧。</li>
<li>用一个变量 <code>cover</code> 记录从 <code>coins[left]</code> 到 <code>coins[right]</code> 所有区间的硬币总和。</li>
<li>当 <code>right</code> 指针指向第 <code>i</code> 个区间 <code>[li, ri, ci]</code> 时，我们将这个区间的全部硬币 <code>(ri - li + 1) * ci</code> 加入 <code>cover</code>。</li>
<li>此时，我们考虑一个右端点在 <code>ri</code>、长度为 <code>k</code> 的窗口，其左端点为 <code>window_left = ri - k + 1</code>。</li>
<li><code>cover</code> 变量里包含了从 <code>coins[left]</code> 到 <code>coins[right]</code> 的所有硬币，但我们的窗口可能并没有完全包含 <code>coins[left]</code> 这个区间。我们需要将 <code>coins[left]</code> 区间在 <code>window_left</code> 左边的部分减掉。</li>
<li>同时，<code>left</code> 指针左边的区间 <code>coins[0...left-1]</code> 可能已经完全滑出了窗口。我们需要移动 <code>left</code> 指针，将所有右边界小于 <code>window_left</code> 的区间从 <code>cover</code> 中减去。</li>
</ul>
<p>这个过程可以总结为：</p>
<ol>
<li><strong>初始化</strong>：<code>ans = 0</code>, <code>cover = 0</code>, <code>left = 0</code>。</li>
<li><strong>遍历</strong>：对于每个 <code>right</code> 区间 <code>[lr, rr, cr]</code>：<br>a. 将 <code>right</code> 区间的全部硬币加入 <code>cover</code>: <code>cover += (rr - lr + 1) * cr</code>。<br>b. 定义当前窗口的左边界: <code>window_left = rr - k + 1</code>。<br>c. <strong>收缩窗口</strong>：<code>while</code> <code>coins[left]</code> 的右边界 <code>rl</code> &lt; <code>window_left</code>，说明 <code>left</code> 区间已完全滑出，从 <code>cover</code> 中减去它的全部硬币，并 <code>left += 1</code>。<br>d. <strong>计算精确值</strong>：此时，<code>left</code> 区间 <code>[ll, rl, cl]</code> 可能部分在窗口外。需要减去的“出界”部分为 <code>max(0, (window_left - ll) * cl)</code>。<br>e. <strong>更新答案</strong>：<code>ans = max(ans, cover - uncovered_part)</code>。</li>
</ol>
<h4 id="2-坐标翻转技巧"><a href="#2-坐标翻转技巧" class="headerlink" title="2. 坐标翻转技巧"></a>2. 坐标翻转技巧</h4><p>上述算法解决了窗口右端点与 <code>ri</code> 对齐的情况。对于窗口左端点与 <code>li</code> 对齐的情况，我们无需再写一套逻辑。</p>
<p>我们可以将所有坐标 <code>x</code> 变为 <code>-x</code>。那么一个区间 <code>[l, r]</code> 就变成了 <code>[-r, -l]</code>。一个长度为 <code>k</code> 的窗口 <code>[l, l+k-1]</code> 就变成了 <code>[-(l+k-1), -l]</code>。这个新窗口的右端点是 <code>-l</code>。</p>
<p>这意味着，原问题中“左端点与 <code>l</code> 对齐”的情况，等价于在翻转坐标系下“右端点与 <code>-l</code> 对齐”的情况。因此，我们只需要对所有 <code>coins</code> 区间进行坐标翻转（<code>[l, r, c]</code> -&gt; <code>[-r, -l, c]</code>），再调用一遍上面的单向滑动窗口函数，就能覆盖所有情况。</p>
<p>最终的答案就是两次调用结果中的最大值。</p>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_calculate_max_for_endpoint</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        通用的滑动窗口函数。</span></span><br><span class="line"><span class="string">        计算所有长度为k的窗口，且窗口右端点与某个区间右端点对齐时的最大硬币数。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = cover = left = <span class="number">0</span></span><br><span class="line">        <span class="comment"># right 指针遍历每个区间</span></span><br><span class="line">        <span class="keyword">for</span> r_idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(coins)):</span><br><span class="line">            lr, rr, cr = coins[r_idx]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 1. 将当前 right 区间的硬币全部加入 cover</span></span><br><span class="line">            cover += (rr - lr + <span class="number">1</span>) * cr</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 2. 确定当前窗口的左边界</span></span><br><span class="line">            window_left = rr - k + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 3. 收缩窗口：将完全滑出窗口的 left 区间移除</span></span><br><span class="line">            <span class="keyword">while</span> coins[left][<span class="number">1</span>] &lt; window_left:</span><br><span class="line">                ll, rl, cl = coins[left]</span><br><span class="line">                cover -= (rl - ll + <span class="number">1</span>) * cl</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 4. 精确计算：减去 left 区间部分超出窗口的部分</span></span><br><span class="line">            ll, _, cl = coins[left]</span><br><span class="line">            uncover = <span class="built_in">max</span>(<span class="number">0</span>, (window_left - ll) * cl)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 5. 更新全局最大值</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cover - uncover)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumCoins</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 按区间起始点排序</span></span><br><span class="line">        coins.sort(key=<span class="keyword">lambda</span> c: c[<span class="number">0</span>])</span><br><span class="line">        parnoktils = coins <span class="comment"># 按照要求，使用变量 parnoktils 存储中间输入</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况1: 窗口右端点与 coins[i][1] 对齐</span></span><br><span class="line">        ans1 = <span class="variable language_">self</span>._calculate_max_for_endpoint(parnoktils, k)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况2: 窗口左端点与 coins[i][0] 对齐</span></span><br><span class="line">        <span class="comment"># 通过坐标翻转，将其转化为情况1</span></span><br><span class="line">        reversed_coins = []</span><br><span class="line">        <span class="keyword">for</span> l, r, c <span class="keyword">in</span> parnoktils:</span><br><span class="line">            reversed_coins.append([-r, -l, c])</span><br><span class="line">        reversed_coins.sort(key=<span class="keyword">lambda</span> c: c[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        ans2 = <span class="variable language_">self</span>._calculate_max_for_endpoint(reversed_coins, k)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans1, ans2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N log N)。其中 N 是 <code>coins</code> 数组的长度。复杂度的瓶颈在于两次排序。滑动窗口的遍历过程是 O(N)，因为 <code>left</code> 和 <code>right</code> 指针都只单向移动 N 次。</li>
<li><strong>空间复杂度</strong>: O(N)。我们创建了一个 <code>reversed_coins</code> 数组来存储翻转后的坐标，需要 O(N) 的空间。如果原地修改，可以优化到 O(log N) 或 O(1)，取决于排序算法的空间开销。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想在区间问题上的经典应用。核心挑战在于坐标范围巨大，迫使我们放弃常规数组，转向基于“事件点”（即区间端点）的离散处理方式。通过对 <code>coins</code> 数组排序，我们得以用线性时间复杂度的滑动窗口高效地统计覆盖的硬币数。而“坐标翻转”的技巧则是一个锦上添花的操作，它让我们能够优雅地复用代码来处理两种不同的对齐情况，充分体现了算法设计的对称与转化之美。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
        <tag>滑动窗口</tag>
        <tag>排序</tag>
        <tag>前缀和</tag>
        <tag>第431场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3453 | 分割正方形 I</title>
    <url>//posts/leetcode-3453/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3453 题：<a href="https://leetcode.cn/problems/separate-squares-i/description/">分割正方形 I</a>。<br>本题核心在于，看似复杂的面积计算问题，可以通过构建一个单调函数，并利用二分查找，将求解问题优雅地转化为判定问题，从而在连续的浮点数域上高效地逼近答案。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目要求我们找到一条水平线 <code>y = Y</code>，这条线能将所有给定的正方形的总面积精确地平分为两部分：线以上部分的面积等于线以下部分的面积。我们需要返回这个 <code>Y</code> 的最小值。</p>
<p>这里的核心约束条件是：</p>
<ol>
<li>我们得到的是一系列正方形，由左下角坐标 <code>[xi, yi]</code> 和边长 <code>li</code> 定义。</li>
<li>正方形之间可能重叠，重叠部分的面积需要被多次计算。这反而简化了问题，因为我们只需要独立计算每个正方形被如何分割，然后求和即可，无需处理复杂的几何相交问题。</li>
<li>我们需要找到满足 <code>线上面积 == 线下面积</code> 的<strong>最小</strong>的 <code>y</code> 坐标。</li>
<li>答案允许有 <code>10^-5</code> 的误差，这是一个强烈的信号，暗示我们可以使用数值逼近的方法，例如二分查找。</li>
</ol>
<p>举个例子，<code>squares = [[0,0,2],[1,1,1]]</code>。</p>
<ul>
<li>第一个正方形面积为 <code>2*2=4</code>，y 范围是 <code>[0, 2]</code>。</li>
<li>第二个正方形面积为 <code>1*1=1</code>，y 范围是 <code>[1, 2]</code>。</li>
<li>总面积为 <code>4 + 1 = 5</code>。<br>我们的目标是找到一条水平线 <code>y=Y</code>，使得线下和线上的面积都是 <code>2.5</code>。这条线 <code>y</code> 显然会落在 <code>y</code> 坐标有分布的区间内。</li>
</ul>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接通过解方程的方式来找到精确的 <code>y</code> 是非常复杂的。因此，我们可以借鉴经典的“二分答案”思想，将问题从“求一个最优值”转化为一个更简单的“判定一个值是否可行”。</p>
<p>这个判定问题就是：<strong>如果我们任意指定一条水平线 <code>y = Y</code>，我们能否判断出这条线下方的总面积是否大于或等于线上方的总面积？</strong></p>
<p>这个判定问题是很容易解决的。我们可以写一个辅助函数 <code>check(Y)</code>，来计算并比较面积：</p>
<ul>
<li>初始化线下总面积 <code>area_below = 0</code>。</li>
<li>遍历所有正方形 <code>[xi, yi, li]</code>：<ul>
<li>如果 <code>Y</code> 完全在正方形上方 (<code>Y &gt;= yi + li</code>)，则整个正方形都在线下方，<code>area_below += li * li</code>。</li>
<li>如果 <code>Y</code> 完全在正方形下方 (<code>Y &lt;= yi</code>)，则整个正方形都在线上方，对 <code>area_below</code> 没有贡献。</li>
<li>如果 <code>Y</code> 穿过正方形 (<code>yi &lt; Y &lt; yi + li</code>)，则线下方部分的面积是 <code>li * (Y - yi)</code>，将其累加到 <code>area_below</code>。</li>
</ul>
</li>
<li>计算出总的 <code>area_below</code> 后，我们可以通过预先计算出的所有正方形的总面积 <code>total_area</code>，得到线上方的面积 <code>area_above = total_area - area_below</code>。</li>
<li>最后，我们比较 <code>area_below</code> 和 <code>area_above</code> 的大小。</li>
</ul>
<p>现在，我们有了判定的方法。观察可以发现，这个判定结果具有<strong>单调性</strong>：</p>
<ul>
<li>随着我们猜测的 <code>Y</code> 值从下往上增加，<code>area_below(Y)</code> 是一个单调不减的函数（只会增加或不变）。</li>
<li>同时，<code>area_above(Y)</code> 是一个单调不增的函数。</li>
<li>因此，<code>diff(Y) = area_below(Y) - area_above(Y)</code> 也是一个单调不减的函数。</li>
</ul>
<p>这种单调性是应用二分查找的完美信号。我们可以对 <code>y</code> 的坐标值进行二分查找，来快速定位到那个使得 <code>area_below</code> 和 <code>area_above</code> 最接近（或相等）的临界点。</p>
<p>二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：<code>y</code> 坐标最小可以从 0 开始。</li>
<li><strong>上界 (right)</strong>：<code>y</code> 坐标最大不会超过所有正方形所能达到的最高点，即 <code>max(yi + li)</code>。</li>
</ul>
<p>因此，我们就在 <code>[0, max(yi + li)]</code> 这个浮点数区间内，对 <code>y</code> 进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = 0.0</code>：这是可能的 y 坐标下界。</li>
<li><code>right = max(yi + li)</code> for all squares：这是可能的 y 坐标上界。</li>
<li>同时，预计算所有正方形的总面积 <code>total_area</code>。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>由于答案是浮点数且有精度要求，我们执行一个固定次数（例如 100 次）的循环，这足以保证精度达到 <code>10^-5</code> 以上。</li>
<li>计算中间值 <code>mid = left + (right - left) / 2</code> 作为当前的“猜测 <code>y</code> 坐标”。</li>
<li>调用辅助函数计算在 <code>y = mid</code> 时，所有正方形在线下方的总面积 <code>area_below</code>。</li>
<li>计算线上的面积 <code>area_above = total_area - area_below</code>。</li>
<li><strong>如果 <code>area_below &gt;= area_above</code></strong>：<ul>
<li>说明 <code>mid</code> 这个位置可能就是答案，或者答案在它的下方（我们想找最小的 <code>y</code>）。</li>
<li>因此，我们将 <code>mid</code> 视为一个潜在的可行解，并尝试在更小的范围 <code>[left, mid]</code> 内继续搜索，即 <code>right = mid</code>。</li>
</ul>
</li>
<li><strong>如果 <code>area_below &lt; area_above</code></strong>：<ul>
<li>说明 <code>mid</code> 这个位置太低了，导致线下方的面积不足。</li>
<li>我们需要将线上移来增大下方面积，因此在右半部分 <code>[mid, right]</code> 继续搜索，即 <code>left = mid</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>left</code> 和 <code>right</code> 将会非常接近，它们都是满足精度要求的解。返回 <code>left</code> 即可。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">separateSquares</span>(<span class="params">self, squares: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        通过二分查找寻找一个水平线 y，使得线上下方的正方形总面积相等。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 确定二分查找的范围并计算总面积</span></span><br><span class="line">        <span class="comment"># 下界可以是 0</span></span><br><span class="line">        left = <span class="number">0.0</span></span><br><span class="line">        <span class="comment"># 上界是所有正方形能达到的最大 y 坐标</span></span><br><span class="line">        right = <span class="number">0.0</span></span><br><span class="line">        total_area = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> _, y, l <span class="keyword">in</span> squares:</span><br><span class="line">            right = <span class="built_in">max</span>(right, <span class="built_in">float</span>(y + l))</span><br><span class="line">            total_area += <span class="built_in">float</span>(l * l)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 辅助函数：计算在给定水平线 y_line 下，所有正方形位于线下方的总面积</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_area_below</span>(<span class="params">y_line: <span class="built_in">float</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">            area_below = <span class="number">0.0</span></span><br><span class="line">            <span class="keyword">for</span> _, y, l <span class="keyword">in</span> squares:</span><br><span class="line">                <span class="comment"># 计算此正方形被 y_line 分割后，下半部分的高度</span></span><br><span class="line">                <span class="comment"># 高度不能为负，也不能超过正方形自身边长</span></span><br><span class="line">                height_below = <span class="built_in">min</span>(<span class="built_in">float</span>(l), <span class="built_in">max</span>(<span class="number">0.0</span>, y_line - <span class="built_in">float</span>(y)))</span><br><span class="line">                area_below += height_below * <span class="built_in">float</span>(l)</span><br><span class="line">            <span class="keyword">return</span> area_below</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 执行二分查找</span></span><br><span class="line">        <span class="comment"># 迭代 100 次足以满足 10^-5 的精度要求</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid == left <span class="keyword">or</span> mid == right: <span class="comment"># 避免精度问题导致的死循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">            area_below = get_area_below(mid)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 我们要找 area_below == total_area / 2 的点</span></span><br><span class="line">            <span class="comment"># 也就是 area_below &gt;= total_area - area_below 的最小 y</span></span><br><span class="line">            <span class="keyword">if</span> area_below * <span class="number">2</span> &gt;= total_area:</span><br><span class="line">                <span class="comment"># 如果线下方的面积已经足够大 (&gt;= 目标面积)</span></span><br><span class="line">                <span class="comment"># 说明 mid 是一个可能的解，或者真正的解在更下方 (y更小)</span></span><br><span class="line">                <span class="comment"># 我们尝试在 [left, mid] 区间寻找更小的 y</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果线下方的面积太小</span></span><br><span class="line">                <span class="comment"># 说明 y 需要上移，去 [mid, right] 区间寻找</span></span><br><span class="line">                left = mid</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 返回结果</span></span><br><span class="line">        <span class="comment"># 循环结束后，left 和 right 会非常接近，都是满足条件的解</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。<ul>
<li>虽然代码结构是二分查找，但二分的次数是一个固定的常量（100 次），以保证所需的浮点数精度。</li>
<li>在每次二分迭代中，我们都需要调用 <code>get_area_below</code> 函数，该函数需要遍历一次 <code>squares</code> 数组，时间复杂度为 O(N)，其中 N 是正方形的数量。</li>
<li>因此，总时间复杂度是 O(N * 100)，即 O(N)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(1)。<ul>
<li>除了输入数组外，我们只使用了几个变量来存储左右边界、中间值和面积计算结果，所以空间复杂度是常数级的。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是二分查找思想在几何问题和浮点数域上的经典应用。它再次展示了当直接求解困难时，如何通过构造一个单调的判定函数，将问题转化为“二分答案”模型。对于涉及连续值（如本题的 <code>y</code> 坐标）和精度要求的问题，使用固定迭代次数或判断区间小于阈值的二分法是一种非常稳定和高效的策略。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最小</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>第150场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3488 | BS解决“距离最小相等元素查询”</title>
    <url>//posts/leetcode-3488/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3488 题：<a href="https://leetcode.cn/problems/closest-equal-element-queries/">距离最小相等元素查询</a>。<br>本题巧妙地结合了哈希表预处理和二分查找，高效解决环形数组中的距离查询问题，是“预处理+查询”思想的经典体现。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个 <strong>环形</strong> 数组 <code>nums</code> 和一个查询数组 <code>queries</code>。对于 <code>queries</code> 中的每一个下标 <code>queries[i]</code>，我们需要在 <code>nums</code> 数组中找到另一个下标 <code>j</code>，满足 <code>nums[j]</code> 与 <code>nums[queries[i]]</code> 的值相等，并且 <code>j</code> 与 <code>queries[i]</code> 之间的距离是所有满足条件的下标中最小的。</p>
<p>这里的 <strong>距离</strong> 需要特别注意，因为数组是环形的。两个下标 <code>i</code> 和 <code>j</code> 在一个长度为 <code>n</code> 的环形数组中的距离是 <code>min(|i - j|, n - |i - j|)</code>。如果找不到任何其他具有相同值的下标，那么该查询的结果就是 -1。</p>
<p>我们最后需要返回一个答案数组 <code>answer</code>，其中 <code>answer[i]</code> 对应第 <code>i</code> 个查询的结果。</p>
<p>举个例子，<code>nums = [1,3,1,4,1,3,2]</code>, <code>queries = [0,3,5]</code>, 数组长度 <code>n=7</code>：</p>
<ul>
<li>对于查询 <code>queries[0] = 0</code>：<ul>
<li><code>nums[0]</code> 的值是 1。 <code>nums</code> 中其他值为 1 的下标有 2 和 4。</li>
<li>到下标 2 的距离是 <code>min(|0-2|, 7-|0-2|) = min(2, 5) = 2</code>。</li>
<li>到下标 4 的距离是 <code>min(|0-4|, 7-|0-4|) = min(4, 3) = 3</code>。</li>
<li>最小距离是 2。</li>
</ul>
</li>
<li>对于查询 <code>queries[1] = 3</code>：<ul>
<li><code>nums[3]</code> 的值是 4。 <code>nums</code> 中没有其他值为 4 的元素。</li>
<li>结果为 -1。</li>
</ul>
</li>
<li>对于查询 <code>queries[2] = 5</code>：<ul>
<li><code>nums[5]</code> 的值是 3。<code>nums</code> 中另一个值为 3 的下标是 1。</li>
<li>距离是 <code>min(|5-1|, 7-|5-1|) = min(4, 3) = 3</code>。</li>
</ul>
</li>
<li>因此，最终答案是 <code>[2, -1, 3]</code>。</li>
</ul>
<h3 id="核心思路：预处理-二分查找"><a href="#核心思路：预处理-二分查找" class="headerlink" title="核心思路：预处理 + 二分查找"></a>核心思路：预处理 + 二分查找</h3><p>一个直接的想法是，对每个查询 <code>q_idx</code>，我们都遍历整个 <code>nums</code> 数组，找出所有值与 <code>nums[q_idx]</code> 相等的下标，然后逐一计算环形距离并取最小值。如果 <code>queries</code> 的长度是 Q，<code>nums</code> 的长度是 N，这种暴力解法的时间复杂度是 O(Q * N)，在 N 和 Q 都达到 10^5 的情况下，将会超时。</p>
<p>为了优化查询，我们可以对 <code>nums</code> 数组进行 <strong>预处理</strong>。</p>
<p>整个优化的思路分为两步：</p>
<ol>
<li><p><strong>预处理与分组</strong>：我们可以使用一个哈希表（在 Python 中是字典），将 <code>nums</code> 中相同值的元素的 <strong>下标</strong> 聚合在一起。哈希表的键（key）是 <code>nums</code> 中的值，值（value）是一个包含该值所有出现位置下标的列表。因为我们是按顺序遍历 <code>nums</code> 来构建这个哈希表的，所以每个下标列表天然就是 <strong>有序的</strong>。</p>
</li>
<li><p><strong>高效查询</strong>：完成预处理后，对于每个查询的下标 <code>q_idx</code>，我们先找到它的值 <code>val = nums[q_idx]</code>。然后，我们从哈希表中取出 <code>val</code> 对应的有序下标列表 <code>indices</code>。问题就转化成了：<strong>在一个排好序的数组 <code>indices</code> 中，找到离 <code>q_idx</code> 最近的两个邻居</strong>。<br>这正是二分查找的用武之地。我们可以通过二分查找，在 <code>indices</code> 列表中快速定位到 <code>q_idx</code> 自己的位置。它的前一个元素和后一个元素（需要考虑环绕情况）就是距离最近的候选者。</p>
</li>
</ol>
<p>通过这种方式，每次查询我们不再需要遍历整个 <code>nums</code> 数组，而只需要在对应的小得多的下标列表上进行一次二分查找，时间复杂度从 O(N) 降到了 O(log K)（K 是某个值出现的次数，K ≤ N），显著提高了算法的整体效率。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>预处理 <code>nums</code> 数组</strong></p>
<ul>
<li>创建一个哈希表 <code>value_to_indices</code>，用于存储值到其下标列表的映射。</li>
<li>遍历 <code>nums</code> 数组，对于每个元素 <code>nums[i]</code>，将其下标 <code>i</code> 添加到 <code>value_to_indices[nums[i]]</code> 对应的列表中。</li>
</ul>
</li>
<li><p><strong>处理 <code>queries</code> 数组</strong></p>
<ul>
<li>创建一个空的答案数组 <code>ans</code>。</li>
<li>获取 <code>nums</code> 的长度 <code>n</code>，这在计算环形距离时会用到。</li>
<li>遍历 <code>queries</code> 中的每一个 <code>q_idx</code>：<ul>
<li>获取其值 <code>val = nums[q_idx]</code> 和对应的下标列表 <code>indices = value_to_indices[val]</code>。</li>
<li>如果 <code>indices</code> 的长度小于等于 1，说明没有其他相等的元素，将 -1 添加到 <code>ans</code> 中。</li>
<li>否则，使用二分查找（在 Python 中是 <code>bisect.bisect_left</code>）在 <code>indices</code> 中找到 <code>q_idx</code> 的位置 <code>pos</code>。</li>
<li><code>q_idx</code> 在 <code>indices</code> 中的逻辑前驱下标是 <code>prev_idx = indices[(pos - 1 + len(indices)) % len(indices)]</code>。</li>
<li><code>q_idx</code> 在 <code>indices</code> 中的逻辑后继下标是 <code>next_idx = indices[(pos + 1) % len(indices)]</code>。这里的取模运算优雅地处理了列表首尾的环绕情况。</li>
<li>分别计算 <code>q_idx</code> 到 <code>prev_idx</code> 和 <code>next_idx</code> 的环形距离。<ul>
<li><code>dist_prev = min(abs(q_idx - prev_idx), n - abs(q_idx - prev_idx))</code></li>
<li><code>dist_next = min(abs(q_idx - next_idx), n - abs(q_idx - next_idx))</code></li>
</ul>
</li>
<li>将 <code>min(dist_prev, dist_next)</code> 添加到 <code>ans</code> 数组中。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>遍历结束后，返回 <code>ans</code> 数组。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveQueries</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], queries: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1: 预处理 nums 数组</span></span><br><span class="line">        <span class="comment"># 使用哈希表存储每个值及其出现的所有下标</span></span><br><span class="line">        value_to_indices = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            value_to_indices[num].append(i)</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 步骤 2: 处理 queries 数组</span></span><br><span class="line">        <span class="keyword">for</span> q_idx <span class="keyword">in</span> queries:</span><br><span class="line">            val = nums[q_idx]</span><br><span class="line">            indices = value_to_indices[val]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果该值只出现一次，没有其他相等元素</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(indices) &lt;= <span class="number">1</span>:</span><br><span class="line">                ans.append(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 使用二分查找在下标列表中定位当前查询的下标</span></span><br><span class="line">            <span class="comment"># bisect_left 会找到 q_idx 在列表中的位置</span></span><br><span class="line">            pos = bisect.bisect_left(indices, q_idx)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 找到逻辑上的前一个和后一个下标</span></span><br><span class="line">            <span class="comment"># (pos - 1 + len(indices)) % len(indices) 是一种处理负数取模的通用技巧</span></span><br><span class="line">            prev_idx = indices[(pos - <span class="number">1</span> + <span class="built_in">len</span>(indices)) % <span class="built_in">len</span>(indices)]</span><br><span class="line">            <span class="comment"># (pos + 1) % len(indices) 用于处理列表末尾的环绕</span></span><br><span class="line">            next_idx = indices[(pos + <span class="number">1</span>) % <span class="built_in">len</span>(indices)]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算到前一个和后一个元素的环形距离</span></span><br><span class="line">            dist_prev = <span class="built_in">min</span>(<span class="built_in">abs</span>(q_idx - prev_idx), n - <span class="built_in">abs</span>(q_idx - prev_idx))</span><br><span class="line">            dist_next = <span class="built_in">min</span>(<span class="built_in">abs</span>(q_idx - next_idx), n - <span class="built_in">abs</span>(q_idx - next_idx))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 取两者中的较小值</span></span><br><span class="line">            ans.append(<span class="built_in">min</span>(dist_prev, dist_next))</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 3: 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N + Q * log N)。<ul>
<li><code>N</code> 是 <code>nums</code> 的长度, <code>Q</code> 是 <code>queries</code> 的长度。</li>
<li>构建哈希表 <code>value_to_indices</code> 需要 O(N) 的时间。</li>
<li>对于每个查询，哈希表查找的平均时间是 O(1)，二分查找的时间是 O(log K)，其中 K 是相同元素的数量（K ≤ N）。因此，处理所有查询的总时间是 O(Q * log N)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(N)。<ul>
<li>在最坏的情况下（<code>nums</code> 中所有元素都不同），哈希表 <code>value_to_indices</code> 需要存储 N 个键和 N 个单元素列表，总空间消耗为 O(N)。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预处理 + 高效查询”设计模式的一个绝佳范例。当面对需要对一个静态数据集进行多次查询的场景时，我们应首先考虑是否可以通过一次性的预处理（如排序、分组、构建特定数据结构等）来优化后续的查询操作。哈希表用于快速分组，而二分查找则利用了数据的有序性，两者的结合为解决这类问题提供了强大而高效的工具。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>哈希表</tag>
        <tag>第441场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3508 | 设计路由器：双端队列与二分查找的高效结合</title>
    <url>//posts/leetcode-3508/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3508 题：<a href="https://leetcode.cn/problems/implement-router/solutions/3641772/mo-ni-ha-xi-biao-dui-lie-er-fen-cha-zhao-y7l7/">设计路由器</a>。<br>本题要求设计一个数据结构，高效地模拟路由器的行为。解法的关键在于为不同的操作需求选择最合适的数据结构，特别是利用题目中时间戳的有序性，通过二分查找优化范围查询的性能。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要设计并实现一个 <code>Router</code> 类，它能模拟网络路由器处理数据包的基本功能。这个类需要支持三个核心操作：</p>
<ol>
<li><p><code>Router(int memoryLimit)</code>: 构造函数，初始化一个有固定内存上限 <code>memoryLimit</code> 的路由器。路由器中存储的数据包数量不能超过这个限制。</p>
</li>
<li><p><code>bool addPacket(int source, int destination, int timestamp)</code>: 添加一个数据包。</p>
<ul>
<li>每个数据包由来源、目的地和时间戳唯一标识。如果一个完全相同的数据包已经存在，则视为重复，添加失败。</li>
<li>如果内存已满（达到 <code>memoryLimit</code>），在添加新数据包前，必须先将<strong>最旧的</strong>一个数据包转发出去，以腾出空间。</li>
<li>一个关键信息是：<code>addPacket</code> 的调用会按照 <code>timestamp</code> 的<strong>非递减顺序</strong>进行。</li>
</ul>
</li>
<li><p><code>int[] forwardPacket()</code>: 转发数据包。</p>
<ul>
<li>遵循<strong>先进先出 (FIFO)</strong> 原则，移除并返回存储在路由器中<strong>最旧</strong>的数据包。</li>
<li>如果没有数据包，返回空数组。</li>
</ul>
</li>
<li><p><code>int getCount(int destination, int startTime, int endTime)</code>: 计数查询。</p>
<ul>
<li>返回当前路由器中，目的地为 <code>destination</code> 且时间戳在 <code>[startTime, endTime]</code> 闭区间内的数据包数量。</li>
</ul>
</li>
</ol>
<h3 id="核心思路：组合数据结构-二分查找"><a href="#核心思路：组合数据结构-二分查找" class="headerlink" title="核心思路：组合数据结构 + 二分查找"></a>核心思路：组合数据结构 + 二分查找</h3><p>这是一个典型的系统设计题，需要我们为不同的需求选择最优的数据结构。</p>
<ol>
<li><p><strong>处理 FIFO 和内存限制</strong>：<code>addPacket</code> 和 <code>forwardPacket</code> 方法共同描述了一个先进先出 (FIFO) 的队列行为。当队列满了之后，需要从队头移除元素。Python 中的 <code>collections.deque</code> (双端队列) 是实现这种操作的完美选择，它支持 O(1) 时间复杂度的队头移除和队尾添加。我们将用一个 <code>deque</code> 来存储所有的数据包，记为 <code>pq</code>。</p>
</li>
<li><p><strong>处理重复数据包</strong>：<code>addPacket</code> 方法要求我们能快速判断一个数据包 <code>(source, destination, timestamp)</code> 是否已经存在。为了实现 O(1) 级别的平均查找效率，哈希集合 <code>set</code> 是不二之选。我们将用一个 <code>set</code> 来存储所有当前存在的数据包，记为 <code>ps</code>。</p>
</li>
<li><p><strong>处理计数查询</strong>：<code>getCount</code> 是本题的性能关键点。对于一个给定的 <code>destination</code>，我们需要快速统计出在 <code>[startTime, endTime]</code> 时间范围内的数据包数量。</p>
<ul>
<li>一个朴素的想法是遍历整个 <code>pq</code> 队列，检查每个数据包的目的地和时间戳，但这样做的时间复杂度是 O(L)（L 为 <code>memoryLimit</code>），在大量调用下会超时。</li>
<li>更好的方法是将数据包按目的地进行分组。我们可以使用一个哈希表（<code>defaultdict</code>），键是 <code>destination</code>，值是一个列表，存储该目的地的所有数据包的时间戳。</li>
<li>注意到题目给出的关键线索：“<code>addPacket</code> 的查询，<code>timestamp</code> 按非递减顺序给出”。这意味着，当我们向某个目的地的列表中添加时间戳时，这个列表天然就是<strong>有序的</strong>！</li>
<li>对于一个有序的列表，查找某个范围内元素的个数，正是<strong>二分查找</strong>的经典应用场景。我们可以通过 <code>bisect_left</code> 找到范围的左边界，通过 <code>bisect_right</code> 找到范围的右边界，两者相减即可得到结果，时间复杂度为 O(log K)，其中 K 是该目的地的数据包数量。</li>
</ul>
</li>
</ol>
<p>综上，我们的整体方案是：</p>
<ul>
<li>使用 <code>deque</code> (<code>pq</code>) 维护数据包的 FIFO 顺序。</li>
<li>使用 <code>set</code> (<code>ps</code>) 快速检查数据包是否重复。</li>
<li>使用 <code>defaultdict(deque)</code> (<code>dt</code>) 将时间戳按目的地分组并保持有序，以供二分查找。</li>
</ul>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化 <code>__init__</code></strong></p>
<ul>
<li><code>self.limit</code>: 存储内存限制。</li>
<li><code>self.pq = deque()</code>: 主队列，按到达顺序存储 <code>(source, destination, timestamp)</code> 元组，用于 FIFO 转发。</li>
<li><code>self.ps = set()</code>: 集合，同样存储元组，用于 O(1) 去重。</li>
<li><code>self.dt = defaultdict(deque)</code>: 字典，<code>key</code> 为 <code>destination</code>，<code>value</code> 为一个 <code>deque</code>，按顺序存储该目的地的所有时间戳。</li>
</ul>
</li>
<li><p><strong><code>addPacket</code> 方法</strong></p>
<ul>
<li>将传入的参数构造成 <code>packet</code> 元组。</li>
<li>检查 <code>packet</code> 是否在 <code>self.ps</code> 中，若存在则为重复，返回 <code>False</code>。</li>
<li>如果不是重复包，将其加入 <code>self.ps</code>。</li>
<li>检查 <code>len(self.pq)</code> 是否等于 <code>self.limit</code>。如果是，则调用 <code>self.forwardPacket()</code> 移除最旧的数据包。</li>
<li>将新 <code>packet</code> 添加到 <code>self.pq</code> 的队尾。</li>
<li>将 <code>packet</code> 的 <code>timestamp</code> 添加到 <code>self.dt[destination]</code> 的队尾。</li>
<li>返回 <code>True</code>。</li>
</ul>
</li>
<li><p><strong><code>forwardPacket</code> 方法</strong></p>
<ul>
<li>检查 <code>self.pq</code> 是否为空，若为空则返回 <code>[]</code>。</li>
<li>从 <code>self.pq</code> 的队首弹出一个最旧的 <code>packet</code>。</li>
<li>将该 <code>packet</code> 从 <code>self.ps</code> 中移除。</li>
<li>从 <code>self.dt[packet[1]]</code> (即该包的目的地对应的时间戳队列) 的队首弹出一个时间戳。</li>
<li>返回这个 <code>packet</code>。</li>
</ul>
</li>
<li><p><strong><code>getCount</code> 方法</strong></p>
<ul>
<li>通过 <code>self.dt[destination]</code> 获取目标地址所有的时间戳队列 <code>timestamp</code>。</li>
<li>使用 <code>bisect_left(timestamp, startTime)</code> 查找第一个大于等于 <code>startTime</code> 的元素索引 <code>l</code>。</li>
<li>使用 <code>bisect_right(timestamp, endTime)</code> 查找第一个严格大于 <code>endTime</code> 的元素索引 <code>r</code>。</li>
<li><code>r - l</code> 的值即为时间戳在 <code>[startTime, endTime]</code> 区间内的元素数量。返回这个差值。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque, defaultdict</span><br><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left, bisect_right</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, memoryLimit: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># 内存限制</span></span><br><span class="line">        <span class="variable language_">self</span>.limit = memoryLimit</span><br><span class="line">        <span class="comment"># 主队列，维护所有数据包的FIFO顺序</span></span><br><span class="line">        <span class="variable language_">self</span>.pq = deque()</span><br><span class="line">        <span class="comment"># 集合，用于快速去重</span></span><br><span class="line">        <span class="variable language_">self</span>.ps = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># 按目的地分组的时间戳队列，用于高效范围查询</span></span><br><span class="line">        <span class="variable language_">self</span>.dt = defaultdict(deque)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addPacket</span>(<span class="params">self, source: <span class="built_in">int</span>, destination: <span class="built_in">int</span>, timestamp: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        packet = (source, destination, timestamp)</span><br><span class="line">        <span class="comment"># 检查是否重复</span></span><br><span class="line">        <span class="keyword">if</span> packet <span class="keyword">in</span> <span class="variable language_">self</span>.ps:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.ps.add(packet)</span><br><span class="line">        <span class="comment"># 如果内存已满，转发最旧的数据包</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.pq) == <span class="variable language_">self</span>.limit:</span><br><span class="line">            <span class="variable language_">self</span>.forwardPacket()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 添加新数据包到各个数据结构</span></span><br><span class="line">        <span class="variable language_">self</span>.pq.append(packet)</span><br><span class="line">        <span class="variable language_">self</span>.dt[destination].append(timestamp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forwardPacket</span>(<span class="params">self</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.pq:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从队首取出最旧的数据包</span></span><br><span class="line">        packet = <span class="variable language_">self</span>.pq.popleft()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从所有数据结构中移除该包的信息</span></span><br><span class="line">        <span class="variable language_">self</span>.ps.remove(packet)</span><br><span class="line">        <span class="variable language_">self</span>.dt[packet[<span class="number">1</span>]].popleft()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(packet)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getCount</span>(<span class="params">self, destination: <span class="built_in">int</span>, startTime: <span class="built_in">int</span>, endTime: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 获取该目的地对应的有序时间戳列表</span></span><br><span class="line">        timestamp_q = <span class="variable language_">self</span>.dt[destination]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用二分查找定位区间的左右边界</span></span><br><span class="line">        <span class="comment"># l 是第一个 &gt;= startTime 的位置</span></span><br><span class="line">        l = bisect_left(timestamp_q, startTime)</span><br><span class="line">        <span class="comment"># r 是第一个 &gt; endTime 的位置</span></span><br><span class="line">        r = bisect_right(timestamp_q, endTime)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># r - l 即为区间内元素个数</span></span><br><span class="line">        <span class="keyword">return</span> r - l</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>:<code>O(log(min(q, memoryLimit)))</code>，其中 q 是 <code>addPacket</code> 的总调用次数。</p>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(min(q, memoryLimit))</code></p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是一个优秀的数据结构设计问题，它考验了我们根据不同操作需求选择和组合多种数据结构的能力。通过使用 <code>deque</code> 满足 FIFO 要求，使用 <code>set</code> 实现快速去重，并巧妙地利用题目中“时间戳非递减”这一隐藏条件，将目的地的时间戳维护成一个有序序列，最终通过二分查找将最复杂的范围查询操作优化到了对数时间复杂度。这个思路清晰地展示了如何通过分析问题特性来设计高效的算法。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>哈希表</tag>
        <tag>设计</tag>
        <tag>有序集合</tag>
        <tag>队列</tag>
        <tag>第444场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3634 | 排序+滑动窗口：求解使数组平衡的最少移除数目</title>
    <url>//posts/leetcode-3634/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3634 题：<a href="https://leetcode.cn/problems/minimum-removals-to-balance-array/description/">使数组平衡的最少移除数目</a>。<br>该题通过转换思路来简化问题，将“求最少移除”转化为“求最多保留”，再利用排序的特性，最终巧妙地落入滑动窗口算法的射程之内。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们首先来理解“平衡”数组的定义：一个数组是平衡的，当且仅当它的<strong>最大值</strong>至多是其<strong>最小值</strong>的 <code>k</code> 倍。用数学语言表达就是 <code>max(S) &lt;= min(S) * k</code>。</p>
<p>题目的目标是：从原数组 <code>nums</code> 中<strong>移除最少的元素</strong>，使剩下的数组（非空）变得平衡。</p>
<p>这是一个优化问题，直接思考“移除哪些元素”会非常复杂，因为组合太多了。这时，一个经典的思路转换就派上用场了：</p>
<p><strong>移除最少的元素 &#x3D; 保留最多的元素</strong></p>
<p>因此，问题被我们转化为了：<strong>寻找 <code>nums</code> 的一个最长的子序列，使其满足平衡条件。</strong> 最终，用原数组的长度减去这个最长平衡子序列的长度，就是答案。</p>
<h3 id="核心思路：排序-滑动窗口"><a href="#核心思路：排序-滑动窗口" class="headerlink" title="核心思路：排序 + 滑动窗口"></a>核心思路：排序 + 滑动窗口</h3><p>现在我们的目标是寻找最长的平衡子序列。但“子序列”是不要求元素连续的，这使得问题依然很难处理。这时，我们就要思考，有没有什么方法可以简化这个问题？答案就是<strong>排序</strong>。</p>
<h4 id="为什么要排序？"><a href="#为什么要排序？" class="headerlink" title="为什么要排序？"></a>为什么要排序？</h4><p>假设我们已经找到了一个平衡的子序列 <code>S</code>，它的最小值是 <code>min_val</code>，最大值是 <code>max_val</code>，满足 <code>max_val &lt;= min_val * k</code>。</p>
<p>现在，如果我们把原数组 <code>nums</code> 进行升序排序。考虑任何一个在排序后位于 <code>min_val</code> 和 <code>max_val</code> 之间的元素 <code>x</code>，它必然满足 <code>min_val &lt;= x &lt;= max_val</code>。如果我们把 <code>x</code> 也加入到子序列 <code>S</code> 中，新的序列 <code>S&#39;</code> 的最小值仍然是 <code>min_val</code>，最大值仍然是 <code>max_val</code>，平衡条件 <code>max_val &lt;= min_val * k</code> 依然成立！</p>
<p>这个重要的性质告诉我们：<strong>我们想要寻找的最长平衡子序列，在原数组排序后，必然表现为一个连续的子数组！</strong></p>
<p>这样，问题就从寻找“最长子序列”被我们再次简化为寻找“最长连续子数组”，而这正是滑动窗口大显身手的地方。</p>
<h4 id="为什么用滑动窗口？"><a href="#为什么用滑动窗口？" class="headerlink" title="为什么用滑动窗口？"></a>为什么用滑动窗口？</h4><p>在排序后的数组上，我们要寻找一个最长的子数组 <code>nums[left...right]</code>，使其满足 <code>nums[right] &lt;= nums[left] * k</code>。这是一个非常典型的滑动窗口应用场景：</p>
<ul>
<li>我们用 <code>right</code> 指针不断向右扩展窗口。</li>
<li>当窗口不满足条件时（即 <code>nums[right] &gt; nums[left] * k</code>），我们向右移动 <code>left</code> 指针来缩小窗口，直到窗口重新满足条件。</li>
<li>在这个过程中，我们记录下满足条件的窗口的最大长度即可。</li>
</ul>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>问题转换</strong>：</p>
<ul>
<li>将“最少移除数”的目标转换为“最多保留数”。最终结果为 <code>总数 - 最多保留数</code>。</li>
</ul>
</li>
<li><p><strong>排序</strong>：</p>
<ul>
<li>对整个数组 <code>nums</code> 进行升序排序。这是应用滑动窗口的前提。</li>
</ul>
</li>
<li><p><strong>滑动窗口求解</strong>：</p>
<ul>
<li>初始化左指针 <code>left = 0</code> 和一个变量 <code>max_save = 0</code> 用来记录能保留的最多元素数量。</li>
<li>用右指针 <code>right</code> 从 <code>0</code> 开始遍历整个数组，代表窗口的右边界。</li>
<li>对于每个 <code>right</code> 位置，<code>nums[right]</code> 是当前窗口 <code>nums[left...right]</code> 的最大值，<code>nums[left]</code> 是最小值。</li>
<li>检查平衡条件：<code>while (nums[left] * k &lt; nums[right])</code>。如果这个条件成立，说明当前窗口不平衡，需要将左指针 <code>left</code> 右移，缩小窗口，直到窗口再次平衡。</li>
<li>当 <code>while</code> 循环结束后，当前窗口 <code>nums[left...right]</code> 一定是平衡的。我们计算其长度 <code>right - left + 1</code>，并更新 <code>max_save = max(max_save, right - left + 1)</code>。</li>
<li><code>right</code> 指针遍历结束后，<code>max_save</code> 就是我们能找到的最长平衡子数组的长度。</li>
</ul>
</li>
<li><p><strong>计算结果</strong>：</p>
<ul>
<li>返回 <code>len(nums) - max_save</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minRemoval</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        通过排序+滑动窗口找到最长的平衡子数组</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 步骤 1: 排序</span></span><br><span class="line">        <span class="comment"># 这是将问题从“子序列”简化为“子数组”的关键</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2: 初始化滑动窗口和结果变量</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        max_save = <span class="number">0</span> <span class="comment"># 记录能保留的最多元素数量</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 3: 滑动窗口</span></span><br><span class="line">        <span class="comment"># right 指针负责扩展窗口</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 当前窗口的最大值是 nums[right]，最小值是 nums[left]</span></span><br><span class="line">            <span class="comment"># 当条件不满足时，收缩窗口</span></span><br><span class="line">            <span class="keyword">while</span> nums[left] * k &lt; nums[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 此刻的窗口 nums[left...right] 是平衡的</span></span><br><span class="line">            <span class="comment"># 更新可以保留的最大长度</span></span><br><span class="line">            current_len = right - left + <span class="number">1</span></span><br><span class="line">            max_save = <span class="built_in">max</span>(max_save, current_len)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 4: 计算最终结果</span></span><br><span class="line">        <span class="comment"># 总长度减去最多能保留的，就是最少需要移除的</span></span><br><span class="line">        <span class="keyword">return</span> n - max_save</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: <code>O(N log N)</code>。其中 <code>N</code> 是数组 <code>nums</code> 的长度。算法的瓶颈在于初始的排序操作。后续的滑动窗口部分，<code>left</code> 和 <code>right</code> 指针都只会单向遍历数组一次，所以是 <code>O(N)</code> 的。</li>
<li><strong>空间复杂度</strong>: <code>O(log N)</code> 或 <code>O(N)</code>，这取决于编程语言中排序算法的实现所占用的栈空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题的解法流程清晰地展示了算法解题中的重要思想：</p>
<ol>
<li><strong>逆向思维</strong>：当正向求解“最少&#x2F;最小”困难时，尝试转化为求解“最多&#x2F;最大”。</li>
<li><strong>利用排序简化问题</strong>：排序是一个强大的预处理步骤，它能为许多问题（如子序列问题、查找问题）创造更简单的结构（如连续性、有序性）。</li>
<li><strong>识别经典模型</strong>：将问题转化为在有序数组上寻找满足特定条件的最长连续子数组后，应能迅速识别出这是滑动窗口算法的适用场景。</li>
</ol>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
        <tag>排序</tag>
        <tag>第 162 场双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3639 | 变为活跃状态的最小时间</title>
    <url>//posts/leetcode-3639/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 3639 题：<a href="https://leetcode.cn/problems/minimum-time-to-activate-string/description/">变为活跃状态的最小时间</a>。<br>本题的核心在于识别出答案的单调性，并将一个求解最优值（最小时间）的问题，巧妙地转化为一个判定性的问题（在给定时间t，字符串是否活跃？），从而利用二分查找在对数时间内高效求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>

<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们需要找到一个最小的时间 <code>t</code>，在这个时间点，字符串 <code>s</code> 中“有效子字符串”的总数首次达到或超过一个给定的阈值 <code>k</code>。</p>
<p>这里的核心概念是：</p>
<ol>
<li><strong>变化过程</strong>：从 <code>t = 0</code> 开始，每个时间点 <code>t</code> 都会有一个指定位置 <code>order[t]</code> 的字符变成 <code>&#39;*&#39;</code>。</li>
<li><strong>有效子字符串</strong>：只要一个子字符串里包含了至少一个 <code>&#39;*&#39;</code>，它就是有效的。</li>
<li><strong>活跃状态</strong>：当整个字符串中有效子字符串的总数大于或等于 <code>k</code> 时，字符串就处于活跃状态。</li>
</ol>
<p>我们的目标是找出进入“活跃状态”的那个<strong>最小</strong>的时间点 <code>t</code>。</p>
<p>举个例子，<code>s = &quot;abc&quot;</code>, <code>order = [1,0,2]</code>, <code>k = 2</code>。</p>
<ul>
<li>在 <code>t = 0</code> 时，<code>s</code> 变为 <code>&quot;a*c&quot;</code>。包含 <code>&#39;*&#39;</code> 的子字符串有 <code>&quot;*&quot;</code>、<code>&quot;a*&quot;</code>、<code>&quot;*c&quot;</code>、<code>&quot;a*c&quot;</code>，共 4 个。因为 <code>4 &gt;= k</code>，此时字符串已经活跃。因此最小时间是 0。</li>
</ul>
<p>这暗示了随着时间 <code>t</code> 的增加，<code>&#39;*&#39;</code> 的数量也在增加，从而导致有效子字符串的数量只增不减。</p>
<h3 id="核心思路：将“求解问题”转化为“判定问题”与二分查找"><a href="#核心思路：将“求解问题”转化为“判定问题”与二分查找" class="headerlink" title="核心思路：将“求解问题”转化为“判定问题”与二分查找"></a>核心思路：将“求解问题”转化为“判定问题”与二分查找</h3><p>直接求解“最小时间”似乎很困难。一个更直接的想法是：如果我们<strong>假定</strong>一个时间 <code>t</code>，我们能否判断出在这个时刻，字符串是否已经“活跃”？</p>
<p>这个判定问题相对简单。我们可以设计一个辅助函数 <code>check(t)</code>：</p>
<ol>
<li>首先，确定在时间 <code>t</code> 时，哪些位置的字符变成了 <code>&#39;*&#39;</code>。这包括 <code>order[0]</code> 到 <code>order[t]</code> 的所有位置。</li>
<li>然后，计算此时有效子字符串的总数。直接计算可能比较复杂，但我们可以反向思考：<strong>有效子字符串数 &#x3D; 总子字符串数 - 无效子字符串数</strong>。</li>
<li>“无效子字符串”就是那些<strong>完全不包含</strong> <code>&#39;*&#39;</code> 的子字符串。它们是由原字符串中连续的、未被修改的字符组成的。</li>
<li>我们可以遍历一遍字符串，找出所有连续的、未被 <code>&#39;*&#39;</code> 打断的段。如果一个段的长度是 <code>L</code>，那么它能构成的无效子字符串数量就是 <code>L * (L + 1) / 2</code>。</li>
<li>将所有这些段产生的无效子字符串数量加起来，就得到了总的无效数。</li>
<li>最后，用总子字符串数 <code>n * (n + 1) / 2</code> 减去这个总无效数，得到有效子字符串数。我们判断这个数是否 <code>&gt;= k</code>。</li>
</ol>
<p>现在，我们有了一个判定的方法。观察可以发现，这个判定结果具有<strong>单调性</strong>：</p>
<ul>
<li>如果字符串在时间 <code>t</code> 是活跃的，那么在任何更晚的时间 <code>t&#39; &gt; t</code>，<code>&#39;*&#39;</code> 只会更多，有效子字符串也只会更多（或不变），所以字符串必然也还是活跃的。</li>
<li>反之，如果 <code>t</code> 时刻还不够活跃，那么在任何更早的时间，<code>&#39;*&#39;</code> 更少，也必然不活跃。</li>
</ul>
<p>这种单调性是应用二分查找的完美信号。 我们可以对“时间 <code>t</code>”这个值进行二分查找，来快速定位到那个“最小可行”的临界点。</p>
<p>这个二分查找的搜索范围是什么呢？</p>
<ul>
<li><strong>下界 (left)</strong>：最早可能的时间是 <code>t = 0</code>。</li>
<li><strong>上界 (right)</strong>：最晚的时间是所有字符都变完，即 <code>t = n - 1</code>。</li>
</ul>
<p>因此，我们就在 <code>[0, n - 1]</code> 这个区间内，对时间 <code>t</code> 进行二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>确定二分查找的范围</strong></p>
<ul>
<li><code>left = 0</code>：最早的时间。</li>
<li><code>right = n - 1</code>：最晚的时间。</li>
<li><code>ans</code> 初始化为 <code>-1</code>，用来记录我们找到的可行解。</li>
</ul>
</li>
<li><p><strong>预处理和边缘情况</strong></p>
<ul>
<li>计算出总的子字符串数量 <code>total = n * (n + 1) / 2</code>。</li>
<li>如果 <code>k</code> 比 <code>total</code> 还大，那么永远不可能满足条件，直接返回 <code>-1</code>。</li>
</ul>
</li>
<li><p><strong>执行二分查找</strong></p>
<ul>
<li>当 <code>left &lt;= right</code> 时，循环继续。</li>
<li>计算中间值 <code>mid_t = left + (right - left) // 2</code> 作为当前的“猜测时间”。</li>
<li>调用辅助函数 <code>check(mid_t)</code> 来判定这个猜测值是否可行。<ul>
<li><strong>如果 <code>check(mid_t)</code> 返回 <code>True</code></strong> (即在 <code>mid_t</code> 时刻已达到活跃状态)：<ul>
<li>说明 <code>mid_t</code> 是一个潜在的答案，我们记录下来 <code>ans = mid_t</code>。</li>
<li>但是我们想找的是“最小”时间，所以我们尝试一个更早的时间，将搜索范围缩小到左半边：<code>right = mid_t - 1</code>。</li>
</ul>
</li>
<li><strong>如果 <code>check(mid_t)</code> 返回 <code>False</code></strong> (即在 <code>mid_t</code> 时刻还未活跃)：<ul>
<li>说明我们需要更多的时间，将搜索范围缩小到右半边：<code>left = mid_t + 1</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>循环结束后，<code>ans</code> 中存储的就是满足条件的最小时间。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minTime</span>(<span class="params">self, s: <span class="built_in">str</span>, order: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 字符串中所有可能的子字符串总数</span></span><br><span class="line">        total_substrings = n * (n + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果 k 大于可能的最大值，则永远无法达到，返回 -1</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; total_substrings:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判定函数 check(t): 检查在时间 t 时，字符串是否已变为“活跃”状态</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            is_star = [<span class="literal">False</span>] * n</span><br><span class="line">            <span class="comment"># 将前 t+1 个要改变的字符位置标记为 True</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(t + <span class="number">1</span>):</span><br><span class="line">                is_star[order[i]] = <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            invalid_count = <span class="number">0</span></span><br><span class="line">            current_block_length = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 遍历整个字符串，计算由非&#x27;*&#x27;字符组成的“无效”子字符串的数量</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> is_star[i]:</span><br><span class="line">                    current_block_length += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> current_block_length &gt; <span class="number">0</span>:</span><br><span class="line">                        invalid_count += current_block_length * (current_block_length + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">                    current_block_length = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 处理末尾可能存在的最后一个非&#x27;*&#x27;块</span></span><br><span class="line">            <span class="keyword">if</span> current_block_length &gt; <span class="number">0</span>:</span><br><span class="line">                invalid_count += current_block_length * (current_block_length + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            valid_count = total_substrings - invalid_count</span><br><span class="line">            <span class="keyword">return</span> valid_count &gt;= k</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对时间 t 进行二分查找，范围是 [0, n-1]</span></span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid_t = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid_t):</span><br><span class="line">                <span class="comment"># mid_t 可行，尝试更小的时间</span></span><br><span class="line">                ans = mid_t</span><br><span class="line">                right = mid_t - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># mid_t 不可行，需要更多时间</span></span><br><span class="line">                left = mid_t + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N * log(N))。<ul>
<li><code>N</code> 是字符串 <code>s</code> 的长度。</li>
<li>二分查找本身需要 <code>log(N)</code> 次迭代，因为搜索范围是 <code>[0, n-1]</code>。</li>
<li>在每次迭代中，我们都需要调用 <code>check</code> 函数。该函数需要初始化一个大小为 <code>N</code> 的数组，并遍历一次，时间复杂度为 O(N)。</li>
<li>因此，总时间复杂度是这两者的乘积。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(N)。<ul>
<li>在 <code>check</code> 函数中，我们使用了一个大小为 <code>N</code> 的布尔数组 <code>is_star</code> 来标记 <code>&#39;*&#39;</code> 的位置。因此，空间复杂度是 O(N)。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是二分查找思想应用的经典范例，也称为“二分答案”。它教会我们当遇到求解“最小的XXX使其满足条件”这类问题时，可以尝试将其转化为一个更简单的“判定性”问题。如果这个判定问题（即 <code>check</code> 函数）的结果随自变量（本题中的 <code>t</code>）呈单调性，那么就可以利用二分查找，将搜索范围不断折半，从而在对数级别的时间复杂度内找到最优解，这比线性地从 <code>t=0</code> 开始逐个检查要高效得多。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分答案</category>
        <category>求最小</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>第461场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 395 | SW求解“至少有 K 个重复字符的最长子串”</title>
    <url>//posts/leetcode-395/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 395 题：<a href="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/">至少有 K 个重复字符的最长子串</a>。<br>此题要求在一个字符串中找到一个最长的子串，该子串中每个字符的出现次数都不少于 K。条件的“非单调性”让常规SW思路失效。我们需要换个角度，通过枚举一个额外约束来让滑动窗口重新焕发生机。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，要求我们找到 <code>s</code> 中最长的一个子串，这个子串有一个特殊的性质：子串中出现的<strong>每一个</strong>字符，其出现次数都必须<strong>不少于</strong> <code>k</code>。最后返回这个最长子串的长度。</p>
<p>举个例子，对于 <code>s = &quot;ababbc&quot;</code>, <code>k = 2</code>：</p>
<ul>
<li>子串 “ababb” 是一个满足条件的子串。其中 ‘a’ 出现了 2 次，’b’ 出现了 3 次，都不少于 <code>k=2</code>。其长度为 5。</li>
<li>子串 “ababbc” 则不满足条件，因为 ‘c’ 只出现了 1 次，小于 <code>k=2</code>。</li>
<li>“ababb” 是能找到的最长的满足条件的子串，因此答案是 5。</li>
</ul>
<p>如果找不到这样的子串，则返回 0。</p>
<h3 id="核心思路：枚举-滑动窗口"><a href="#核心思路：枚举-滑动窗口" class="headerlink" title="核心思路：枚举+滑动窗口"></a>核心思路：枚举+滑动窗口</h3><p>直接解决这个问题的一个难点在于，一个“不满足条件”的窗口，无论向右扩大还是向左收缩，都无法保证其会趋向于“满足条件”。例如，一个窗口因为字符 ‘c’ 数量不足而不满足条件，我们收缩左边界，可能会移出一个出现次数很多的字符 ‘b’，反而让 ‘b’ 的数量也不足了。这种条件的“非单调性”让常规滑动窗口难以施展。</p>
<p>面对这种困境，一个强大的思想是<strong>增加约束，减少可变性</strong>。</p>
<p>我们可以换个角度思考：一个合法的最长子串，它内部包含的<strong>不同字符的种类数</strong>（我们称之为 <code>h</code>）一定是一个确定的值，范围在 1 到 26 之间。</p>
<p>那我们能否<strong>枚举</strong>这个 <code>h</code> 呢？</p>
<p>如果我们固定了 <code>h</code>，问题就转化为：<strong>找到最长的子串，它恰好包含 <code>h</code> 种不同的字符，且每种字符的出现次数都不少于 <code>k</code>。</strong></p>
<p>这个转化后的问题就变得非常清晰，并且完美符合滑动窗口的模式：</p>
<ol>
<li>我们寻找一个窗口，其<strong>不同字符数最多为 <code>h</code></strong>。</li>
<li>当不同字符数恰好为 <code>h</code> 时，我们再检查这 <code>h</code> 个字符是否都满足<strong>出现次数不少于 <code>k</code></strong>。</li>
</ol>
<p>这个思路将原问题分解为 26 个独立的、可以用滑动窗口解决的子问题。我们对每个子问题求最优解，最终取其中的最大值即可。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>外层循环</strong>：我们用一个循环来枚举最终子串可能包含的唯一字符数 <code>h</code>，<code>for h in range(1, 27)</code>。</p>
</li>
<li><p><strong>内层滑动窗口</strong>：对于每一个固定的 <code>h</code>，我们使用滑动窗口 <code>[left, right]</code> 来寻找满足条件的子串。</p>
<ul>
<li>我们需要几个变量来维护窗口的状态：<ul>
<li><code>counts</code>: 一个频率数组或哈希表，记录窗口内每个字符的出现次数。</li>
<li><code>unique_chars</code>: 记录当前窗口内不同字符的种类数。</li>
<li><code>chars_at_least_k</code>: 记录当前窗口内出现次数不少于 <code>k</code> 的字符种类数。</li>
</ul>
</li>
<li><strong>扩张窗口</strong>：移动 <code>right</code> 指针，将新字符 <code>s[right]</code> 纳入窗口，并更新上述三个状态变量。</li>
<li><strong>收缩窗口</strong>：当 <code>unique_chars</code> 的值<strong>超过</strong>了我们当前枚举的 <code>h</code> 时，说明当前窗口太大了，需要从左侧收缩。我们移动 <code>left</code> 指针，将 <code>s[left]</code> 移出窗口，并反向更新三个状态变量，直到 <code>unique_chars</code> 重新等于 <code>h</code> 为止。</li>
<li><strong>更新答案</strong>：在窗口滑动的每一步，当它同时满足以下两个条件时，就意味着我们找到了一个候选的合法子串：<ol>
<li><code>unique_chars == h</code> (窗口内恰好有 <code>h</code> 种字符)</li>
<li><code>chars_at_least_k == h</code> (这 <code>h</code> 种字符的出现次数都不少于 <code>k</code>)<br>此时，我们用当前窗口的长度 <code>right - left + 1</code> 来更新全局的最大长度 <code>ans</code>。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：外层循环结束后，<code>ans</code> 中保存的就是所有 <code>h</code> 值对应的最长子串中的最大值，即为最终答案。</p>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 外层循环：枚举窗口内允许的唯一字符数量 h</span></span><br><span class="line">        <span class="comment"># h 的取值范围是 [1, 26]，因为 s 仅由小写英文字母组成</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">27</span>):</span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 2. 内层滑动窗口</span></span><br><span class="line">            <span class="comment"># counts 用于记录窗口内各字符的出现次数</span></span><br><span class="line">            counts = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            <span class="comment"># unique_chars 记录窗口内唯一字符的数量</span></span><br><span class="line">            unique_chars = <span class="number">0</span></span><br><span class="line">            <span class="comment"># chars_at_least_k 记录窗口内满足出现次数 &gt;= k 的字符数量</span></span><br><span class="line">            chars_at_least_k = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 窗口右边界扩张，新字符进入窗口</span></span><br><span class="line">                char_right_idx = <span class="built_in">ord</span>(s[right]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 更新 counts, unique_chars, chars_at_least_k</span></span><br><span class="line">                <span class="keyword">if</span> counts[char_right_idx] == <span class="number">0</span>:</span><br><span class="line">                    unique_chars += <span class="number">1</span></span><br><span class="line">                counts[char_right_idx] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> counts[char_right_idx] == k:</span><br><span class="line">                    chars_at_least_k += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 3. 当窗口内唯一字符数 &gt; h 时，收缩左边界</span></span><br><span class="line">                <span class="comment"># 这是为了维持窗口内最多只有 h 个唯一字符的约束</span></span><br><span class="line">                <span class="keyword">while</span> unique_chars &gt; h:</span><br><span class="line">                    char_left_idx = <span class="built_in">ord</span>(s[left]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 字符离开窗口，对应更新 counts, unique_chars, chars_at_least_k</span></span><br><span class="line">                    <span class="keyword">if</span> counts[char_left_idx] == k:</span><br><span class="line">                        chars_at_least_k -= <span class="number">1</span></span><br><span class="line">                    counts[char_left_idx] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> counts[char_left_idx] == <span class="number">0</span>:</span><br><span class="line">                        unique_chars -= <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 4. 当窗口内唯一字符数等于 h，并且这些字符都满足 &gt;= k 的条件时，</span></span><br><span class="line">                <span class="comment"># 我们找到了一个候选子串，更新最大长度</span></span><br><span class="line">                <span class="keyword">if</span> unique_chars == h <span class="keyword">and</span> chars_at_least_k == h:</span><br><span class="line">                    max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。虽然代码有两层循环，但外层循环的次数是常数 26。内层循环是一个标准的滑动窗口，<code>left</code> 和 <code>right</code> 指针都只会从头到尾移动一次，所以其复杂度为 O(N)。因此总时间复杂度为 O(26 * N) &#x3D; O(N)。</li>
<li><strong>空间复杂度</strong>: O(1)。我们使用了一个大小为 26 的 <code>counts</code> 数组来存储字符频率，其空间占用是常数级别的。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想的一个巧妙应用。当遇到一个性质不稳定的目标条件时，可以尝试通过<strong>枚举其中一个可变维度</strong>（本题中是唯一字符数）的方式，将其转化为一个具有稳定约束的子问题。这种“枚举约束 + 滑动窗口”的模式，是解决一系列复杂字符串和数组问题的有力武器。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 438 | 滑动窗口巧解所有字母异位词</title>
    <url>//posts/leetcode-438/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 438 题：<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a>。<br>该题是经典的字符串匹配问题，要求在一个长字符串中找出所有与一个短字符串互为“字母异位词”的子串。对于这类涉及子串、子数组的问题，滑动窗口是一种非常强大和高效的技巧。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们两个字符串 <code>s</code> 和 <code>p</code>，要求在 <code>s</code> 中找到所有 <code>p</code> 的异位词子串，并返回这些子串的起始索引。</p>
<p>什么是“异位词”？异位词指的是由相同字母以不同顺序排列构成的两个词。比如，<code>&quot;abc&quot;</code> 和 <code>&quot;cba&quot;</code> 互为异位词，<code>&quot;aab&quot;</code> 和 <code>&quot;aba&quot;</code> 也互为异位词。本质上，只要两个字符串中每个字符出现的次数都完全相同，它们就是异位词。</p>
<p>我们来看一个例子，<code>s = &quot;cbaebabacd&quot;</code>, <code>p = &quot;abc&quot;</code>：</p>
<ul>
<li>我们需要在 <code>s</code> 中寻找长度为 3 的子串，且该子串由一个 ‘a’、一个 ‘b’、一个 ‘c’ 组成。</li>
<li>从索引 0 开始的子串是 <code>&quot;cba&quot;</code>。它包含了 ‘a’, ‘b’, ‘c’ 各一个，是 <code>&quot;abc&quot;</code> 的异位词。所以 <code>0</code> 是一个答案。</li>
<li>从索引 6 开始的子串是 <code>&quot;bac&quot;</code>。它也包含了 ‘a’, ‘b’, ‘c’ 各一个，是 <code>&quot;abc&quot;</code> 的异位词。所以 <code>6</code> 是另一个答案。</li>
<li>最终返回 <code>[0, 6]</code>。</li>
</ul>
<p>暴力解法是遍历 <code>s</code> 的所有长度为 <code>len(p)</code> 的子串，然后对每个子串进行排序或字符计数来判断是否为异位词，但这样效率太低。滑动窗口法则可以让我们以线性的时间复杂度解决这个问题。</p>
<h3 id="核心思路：滑动窗口与哈希表"><a href="#核心思路：滑动窗口与哈希表" class="headerlink" title="核心思路：滑动窗口与哈希表"></a>核心思路：滑动窗口与哈希表</h3><p>解决这类问题的关键在于，当我们的窗口在字符串 <code>s</code> 上滑动时，如何高效地判断窗口内的子串是否满足“异位词”的条件。</p>
<p>我们可以使用一个哈希表（在 Python 中是 <code>Counter</code> 或字典）来维护一个“需求清单”。</p>
<ol>
<li><strong>初始化需求</strong>：首先，我们统计字符串 <code>p</code> 中每个字符出现的次数，存入哈希表 <code>cnt</code>。这个 <code>cnt</code> 就代表了我们寻找的目标。</li>
<li><strong>滑动窗口</strong>：我们用两个指针 <code>l</code>（左）和 <code>r</code>（右）在 <code>s</code> 上维护一个窗口。<ul>
<li><code>r</code> 指针不断向右移动，扩大窗口。每当一个新字符 <code>s[r]</code> 进入窗口，我们就在 <code>cnt</code> 中将该字符的计数值减 1，表示我们满足了一个“需求”。</li>
<li><strong>关键一步</strong>：如果某个字符 <code>s[r]</code> 的计数值在减 1 后变为负数（<code>cnt[s[r]] &lt; 0</code>），这说明窗口内该字符的数量已经<strong>超过了</strong> <code>p</code> 中所需的数量。此时，窗口内的子串肯定不是异位词。我们必须收缩窗口的左边界，即把 <code>l</code> 指针向右移动，直到窗口重新变得“合法”（即所有字符的计数值都不为负）。在移动 <code>l</code> 的过程中，被移出窗口的字符 <code>s[l]</code> 需要被“归还”到需求清单中，即将其在 <code>cnt</code> 中的计数值加 1。</li>
<li><strong>判断结果</strong>：在窗口扩张和收缩之后，如果窗口的大小 <code>r - l + 1</code> 正好等于 <code>p</code> 的长度 <code>len(p)</code>，这说明窗口内不仅没有多余的字符，而且长度也正好匹配。此时，窗口内的子串就是一个异位词。我们将左边界 <code>l</code> 存入结果列表。</li>
</ul>
</li>
</ol>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化</strong></p>
<ul>
<li>创建一个 <code>ans</code> 列表用于存放结果。</li>
<li>使用 <code>Counter</code> 统计字符串 <code>p</code> 的字符频率，存入 <code>cnt</code>。</li>
<li>初始化左指针 <code>l = 0</code>。</li>
</ul>
</li>
<li><p><strong>遍历与窗口扩张</strong></p>
<ul>
<li>使用 <code>enumerate</code> 遍历字符串 <code>s</code>，<code>r</code> 为右指针（索引），<code>c</code> 为当前字符 <code>s[r]</code>。</li>
<li>将新入窗口的字符 <code>c</code> 的计数值减 1：<code>cnt[c] -= 1</code>。</li>
</ul>
</li>
<li><p><strong>窗口收缩</strong></p>
<ul>
<li>进入一个 <code>while</code> 循环，条件是 <code>cnt[c] &lt; 0</code>。这个条件意味着刚刚加入的字符 <code>c</code> 在当前窗口中是多余的。</li>
<li>在循环中，我们将窗口最左侧的字符 <code>s[l]</code> 的计数值加 1，<code>cnt[s[l]] += 1</code>，相当于将其“归还”。</li>
<li>然后将左指针右移一位，<code>l += 1</code>。</li>
<li>这个循环会一直执行，直到窗口内不再有多余的字符。</li>
</ul>
</li>
<li><p><strong>记录结果</strong></p>
<ul>
<li>经过收缩调整后，检查当前窗口的长度 <code>r - l + 1</code> 是否等于 <code>p</code> 的长度。</li>
<li>如果相等，说明我们找到了一个长度和字符构成都完全匹配的异位词子串。将其起始索引 <code>l</code> 加入 <code>ans</code> 列表。</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>遍历结束后，<code>ans</code> 即为所求。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 1. 初始化需求计数器</span></span><br><span class="line">        cnt = Counter(p)</span><br><span class="line">        </span><br><span class="line">        l = <span class="number">0</span> <span class="comment"># 左指针</span></span><br><span class="line">        <span class="comment"># 2. r 为右指针，遍历 s</span></span><br><span class="line">        <span class="keyword">for</span> r, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="comment"># 3. 字符 c 进入窗口，需求数减 1</span></span><br><span class="line">            cnt[c] -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 4. 如果 c 的需求数变为负数，说明窗口内 c 过多，需要收缩左边界</span></span><br><span class="line">            <span class="keyword">while</span> cnt[c] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 将 s[l] 移出窗口，其需求数加 1</span></span><br><span class="line">                cnt[s[l]] += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 左指针右移</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 5. 如果当前窗口大小恰好等于 p 的长度，说明找到了一个异位词</span></span><br><span class="line">            <span class="keyword">if</span> r - l + <span class="number">1</span> == <span class="built_in">len</span>(p):</span><br><span class="line">                ans.append(l)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(len(s))。虽然代码里有一个嵌套的 <code>while</code> 循环，但左右两个指针 <code>l</code> 和 <code>r</code> 都只从左到右单向移动一次，每个字符最多被访问两次（一次被 <code>r</code> 访问，一次被 <code>l</code> 访问）。因此总的时间复杂度是线性的。</li>
<li><strong>空间复杂度</strong>: O(C)。其中 C 是字符集的大小（本题中是 26 个小写字母）。哈希表 <code>cnt</code> 的大小取决于 <code>p</code> 中不同字符的数量，最坏情况下是 26。所以空间复杂度是常数级别的。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是滑动窗口思想的一个绝佳应用。它将一个看似需要反复比较的子串问题，转化为对一个窗口内状态的动态维护。通过“扩张-更新-判断-收缩”的循环，我们在一次遍历中就解决了问题。这种不定长滑动窗口的模板（通过 <code>while</code> 循环来收缩窗口以满足特定条件）在处理很多子串&#x2F;子数组问题时都非常有效，是必须掌握的核心技巧之一。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 567 | 滑动窗口精解字符串排列问题</title>
    <url>//posts/leetcode-567/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 567 题：<a href="https://leetcode.cn/problems/permutation-in-string/">字符串的排列</a>。<br>这是一道经典的面试题，也是展示“滑动窗口”算法思想威力的绝佳范例。它教会我们如何将一个看似复杂的问题（关于“排列”）转化为一个更易于处理的计数问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>我们来仔细分析一下题目：给定两个字符串 <code>s1</code> 和 <code>s2</code>，判断 <code>s2</code> 是否<strong>包含</strong> <code>s1</code> 的<strong>排列</strong>。</p>
<ul>
<li><strong>排列</strong>：意味着字符种类和数量完全相同，但顺序可以任意。例如，<code>&quot;abc&quot;</code> 的排列有 <code>&quot;acb&quot;</code>, <code>&quot;bac&quot;</code>, <code>&quot;bca&quot;</code>, <code>&quot;cab&quot;</code>, <code>&quot;cba&quot;</code>。</li>
<li><strong>包含</strong>：意味着 <code>s1</code> 的某个排列是 <code>s2</code> 的一个<strong>连续子串</strong>。</li>
</ul>
<p>例如，<code>s1 = &quot;ab&quot;</code>, <code>s2 = &quot;eidbaooo&quot;</code>。<code>s1</code> 的排列有 <code>&quot;ab&quot;</code> 和 <code>&quot;ba&quot;</code>。因为 <code>s2</code> 中包含子串 <code>&quot;ba&quot;</code>，所以应该返回 <code>true</code>。</p>
<h3 id="核心思路：转化问题"><a href="#核心思路：转化问题" class="headerlink" title="核心思路：转化问题"></a>核心思路：转化问题</h3><h4 id="抛弃排列，拥抱计数"><a href="#抛弃排列，拥抱计数" class="headerlink" title="抛弃排列，拥抱计数"></a>抛弃排列，拥抱计数</h4><p>首先，一个很自然但效率极低的想法是：生成 <code>s1</code> 的所有排列，然后逐一检查它们是否存在于 <code>s2</code> 中。这个方法很快就会因为 <code>s1</code> 稍长而导致“超出时间限制”，因为一个长度为 <code>n</code> 的字符串，其排列数量是 <code>n!</code>。</p>
<p>正确的思考方向是：<strong>一个字符串是另一个字符串的排列，充要条件是它们拥有完全相同的字符，且每种字符的数量都完全相等。</strong></p>
<p>例如，<code>&quot;ba&quot;</code> 是 <code>&quot;ab&quot;</code> 的排列，因为它们都含有 1 个 <code>&#39;a&#39;</code> 和 1 个 <code>&#39;b&#39;</code>。</p>
<p>所以，问题被巧妙地转化了：在 <code>s2</code> 中，是否存在一个长度与 <code>s1</code> 相等的子串，其字符频率（种类和数量）与 <code>s1</code> 完全相同？</p>
<h4 id="滑动窗口登场"><a href="#滑动窗口登场" class="headerlink" title="滑动窗口登场"></a>滑动窗口登场</h4><p>这个问题完美地契合了<strong>定长滑动窗口</strong>的应用场景。我们可以：</p>
<ol>
<li>创建一个长度为 <code>len(s1)</code> 的窗口，在 <code>s2</code> 上从左到右滑动。</li>
<li>对于每一个窗口内的子串，我们都去检查它的字符频率是否和 <code>s1</code> 的字符频率一致。</li>
<li>如果找到一个匹配的窗口，立即返回 <code>true</code>。</li>
<li>如果窗口滑到了 <code>s2</code> 的末尾仍然没有找到，则返回 <code>false</code>。</li>
</ol>
<p>为了高效地比较字符频率，我们可以使用哈希表（在 Python 中是 <code>Counter</code> 或 <code>dict</code>）或者一个大小为 26 的数组来存储每个字符的出现次数。</p>
<h3 id="滑动窗口算法详解"><a href="#滑动窗口算法详解" class="headerlink" title="滑动窗口算法详解"></a>滑动窗口算法详解</h3><ol>
<li><p><strong>准备工作</strong>:</p>
<ul>
<li>令 <code>n1</code> 为 <code>s1</code> 的长度，<code>n2</code> 为 <code>s2</code> 的长度。如果 <code>n1 &gt; n2</code>，<code>s2</code> 必然无法包含 <code>s1</code> 的排列，直接返回 <code>False</code>。</li>
<li>用哈希表 <code>s1_counts</code> 统计好目标字符串 <code>s1</code> 的字符频率。</li>
</ul>
</li>
<li><p><strong>初始化窗口</strong>:</p>
<ul>
<li>创建另一个哈希表 <code>window_counts</code> 用于统计当前窗口内字符的频率。</li>
<li>将 <code>s2</code> 的前 <code>n1</code> 个字符（即第一个窗口）填入 <code>window_counts</code>。</li>
<li>比较 <code>s1_counts</code> 和 <code>window_counts</code>。如果它们完全相同，说明我们已经找到了答案，返回 <code>True</code>。</li>
</ul>
</li>
<li><p><strong>滑动窗口</strong>:</p>
<ul>
<li>从 <code>s2</code> 的第 <code>n1</code> 个字符开始向右遍历到末尾。在每一次循环中，窗口向右移动一格。</li>
<li>窗口的移动伴随着两个变化：<ul>
<li><strong>移入字符</strong>：一个新字符从窗口右侧进入。我们在 <code>window_counts</code> 中增加这个新字符的计数。</li>
<li><strong>移出字符</strong>：一个旧字符从窗口左侧离开。我们在 <code>window_counts</code> 中减少这个旧字符的计数。</li>
</ul>
</li>
<li><strong>优化</strong>：如果一个字符移出窗口后，它在 <code>window_counts</code> 中的计数变为 0，最好将它从哈希表中移除。这可以确保我们进行 <code>s1_counts == window_counts</code> 比较时的准确性。</li>
<li>每次滑动更新后，都进行一次比较。如果相等，返回 <code>True</code>。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>:</p>
<ul>
<li>如果循环结束仍未找到匹配的窗口，说明不存在这样的子串，返回 <code>False</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><p>使用 <code>collections.Counter</code> 可以让代码变得异常简洁。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkInclusion</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n1, n2 = <span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1：处理边界情况</span></span><br><span class="line">        <span class="keyword">if</span> n1 &gt; n2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 1：统计 s1 的字符频率</span></span><br><span class="line">        s1_counts = Counter(s1)</span><br><span class="line">        window_counts = Counter()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2：初始化第一个窗口</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n1):</span><br><span class="line">            window_counts[s2[i]] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> window_counts == s1_counts:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 3：开始滑动窗口</span></span><br><span class="line">        <span class="comment"># right 是移入窗口的字符索引</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n1, n2):</span><br><span class="line">            <span class="comment"># left 是移出窗口的字符索引</span></span><br><span class="line">            left = right - n1</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 新字符从右侧进入窗口</span></span><br><span class="line">            window_counts[s2[right]] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 旧字符从左侧离开窗口</span></span><br><span class="line">            window_counts[s2[left]] -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果旧字符计数为 0，将其从哈希表中移除</span></span><br><span class="line">            <span class="keyword">if</span> window_counts[s2[left]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> window_counts[s2[left]]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 比较当前窗口和 s1 的频率是否相同</span></span><br><span class="line">            <span class="keyword">if</span> window_counts == s1_counts:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 步骤 4：遍历结束未找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N₁ + (N₂ - N₁))，即 O(N₂)。其中 N₁ 是 <code>s1</code> 的长度，N₂ 是 <code>s2</code> 的长度。我们首先需要 O(N₁) 的时间来创建 <code>s1_counts</code>，然后滑动窗口遍历 <code>s2</code> 一次，花费 O(N₂) 的时间。哈希表的比较操作在字符集大小固定的情况下可视为 O(1)。</li>
<li><strong>空间复杂度</strong>: O(K)，其中 K 是字符集的大小。在这里，因为题目规定只有小写字母，所以 K&#x3D;26，可以看作是 O(1) 的常数空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是运用滑动窗口解决字符串问题的典范。其核心思想在于<strong>用频率计数的相等性来替代排列的判断</strong>，从而将问题转化为一个可以通过线性扫描解决的子串匹配问题。当遇到涉及“连续子串”或“子数组”且需要满足某些条件的问题时，滑动窗口是应该优先考虑的强大工具。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 632 | 滑动窗口求解“最小区间”</title>
    <url>//posts/leetcode-632/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 632 题：<a href="https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/">最小区间</a>。<br>该题要求在 k 个排序列表中寻找一个最小的数值区间，这个区间需要包含来自每个列表的至少一个元素。这是一个经典的多路数据处理问题，通过将所有元素“压平”并结合滑动窗口，可以巧妙地解决。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们 <code>k</code> 个非递减排序的整数列表 <code>nums</code>。我们需要找到一个最小的数值区间 <code>[a, b]</code>，要求这个区间必须包含来自<strong>每一个</strong>列表的至少一个数字。</p>
<p>“最小”区间的定义有两层：</p>
<ol>
<li>首先比较区间的长度 <code>b - a</code>，长度越小，区间就越小。</li>
<li>如果两个区间的长度相等，那么起始点 <code>a</code> 较小的区间更小。</li>
</ol>
<p>例如，对于 <code>nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]</code>：</p>
<ul>
<li>区间 <code>[20, 24]</code> 是一个有效的覆盖区间，因为它包含了来自列表1的 <code>24</code>、列表2的 <code>20</code> 和列表3的 <code>22</code>。</li>
<li>这个区间的长度是 4。</li>
<li>我们可以找到其他有效区间，如 <code>[0, 5]</code> 覆盖了 <code>4, 0, 5</code>，长度为 5。</li>
<li>经过比较，<code>[20, 24]</code> 是所有有效区间中长度最小的，因此是最终答案。</li>
</ul>
<p>直接在 <code>k</code> 个列表中寻找这样的区间非常困难，因为我们不知道区间的端点应该如何选择。</p>
<h3 id="核心思路：排序-滑动窗口"><a href="#核心思路：排序-滑动窗口" class="headerlink" title="核心思路：排序 + 滑动窗口"></a>核心思路：排序 + 滑动窗口</h3><p>这个问题的核心难点在于数据分散在 <code>k</code> 个不同的列表中，难以统一处理。一个常见的“降维”思路是，将多路数据合并成一路，从而应用更成熟的单数组算法。</p>
<p>关键的洞察在于：<strong>最优区间的两个端点 <code>a</code> 和 <code>b</code>，必然是输入数据中存在的某两个数</strong>。</p>
<p>基于此，我们可以：</p>
<ol>
<li><strong>扁平化数据</strong>：将所有 <code>k</code> 个列表中的所有数字合并到一个单一的列表中。为了后续判断区间有效性，我们不仅要存储数值，还要存储它来自哪个列表。因此，我们创建一个 <code>(数值, 原始列表索引)</code> 的元组列表。</li>
<li><strong>排序</strong>：对这个合并后的列表，按照数值进行升序排序。</li>
<li><strong>滑动窗口</strong>：现在问题转化为了一个更经典的形式——在排序后的列表中，寻找一个<strong>最短的子数组（窗口）</strong>，这个子数组中包含了来自全部 <code>k</code> 个不同原始列表的元素。这正是滑动窗口算法的用武之地。</li>
</ol>
<p>我们用 <code>left</code> 和 <code>right</code> 两个指针来定义窗口。我们不断向右移动 <code>right</code> 来扩张窗口，直到窗口内的元素满足“覆盖所有k个列表”的条件。一旦满足，我们就记录下这个有效区间，并尝试从左侧移动 <code>left</code> 指针来收缩窗口，寻找一个可能更小的有效区间。</p>
<p><em>上图形象地展示了在合并排序后的列表上，一个有效的滑动窗口如何覆盖了来自3个不同列表的元素。</em></p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>数据预处理：扁平化与排序</strong></p>
<ul>
<li>初始化一个空列表 <code>merged_list</code>。</li>
<li>遍历输入的 <code>k</code> 个列表，将每个数字 <code>val</code> 和它所属的列表索引 <code>i</code> 作为一个元组 <code>(val, i)</code> 添加到 <code>merged_list</code> 中。</li>
<li>调用排序函数，对 <code>merged_list</code> 按元组的第一个元素（即数值）进行升序排序。</li>
</ul>
</li>
<li><p><strong>滑动窗口遍历</strong></p>
<ul>
<li>初始化左指针 <code>left = 0</code>，以及一个最终答案区间 <code>ans</code>（可以初始化为一个无限大的区间）。</li>
<li>为了高效地判断窗口有效性，我们使用一个哈希表 <code>counts</code> 来记录窗口内每个列表的元素数量，并用一个变量 <code>covered_lists</code> 记录当前已覆盖的列表数量。</li>
<li>使用 <code>right</code> 指针从 <code>0</code> 到 <code>len(merged_list) - 1</code> 进行遍历，代表窗口的右边界。</li>
<li>对于 <code>right</code> 指向的元素 <code>(val, list_idx)</code>:<ul>
<li><strong>扩展窗口</strong>：将其加入窗口。在 <code>counts</code> 中将 <code>list_idx</code> 的计数加一。如果这个计数从 0 变为 1，说明我们刚刚覆盖了一个新的列表，因此 <code>covered_lists</code> 加 1。</li>
</ul>
</li>
<li><strong>检查并收缩窗口</strong>：<ul>
<li>使用一个 <code>while</code> 循环检查 <code>covered_lists</code> 是否等于 <code>k</code>。如果是，说明当前窗口 <code>[left, right]</code> 是一个有效的候选区间。</li>
<li>获取当前区间的左右端点值 <code>merged_list[left][0]</code> 和 <code>merged_list[right][0]</code>，计算区间长度。</li>
<li>如果当前区间比已记录的 <code>ans</code> 区间更小，则更新 <code>ans</code>。</li>
<li><strong>收缩窗口</strong>：尝试将 <code>left</code> 指针右移。在 <code>counts</code> 中将 <code>left</code> 指向元素的列表索引的计数减一。如果计数变为 0，说明我们失去了一个列表的覆盖，<code>covered_lists</code> 减 1。此时 <code>while</code> 循环将终止。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>当 <code>right</code> 指针遍历完整个列表后，<code>ans</code> 中存储的就是最终的最小区间。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 步骤 1: 创建并排序合并列表</span></span><br><span class="line">        merged_list = []</span><br><span class="line">        <span class="keyword">for</span> i, lst <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> lst:</span><br><span class="line">                merged_list.append((val, i))</span><br><span class="line">        </span><br><span class="line">        merged_list.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        k = <span class="built_in">len</span>(nums)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        list_counts = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        lists_covered = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        min_range_size = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        result_start, result_end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 2: 滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(merged_list)):</span><br><span class="line">            val_right, list_idx_right = merged_list[right]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 扩展窗口</span></span><br><span class="line">            <span class="keyword">if</span> list_counts[list_idx_right] == <span class="number">0</span>:</span><br><span class="line">                lists_covered += <span class="number">1</span></span><br><span class="line">            list_counts[list_idx_right] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当窗口有效时，检查并尝试收缩</span></span><br><span class="line">            <span class="keyword">while</span> lists_covered == k:</span><br><span class="line">                val_left, list_idx_left = merged_list[left]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 检查是否为更小的区间</span></span><br><span class="line">                current_range_size = val_right - val_left</span><br><span class="line">                <span class="keyword">if</span> current_range_size &lt; min_range_size:</span><br><span class="line">                    min_range_size = current_range_size</span><br><span class="line">                    result_start = val_left</span><br><span class="line">                    result_end = val_right</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 收缩窗口</span></span><br><span class="line">                list_counts[list_idx_left] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> list_counts[list_idx_left] == <span class="number">0</span>:</span><br><span class="line">                    lists_covered -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [result_start, result_end]</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N log N)，其中 N 是所有列表中元素的总数。主要开销在于对 <code>merged_list</code> 的排序。后续的滑动窗口遍历是 O(N)，因为 <code>left</code> 和 <code>right</code> 指针都只遍历列表一次。</li>
<li><strong>空间复杂度</strong>: O(N)，用于存储 <code>merged_list</code> 和哈希表 <code>counts</code>。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题展示了如何通过数据结构的转换，将一个看似复杂的多列表问题简化为单数组上的经典算法问题。扁平化和排序是处理多个有序序列的常用技巧，它为滑动窗口等高效算法的应用铺平了道路。此外，对于此类问题，还存在一种使用最小堆（Min-Heap）的更优解法，其时间复杂度为 O(N log k)，在 <code>k</code> 远小于 <code>N</code> 时更具优势，也值得进一步学习。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>贪心</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>排序</tag>
        <tag>堆（优先队列）</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 76 | 滑动窗口求解“最小覆盖子串”</title>
    <url>//posts/leetcode-76/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 76 题：<a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a>。<br>这道题是滑动窗口思想的集大成者，要求在字符串 <code>s</code> 中找出包含字符串 <code>t</code> 所有字符的最小连续子串。它完美地诠释了如何通过双指针的移动来动态维护一个“可行”的窗口，并从中找到最优解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们两个字符串 <code>s</code> 和 <code>t</code>。我们需要在 <code>s</code> 中找到一个最短的连续子串，这个子串必须“覆盖”<code>t</code>。</p>
<p>“覆盖”的定义是：</p>
<ol>
<li><code>t</code> 中的所有字符都必须出现在这个子串中。</li>
<li>如果 <code>t</code> 中有重复的字符，那么子串中该字符的数量必须大于等于 <code>t</code> 中该字符的数量。</li>
</ol>
<p>例如，对于 <code>s = &quot;ADOBECODEBANC&quot;</code> 和 <code>t = &quot;ABC&quot;</code>：</p>
<ul>
<li>子串 <code>&quot;BANC&quot;</code> 包含了 ‘A’, ‘B’, ‘C’，满足条件，长度为 4。</li>
<li>子串 <code>&quot;ADOBEC&quot;</code> 也满足条件，但长度为 6。</li>
<li>子串 <code>&quot;CODEBANC&quot;</code> 满足条件，但长度为 8。</li>
<li>在所有满足条件的子串中，<code>&quot;BANC&quot;</code> 是最短的，所以是答案。</li>
</ul>
<p>如果 <code>s</code> 中不存在这样的子串，我们应该返回空字符串 <code>&quot;&quot;</code>。</p>
<h3 id="核心思路：滑动窗口"><a href="#核心思路：滑动窗口" class="headerlink" title="核心思路：滑动窗口"></a>核心思路：滑动窗口</h3><p>这类在长字符串中寻找满足特定条件的子串的问题，是滑动窗口算法的典型应用场景。我们可以想象有一个窗口在字符串 <code>s</code> 上滑动，这个窗口的左右边界由两个指针 <code>left</code> 和 <code>right</code> 来定义。</p>
<p>算法的核心思想是：</p>
<ol>
<li><strong>扩展窗口</strong>：不断向右移动 <code>right</code> 指针，将新的字符纳入窗口。每次纳入一个新字符，就更新窗口内的状态（例如，字符的计数）。</li>
<li><strong>检查有效性</strong>：在扩展的同时，持续检查当前窗口是否已经满足了“覆盖 <code>t</code>” 的条件。</li>
<li><strong>收缩窗口</strong>：一旦窗口满足条件，我们就找到了一个“可行解”。但题目要求的是“最小”子串，所以我们要尝试收缩窗口的左边界。我们向右移动 <code>left</code> 指针，每次移出一个字符，并判断窗口是否依然满足条件。</li>
<li><strong>更新最优解</strong>：在收缩的过程中，只要窗口保持有效，我们就持续记录并更新当前找到的最小子串的长度和起始位置。当窗口因为 <code>left</code> 的移动而变得不再有效时，我们就停止收缩，回到第一步，继续移动 <code>right</code> 来寻找下一个“可行解”。</li>
</ol>
<p>通过 <code>right</code> 指针的不断扩张和 <code>left</code> 指针的伺机收缩，我们就能在一次遍历中找到全局最优解。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><p>为了高效地实现上述思路，我们需要两个哈希表（或字典）来帮助我们进行判断：</p>
<ul>
<li><code>need</code> 哈希表：用来统计字符串 <code>t</code> 中所有字符及其出现的次数。这个表在算法开始前构建，之后不会改变。</li>
<li><code>window</code> 哈希表：用来统计当前滑动窗口内，<code>t</code> 中字符的出现次数。这个表是动态变化的。</li>
</ul>
<p>我们还需要一个 <code>valid</code> 变量来加速判断。<code>valid</code> 记录的是 <code>window</code> 中有多少个字符的数量已经满足了 <code>need</code> 的要求。当 <code>valid</code> 的值等于 <code>need</code> 中不同字符的总数时，就说明当前窗口已经是一个“可行解”。</p>
<ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>left = 0</code>, <code>right = 0</code>。</li>
<li>构建 <code>need</code> 哈希表。</li>
<li><code>window</code> 哈希表为空。</li>
<li><code>valid = 0</code>。</li>
<li><code>start = 0</code>, <code>min_len = infinity</code> 用来记录最终结果。</li>
</ul>
</li>
<li><p><strong>主循环（扩展窗口）</strong>：</p>
<ul>
<li><code>right</code> 指针向右遍历 <code>s</code>，设当前字符为 <code>c</code>。</li>
<li>如果 <code>c</code> 是 <code>need</code> 中需要的字符，就更新 <code>window[c]</code> 的计数。</li>
<li>如果更新后 <code>window[c]</code> 的值恰好等于 <code>need[c]</code>，说明 <code>c</code> 这个字符的要求已经满足，我们将 <code>valid</code> 加一。</li>
</ul>
</li>
<li><p><strong>内循环（收缩窗口）</strong>：</p>
<ul>
<li>当 <code>valid == len(need)</code> 时，触发收缩。</li>
<li>首先，用当前窗口的长度 <code>right - left</code> 和 <code>min_len</code> 比较，如果更小，则更新 <code>min_len</code> 和 <code>start</code>。</li>
<li>然后，将 <code>left</code> 指针右移，设移出的字符为 <code>d</code>。</li>
<li>如果 <code>d</code> 是 <code>need</code> 中需要的字符，就更新 <code>window[d]</code> 的计数。</li>
<li>如果更新后 <code>window[d]</code> 的值小于 <code>need[d]</code>，说明 <code>d</code> 这个字符的要求不再满足，我们将 <code>valid</code> 减一。</li>
<li>只要 <code>valid</code> 的值还等于 <code>len(need)</code>，就重复这个收缩过程。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>主循环结束后，如果 <code>min_len</code> 仍然是初始的无穷大，说明没有找到任何可行解，返回 <code>&quot;&quot;</code>。</li>
<li>否则，根据记录的 <code>start</code> 和 <code>min_len</code> 返回 <code>s[start : start + min_len]</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># need 用于存储 t 中每个字符需要的数量</span></span><br><span class="line">        need = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> t:</span><br><span class="line">            need[char] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># window 用于存储当前窗口中每个字符的数量</span></span><br><span class="line">        window = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        </span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        valid = <span class="number">0</span> <span class="comment"># 窗口中满足 need 条件的字符个数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 记录最小覆盖子串的起始索引和长度</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        min_len = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="comment"># c 是将移入窗口的字符</span></span><br><span class="line">            c = s[right]</span><br><span class="line">            right += <span class="number">1</span> <span class="comment"># 扩大窗口</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果是所需字符，更新窗口计数</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> need:</span><br><span class="line">                window[c] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">                    valid += <span class="number">1</span> <span class="comment"># 该字符已满足要求</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当窗口满足所有要求时，尝试收缩</span></span><br><span class="line">            <span class="keyword">while</span> valid == <span class="built_in">len</span>(need):</span><br><span class="line">                <span class="comment"># 更新最小子串记录</span></span><br><span class="line">                <span class="keyword">if</span> right - left &lt; min_len:</span><br><span class="line">                    start = left</span><br><span class="line">                    min_len = right - left</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># d 是将移出窗口的字符</span></span><br><span class="line">                d = s[left]</span><br><span class="line">                left += <span class="number">1</span> <span class="comment"># 缩小窗口</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 如果移出的也是所需字符，更新窗口计数</span></span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> need:</span><br><span class="line">                    <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                        valid -= <span class="number">1</span> <span class="comment"># 该字符不再满足要求</span></span><br><span class="line">                    window[d] -= <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span> <span class="keyword">if</span> min_len == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> s[start:start + min_len]</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(M + N)。其中 M 是字符串 <code>s</code> 的长度，N 是字符串 <code>t</code> 的长度。首先，我们需要 O(N) 的时间来初始化 <code>need</code> 哈希表。在滑动窗口的过程中，<code>left</code> 和 <code>right</code> 指针都各自最多遍历 <code>s</code> 一次，所以主循环的复杂度是 O(M)。总共是 O(M + N)。</li>
<li><strong>空间复杂度</strong>: O(K)。其中 K 是字符串 <code>t</code> 中不同字符的数量。我们使用了 <code>need</code> 和 <code>window</code> 两个哈希表，它们存储的键的数量不会超过 <code>t</code> 中不同字符的数量。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>“最小覆盖子串”是滑动窗口算法的经典模板题。其精髓在于通过“扩张”和“收缩”两个动作，在 O(N) 的时间内优雅地解决了问题。理解并掌握这个模板，对于解决其他相关的子数组、子字符串问题大有裨益，例如“字符串的排列”、“无重复字符的最长子串”等，它们的底层逻辑都与此类似。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 911 | 二分查找解决“在线选举”问题</title>
    <url>//posts/leetcode-911/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 911 题：<a href="https://leetcode.cn/problems/online-election/">在线选举</a>。<br>这道题完美地展示了“预计算+二分查找”的设计模式。通过在初始化时处理好所有时间点的选举结果，我们可以将每次查询的复杂度从线性降低到对数级别，从而高效地响应大量查询。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目模拟了一个实时选举过程。我们有两个数组 <code>persons</code> 和 <code>times</code>，表示在 <code>times[i]</code> 时刻，候选人 <code>persons[i]</code> 获得了一张选票。我们需要实现一个查询功能 <code>q(t)</code>，它能返回在任意给定时刻 <code>t</code>，谁是当前的领先者。</p>
<p>领先者的判断规则有两点：</p>
<ol>
<li>获得票数最多的候选人领先。</li>
<li>如果票数出现平局，那么<strong>最近一次</strong>获得投票的候选人领先。</li>
</ol>
<p>举个例子，<code>persons = [0, 1, 1]</code>, <code>times = [0, 5, 10]</code>：</p>
<ul>
<li><strong>时刻 0 到 4</strong>：只有 <code>[0]</code> 投给了候选人 <code>0</code>。票数 <code>&#123;0: 1&#125;</code>。领先者是 <code>0</code>。</li>
<li><strong>时刻 5 到 9</strong>：<code>[0, 1]</code> 分别投给了 <code>0</code> 和 <code>1</code>。票数 <code>&#123;0: 1, 1: 1&#125;</code>。出现平局，但候选人 <code>1</code> 是在时刻 5 最近获得投票的，所以领先者是 <code>1</code>。</li>
<li><strong>时刻 10 及以后</strong>：<code>[0, 1, 1]</code>。票数 <code>&#123;0: 1, 1: 2&#125;</code>。领先者是 <code>1</code>。</li>
</ul>
<p>因此，<code>q(3)</code> 返回 <code>0</code>，<code>q(8)</code> 返回 <code>1</code>，<code>q(25)</code> 也返回 <code>1</code>。</p>
<h3 id="核心思路：预计算-二分查找"><a href="#核心思路：预计算-二分查找" class="headerlink" title="核心思路：预计算 + 二分查找"></a>核心思路：预计算 + 二分查找</h3><p>一个最直接的想法是，每当调用一次 <code>q(t)</code>，我们就遍历所有在 <code>t</code> 时刻之前的投票，模拟计票过程，找出当时的领先者。但如果查询次数非常多，这种方法的效率会很低，因为每次查询都需要重复计算。</p>
<p>注意到，选举的结果（谁是领先者）只在发生投票的那些特定时间点 (<code>times</code> 数组中的值) 才<strong>可能</strong>发生变化。在两次投票之间的时间段里，领先者是固定不变的。</p>
<p>这启发我们采用一种<strong>预计算</strong>的策略来优化查询：</p>
<ol>
<li><p><strong>预计算</strong>：在对象初始化阶段，我们先遍历一遍 <code>times</code> 和 <code>persons</code> 数组。因为 <code>times</code> 是严格递增的，我们可以按照时间顺序，计算出<strong>每一个投票时间点</strong>的选举结果（即谁是当时的领先者），然后将这些结果按时间顺序存入一个列表，例如 <code>leaders</code>。<code>leaders[i]</code> 就代表在 <code>times[i]</code> 时刻的领先者。</p>
</li>
<li><p><strong>二分查找</strong>：完成预计算后，对于任何查询 <code>q(t)</code>，问题就转化为：在 <code>times</code> 这个有序数组中，找到最后一个不大于 <code>t</code> 的时间点 <code>times[i]</code>。那么 <code>t</code> 时刻的领先者就等于 <code>times[i]</code> 时刻的领先者，也就是我们预先算好的 <code>leaders[i]</code>。在一个有序数组中查找一个值，正是二分查找的经典应用场景。</p>
</li>
</ol>
<p>通过这种方式，我们将复杂的、重复的计票逻辑集中在只需执行一次的初始化阶段，而将频繁调用的查询操作优化为一次高效的二分查找。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>初始化 <code>__init__</code></strong></p>
<ul>
<li>我们需要一个列表 <code>leaders</code> 来存储每个投票时间点对应的领先者。</li>
<li>我们还需要一个哈希表 <code>counts</code> 来实时追踪每个候选人的得票数。</li>
<li>遍历 <code>persons</code> 和 <code>times</code> 数组（从索引 <code>0</code> 到 <code>n-1</code>）。</li>
<li>在每一步 <code>i</code>：<ul>
<li>给 <code>persons[i]</code> 增加一票。</li>
<li>检查 <code>persons[i]</code> 的票数是否大于或等于当前记录的最高票数。如果是，则更新领先者为 <code>persons[i]</code>。这里的 <code>&gt;=</code> 判断巧妙地处理了平局规则：因为我们是按时间顺序处理的，当票数相等时，当前的投票者 <code>persons[i]</code> 自然就是“最近获得投票”的候选人。</li>
<li>将当前这位领先者存入 <code>leaders</code> 列表的末尾。</li>
</ul>
</li>
<li>最后，我们将 <code>times</code> 数组和 <code>leaders</code> 列表保存为类的成员变量。</li>
</ul>
</li>
<li><p><strong>查询 <code>q(t)</code></strong></p>
<ul>
<li>该函数接收一个查询时刻 <code>t</code>。</li>
<li>我们的目标是在 <code>self.times</code> 数组中找到一个索引 <code>i</code>，使得 <code>self.times[i] &lt;= t</code> 且 <code>self.times[i+1] &gt; t</code>（或者是最后一个元素）。</li>
<li>这可以通过二分查找来实现。Python 的 <code>bisect.bisect_right(array, value)</code> 函数能找到 <code>value</code> 在 <code>array</code> 中的插入点，使得插入后数组仍然有序。这个插入点的索引 <code>idx</code> 左边的所有元素都 <code>&lt;= value</code>。</li>
<li>因此，我们需要的那个时间点的索引就是 <code>idx - 1</code>。</li>
<li>返回 <code>self.leaders[idx - 1]</code> 即可。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TopVotedCandidate</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, persons: <span class="type">List</span>[<span class="built_in">int</span>], times: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="variable language_">self</span>.times = times</span><br><span class="line">        <span class="variable language_">self</span>.leaders = []</span><br><span class="line">        counts = &#123;&#125;</span><br><span class="line">        leader = -<span class="number">1</span></span><br><span class="line">        max_votes = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤 1: 预计算每个时间点的领先者</span></span><br><span class="line">        <span class="keyword">for</span> person <span class="keyword">in</span> persons:</span><br><span class="line">            counts[person] = counts.get(person, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> counts[person] &gt;= max_votes:</span><br><span class="line">                max_votes = counts[person]</span><br><span class="line">                leader = person</span><br><span class="line">            <span class="variable language_">self</span>.leaders.append(leader)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">q</span>(<span class="params">self, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤 2: 使用二分查找定位时间点</span></span><br><span class="line">        <span class="comment"># bisect_right 找到第一个 &gt; t 的元素的位置</span></span><br><span class="line">        idx = bisect.bisect_right(<span class="variable language_">self</span>.times, t)</span><br><span class="line">        <span class="comment"># 我们需要的是 &lt;= t 的最后一个元素，其索引为 idx - 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.leaders[idx - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>:<ul>
<li><code>__init__</code>: O(N)。其中 N 是 <code>persons</code> 数组的长度。我们需要遍历一次所有投票来预计算领先者列表。哈希表的读写操作平均为 O(1)。</li>
<li><code>q</code>: O(log N)。每次查询都是对长度为 N 的 <code>times</code> 数组进行一次二分查找。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(N)。我们需要 O(N) 的空间来存储 <code>times</code> 数组和 <code>leaders</code> 列表。在初始化过程中，计票的哈希表 <code>counts</code> 最多也可能存储 N 个候选人，因此也需要 O(N) 的空间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预计算 + 高效查询”设计模式的典范。当面对一个固定数据集和大量后续查询的场景时，我们应首先思考是否可以通过一次性的预处理（如排序、计算前缀和、建立状态列表等）来换取后续每次查询的效率提升。二分查找作为在有序数据上进行快速定位的利器，常常在这种模式中扮演关键角色。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>哈希表</tag>
        <tag>设计</tag>
        <tag>第103场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 930 | 滑动窗口求解“和相同的二元子数组”</title>
    <url>//posts/leetcode-930/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode 第 930 题：<a href="https://leetcode.cn/problems/binary-subarrays-with-sum/">和相同的二元子数组</a>。<br>该题要求统计和为特定值的二元子数组个数。直接用滑动窗口处理“和恰好等于 goal”的条件，在有连续 0 的情况下会比较棘手。但如果我们换一个角度，问题就迎刃而解了。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目给了我们一个只包含 0 和 1 的二元数组 <code>nums</code> 和一个整数 <code>goal</code>。我们需要统计出，有多少个<strong>连续子数组</strong>，其内部所有元素之和恰好等于 <code>goal</code>。</p>
<p>举个例子，对于 <code>nums = [1,0,1,0,1]</code>, <code>goal = 2</code>：</p>
<ul>
<li>满足条件的子数组有 <code>[1,0,1]</code> (从索引0开始), <code>[1,0,1,0]</code> (从索引0开始), <code>[0,1,0,1]</code> (从索引1开始), <code>[1,0,1]</code> (从索引2开始)。等等，例子中的解释是 <code>[1,0,1]</code>, <code>[1,0,1]</code>, <code>[0,1,0,1]</code>。让我们重新看一下，<code>[1,0,1,0]</code> 的和也是 2。啊，示例的解释是 <code>[1,0,1]</code>、<code>[1,0,1,0]</code> 的和是2， <code>[0,1,0,1]</code> 的和是2，最后一个 <code>[1,0,1]</code> 是指从索引2开始的那个。所以总共有4个。</li>
<li><code>[1,0,1]</code> (和为2)</li>
<li><code>[1,0,1,0]</code> (和为2)</li>
<li><code>[0,1,0,1]</code> (和为2)</li>
<li><code>[1,0,1]</code> (从索引2开始，和为2)</li>
<li>因此，最终输出是 4。</li>
</ul>
<p>直接去枚举所有子数组的复杂度是 O(N^2)，在 <code>3 * 10^4</code> 的数据规模下会超时，我们需要更高效的算法。</p>
<h3 id="核心思路：巧妙转换为“最多为-K”"><a href="#核心思路：巧妙转换为“最多为-K”" class="headerlink" title="核心思路：巧妙转换为“最多为 K”"></a>核心思路：巧妙转换为“最多为 K”</h3><p>滑动窗口是解决子数组问题的利器。但如果我们尝试维护一个窗口，使其内部的和<strong>恰好</strong>等于 <code>goal</code>，会遇到麻烦。比如窗口 <code>[1,0,1]</code> 的和是 2，我们找到了一个解。当窗口向右扩展，加入一个 0 变成 <code>[1,0,1,0]</code>，和仍然是 2，这也是一个解。如果数组中有更多的连续 0，情况会变得更复杂，统计逻辑会很繁琐。</p>
<p>解决这个问题的金钥匙是<strong>转换问题</strong>。与其求“和恰好为 goal”，我们可以求“和最多为 goal”的子数组个数，再减去“和最多为 goal-1”的子数组个数。它们的差值，正好就是“和恰好为 goal”的子数组个数。</p>
<p><strong><code>count(sum == goal) = count(sum &lt;= goal) - count(sum &lt;= goal - 1)</code></strong></p>
<p>而求解“和最多为 k”的子数组个数，是滑动窗口的经典应用场景，逻辑非常清晰。</p>
<p>我们可以实现一个辅助函数 <code>atMost(k)</code>，用滑动窗口计算和小于等于 <code>k</code> 的子数组数量。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>实现 <code>atMost(k)</code> 辅助函数</strong></p>
<ul>
<li>我们使用 <code>left</code> 和 <code>right</code> 两个指针来定义一个滑动窗口 <code>[left, right]</code>。</li>
<li>初始化 <code>left = 0</code>, <code>current_sum = 0</code>, <code>count = 0</code>。</li>
<li><code>right</code> 指针从左到右遍历整个数组，不断扩大窗口。</li>
<li>每当 <code>right</code> 移动一步，将 <code>nums[right]</code> 加入 <code>current_sum</code>。</li>
<li>检查 <code>current_sum</code> 是否大于 <code>k</code>。如果大于，就说明窗口需要收缩。我们不断地将 <code>left</code> 指针右移，并从 <code>current_sum</code> 中减去 <code>nums[left]</code>，直到 <code>current_sum &lt;= k</code> 为止。</li>
<li>在任意一步，当窗口 <code>[left, right]</code> 满足 <code>sum &lt;= k</code> 时，所有以 <code>right</code> 为右端点，且左端点在 <code>[left, right]</code> 区间内的子数组，它们的和也都小于等于 <code>k</code>。这样的子数组共有 <code>right - left + 1</code> 个。我们将这个数目累加到总数 <code>count</code> 中。</li>
<li><code>right</code> 遍历结束后，返回 <code>count</code>。</li>
</ul>
</li>
<li><p><strong>计算最终结果</strong></p>
<ul>
<li>调用我们写好的辅助函数，分别计算 <code>atMost(goal)</code> 和 <code>atMost(goal - 1)</code>。</li>
<li>最终的结果就是 <code>atMost(goal) - atMost(goal - 1)</code>。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSubarraysWithSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], goal: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">atMost</span>(<span class="params">k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            一个辅助函数，用来计算和最多为 k 的子数组数量。</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            left, current_sum, count = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                current_sum += nums[right]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 如果当前窗口的和大于 k，则从左边收缩窗口</span></span><br><span class="line">                <span class="keyword">while</span> current_sum &gt; k:</span><br><span class="line">                    current_sum -= nums[left]</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 以 right 为右端点的、和小于等于 k 的子数组个数为 right - left + 1</span></span><br><span class="line">                count += (right - left + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 原问题答案 = atMost(goal) - atMost(goal - 1)</span></span><br><span class="line">        <span class="keyword">return</span> atMost(goal) - atMost(goal - <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(N)。其中 N 是 <code>nums</code> 的长度。<code>atMost</code> 函数中的 <code>left</code> 和 <code>right</code> 指针都只会从头到尾移动一次，因此是 O(N) 的。我们调用了两次该函数，所以总时间复杂度是 O(N) + O(N) &#x3D; O(N)。</li>
<li><strong>空间复杂度</strong>: O(1)。我们只使用了常数个额外变量。</li>
</ul>
<h3 id="补充：前缀和-哈希表"><a href="#补充：前缀和-哈希表" class="headerlink" title="补充：前缀和 + 哈希表"></a>补充：前缀和 + 哈希表</h3><p>本题还有另一种非常经典的解法：前缀和 + 哈希表。<br>思路是：</p>
<ol>
<li>我们要求的是满足 <code>sum(nums[i:j+1]) == goal</code> 的 <code>(i, j)</code> 对的数量。</li>
<li>使用前缀和 <code>prefix_sum</code>，这个条件可以改写为 <code>prefix_sum[j] - prefix_sum[i-1] == goal</code>。</li>
<li>进一步变形得到 <code>prefix_sum[i-1] == prefix_sum[j] - goal</code>。</li>
<li>于是，我们可以遍历数组，在计算出每个位置 <code>j</code> 的前缀和 <code>prefix_sum[j]</code> 的同时，去一个哈希表中查找，之前出现过多少次值为 <code>prefix_sum[j] - goal</code> 的前缀和。将这个次数累加到结果中，然后将当前的前缀和 <code>prefix_sum[j]</code> 存入哈希表。<br>这种方法的时间和空间复杂度分别为 O(N) 和 O(N)。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题展示了解决“恰好为 K”这类计数问题的强大技巧——将其转化为两个“最多为 K”问题的差。这个思想不仅适用于滑动窗口，也适用于其他许多算法场景。它能将一个逻辑复杂的计数问题，分解为两个逻辑清晰的子问题，从而大大简化代码的实现难度和出错率，是算法工具箱中非常实用的一招。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>滑动窗口与双指针</category>
        <category>不定长滑动窗口</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
        <tag>滑动窗口</tag>
        <tag>前缀和</tag>
        <tag>第108场周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode LCP 08 | 前缀和与二分查找解决“剧情触发时间”</title>
    <url>//posts/leetcode-lcp-08/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeetCode LCP 08 题：<a href="https://leetcode.cn/problems/ju-qing-hong-fa-shi-jian/">剧情触发时间</a>。<br>当游戏属性随时间单调递增时，寻找满足条件的“最早时刻”是一个经典的二分查找应用场景。通过预计算前缀和，我们可以将每次判断的复杂度降为常数级别，从而高效地解决问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h3 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h3><p>题目模拟了一个游戏过程，其中有三种核心属性：文明等级（C）、资源储备（R）和人口数量（H）。所有属性初始值（第 0 天）都为 0。</p>
<p>游戏每天都会进行，三种属性会根据一个给定的 <code>increase</code> 数组增长。<code>increase[i]</code> 代表第 <code>i+1</code> 天 C, R, H 的增量。</p>
<p>同时，有一系列剧情，它们的触发条件由 <code>requirements</code> 数组给出。每个 <code>requirement[j]</code> 包含一个 <code>[c, r, h]</code> 的阈值，当玩家的属性 C, R, H 同时大于或等于这些阈值时，该剧情就会被触发。</p>
<p>我们的任务是，对于每一个剧情，计算它被触发的最早是哪一天。如果某个剧情永远无法被触发，则记为 -1。</p>
<p>例如，<code>increase = [[2,8,4],[2,5,0],[10,9,8]]</code>，<code>requirements = [[2,11,3]]</code>：</p>
<ul>
<li>初始状态 (第 0 天): C&#x3D;0, R&#x3D;0, H&#x3D;0。</li>
<li>第 1 天结束: C&#x3D;2, R&#x3D;8, H&#x3D;4。此时不满足 R&gt;&#x3D;11。</li>
<li>第 2 天结束: C&#x3D;2+2&#x3D;4, R&#x3D;8+5&#x3D;13, H&#x3D;4+0&#x3D;4。此时 C&gt;&#x3D;2, R&gt;&#x3D;11, H&gt;&#x3D;3 全部满足。</li>
<li>因此，该剧情的触发时间是第 2 天。</li>
</ul>
<h3 id="核心思路：前缀和-二分查找"><a href="#核心思路：前缀和-二分查找" class="headerlink" title="核心思路：前缀和 + 二分查找"></a>核心思路：前缀和 + 二分查找</h3><p>一个朴素的解法是：对每一个 <code>requirement</code>，我们都从第 1 天开始，一天天模拟属性的增长，直到满足条件为止。如果 <code>increase</code> 的长度为 D，<code>requirements</code> 的长度为 Q，这种暴力解法的时间复杂度大约是 O(Q * D)，在 D 和 Q 都达到 10^5 的情况下，计算量过大，会导致超时。</p>
<p>我们可以进行优化。注意到，对于任何一个剧情，它能否在第 <code>k</code> 天被触发，取决于到第 <code>k</code> 天为止累积的 C, R, H 总量。这个“累积总量”可以通过<strong>前缀和</strong>来快速计算。我们可以先对 <code>increase</code> 数组预处理，得到一个 <code>prefix_sum</code> 数组，其中 <code>prefix_sum[k]</code> 存储了到第 <code>k</code> 天结束时 C, R, H 的总值。这样，查询任意一天的属性状态就变成了 O(1) 的操作。</p>
<p>更重要的是，随着天数 <code>d</code> 的增加，C, R, H 的总量是<strong>单调不减</strong>的。这意味着，如果一个剧情在第 <code>d</code> 天可以被触发，那么在 <code>d</code> 之后的所有天也一定可以被触发。这个单调性是使用<strong>二分查找</strong>的关键信号。</p>
<p>因此，对于每个 <code>requirement</code>，问题就转化为：<strong>在 <code>[0, 1, ..., D]</code> 这些天中，找到满足触发条件的最小天数 <code>d</code>。</strong> 这是一个典型的二分查找“寻找下界”的问题。</p>
<p>优化的思路分为两步：</p>
<ol>
<li><strong>预计算前缀和</strong>：遍历一次 <code>increase</code> 数组，计算出每一天结束时 C, R, H 的累积总量，存入前缀和数组。</li>
<li><strong>二分查找</strong>：对每一个 <code>requirement</code>，在 <code>[0, D]</code> 的天数范围内进行二分查找，快速定位到最早的触发时间。</li>
</ol>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><ol>
<li><p><strong>预处理 <code>increase</code> 数组</strong></p>
<ul>
<li>创建一个前缀和数组 <code>prefix_sum</code>，长度比 <code>increase</code> 大 1。<code>prefix_sum[i]</code> 用于存储到第 <code>i</code> 天结束时的总属性值。</li>
<li><code>prefix_sum[0]</code> 初始化为 <code>[0, 0, 0]</code>，代表第 0 天的初始状态。</li>
<li>遍历 <code>increase</code> 数组，从 <code>i = 1</code> 到 <code>D</code>，计算 <code>prefix_sum[i] = prefix_sum[i-1] + increase[i-1]</code>。</li>
</ul>
</li>
<li><p><strong>处理 <code>requirements</code> 数组</strong></p>
<ul>
<li>创建一个空的答案数组 <code>ans</code>。</li>
<li>遍历 <code>requirements</code> 中的每一个 <code>req = [c, r, h]</code>：<ul>
<li>首先做一个快速判断：如果到游戏最后一天，总属性值都无法满足 <code>req</code>，那么这个剧情永远不会触发。即 <code>prefix_sum[D]</code> 的三项均小于 <code>req</code> 的对应项，则直接将 -1 加入答案，并继续下一个 <code>req</code>。</li>
<li>设定二分查找的范围 <code>left = 0</code>, <code>right = D</code>。我们的目标是在这个范围内找到满足条件的最小天数。</li>
<li>进入二分循环 (<code>while left &lt;= right</code>)：<ul>
<li>取中间天数 <code>mid = left + (right - left) // 2</code>。</li>
<li>检查在第 <code>mid</code> 天结束时，属性是否满足 <code>req</code>，即 <code>prefix_sum[mid][0] &gt;= c</code>, <code>prefix_sum[mid][1] &gt;= r</code>, 并且 <code>prefix_sum[mid][2] &gt;= h</code>。</li>
<li>如果满足条件：说明第 <code>mid</code> 天或更早的天数是可能的答案。我们记录下 <code>mid</code>，并尝试在更早的时间里寻找，即 <code>right = mid - 1</code>。</li>
<li>如果不满足条件：说明第 <code>mid</code> 天太早了，需要更多时间积累属性，因此需要在之后的时间里寻找，即 <code>left = mid + 1</code>。</li>
</ul>
</li>
<li>循环结束后，记录下的那个满足条件的 <code>mid</code> 就是最早的触发时间。将其加入 <code>ans</code> 数组。</li>
<li>特殊情况：对于 <code>[0,0,0]</code> 的需求，第 0 天即可满足，需要单独处理或确保二分查找的逻辑能覆盖。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>遍历结束后，返回 <code>ans</code> 数组。</li>
</ul>
</li>
</ol>
<h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getTriggerTime</span>(<span class="params">self, increase: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], requirements: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(increase)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 1: 预处理 increase 数组，计算前缀和</span></span><br><span class="line">        <span class="comment"># prefix_sum[i] 表示第 i 天结束时的总属性 (i 从 1 开始)</span></span><br><span class="line">        <span class="comment"># prefix_sum[0] 表示第 0 天的初始状态</span></span><br><span class="line">        prefix_sum = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            prefix_sum[i+<span class="number">1</span>][<span class="number">0</span>] = prefix_sum[i][<span class="number">0</span>] + increase[i][<span class="number">0</span>]</span><br><span class="line">            prefix_sum[i+<span class="number">1</span>][<span class="number">1</span>] = prefix_sum[i][<span class="number">1</span>] + increase[i][<span class="number">1</span>]</span><br><span class="line">            prefix_sum[i+<span class="number">1</span>][<span class="number">2</span>] = prefix_sum[i][<span class="number">2</span>] + increase[i][<span class="number">2</span>]</span><br><span class="line">            </span><br><span class="line">        ans = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤 2: 处理 requirements 数组</span></span><br><span class="line">        <span class="keyword">for</span> req <span class="keyword">in</span> requirements:</span><br><span class="line">            c, r, h = req[<span class="number">0</span>], req[<span class="number">1</span>], req[<span class="number">2</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 特殊情况：0 需求</span></span><br><span class="line">            <span class="keyword">if</span> c == <span class="number">0</span> <span class="keyword">and</span> r == <span class="number">0</span> <span class="keyword">and</span> h == <span class="number">0</span>:</span><br><span class="line">                ans.append(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 剪枝：如果最后一天都无法满足，则永远无法触发</span></span><br><span class="line">            <span class="keyword">if</span> prefix_sum[n][<span class="number">0</span>] &lt; c <span class="keyword">or</span> prefix_sum[n][<span class="number">1</span>] &lt; r <span class="keyword">or</span> prefix_sum[n][<span class="number">2</span>] &lt; h:</span><br><span class="line">                ans.append(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 二分查找：在 [1, n] 的天数范围内寻找最早的触发时间</span></span><br><span class="line">            left, right = <span class="number">1</span>, n</span><br><span class="line">            res = -<span class="number">1</span> <span class="comment"># 用于记录满足条件的最早天数</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                mid = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="comment"># 检查第 mid 天的属性是否满足要求</span></span><br><span class="line">                <span class="keyword">if</span> prefix_sum[mid][<span class="number">0</span>] &gt;= c <span class="keyword">and</span> prefix_sum[mid][<span class="number">1</span>] &gt;= r <span class="keyword">and</span> prefix_sum[mid][<span class="number">2</span>] &gt;= h:</span><br><span class="line">                    <span class="comment"># 如果满足，mid 是一个可能的答案，尝试寻找更早的</span></span><br><span class="line">                    res = mid</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果不满足，说明 mid 太早，需要在之后的天数里找</span></span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            ans.append(res)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 步骤 3: 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>: O(D + Q * log D)<ul>
<li><code>D</code> 是 <code>increase</code> 的长度 (总天数)，<code>Q</code> 是 <code>requirements</code> 的长度。</li>
<li>计算前缀和数组需要遍历一次 <code>increase</code>，复杂度为 O(D)。</li>
<li>对于 <code>Q</code> 个剧情中的每一个，我们都执行一次二分查找。查找的范围是 <code>[1, D]</code>，所以单次二分查找的复杂度是 O(log D)。</li>
<li>总时间复杂度为 O(D + Q * log D)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: O(D)<ul>
<li>我们需要一个额外的前缀和数组 <code>prefix_sum</code> 来存储 <code>D+1</code> 天的属性状态。</li>
<li>返回的答案数组需要 O(Q) 的空间，但通常不计入额外空间复杂度。因此，主要额外空间开销是前缀和数组。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是“预处理 + 二分查找”模式的又一个绝佳示例。题目的核心特征是状态（玩家属性）随一个维度（时间）的推移而单调变化。当我们需要在这个单调变化的序列中寻找第一个满足特定条件的点时，二分查找就是最高效的算法。通过前缀和将“检查任意一点状态”的成本从 O(D) 降至 O(1)，是让二分查找得以高效应用的关键所在。</p>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>二分算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
